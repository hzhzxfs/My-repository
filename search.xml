<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>地理空间数据EDA数据探索性分析</title>
    <url>/2021/04/17/EDA%E6%95%B0%E6%8D%AE%E6%8E%A2%E7%B4%A2%E6%80%A7%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>EDA——数据探索性分析，是通过了解数据集的基本情况、变量间的相互关系以及变量与预测值之间的关系，为后期特征工程和建立模型做铺垫。本文以<em>智慧海洋建设竞赛</em>为例进行演示。</p>
<h4 id="1-总体了解数据"><a href="#1-总体了解数据" class="headerlink" title="1. 总体了解数据"></a>1. 总体了解数据</h4><h5 id="1-1-查看样本个数和原始特征维度"><a href="#1-1-查看样本个数和原始特征维度" class="headerlink" title="1.1 查看样本个数和原始特征维度"></a>1.1 查看样本个数和原始特征维度</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_train.shape</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_test.shape</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_train.columns	<span class="comment">#查看列名</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.set_option(<span class="string">&#x27;display.max_info_rows&#x27;</span>,<span class="number">2699639</span>)	<span class="comment">#提高非缺失值检查的行数上线</span></span><br><span class="line"><span class="comment">#pd.options.display.max_info_rows = 2699639</span></span><br><span class="line">data_train.info()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看count 非空值数、std 标准差、（25%、50%、75%）分位数等基本情况</span></span><br><span class="line">data_train.describe([<span class="number">0.01</span>,<span class="number">0.025</span>,<span class="number">0.05</span>,<span class="number">0.5</span>,<span class="number">0.75</span>,<span class="number">0.9</span>,<span class="number">0.99</span>])	</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h5 id="1-2-查看缺失值和唯一值等"><a href="#1-2-查看缺失值和唯一值等" class="headerlink" title="1.2 查看缺失值和唯一值等"></a>1.2 查看缺失值和唯一值等</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_train.isnull().<span class="built_in">any</span>()	<span class="comment">#查看缺失值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看含有缺失值的列名</span></span><br><span class="line">data_train.columns[data_train.isnull().<span class="built_in">any</span>()].tolist()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看仅有唯一值的特征</span></span><br><span class="line">one_value_fea_train = [col <span class="keyword">for</span> col <span class="keyword">in</span> data_train.columns <span class="keyword">if</span> data_train[col].nunique() &lt;= <span class="number">1</span>]</span><br><span class="line">one_value_fea_test = [col <span class="keyword">for</span> col <span class="keyword">in</span> data_test.columns <span class="keyword">if</span> data_test[col].nunique() &lt;= <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="2-查看数据特性和特征分布"><a href="#2-查看数据特性和特征分布" class="headerlink" title="2. 查看数据特性和特征分布"></a>2. 查看数据特性和特征分布</h4><h5 id="2-1-渔船轨迹可视化"><a href="#2-1-渔船轨迹可视化" class="headerlink" title="2.1 渔船轨迹可视化"></a>2.1 渔船轨迹可视化</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从每个类别中随机抽取三个渔船的轨迹进行可视化</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visualize_three_traj</span>():</span></span><br><span class="line">    fig,axes = plt.subplots(nrows=<span class="number">3</span>,ncols=<span class="number">3</span>,figsize=(<span class="number">20</span>,<span class="number">15</span>))</span><br><span class="line">    plt.subplots_adjust(wspace=<span class="number">0.2</span>,hspace=<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># 对于每一个类别，随机选出刺网的三条轨迹进行可视化</span></span><br><span class="line">    lables = [<span class="string">&quot;ciwang&quot;</span>,<span class="string">&quot;weiwang&quot;</span>,<span class="string">&quot;tuowang&quot;</span>]</span><br><span class="line">    <span class="keyword">for</span> i,file_type <span class="keyword">in</span> tqdm(<span class="built_in">enumerate</span>([<span class="string">&quot;ciwang_data&quot;</span>,<span class="string">&quot;weiwang_data&quot;</span>,<span class="string">&quot;tuowang_data&quot;</span>])):</span><br><span class="line">        data1, data2, data3 = get_random_three_traj(<span class="built_in">type</span>=file_type)</span><br><span class="line">        <span class="keyword">for</span> j, datax <span class="keyword">in</span> <span class="built_in">enumerate</span>([data1, data2, data3]):</span><br><span class="line">            x_data = datax[<span class="string">&quot;x&quot;</span>].loc[-<span class="number">1</span>:].values</span><br><span class="line">            y_data = datax[<span class="string">&quot;y&quot;</span>].loc[-<span class="number">1</span>:].values</span><br><span class="line">            axes[i][j - <span class="number">1</span>].scatter(x_data[<span class="number">0</span>], y_data[<span class="number">0</span>], label=<span class="string">&quot;start&quot;</span>, c=<span class="string">&quot;red&quot;</span>, s=<span class="number">20</span>, marker=<span class="string">&quot;o&quot;</span>)</span><br><span class="line">            axes[i][j - <span class="number">1</span>].plot(x_data, y_data, label=lables[i])</span><br><span class="line">            axes[i][j - <span class="number">1</span>].scatter(x_data[<span class="built_in">len</span>(x_data) - <span class="number">1</span>], y_data[<span class="built_in">len</span>(y_data) - <span class="number">1</span>], label=<span class="string">&quot;end&quot;</span>, c=<span class="string">&quot;green&quot;</span>, s=<span class="number">20</span>,</span><br><span class="line">                                   marker=<span class="string">&quot;D&quot;</span>)</span><br><span class="line">            axes[i][j - <span class="number">1</span>].grid(alpha=<span class="number">2</span>)</span><br><span class="line">            axes[i][j - <span class="number">1</span>].legend(loc=<span class="string">&quot;best&quot;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line">    </span><br><span class="line">visualize_three_traj()</span><br></pre></td></tr></table></figure>
<p>—————-图1——————</p>
<p>从图中可以发现,不同类别的轨迹有一定区分性.</p>
<blockquote>
<p>刺网为规则多边形.</p>
<p>围网为包围的形状.</p>
<p>拖网为点到点,转弯次数少.</p>
</blockquote>
<p>从轨迹数据可以猜测其特征可能为转弯的角度大小\转弯次数\起始点之间的距离和时间\经度和维度变化范围等.</p>
<p>此外,存在一些异常轨迹需要剔除.</p>
<h4 id="3-坐标序列可视化"><a href="#3-坐标序列可视化" class="headerlink" title="3. 坐标序列可视化"></a>3. 坐标序列可视化</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 随机选取某条数据，观察x坐标序列和y坐标序列的变化情况</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visualize_one_traj_x_y</span>():</span></span><br><span class="line">    fig,axes = plt.subplots(nrows=<span class="number">2</span>,ncols=<span class="number">1</span>,figsize=(<span class="number">10</span>,<span class="number">8</span>))</span><br><span class="line">    plt.subplots_adjust(wspace=<span class="number">0.2</span>,hspace=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">    data1 = get_random_one_traj(<span class="built_in">type</span>=<span class="string">&quot;weiwang_data&quot;</span>)</span><br><span class="line">    x = data1[<span class="string">&quot;x&quot;</span>].loc[-<span class="number">1</span>:]</span><br><span class="line">    x = x / <span class="number">10000</span></span><br><span class="line">    </span><br><span class="line">    y = data1[<span class="string">&quot;y&quot;</span>].loc[-<span class="number">1</span>:]</span><br><span class="line">    y = y / <span class="number">10000</span></span><br><span class="line"></span><br><span class="line">    arr1 = np.arange(<span class="built_in">len</span>(x))</span><br><span class="line">    arr2 = np.arange(<span class="built_in">len</span>(y))</span><br><span class="line"></span><br><span class="line">    axes[<span class="number">0</span>].plot(arr1,x,label=<span class="string">&quot;x&quot;</span>)</span><br><span class="line">    axes[<span class="number">1</span>].plot(arr2,y,label=<span class="string">&quot;y&quot;</span>)</span><br><span class="line">    axes[<span class="number">0</span>].grid(alpha=<span class="number">3</span>)</span><br><span class="line">    axes[<span class="number">0</span>].legend(loc=<span class="string">&quot;best&quot;</span>)</span><br><span class="line">    axes[<span class="number">1</span>].grid(alpha=<span class="number">3</span>)</span><br><span class="line">    axes[<span class="number">1</span>].legend(loc=<span class="string">&quot;best&quot;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line">    </span><br><span class="line">visualize_one_traj_x_y()</span><br></pre></td></tr></table></figure>
<p>———-图2———–</p>
<p>由上图可知,存在同一时间段内x\y坐标均未变化,说明可能该时段内渔船正停留在某处.</p>
<h4 id="4-三类渔船速度和方向可视化"><a href="#4-三类渔船速度和方向可视化" class="headerlink" title="4.三类渔船速度和方向可视化"></a>4.三类渔船速度和方向可视化</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 每类轨迹，随机选取某个渔船，可视化速度序列和方向序列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visualize_three_traj_speed_direction</span>():</span></span><br><span class="line">    fig,axes = plt.subplots(nrows=<span class="number">3</span>,ncols=<span class="number">2</span>,figsize=(<span class="number">20</span>,<span class="number">15</span>))</span><br><span class="line">    plt.subplots_adjust(wspace=<span class="number">0.1</span>,hspace=<span class="number">0.1</span>)</span><br><span class="line">    <span class="comment"># 随机选出刺网的三条轨迹进行可视化</span></span><br><span class="line">    file_types = [<span class="string">&quot;ciwang_data&quot;</span>,<span class="string">&quot;weiwang_data&quot;</span>,<span class="string">&quot;tuowang_data&quot;</span>]</span><br><span class="line">    speed_types = [<span class="string">&quot;ciwang_speed&quot;</span>,<span class="string">&quot;weiwang_speed&quot;</span>,<span class="string">&quot;tuowang_speed&quot;</span>]</span><br><span class="line">    doirections = [<span class="string">&quot;ciwang_direction&quot;</span>,<span class="string">&quot;weiwang_direction&quot;</span>,<span class="string">&quot;tuowang_direction&quot;</span>]</span><br><span class="line">    colors = [<span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;brown&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> i,file_name <span class="keyword">in</span> tqdm(<span class="built_in">enumerate</span>(file_types)):</span><br><span class="line">        datax = get_random_one_traj(<span class="built_in">type</span>=file_name)</span><br><span class="line">        x_data = datax[<span class="string">&quot;速度&quot;</span>].loc[-<span class="number">1</span>:].values</span><br><span class="line">        y_data = datax[<span class="string">&quot;方向&quot;</span>].loc[-<span class="number">1</span>:].values</span><br><span class="line">        axes[i][<span class="number">0</span>].plot(<span class="built_in">range</span>(<span class="built_in">len</span>(x_data)), x_data, label=speed_types[i], color=colors[i])</span><br><span class="line">        axes[i][<span class="number">0</span>].grid(alpha=<span class="number">2</span>)</span><br><span class="line">        axes[i][<span class="number">0</span>].legend(loc=<span class="string">&quot;best&quot;</span>)</span><br><span class="line">        axes[i][<span class="number">1</span>].plot(<span class="built_in">range</span>(<span class="built_in">len</span>(y_data)), y_data, label=doirections[i], color=colors[i])</span><br><span class="line">        axes[i][<span class="number">1</span>].grid(alpha=<span class="number">2</span>)</span><br><span class="line">        axes[i][<span class="number">1</span>].legend(loc=<span class="string">&quot;best&quot;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">visualize_three_traj_speed_direction()</span><br></pre></td></tr></table></figure>
<p>————图3—————-<br>由上图可知,不同分类渔船的轨迹速度某些时段均存在连续的低值情况,说明可能存在某些海上停留点;不同类别渔船的方向变化都很大,可能是海上漂泊导致,作为特征对于类别的区分度低,但也存在方向变化不大的时段,强化了对停留点存在的判断.</p>
<h4 id="5-三类渔船速度和方向的数据分布"><a href="#5-三类渔船速度和方向的数据分布" class="headerlink" title="5.三类渔船速度和方向的数据分布"></a>5.三类渔船速度和方向的数据分布</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对某一特征进行数据统计</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data_cummulation</span>(<span class="params"><span class="built_in">type</span>,path,kind,columns</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    type:&quot;ciwang&quot;,&quot;weiwang&quot; or &quot;tuowang&quot;</span></span><br><span class="line"><span class="string">    path:数据路径</span></span><br><span class="line"><span class="string">    kind:&quot;速度&quot;or&quot;方向&quot;</span></span><br><span class="line"><span class="string">    columns:与kind对应，&quot;speed&quot;or&quot;direction&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    data_dict = <span class="built_in">dict</span>()</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path + <span class="built_in">type</span>+<span class="string">&quot;.pkl&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        data_list = pickle.load(file)</span><br><span class="line">    <span class="keyword">for</span> datax <span class="keyword">in</span> tqdm(data_list):</span><br><span class="line">        data = datax[kind].values</span><br><span class="line">        <span class="keyword">for</span> speed <span class="keyword">in</span> data:</span><br><span class="line">            data_dict.setdefault(speed,<span class="number">0</span>)</span><br><span class="line">            data_dict[speed] += <span class="number">1</span></span><br><span class="line">    data_dict = <span class="built_in">dict</span>(<span class="built_in">sorted</span>(data_dict.items(),key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>],reverse=<span class="literal">False</span>))</span><br><span class="line">    data_df = pd.DataFrame.from_dict(data_dict,columns=[columns],orient=<span class="string">&quot;index&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> data_df</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分别得到速度和方向的分布数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_speed_and_direction_distribution_data</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    path = <span class="string">&quot;./data/&quot;</span></span><br><span class="line">    data_speed_df = get_data_cummulation(<span class="built_in">type</span>=<span class="built_in">type</span>, path=path,kind=<span class="string">&quot;速度&quot;</span>,columns=<span class="string">&quot;speed&quot;</span>)</span><br><span class="line">    data_direction_df = get_data_cummulation(<span class="built_in">type</span>=<span class="built_in">type</span>,path=path,kind=<span class="string">&quot;方向&quot;</span>,columns=<span class="string">&quot;direction&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> data_speed_df,data_direction_df</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可视化速度和方向的数据分布</span></span><br><span class="line">df_speeds = []</span><br><span class="line">df_directions = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_speed_direction1_distribution</span>():</span></span><br><span class="line">    plt.subplots(nrows=<span class="number">1</span>, ncols=<span class="number">2</span>, figsize=(<span class="number">15</span>, <span class="number">6</span>))</span><br><span class="line">    plt.subplots_adjust(wspace=<span class="number">0.2</span>, hspace=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">    file_types = [<span class="string">&quot;ciwang_data&quot;</span>, <span class="string">&quot;weiwang_data&quot;</span>, <span class="string">&quot;tuowang_data&quot;</span>]</span><br><span class="line">    lables = [<span class="string">&quot;ciwang&quot;</span>, <span class="string">&quot;weiwang&quot;</span>, <span class="string">&quot;tuowang&quot;</span>]</span><br><span class="line">    colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, filenames <span class="keyword">in</span> <span class="built_in">enumerate</span>(file_types):</span><br><span class="line">        df11, df21 = get_speed_and_direction_distribution_data(file_types[i])</span><br><span class="line">        plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">        ax1 = sns.kdeplot(df11[<span class="string">&quot;speed&quot;</span>].values / <span class="number">1000000</span>, color=colors[i],shade=<span class="literal">True</span>)</span><br><span class="line">        plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">        ax3 = sns.kdeplot(df21[<span class="string">&quot;direction&quot;</span>].values / <span class="number">1000000</span>, color=colors[i],shade=<span class="literal">True</span>)</span><br><span class="line">        df_speeds.append(df11)</span><br><span class="line">        df_directions.append(df21)</span><br><span class="line">    ax1.legend(lables)</span><br><span class="line">    ax1.set_xlabel(<span class="string">&quot;Speed&quot;</span>)</span><br><span class="line">    ax3.set_xlabel(<span class="string">&quot;Direction&quot;</span>)</span><br><span class="line">    ax3.legend(lables)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">plot_speed_direction1_distribution()</span><br></pre></td></tr></table></figure>
<p>———–图4———————</p>
<p>由上图可知,三种类别渔船的速度分布差异较大,而刺网和围网方向分布差异不明显,拖网方向分布有差异.</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>DataFrame</tag>
        <tag>Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>LightGBM调参_1</title>
    <url>/2021/03/26/lightGBM%E8%B0%83%E5%8F%82/</url>
    <content><![CDATA[<p>#1简单列举一下日常调参过程中常用的几种方法，具体的原理下次补上。</p>
<h4 id="1-经验法"><a href="#1-经验法" class="headerlink" title="1. 经验法:"></a>1. 经验法:</h4><blockquote>
<p>往两个方向调：</p>
<p>1.提高准确率：max_depth, num_leaves, learning_rate</p>
<p>2.降低过拟合：max_bin, min_data_in_leaf；L1, L2正则化；数据抽样, 列采样</p>
</blockquote>
<p>1.使用较小的num_leaves，max_depth和max_bin，降低复杂度。</p>
<p>2.使用min_data_in_leaf和min_sum_hessian_in_leaf，该值越大，模型的学习越保守。</p>
<span id="more"></span>

<p>3.设置bagging_freq和bagging_fraction使用bagging。</p>
<p>4.设置feature_fraction进行特征采样。</p>
<p>5.使用lambda_l1,lambda_l2和min_gain_to_split正则化。</p>
<h4 id="2-贪心调参"><a href="#2-贪心调参" class="headerlink" title="2. 贪心调参:"></a>2. 贪心调参:</h4><p>先调整对模型影响最大的参数，再调整对模型影响次大的参数，缺点是容易调成局部最优，需要多次调试。日常调参顺序如下:</p>
<p>① num_leaves, max_depth</p>
<p>② min_data_in_leaf, min_child_weight</p>
<p>③ bagging_freq, bagging_fraction,  feature_fraction,</p>
<p>④ reg_lambda, reg_alpha</p>
<p>⑤ min_split_gain</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="comment"># 调objective</span></span><br><span class="line">best_obj = <span class="built_in">dict</span>()</span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> objective:</span><br><span class="line">    model = LGBMRegressor(objective=obj)</span><br><span class="line">    score = cross_val_score(model, X_train, y_train, cv=<span class="number">5</span>, scoring=<span class="string">&#x27;f1&#x27;</span>).mean()</span><br><span class="line">    best_obj[obj] = score</span><br><span class="line"></span><br><span class="line"><span class="comment"># num_leaves</span></span><br><span class="line">best_leaves = <span class="built_in">dict</span>()</span><br><span class="line"><span class="keyword">for</span> leaves <span class="keyword">in</span> num_leaves:</span><br><span class="line">    model = LGBMRegressor(objective=<span class="built_in">min</span>(best_obj.items(), key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])[<span class="number">0</span>], num_leaves=leaves)</span><br><span class="line">    score = cross_val_score(model, X_train, y_train, cv=<span class="number">5</span>, scoring=<span class="string">&#x27;f1&#x27;</span>).mean()</span><br><span class="line">    best_leaves[leaves] = score</span><br><span class="line"></span><br><span class="line"><span class="comment"># max_depth</span></span><br><span class="line">best_depth = <span class="built_in">dict</span>()</span><br><span class="line"><span class="keyword">for</span> depth <span class="keyword">in</span> max_depth:</span><br><span class="line">    model = LGBMRegressor(objective=<span class="built_in">min</span>(best_obj.items(), key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])[<span class="number">0</span>],</span><br><span class="line">                          num_leaves=<span class="built_in">min</span>(best_leaves.items(), key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])[<span class="number">0</span>],</span><br><span class="line">                          max_depth=depth)</span><br><span class="line">    score = cross_val_score(model, X_train, y_train, cv=<span class="number">5</span>, scoring=<span class="string">&#x27;f1&#x27;</span>).mean()</span><br><span class="line">    best_depth[depth] = score</span><br></pre></td></tr></table></figure>

<p>以此类推，按调参顺序依次调整优化，并且可以对每一个最优参数下模型的得分进行可视化。</p>
<h4 id="3-网格搜索"><a href="#3-网格搜索" class="headerlink" title="3. 网格搜索"></a>3. 网格搜索</h4><p>即穷举搜索，在参数数组里循环遍历，一般大数据集不会用到，因为速度太慢。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_best_cv_params</span>(<span class="params">learning_rate=<span class="number">0.1</span>, n_estimators=<span class="number">581</span>, num_leaves=<span class="number">31</span>, max_depth=-<span class="number">1</span>, bagging_fraction=<span class="number">1.0</span>, feature_fraction=<span class="number">1.0</span>, bagging_freq=<span class="number">0</span>, min_data_in_leaf=<span class="number">20</span>, min_child_weight=<span class="number">0.001</span>, min_split_gain=<span class="number">0</span>, reg_lambda=<span class="number">0</span>, reg_alpha=<span class="number">0</span>, param_grid=<span class="literal">None</span></span>):</span></span><br><span class="line"></span><br><span class="line">    cv_fold = KFold(n_splits=<span class="number">5</span>, shuffle=<span class="literal">True</span>, random_state=<span class="number">2021</span>)</span><br><span class="line"></span><br><span class="line">    model_lgb = lgb.LGBMClassifier(learning_rate=learning_rate,</span><br><span class="line">                                   n_estimators=n_estimators,</span><br><span class="line">                                   num_leaves=num_leaves,</span><br><span class="line">                                   max_depth=max_depth,</span><br><span class="line">                                   bagging_fraction=bagging_fraction,</span><br><span class="line">                                   feature_fraction=feature_fraction,</span><br><span class="line">                                   bagging_freq=bagging_freq,</span><br><span class="line">                                   min_data_in_leaf=min_data_in_leaf,</span><br><span class="line">                                   min_child_weight=min_child_weight,</span><br><span class="line">                                   min_split_gain=min_split_gain,</span><br><span class="line">                                   reg_lambda=reg_lambda,</span><br><span class="line">                                   reg_alpha=reg_alpha,</span><br><span class="line">                                   n_jobs= <span class="number">8</span></span><br><span class="line">                                  )</span><br><span class="line"></span><br><span class="line">    f1 = make_scorer(f1_score, average=<span class="string">&#x27;micro&#x27;</span>)</span><br><span class="line">    grid_search = GridSearchCV(estimator=model_lgb, </span><br><span class="line">                               cv=cv_fold,</span><br><span class="line">                               param_grid=param_grid,</span><br><span class="line">                               scoring=f1</span><br><span class="line"></span><br><span class="line">                              )</span><br><span class="line">    grid_search.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;模型当前最优参数为:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(grid_search.best_params_))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;模型当前最优得分为:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(grid_search.best_score_))</span><br></pre></td></tr></table></figure>
<p>总体思路是先粗调再细调。在一开始调整时，可设置较大的学习率如0.1，先确定树的个数，再依次调整参数，最后设置较小的学习率如0.05，确定最终参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lgb_params = &#123;<span class="string">&#x27;num_leaves&#x27;</span>: <span class="built_in">range</span>(<span class="number">10</span>, <span class="number">80</span>, <span class="number">5</span>), <span class="string">&#x27;max_depth&#x27;</span>: <span class="built_in">range</span>(<span class="number">3</span>,<span class="number">10</span>,<span class="number">2</span>)&#125;</span><br><span class="line">get_best_cv_params()</span><br><span class="line"><span class="comment">#----------------------------------------</span></span><br><span class="line">lgb_params = &#123;<span class="string">&#x27;num_leaves&#x27;</span>: <span class="built_in">range</span>(<span class="number">25</span>, <span class="number">35</span>, <span class="number">1</span>), <span class="string">&#x27;max_depth&#x27;</span>: <span class="built_in">range</span>(<span class="number">5</span>,<span class="number">9</span>,<span class="number">1</span>)&#125;</span><br><span class="line">get_best_cv_params(n_estimators=<span class="number">85</span>)</span><br><span class="line"><span class="comment">#----------------------------------------</span></span><br><span class="line">lgb_params = &#123;<span class="string">&#x27;bagging_fraction&#x27;</span>: [i/<span class="number">10</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>,<span class="number">10</span>,<span class="number">1</span>)], </span><br><span class="line">              <span class="string">&#x27;feature_fraction&#x27;</span>: [i/<span class="number">10</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>,<span class="number">10</span>,<span class="number">1</span>)],</span><br><span class="line">              <span class="string">&#x27;bagging_freq&#x27;</span>: <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">81</span>,<span class="number">10</span>)&#125;</span><br><span class="line">get_best_cv_params(n_estimators=<span class="number">85</span>, num_leaves=<span class="number">29</span>, max_depth=<span class="number">7</span>, min_data_in_leaf=<span class="number">45</span>）</span><br><span class="line"><span class="comment">#----------------------------------------</span></span><br><span class="line">lgb_params = &#123;<span class="string">&#x27;reg_lambda&#x27;</span>: [<span class="number">0</span>,<span class="number">0.001</span>,<span class="number">0.01</span>,<span class="number">0.03</span>,<span class="number">0.08</span>,<span class="number">0.3</span>,<span class="number">0.5</span>], <span class="string">&#x27;reg_alpha&#x27;</span>: [<span class="number">0</span>,<span class="number">0.001</span>,<span class="number">0.01</span>,<span class="number">0.03</span>,<span class="number">0.08</span>,<span class="number">0.3</span>,<span class="number">0.5</span>]&#125;</span><br><span class="line">get_best_cv_params(n_estimators=<span class="number">85</span>, num_leaves=<span class="number">29</span>, max_depth=<span class="number">7</span>, min_data_in_leaf=<span class="number">45</span>, bagging_fraction=<span class="number">0.9</span>, feature_fraction=<span class="number">0.9</span>, bagging_freq=<span class="number">40</span>)</span><br><span class="line"><span class="comment">#----------------------------------------</span></span><br><span class="line">lgb_params = &#123;<span class="string">&#x27;min_split_gain&#x27;</span>: [i/<span class="number">10</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">11</span>,<span class="number">1</span>)]&#125;</span><br><span class="line">get_best_cv_params(n_estimators=<span class="number">85</span>, num_leaves=<span class="number">29</span>, max_depth=<span class="number">7</span>, min_data_in_leaf=<span class="number">45</span>, bagging_fraction=<span class="number">0.9</span>, feature_fraction=<span class="number">0.9</span>, bagging_freq=<span class="number">40</span>, min_split_gain=<span class="literal">None</span>)</span><br><span class="line"><span class="comment">#----------------------------------------</span></span><br><span class="line">final_params = &#123;</span><br><span class="line">                <span class="string">&#x27;boosting_type&#x27;</span>: <span class="string">&#x27;gbdt&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;learning_rate&#x27;</span>: <span class="number">0.01</span>,</span><br><span class="line">                <span class="string">&#x27;num_leaves&#x27;</span>: <span class="number">29</span>,</span><br><span class="line">                <span class="string">&#x27;max_depth&#x27;</span>: <span class="number">7</span>,</span><br><span class="line">                <span class="string">&#x27;objective&#x27;</span>: <span class="string">&#x27;multiclass&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;num_class&#x27;</span>: <span class="number">4</span>,</span><br><span class="line">                <span class="string">&#x27;min_data_in_leaf&#x27;</span>:<span class="number">45</span>,</span><br><span class="line">                <span class="string">&#x27;min_child_weight&#x27;</span>:<span class="number">0.001</span>,</span><br><span class="line">                <span class="string">&#x27;bagging_fraction&#x27;</span>: <span class="number">0.9</span>,</span><br><span class="line">                <span class="string">&#x27;feature_fraction&#x27;</span>: <span class="number">0.9</span>,</span><br><span class="line">                <span class="string">&#x27;bagging_freq&#x27;</span>: <span class="number">40</span>,</span><br><span class="line">                <span class="string">&#x27;min_split_gain&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="string">&#x27;reg_lambda&#x27;</span>:<span class="number">0</span>,</span><br><span class="line">                <span class="string">&#x27;reg_alpha&#x27;</span>:<span class="number">0</span>,</span><br><span class="line">                <span class="string">&#x27;nthread&#x27;</span>: <span class="number">6</span></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">cv_result = lgb.cv(train_set=lgb_train,</span><br><span class="line">                   early_stopping_rounds=<span class="number">20</span>,</span><br><span class="line">                   num_boost_round=<span class="number">5000</span>,</span><br><span class="line">                   nfold=<span class="number">5</span>,</span><br><span class="line">                   stratified=<span class="literal">True</span>,</span><br><span class="line">                   shuffle=<span class="literal">True</span>,</span><br><span class="line">                   params=final_params,</span><br><span class="line">                   feval=f1_score_vali,</span><br><span class="line">                   seed=<span class="number">0</span>,</span><br><span class="line">                  )</span><br></pre></td></tr></table></figure>
<h4 id="4-贝叶斯调参"><a href="#4-贝叶斯调参" class="headerlink" title="4. 贝叶斯调参"></a>4. 贝叶斯调参</h4><p>是一种用模型找到目标函数最小值的方法，比网格和随机搜索省时。步骤如下：</p>
<p>① 定义优化函数(rf_cv）</p>
<p>② 建立模型</p>
<p>③ 定义待优化的参数</p>
<p>④ 得到优化结果，并返回要优化的分数指标</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="comment">#定义优化函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rf_cv_lgb</span>(<span class="params">num_leaves, max_depth, bagging_fraction, feature_fraction, bagging_freq, min_data_in_leaf, </span></span></span><br><span class="line"><span class="function"><span class="params">              min_child_weight, min_split_gain, reg_lambda, reg_alpha</span>):</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立模型</span></span><br><span class="line">    model_lgb = lgb.LGBMClassifier(boosting_type=<span class="string">&#x27;gbdt&#x27;</span>, objective=<span class="string">&#x27;multiclass&#x27;</span>, num_class=<span class="number">4</span>,learning_rate=<span class="number">0.1</span>, n_estimators=<span class="number">5000</span>,num_leaves=<span class="built_in">int</span>(num_leaves), max_depth=<span class="built_in">int</span>(max_depth), bagging_fraction=<span class="built_in">round</span>(bagging_fraction, <span class="number">2</span>), feature_fraction=<span class="built_in">round</span>(feature_fraction, <span class="number">2</span>),bagging_freq=<span class="built_in">int</span>(bagging_freq), min_data_in_leaf=<span class="built_in">int</span>(min_data_in_leaf),min_child_weight=min_child_weight)</span><br><span class="line">    f1 = make_scorer(f1_score, average=<span class="string">&#x27;micro&#x27;</span>)</span><br><span class="line">    val = cross_val_score(model_lgb, X_train_split, y_train_split, cv=<span class="number">5</span>, scoring=f1).mean()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> val</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bayes_opt <span class="keyword">import</span> BayesianOptimization</span><br><span class="line"><span class="comment">#定义优化参数</span></span><br><span class="line">bayes_lgb = BayesianOptimization(</span><br><span class="line">    rf_cv_lgb, </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;num_leaves&#x27;</span>:(<span class="number">10</span>, <span class="number">200</span>),</span><br><span class="line">        <span class="string">&#x27;max_depth&#x27;</span>:(<span class="number">3</span>, <span class="number">20</span>),</span><br><span class="line">        <span class="string">&#x27;bagging_fraction&#x27;</span>:(<span class="number">0.5</span>, <span class="number">1.0</span>),</span><br><span class="line">        <span class="string">&#x27;feature_fraction&#x27;</span>:(<span class="number">0.5</span>, <span class="number">1.0</span>),</span><br><span class="line">        <span class="string">&#x27;bagging_freq&#x27;</span>:(<span class="number">0</span>, <span class="number">100</span>),</span><br><span class="line">        <span class="string">&#x27;min_data_in_leaf&#x27;</span>:(<span class="number">10</span>,<span class="number">100</span>),</span><br><span class="line">        <span class="string">&#x27;min_child_weight&#x27;</span>:(<span class="number">0</span>, <span class="number">10</span>),</span><br><span class="line">        <span class="string">&#x27;min_split_gain&#x27;</span>:(<span class="number">0.0</span>, <span class="number">1.0</span>),</span><br><span class="line">        <span class="string">&#x27;reg_alpha&#x27;</span>:(<span class="number">0.0</span>, <span class="number">10</span>),</span><br><span class="line">        <span class="string">&#x27;reg_lambda&#x27;</span>:(<span class="number">0.0</span>, <span class="number">10</span>),</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">#开始优化</span></span><br><span class="line">bayes_lgb.maximize(n_iter=<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#显示优化结果</span></span><br><span class="line">bayes_lgb.<span class="built_in">max</span></span><br></pre></td></tr></table></figure>

<p>参数优化完成后，可根据优化后的参数建立新的模型，降低学习率并寻找最优模型迭代次数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置较小的学习率，并通过cv函数确定当前最优的迭代次数</span></span><br><span class="line">base_params_lgb = &#123;</span><br><span class="line">                    <span class="string">&#x27;boosting_type&#x27;</span>: <span class="string">&#x27;gbdt&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;objective&#x27;</span>: <span class="string">&#x27;multiclass&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;num_class&#x27;</span>: <span class="number">4</span>,</span><br><span class="line">                    <span class="string">&#x27;learning_rate&#x27;</span>: <span class="number">0.01</span>,</span><br><span class="line">                    <span class="string">&#x27;num_leaves&#x27;</span>: <span class="number">138</span>,</span><br><span class="line">                    <span class="string">&#x27;max_depth&#x27;</span>: <span class="number">11</span>,</span><br><span class="line">                    <span class="string">&#x27;min_data_in_leaf&#x27;</span>: <span class="number">43</span>,</span><br><span class="line">                    <span class="string">&#x27;min_child_weight&#x27;</span>: <span class="number">6.5</span>,</span><br><span class="line">                    <span class="string">&#x27;bagging_fraction&#x27;</span>: <span class="number">0.64</span>,</span><br><span class="line">                    <span class="string">&#x27;feature_fraction&#x27;</span>: <span class="number">0.93</span>,</span><br><span class="line">                    <span class="string">&#x27;bagging_freq&#x27;</span>: <span class="number">49</span>,</span><br><span class="line">                    <span class="string">&#x27;reg_lambda&#x27;</span>: <span class="number">7</span>,</span><br><span class="line">                    <span class="string">&#x27;reg_alpha&#x27;</span>: <span class="number">0.21</span>,</span><br><span class="line">                    <span class="string">&#x27;min_split_gain&#x27;</span>: <span class="number">0.288</span>,</span><br><span class="line">                    <span class="string">&#x27;nthread&#x27;</span>: <span class="number">10</span>,</span><br><span class="line">                    <span class="string">&#x27;verbose&#x27;</span>: -<span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cv_result_lgb = lgb.cv(</span><br><span class="line">    train_set=train_matrix,</span><br><span class="line">    early_stopping_rounds=<span class="number">1000</span>, </span><br><span class="line">    num_boost_round=<span class="number">20000</span>,</span><br><span class="line">    nfold=<span class="number">5</span>,</span><br><span class="line">    stratified=<span class="literal">True</span>,</span><br><span class="line">    shuffle=<span class="literal">True</span>,</span><br><span class="line">    params=base_params_lgb,</span><br><span class="line">    feval=f1_score_vali,</span><br><span class="line">    seed=<span class="number">0</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;迭代次数&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(cv_result_lgb[<span class="string">&#x27;f1_score-mean&#x27;</span>])))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最终模型的f1为&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">max</span>(cv_result_lgb[<span class="string">&#x27;f1_score-mean&#x27;</span>])))</span><br></pre></td></tr></table></figure>

<p>模型参数确定之后，建立最终模型并对验证集进行验证。</p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Grid search</tag>
        <tag>Bayesian optimization</tag>
        <tag>Cross validation</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas的一些常用操作_1</title>
    <url>/2021/02/21/pandas_1/</url>
    <content><![CDATA[<blockquote>
<p>今天介绍几个常用的Pandas操作。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;./economics.csv&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="1-DataFrame-to-markdown-latex"><a href="#1-DataFrame-to-markdown-latex" class="headerlink" title="1.DataFrame to markdown/latex"></a>1.DataFrame to markdown/latex</h4><p>dataframe可以转换为许多常用格式，如csv,excel,sql,json,html,latex等等，这里以markdown和latex为例。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(df.to_markdown())</span><br><span class="line"><span class="built_in">print</span>(df.to_latex())</span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.to_markdown(<span class="string">&#x27;table.md&#x27;</span>)</span><br><span class="line">df.to_latex(<span class="string">&#x27;table.tex&#x27;</span>)</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>也可以自定义输出latex格式，如表格宽度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.to_latex(<span class="string">&#x27;tb.tex&#x27;</span>,column_format=<span class="string">&#x27;lp&#123;1.8cm&#125;p&#123;1.8cm&#125;p&#123;1.8cm&#125;p&#123;1.8cm&#125;p&#123;1.8cm&#125;p&#123;1.8cm&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>除此以外，dataframe还可以保存为图片。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> dataframe_image <span class="keyword">as</span> dfi</span><br><span class="line">dfi.export(obj = df, filename = <span class="string">&#x27;table.jpg&#x27;</span>, fontsize=<span class="number">15</span>)</span><br></pre></td></tr></table></figure>
<h4 id="2-DataFrame常用属性查询"><a href="#2-DataFrame常用属性查询" class="headerlink" title="2.DataFrame常用属性查询"></a>2.DataFrame常用属性查询</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.values	<span class="comment">#值</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.index	<span class="comment">#索引号</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.columns	<span class="comment">#列标签</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.dtypes	<span class="comment">#数据类型</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.shape	<span class="comment">#形状(几行几列)</span></span><br></pre></td></tr></table></figure>
<h4 id="3-DataFrame常用基本函数"><a href="#3-DataFrame常用基本函数" class="headerlink" title="3.DataFrame常用基本函数"></a>3.DataFrame常用基本函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.head(<span class="number">5</span>)	<span class="comment">#前5行</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.tail(<span class="number">5</span>)	<span class="comment">#后5行</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.info()	<span class="comment">#信息概况</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.describe()	<span class="comment">#主要统计量(count、mean、std、max、min、quartile)</span></span><br></pre></td></tr></table></figure>
<h4 id="4-DataFrame唯一值函数"><a href="#4-DataFrame唯一值函数" class="headerlink" title="4.DataFrame唯一值函数"></a>4.DataFrame唯一值函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;psavert&#x27;</span>].unique()	<span class="comment">#唯一值组成的数组</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;psavert&#x27;</span>].nunique()    <span class="comment">#唯一值个数</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;psavert&#x27;</span>].value_counts()    <span class="comment">#唯一值及其频数</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.describe()    <span class="comment">#主要统计量(count、mean、std、max、min、quartile)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;psavert&#x27;</span>].duplicated()    <span class="comment">#重复行的布尔值</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[df[<span class="string">&#x27;psavert&#x27;</span>].duplicated()]    <span class="comment">#单列去重(删除重复行)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.drop_duplicates(subset=[<span class="string">&#x27;psavert&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>], keep=<span class="string">&#x27;first&#x27;</span>)    <span class="comment">#多列去重(保留first唯一值)</span></span><br></pre></td></tr></table></figure>
<h4 id="5-DataFrame替换函数"><a href="#5-DataFrame替换函数" class="headerlink" title="5.DataFrame替换函数"></a>5.DataFrame替换函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;psavert&#x27;</span>].replace(<span class="number">12.5</span>, <span class="string">&#x27;A&#x27;</span>, inplace = <span class="literal">True</span>)    <span class="comment">#替换某列的单个值</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;psavert&#x27;</span>].replace(&#123;<span class="number">12.5</span>:<span class="string">&#x27;A&#x27;</span>, <span class="number">11.7</span>:<span class="string">&#x27;B&#x27;</span>&#125;, inplace = <span class="literal">True</span>)    <span class="comment">#替换某列的多个值</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;date&#x27;</span>].replace(&#123;<span class="string">r&#x27;2\d+&#x27;</span>: <span class="string">&#x27;The 21st century&#x27;</span>&#125;, regex=<span class="literal">True</span>, inplace = <span class="literal">True</span>)    <span class="comment">#正则替换</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;psavert&#x27;</span>].mask(df[<span class="string">&#x27;psavert&#x27;</span>]&gt;<span class="number">12.0</span> ,<span class="string">&#x27;A&#x27;</span>, inplace = <span class="literal">True</span>)    <span class="comment">#条件符合，进行替换</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;psavert&#x27;</span>].where(df[<span class="string">&#x27;psavert&#x27;</span>]&lt;<span class="number">12.0</span> ,<span class="string">&#x27;A&#x27;</span>, inplace = <span class="literal">True</span>)    <span class="comment">#条件不符合，进行替换</span></span><br></pre></td></tr></table></figure>
<h4 id="5-DataFrame排序函数"><a href="#5-DataFrame排序函数" class="headerlink" title="5.DataFrame排序函数"></a>5.DataFrame排序函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.sort_values(<span class="string">&#x27;psavert&#x27;</span>,ascending = <span class="literal">False</span>)    <span class="comment">#单列降序排序</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.sort_values([<span class="string">&#x27;psavert&#x27;</span>,<span class="string">&#x27;uempmed&#x27;</span>],ascending=[<span class="literal">True</span>,<span class="literal">False</span>])    <span class="comment">#前者升序情况下，后降序</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>今天先写到这，下一期接着写DataFrame的apply方法。</p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas的一些常用操作_2</title>
    <url>/2021/02/21/pandas_2/</url>
    <content><![CDATA[<blockquote>
<p>今天继续介绍几个常用的Pandas操作。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;./economics.csv&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="1-DataFrame的apply方法"><a href="#1-DataFrame的apply方法" class="headerlink" title="1.DataFrame的apply方法"></a>1.DataFrame的apply方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[[<span class="string">&#x27;psavert&#x27;</span>,<span class="string">&#x27;uempmed&#x27;</span>]].apply(<span class="keyword">lambda</span> x:x.<span class="built_in">max</span>()-x.<span class="built_in">min</span>(), axis=<span class="number">1</span>)<span class="comment">#axis=1 将函数应用到列</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.applymap(<span class="keyword">lambda</span> x:x*<span class="number">10</span>)<span class="comment">#applymap 将函数应用到每个元素</span></span><br></pre></td></tr></table></figure>
<h4 id="2-DataFrame的分组"><a href="#2-DataFrame的分组" class="headerlink" title="2.DataFrame的分组"></a>2.DataFrame的分组</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.groupby(<span class="string">&#x27;unemploy&#x27;</span>)[<span class="string">&#x27;psavert&#x27;</span>].median()<span class="comment">#样例:df.groupby(分组依据)[数据来源].使用操作</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">condition = df.unemploy &gt; df.unemploy.mean()<span class="comment">#使用condition定义分组依据</span></span><br><span class="line">df.groupby(condition)[<span class="string">&#x27;psavert&#x27;</span>].mean()<span class="comment">#分为True和False两组</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.groupby([condition, df[<span class="string">&#x27;unemploy&#x27;</span>]])[<span class="string">&#x27;psavert&#x27;</span>].mean()<span class="comment">#True组和False两组分别细分</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.groupby([df[<span class="string">&#x27;unemploy&#x27;</span>], df[<span class="string">&#x27;uempmed&#x27;</span>]])[<span class="string">&#x27;psavert&#x27;</span>].mean()<span class="comment">#两级分组</span></span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gb = df.groupby([<span class="string">&#x27;unemploy&#x27;</span>])<span class="comment">#Groupby对象</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gb.size()<span class="comment">#每组的元素个数</span></span><br><span class="line"><span class="comment">#和DataFrame一样，Groupby对象也有max\idxmin\all\\nunique\quantile\prod等函数，这里不一一列举。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gb.agg([<span class="string">&#x27;skew&#x27;</span>, <span class="string">&#x27;sum&#x27;</span>, <span class="string">&#x27;idxmax&#x27;</span>])<span class="comment">#agg聚合函数，查看每个分组的三个统计量</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gb.agg(<span class="keyword">lambda</span> x: x.mean()-x.<span class="built_in">min</span>())<span class="comment">#在agg中自定义函数</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gb.<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x.shape[<span class="number">0</span>] &gt; <span class="number">100</span>)<span class="comment">#组过滤</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gb.apply(<span class="keyword">lambda</span> x: x**<span class="number">2</span>)<span class="comment">#组的apply方法</span></span><br></pre></td></tr></table></figure>
<h4 id="3-DataFrame的连接"><a href="#3-DataFrame的连接" class="headerlink" title="3.DataFrame的连接"></a>3.DataFrame的连接</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df1 = df[<span class="number">0</span>:<span class="number">10</span>]</span><br><span class="line">df2 = df[<span class="number">10</span>:<span class="number">20</span>]</span><br><span class="line">df1.merge(df2, on=<span class="string">&#x27;date&#x27;</span>, how=<span class="string">&#x27;outer&#x27;</span>)<span class="comment">#merge表示关系型连接，包括左连接、右连接、内连接和外(全)连接</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.concat([df1, df2], axis=<span class="number">0</span>)<span class="comment">#concat是方向性连接，axis=0表示纵向连接</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">choose_min</span>(<span class="params">x1, x2</span>):</span></span><br><span class="line">    <span class="built_in">min</span> = x1.where(x1&lt;x2, x1)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span></span><br><span class="line">df1.combine(df2, choose_min)<span class="comment">#使用combine函数自定义连接规则</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>下一期是Pandas的常见数据处理，包括缺失数据、文本数据、分类数据和时序数据。</p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas的一些常用操作_3</title>
    <url>/2021/02/21/pandas_3/</url>
    <content><![CDATA[<blockquote>
<p>今天介绍Pandas对一些常见数据的处理方法。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;./economics.csv&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="1-缺失数据处理"><a href="#1-缺失数据处理" class="headerlink" title="1.缺失数据处理"></a>1.缺失数据处理</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.isna()<span class="comment">#是否有缺失值</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.isna().mean()<span class="comment">#缺失的比例 </span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[df.psavert.isna()]<span class="comment">#查看某列是否有缺失值</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[df[[<span class="string">&#x27;psavert&#x27;</span>,<span class="string">&#x27;pop&#x27;</span>,<span class="string">&#x27;uempmed&#x27;</span>]].isna().<span class="built_in">any</span>(<span class="number">1</span>)]<span class="comment">#查看所有列至少有一个缺失值的行“any()至少有一个为空,all()都为空”</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[df[[<span class="string">&#x27;psavert&#x27;</span>,<span class="string">&#x27;pop&#x27;</span>,<span class="string">&#x27;uempmed&#x27;</span>]].notna().<span class="built_in">all</span>(<span class="number">1</span>)]<span class="comment">#查看所有没有缺失值的行</span></span><br><span class="line">df.loc[df[[<span class="string">&#x27;psavert&#x27;</span>,<span class="string">&#x27;pop&#x27;</span>,<span class="string">&#x27;uempmed&#x27;</span>]].notna().<span class="built_in">all</span>(<span class="number">1</span>)]<span class="comment">#查看所有没有缺失值的区域</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.dropna(axis = <span class="number">0</span>, how = <span class="string">&#x27;any&#x27;</span>, subset = [<span class="string">&#x27;psavert&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>])<span class="comment">#axis=0(删除)行,how=&#x27;any&#x27;至少有一个缺失的行</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.dropna(axis = <span class="number">1</span>, thresh = df.shape[<span class="number">0</span>]-<span class="number">5</span>)<span class="comment">#删除超过5个缺失值的列</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.fillna(method = <span class="string">&#x27;ffill&#x27;</span>, limit = <span class="number">1</span>)<span class="comment">#method=&#x27;ffill&#x27;用前面的元素填充/method=&#x27;bfill&#x27;用后面的元素填充,limit=1连续缺失值的最大填充次数为1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.fillna(df.mean())<span class="comment">#用每列的均值填充</span></span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.interpolate(limit_direction=<span class="string">&#x27;both&#x27;</span>, limit=<span class="number">1</span>)<span class="comment">#用线性插值填充(both为双向限制插值)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.interpolate(<span class="string">&#x27;nearest&#x27;</span>).values<span class="comment">#用最近邻插值填充</span></span><br></pre></td></tr></table></figure>
<p>此外，也可以<a href="https://blog.csdn.net/wj1298250240/article/details/103600075">使用KNN来填充缺失值</a>。</p>
<h4 id="2-文本数据处理"><a href="#2-文本数据处理" class="headerlink" title="2.文本数据处理"></a>2.文本数据处理</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts = pd.Series(df[<span class="string">&#x27;Area&#x27;</span>].values, index=df[<span class="string">&#x27;pct_2014&#x27;</span>])<span class="comment">#DataFrame转换为Series</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts.<span class="built_in">str</span>[<span class="number">0</span>]<span class="comment">#查看第一个字符</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts.<span class="built_in">str</span>.<span class="built_in">len</span>()<span class="comment">#查看字符长度</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts.<span class="built_in">str</span>.split(<span class="string">&#x27;[aon]&#x27;</span>, n=<span class="number">3</span>, expand=<span class="literal">True</span>)<span class="comment">#从左到右拆分字符串，最大拆分次数3次，生成多列</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts.<span class="built_in">str</span>.join(<span class="string">&#x27;-&#x27;</span>)<span class="comment">#每个字符用“-”连接</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts.<span class="built_in">str</span>.cat(ts2, sep=<span class="string">&#x27;-&#x27;</span>)<span class="comment">#合并两个字符Series，连接符为“-”</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts.<span class="built_in">str</span>.contains(<span class="string">&#x27;[a-z]u&#x27;</span>)<span class="comment">#查看包含正则模式的序列</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts.<span class="built_in">str</span>.startswith(<span class="string">&#x27;A&#x27;</span>)<span class="comment">#查看以A为开始的序列</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts.<span class="built_in">str</span>.endswith(<span class="string">&#x27;e&#x27;</span>)<span class="comment">#查看以e为结尾的序列</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts.<span class="built_in">str</span>.match(<span class="string">&#x27;A|s&#x27;</span>)<span class="comment">#查看以A为开头,s为结尾的序列</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts.<span class="built_in">str</span>.count(<span class="string">&#x27;[A|s]&#x27;</span>)<span class="comment">#查看以A为开头,s为结尾的序列数量</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts.<span class="built_in">str</span>.find(<span class="string">&#x27;de&#x27;</span>)<span class="comment">#从左往右寻找&#x27;de&#x27;,匹配返回位置索引,未找到返回&#x27;-1&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts.<span class="built_in">str</span>.rfind(<span class="string">&#x27;de&#x27;</span>)<span class="comment">#从右往左寻找</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts.<span class="built_in">str</span>.replace(<span class="string">&#x27;\s?&#x27;</span>, <span class="string">&#x27;LA&#x27;</span>, regex=<span class="literal">True</span>)<span class="comment">#使用正则进行字符串替换</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pat = <span class="string">&#x27;(\w+o)(\w+s)(\w+u)(\w+n)&#x27;</span></span><br><span class="line">ts.<span class="built_in">str</span>.extract(pat)<span class="comment">#拆分&#x27;o&#x27;,&#x27;s&#x27;,&#x27;u&#x27;,&#x27;n&#x27;为4列</span></span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.to_numeric(ts, errors=<span class="string">&#x27;ignore&#x27;</span>)<span class="comment">#将可以转为数值的字符转为数值</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts.<span class="built_in">str</span>.pad(<span class="number">6</span>,<span class="string">&#x27;left&#x27;</span>,<span class="string">&#x27;*&#x27;</span>)<span class="comment">#选定字符串长度为6的填充为&quot;*&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts.<span class="built_in">str</span>.lstrip()<span class="comment">#去掉字符串左侧空格</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts.<span class="built_in">str</span>.zfill(<span class="number">8</span>)<span class="comment">#用0补足8位</span></span><br></pre></td></tr></table></figure>
<h4 id="3-分类数据"><a href="#3-分类数据" class="headerlink" title="3.分类数据"></a>3.分类数据</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = df.psavert.astype(<span class="string">&#x27;category&#x27;</span>)<span class="comment">#Dataframe转为category对象</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s.cat.categories<span class="comment">#查看分类对象属性</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s.cat.add_categories(<span class="string">&#x27;C1&#x27;</span>)<span class="comment">#增加一个类别</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s.cat.remove_categories(<span class="number">11.7</span>)<span class="comment">#删除一个类别</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = s.cat.rename_categories(&#123;<span class="string">&#x27;S1&#x27;</span>:<span class="string">&#x27;xxx&#x27;</span>&#125;)<span class="comment">#重命名类别及其值</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s.cat.reorder_categories([<span class="string">&#x27;S1&#x27;</span>, <span class="string">&#x27;S2&#x27;</span>, <span class="string">&#x27;S3&#x27;</span>, <span class="string">&#x27;S4&#x27;</span>], ordered=<span class="literal">True</span>)<span class="comment">#设置排序</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.sort_values(<span class="string">&#x27;psavert&#x27;</span>)<span class="comment">#值排序</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.set_index(<span class="string">&#x27;psavert&#x27;</span>).sort_index()<span class="comment">#作为索引排序</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = df.psavert &lt;= <span class="string">&#x27;S4&#x27;</span><span class="comment">#比较顺序</span></span><br><span class="line">res</span><br></pre></td></tr></table></figure>
<h4 id="4-时序数据"><a href="#4-时序数据" class="headerlink" title="4.时序数据"></a>4.时序数据</h4><p>————-图——————–</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = pd.to_datetime(df.date)<span class="comment">#生成时间序列</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s2 = pd.to_datetime([<span class="string">&#x27;2020\\1\\1&#x27;</span>,<span class="string">&#x27;2020\\1\\3&#x27;</span>],<span class="built_in">format</span>=<span class="string">&#x27;%Y\\%m\\%d&#x27;</span>)<span class="comment">#强制格式转换,生成时间序列</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.date_range(<span class="string">&#x27;1967-07-01&#x27;</span>,<span class="string">&#x27;2015-04-01&#x27;</span>, freq=<span class="string">&#x27;D&#x27;</span>)<span class="comment">#查看两个时间之间的时间,间隔1天</span></span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#dt对象</span></span><br><span class="line">s.dt.daysinmonth<span class="comment">#每个月几天</span></span><br><span class="line">s.dt.dayofweek<span class="comment">#每周几天</span></span><br><span class="line">s.dt.dayofweek.isin([<span class="number">5</span>,<span class="number">6</span>])<span class="comment">#是否包含双休日</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.Timestamp(<span class="string">&#x27;20210223 22:00:00&#x27;</span>)-pd.Timestamp(<span class="string">&#x27;20210222 18:35:00&#x27;</span>)<span class="comment">#计算两个时间之差</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>图神经网络——基于图神经网络的节点表征学习</title>
    <url>/2021/06/23/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%8A%82%E7%82%B9%E8%A1%A8%E5%BE%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>Graph的特征表示非常复杂：</p>
<blockquote>
<p>1.复杂的拓扑结构，较难从图像中的感受野提取有效信息；<br>2.无特定的节点顺序；<br>3.通常graph会是动态变化的， 且使用多模态特征。</p>
</blockquote>
<p>高质量的节点表征能够用于衡量节点的相似性，同时高质量的节点表征也是准确分类节点的前提。</p>
<p>本文以Cora论文引用网络数据集为例，对MLP、GCN、GAT三种神经网络的分类性能进行对比。首先载入数据集并定义可视化函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#载入数据集</span></span><br><span class="line"><span class="keyword">from</span> torch_geometric.datasets <span class="keyword">import</span> Planetoid</span><br><span class="line"><span class="keyword">from</span> torch_geometric.transforms <span class="keyword">import</span> NormalizeFeatures</span><br><span class="line"></span><br><span class="line">dataset = Planetoid(root=<span class="string">&#x27;dataset&#x27;</span>, name=<span class="string">&#x27;Cora&#x27;</span>, transform=NormalizeFeatures())</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义可视化函数，并观察整体数据分布</span></span><br><span class="line"><span class="keyword">from</span> sklearn.manifold <span class="keyword">import</span> TSNE</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visualize</span>(<span class="params">h, color</span>):</span></span><br><span class="line">    z = TSNE(n_components=<span class="number">2</span>).fit_transform(out.detach().cpu().numpy())</span><br><span class="line">    plt.figure(figsize=(<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line">    plt.xticks([])</span><br><span class="line">    plt.yticks([])</span><br><span class="line"></span><br><span class="line">    plt.scatter(z[:, <span class="number">0</span>], z[:, <span class="number">1</span>], s=<span class="number">70</span>, c=color, cmap=<span class="string">&quot;Set2&quot;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line">    </span><br><span class="line">out = data.x</span><br><span class="line">visualize(out,data.y)</span><br></pre></td></tr></table></figure>
<p><img src="https://z3.ax1x.com/2021/06/28/RtavIs.png" alt="整张图"></p>
<h4 id="1-MLP-Multi-layer-Perceptron-在图节点分类中的应用"><a href="#1-MLP-Multi-layer-Perceptron-在图节点分类中的应用" class="headerlink" title="1. MLP(Multi-layer Perceptron)在图节点分类中的应用"></a>1. MLP(Multi-layer Perceptron)在图节点分类中的应用</h4><p>多层感知机（MLP，Multilayer Perceptron）也叫人工神经网络（ANN，Artificial Neural Network）.</p>
<h5 id="1-1-MLP代码"><a href="#1-1-MLP代码" class="headerlink" title="1.1 MLP代码"></a>1.1 MLP代码</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#构造MLP</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Linear</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MLP</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, hidden_channels</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(MLP, self).__init__()</span><br><span class="line">        torch.manual_seed(<span class="number">2021</span>)</span><br><span class="line">        self.lin1 = Linear(dataset.num_features, hidden_channels)</span><br><span class="line">        self.lin2 = Linear(hidden_channels, dataset.num_classes)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.lin1(x)</span><br><span class="line">        x = x.relu()</span><br><span class="line">        x = F.dropout(x, p=<span class="number">0.5</span>, training=self.training)</span><br><span class="line">        x = self.lin2(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">model = MLP(hidden_channels=<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(model)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果：<br>MLP(<br>       (lin1): Linear(in_features=1433, out_features=16, bias=True)<br>       (lin2): Linear(in_features=16, out_features=7, bias=True)<br>)</p>
</blockquote>
<p>该MLP由两个线性层、一个ReLU非线性层和一个dropout组成。第一个线程层将1433维的节点表征嵌入(embedding)到低维空间中(hidden_channels=16)，第二个线性层将节点表征嵌入到类别空间中(num_classes=7)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#训练MLP</span></span><br><span class="line">model = MLP(hidden_channels=<span class="number">16</span>)</span><br><span class="line">criterion = torch.nn.CrossEntropyLoss()  <span class="comment"># Define loss criterion.</span></span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">0.01</span>, weight_decay=<span class="number">5e-4</span>)  <span class="comment"># Define optimizer.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>():</span></span><br><span class="line">    model.train()</span><br><span class="line">    optimizer.zero_grad()  <span class="comment"># Clear gradients.</span></span><br><span class="line">    out = model(data.x)  <span class="comment"># Perform a single forward pass.</span></span><br><span class="line">    loss = criterion(out[data.train_mask], data.y[data.train_mask])  <span class="comment"># Compute the loss solely based on the training nodes.</span></span><br><span class="line">    loss.backward()  <span class="comment"># Derive gradients.</span></span><br><span class="line">    optimizer.step()  <span class="comment"># Update parameters based on gradients.</span></span><br><span class="line">    <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">201</span>):</span><br><span class="line">    <span class="keyword">if</span> epoch % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">        loss = train()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Epoch: <span class="subst">&#123;epoch:03d&#125;</span>, Loss: <span class="subst">&#123;loss:<span class="number">.4</span>f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果:<br>Epoch: 050, Loss: 1.1777<br>Epoch: 100, Loss: 0.5491<br>Epoch: 150, Loss: 0.4577<br>Epoch: 200, Loss: 0.2876</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#测试训练后的MLP</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    out = model(data.x)</span><br><span class="line">    pred = out.argmax(dim=<span class="number">1</span>)  <span class="comment"># Use the class with highest probability.</span></span><br><span class="line">    test_correct = pred[data.test_mask] == data.y[data.test_mask]  <span class="comment"># Check against ground-truth labels.</span></span><br><span class="line">    test_acc = <span class="built_in">int</span>(test_correct.<span class="built_in">sum</span>()) / <span class="built_in">int</span>(data.test_mask.<span class="built_in">sum</span>())  <span class="comment"># Derive ratio of correct predictions.</span></span><br><span class="line">    <span class="keyword">return</span> test_acc</span><br><span class="line"></span><br><span class="line">test_acc = test()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Test Accuracy: <span class="subst">&#123;test_acc:<span class="number">.4</span>f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果：<br>Test Accuracy: 0.5850</p>
</blockquote>
<p>MLP的结果较差，是因为用于训练此神经网络的有标签节点数量过少，它对未见过的节点泛化能力很差。</p>
<h4 id="2-GCN-Graph-Convolutional-Network-在图节点分类中的应用"><a href="#2-GCN-Graph-Convolutional-Network-在图节点分类中的应用" class="headerlink" title="2 GCN(Graph Convolutional Network)在图节点分类中的应用"></a>2 GCN(Graph Convolutional Network)在图节点分类中的应用</h4><p>GCN，图卷积神经网络，本质上和CNN的作用一样，就是一个特征提取器，只不过它的对象是图数据。关键在于如何定义局部感受域:</p>
<ul>
<li>Spatial approach: 指定节点的边的方向;</li>
<li>Spectral approach: 通过图的拉普拉斯矩阵的特征值和特征向量对图结构进行处理.</li>
</ul>
<h5 id="2-1-GCN公式"><a href="#2-1-GCN公式" class="headerlink" title="2.1 GCN公式"></a>2.1 GCN公式</h5><p>$$<br>\mathbf{X}^{\prime} = \mathbf{\hat{D}}^{-1/2} \mathbf{\hat{A}}\mathbf{\hat{D}}^{-1/2} \mathbf{X} \mathbf{\Theta}<br>$$<br>其中$\mathbf{\hat{A}} = \mathbf{A} + \mathbf{I}$表示插入自环的邻接矩阵,$\mathbf{I}$是单位矩阵，$\hat{D}<em>{ii} = \sum</em>{j=0} \hat{A}<em>{ij}$表示$\mathbf{\hat{A}}$的对角线度矩阵。$\mathbf{\hat{D}}^{-1/2} \mathbf{\hat{A}}<br>\mathbf{\hat{D}}^{-1/2}$是对称归一化矩阵，它的节点式公式为：<br>$$<br>\mathbf{x}^{\prime}<em>i = \mathbf{\Theta} \sum</em>{j \in \mathcal{N}(v) \cup{ i }} \frac{e</em>{j,i}}{\sqrt{\hat{d}_j \hat{d}<em>i}} \mathbf{x}<em>j<br>$$<br>其中，$\hat{d}<em>i = 1 + \sum</em>{j \in \mathcal{N}(i)} e</em>{j,i}$，$e</em>{j,i}$表示从源节点$j$到目标节点$i$的边的对称归一化系数（默认值为1.0）。</p>
<h5 id="2-2-GCN代码"><a href="#2-2-GCN代码" class="headerlink" title="2.2 GCN代码"></a>2.2 GCN代码</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#构造GCN</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch_geometric.nn <span class="keyword">import</span> GCNConv</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GCN</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, hidden_channels</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(GCN, self).__init__()</span><br><span class="line">        torch.manual_seed(<span class="number">2021</span>)</span><br><span class="line">        self.conv1 = GCNConv(dataset.num_features, hidden_channels)</span><br><span class="line">        self.conv2 = GCNConv(hidden_channels, dataset.num_classes)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x, edge_index</span>):</span></span><br><span class="line">        <span class="comment"># x:输入节点特征,可以是节点特征矩阵或一维节点索引张量</span></span><br><span class="line">        <span class="comment"># edge_type:每条边的一维关系类型/索引</span></span><br><span class="line">        x = self.conv1(x, edge_index)</span><br><span class="line">        x = x.relu()</span><br><span class="line">        x = F.dropout(x, p=<span class="number">0.5</span>, training=self.training)</span><br><span class="line">        x = self.conv2(x, edge_index)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">model = GCN(hidden_channels=<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(model)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果：<br>GCN(<br>      (conv1): GCNConv(1433, 16)<br>      (conv2): GCNConv(16, 7)<br>)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#可视化未训练的GCN</span></span><br><span class="line">model = GCN(hidden_channels=<span class="number">16</span>)</span><br><span class="line">model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line">out = model(data.x, data.edge_index)</span><br><span class="line">visualize(out, color=data.y)</span><br></pre></td></tr></table></figure>
<p><img src="https://z3.ax1x.com/2021/06/28/RtaLqg.png" alt="未训练GCN"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#训练GCN</span></span><br><span class="line">model = GCN(hidden_channels=<span class="number">16</span>)</span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">0.01</span>, weight_decay=<span class="number">5e-4</span>)</span><br><span class="line">criterion = torch.nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>():</span></span><br><span class="line">      model.train()</span><br><span class="line">      optimizer.zero_grad()  <span class="comment"># Clear gradients.</span></span><br><span class="line">      out = model(data.x, data.edge_index)  <span class="comment"># Perform a single forward pass.</span></span><br><span class="line">      loss = criterion(out[data.train_mask], data.y[data.train_mask])  <span class="comment"># Compute the loss solely based on the training nodes.</span></span><br><span class="line">      loss.backward()  <span class="comment"># Derive gradients.</span></span><br><span class="line">      optimizer.step()  <span class="comment"># Update parameters based on gradients.</span></span><br><span class="line">      <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">201</span>):</span><br><span class="line">    loss = train()</span><br><span class="line">    <span class="keyword">if</span> epoch % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Epoch: <span class="subst">&#123;epoch:03d&#125;</span>, Loss: <span class="subst">&#123;loss:<span class="number">.4</span>f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果：<br>Epoch: 050, Loss: 1.1346<br>Epoch: 100, Loss: 0.5471<br>Epoch: 150, Loss: 0.4021<br>Epoch: 200, Loss: 0.3391</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#测试</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">      model.<span class="built_in">eval</span>()</span><br><span class="line">      out = model(data.x, data.edge_index)</span><br><span class="line">      pred = out.argmax(dim=<span class="number">1</span>)  <span class="comment"># Use the class with highest probability.</span></span><br><span class="line">      test_correct = pred[data.test_mask] == data.y[data.test_mask]  <span class="comment"># Check against ground-truth labels.</span></span><br><span class="line">      test_acc = <span class="built_in">int</span>(test_correct.<span class="built_in">sum</span>()) / <span class="built_in">int</span>(data.test_mask.<span class="built_in">sum</span>())  <span class="comment"># Derive ratio of correct predictions.</span></span><br><span class="line">      <span class="keyword">return</span> test_acc</span><br><span class="line"></span><br><span class="line">test_acc = test()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Test Accuracy: <span class="subst">&#123;test_acc:<span class="number">.4</span>f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果:Test Accuracy: 0.8090</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#可视化训练后的GCN</span></span><br><span class="line">model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line">out = model(data.x, data.edge_index)</span><br><span class="line">visualize(out, color=data.y)</span><br></pre></td></tr></table></figure>
<p><img src="https://z3.ax1x.com/2021/06/28/Rtajaj.png" alt="训练后GCN"></p>
<h4 id="3-GAT-Graph-Attention-Network-在图节点分类中的应用"><a href="#3-GAT-Graph-Attention-Network-在图节点分类中的应用" class="headerlink" title="3.GAT(Graph Attention Network)在图节点分类中的应用"></a>3.GAT(Graph Attention Network)在图节点分类中的应用</h4><p>GAT的提出解决了GCN存在的问题:</p>
<ul>
<li>GCN 假设图是无向的,因为利用了对称的拉普拉斯矩阵 (只有邻接矩阵 A 是对称的，拉普拉斯矩阵才可以正交分解)，不能直接用于有向图。</li>
<li>GCN 不能处理动态图,GCN 在训练时依赖于具体的图结构，测试的时候也要在相同的图上进行。因此只能处理 transductive 任务，不能处理 inductive 任务。</li>
<li>GCN 不能为每个邻居分配不同的权重,GCN 在卷积时对所有邻居节点均一视同仁，不能根据节点重要性分配不同的权重。<h5 id="3-1-GAT公式"><a href="#3-1-GAT公式" class="headerlink" title="3.1 GAT公式"></a>3.1 GAT公式</h5>图注意力算子:<br>$$<br>\mathbf{x}^{\prime}<em>i = \alpha</em>{i,i}\mathbf{\Theta}\mathbf{x}<em>{i} +<br>\sum</em>{j \in \mathcal{N}(i)} \alpha_{i,j}\mathbf{\Theta}\mathbf{x}<em>{j}<br>$$<br>注意力系数$\alpha</em>{i,j}$为:<br>$$<br>\alpha_{i,j} =<br>\frac{<br>\exp\left(\mathrm{LeakyReLU}\left(\mathbf{a}^{\top}<br>[\mathbf{\Theta}\mathbf{x}_i , \Vert , \mathbf{\Theta}\mathbf{x}<em>j]<br>\right)\right)}<br>{\sum</em>{k \in \mathcal{N}(i) \cup { i }}<br>\exp\left(\mathrm{LeakyReLU}\left(\mathbf{a}^{\top}<br>[\mathbf{\Theta}\mathbf{x}_i , \Vert , \mathbf{\Theta}\mathbf{x}_k]<br>\right)\right)}<br>$$<h5 id="3-2-GAT代码"><a href="#3-2-GAT代码" class="headerlink" title="3.2 GAT代码"></a>3.2 GAT代码</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#构造GAT</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Linear</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> torch_geometric.nn <span class="keyword">import</span> GATConv</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GAT</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, hidden_channels</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(GAT, self).__init__()</span><br><span class="line">        torch.manual_seed(<span class="number">2021</span>)</span><br><span class="line">        self.conv1 = GATConv(dataset.num_features, hidden_channels)</span><br><span class="line">        self.conv2 = GATConv(hidden_channels, dataset.num_classes)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x, edge_index</span>):</span></span><br><span class="line">        x = self.conv1(x, edge_index)</span><br><span class="line">        x = x.relu()</span><br><span class="line">        x = F.dropout(x, p=<span class="number">0.5</span>, training=self.training)</span><br><span class="line">        x = self.conv2(x, edge_index)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">model = GAT(hidden_channels=<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(model)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果:<br>GAT(</p>
<pre><code>(conv1): GATConv(1433, 16, heads=1)
(conv2): GATConv(16, 7, heads=1)
</code></pre>
<p>)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#可视化未训练的GAT</span></span><br><span class="line">model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line">out = model(data.x, data.edge_index)</span><br><span class="line">visualize(out, color=data.y)</span><br></pre></td></tr></table></figure>
<img src="https://z3.ax1x.com/2021/06/28/RtaqsS.png" alt="未训练GAT"></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#训练GAT</span></span><br><span class="line">model = GAT(hidden_channels=<span class="number">16</span>)</span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">0.01</span>, weight_decay=<span class="number">5e-4</span>)</span><br><span class="line">criterion = torch.nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>():</span></span><br><span class="line">      model.train()</span><br><span class="line">      optimizer.zero_grad()  <span class="comment"># Clear gradients.</span></span><br><span class="line">      out = model(data.x, data.edge_index)  <span class="comment"># Perform a single forward pass.</span></span><br><span class="line">      loss = criterion(out[data.train_mask], data.y[data.train_mask])  <span class="comment"># 只根据训练节点计算损失</span></span><br><span class="line">      loss.backward()  <span class="comment"># Derive gradients.</span></span><br><span class="line">      optimizer.step()  <span class="comment"># 根据梯度更新参数</span></span><br><span class="line">      <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">201</span>):</span><br><span class="line">    loss = train()</span><br><span class="line">    <span class="keyword">if</span> epoch % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Epoch: <span class="subst">&#123;epoch:03d&#125;</span>, Loss: <span class="subst">&#123;loss:<span class="number">.4</span>f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果:<br>Epoch: 050, Loss: 0.8583<br>Epoch: 100, Loss: 0.3209<br>Epoch: 150, Loss: 0.2267<br>Epoch: 200, Loss: 0.1939</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#测试GAT</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">      model.<span class="built_in">eval</span>()</span><br><span class="line">      out = model(data.x, data.edge_index)</span><br><span class="line">      pred = out.argmax(dim=<span class="number">1</span>)  <span class="comment"># 选取概率最高的一类</span></span><br><span class="line">      test_correct = pred[data.test_mask] == data.y[data.test_mask]		<span class="comment"># 预测与真实对比</span></span><br><span class="line">      test_acc = <span class="built_in">int</span>(test_correct.<span class="built_in">sum</span>()) / <span class="built_in">int</span>(data.test_mask.<span class="built_in">sum</span>())	<span class="comment"># 准确率</span></span><br><span class="line">      <span class="keyword">return</span> test_acc</span><br><span class="line"></span><br><span class="line">test_acc = test()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Test Accuracy: <span class="subst">&#123;test_acc:<span class="number">.4</span>f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果:Test Accuracy: 0.7310</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#可视化训练后的GAT</span></span><br><span class="line">model = GAT(hidden_channels=<span class="number">16</span>)</span><br><span class="line">model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line">out = model(data.x, data.edge_index)</span><br><span class="line">visualize(out, color=data.y)</span><br></pre></td></tr></table></figure>
<p><img src="https://z3.ax1x.com/2021/06/28/RtaXZQ.png" alt="训练后GAT"></p>
<h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h4><p>GCN和GAT的结果都优于MLP,原因是他们同时考虑了节点自身信息与周围邻接节点的信息.</p>
<p>GCN和GAT的共同点:</p>
<ul>
<li>都遵循消息传递范式；</li>
<li>在邻接节点信息变换阶段，它们都对邻接节点做归一化和线性变换；</li>
<li>在邻接节点信息聚合阶段，它们都将变换后的邻接节点信息做求和聚合；</li>
<li>在中心节点信息变换阶段，它们都只是简单返回邻接节点信息聚合阶段的聚合结果。</li>
</ul>
<p>GCN和GAT的不同点在于归一化方法不同():</p>
<ul>
<li>GCN根据中心节点与邻接节点的度计算归一化系数;GAT根据中心节点与邻接节点的相似度计算归一化系数。</li>
<li>GCN的归一化方式依赖于图的拓扑结构：不同的节点会有不同的度，同时不同节点的邻接节点的度也不同，于是在一些应用中GCN图神经网络会表现出较差的泛化能力;GAT的归一化方式依赖于中心节点与邻接节点的相似度，相似度是训练得到的，因此不受图的拓扑结构的影响，在不同的任务中都会有较好的泛化表现。</li>
</ul>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>1.<a href="https://github.com/datawhalechina/team-learning-nlp/tree/master/GNN">datawhale-GNN开源学习资料</a><br>2.<a href="https://zhuanlan.zhihu.com/p/306261981">知乎-图节点表征学习</a><br>3.<a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/nn.html#torch_geometric.nn.conv.RGCNConv">GCNConv官方文档</a><br>4.<a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/nn.html#torch_geometric.nn.conv.GATConv">GATConv官方文档</a><br>5.<a href="https://baijiahao.baidu.com/s?id=1671028964544884749&wfr=spider&for=pc">GAT图注意力网络</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>PyG</tag>
        <tag>Graph</tag>
        <tag>MLP</tag>
        <tag>GCN</tag>
        <tag>GAT</tag>
      </tags>
  </entry>
  <entry>
    <title>Tsfresh——自动化特征工程工具</title>
    <url>/2021/03/25/tsfresh/</url>
    <content><![CDATA[<blockquote>
<p>改进模型的潜在途径之一是：生成更多的潜在特征，输入更多的样本。</p>
</blockquote>
<p>Tsfresh是处理时间序列数据的特征工程工具，能够自动计算大量时间序列特征，如平均值、最大值、峰度等。之后，可以使用这些特征集构建机器学习模型。</p>
<p>本文以<em>天池-心跳信号分类预测</em>为例，演示tsfresh工具的用法。</p>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><h5 id="1-合并train和test数据"><a href="#1-合并train和test数据" class="headerlink" title="1. 合并train和test数据"></a>1. 合并train和test数据</h5><p>合并数据集，对整体数据做统一的特征工程。(注意需要为test数据添加label列，值为-1，方便后续操作)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_test[<span class="string">&#x27;label&#x27;</span>] = -<span class="number">1</span></span><br><span class="line">all_data = pd.concat((data_train, data_test)).reset_index(drop = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h5 id="2-对原特征一列拆成多列，并为每条数据添加时间特征time"><a href="#2-对原特征一列拆成多列，并为每条数据添加时间特征time" class="headerlink" title="2. 对原特征一列拆成多列，并为每条数据添加时间特征time"></a>2. 对原特征一列拆成多列，并为每条数据添加时间特征time</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">all_heatbeat_df = all_data[<span class="string">&#x27;heartbeat_signals&#x27;</span>].<span class="built_in">str</span>.split(<span class="string">&#x27;,&#x27;</span>, expand = <span class="literal">True</span>).stack()</span><br></pre></td></tr></table></figure>
<h5 id="3-Index处理"><a href="#3-Index处理" class="headerlink" title="3. Index处理"></a>3. Index处理</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">all_heatbeat_df = all_heatbeat_df.reset_inex()</span><br><span class="line">all_heatbeat_df = all_heatbeat_df.set_inex(<span class="string">&#x27;level_0&#x27;</span>)</span><br><span class="line">all_heatbeat_df.index.name = <span class="literal">None</span></span><br><span class="line">all_heatbeat_df.rename(columns=&#123;<span class="string">&#x27;level_1&#x27;</span>:<span class="string">&#x27;time&#x27;</span>, <span class="number">0</span>:<span class="string">&#x27;heartbeat_signals&#x27;</span>, inpalce = <span class="literal">True</span>&#125;)</span><br><span class="line">all_heatbeat_df[<span class="string">&#x27;heartbeat_signals&#x27;</span>].astype(<span class="built_in">float</span>)</span><br></pre></td></tr></table></figure>

<h5 id="4-label列单独存储，不进入tsfresh"><a href="#4-label列单独存储，不进入tsfresh" class="headerlink" title="4. label列单独存储，不进入tsfresh"></a>4. label列单独存储，不进入tsfresh</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">all_data_label = all_data[<span class="string">&#x27;label&#x27;</span>]</span><br><span class="line">all_data = all_data.drop[<span class="string">&#x27;label&#x27;</span>, axis=<span class="number">1</span>].drop[<span class="string">&#x27;heartbeat_signals&#x27;</span>, axis=<span class="number">1</span>]</span><br><span class="line">all_data = all_data.join(all_heatbeat_df)</span><br></pre></td></tr></table></figure>

<h5 id="5-tsfresh特征抽取"><a href="#5-tsfresh特征抽取" class="headerlink" title="5. tsfresh特征抽取"></a>5. tsfresh特征抽取</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tsfresh <span class="keyword">import</span> extract_features</span><br><span class="line">all_features = extract_features(all_data, column_id=<span class="string">&#x27;id&#x27;</span>, column_sort=<span class="string">&#x27;time&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="6-特征选择"><a href="#6-特征选择" class="headerlink" title="6.特征选择"></a>6.特征选择</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#删除nan值</span></span><br><span class="line"><span class="keyword">from</span> tsfresh.utilities.dataframe_functions <span class="keyword">import</span> impute</span><br><span class="line">impute(all_features)</span><br></pre></td></tr></table></figure>

<h5 id="7-相关性特征提取"><a href="#7-相关性特征提取" class="headerlink" title="7.相关性特征提取"></a>7.相关性特征提取</h5><p>衍生众多特征之后，许多特征之间可能有很多相关性，需进一步筛选。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tsfresh <span class="keyword">import</span> select_features</span><br><span class="line">all_features_filtered = select_features(all_features, all_data_label)</span><br></pre></td></tr></table></figure>
<h5 id="8-特征重命名，重新添加label"><a href="#8-特征重命名，重新添加label" class="headerlink" title="8.特征重命名，重新添加label"></a>8.特征重命名，重新添加label</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = all_features_filtered.columns.size</span><br><span class="line">all_features_filtered.columns = [<span class="string">&#x27;f_&#x27;</span> + <span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">0</span>, num)]</span><br><span class="line">all_features_filtered[<span class="string">&#x27;label&#x27;</span>] = all_data_label</span><br></pre></td></tr></table></figure>

<h4 id="tsfresh包深入探究"><a href="#tsfresh包深入探究" class="headerlink" title="tsfresh包深入探究"></a>tsfresh包深入探究</h4><h5 id="1-筛选特征的方法"><a href="#1-筛选特征的方法" class="headerlink" title="1. 筛选特征的方法"></a>1. 筛选特征的方法</h5><p>上文采用了手工打标签的方式划分训练集和测试集，略显麻烦，可以通过tsfresh的内置方法来提取训练数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kind_to_fc_parameters = tsfresh.feature_extration.settings.from_columns(directed_features)</span><br></pre></td></tr></table></figure>
<p>生成的params为训练集的特征字典，可以当作参数传入后续计算中。</p>
<h5 id="2-自定义特征衍生规则"><a href="#2-自定义特征衍生规则" class="headerlink" title="2. 自定义特征衍生规则"></a>2. 自定义特征衍生规则</h5><p>tsfresh自带的衍生规则以字典的形式存放，可以直接调用，也可以自定义。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#单个特征计算</span></span><br><span class="line">tsfresh.feature_extraction.feature_calculators.abs_energy(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设定衍生规则</span></span><br><span class="line"><span class="keyword">from</span> tsfresh.featureextraction <span class="keyword">import</span> extractfeatures</span><br><span class="line">params = &#123;<span class="string">&#x27;fft_coefficient:[&#123;&#x27;</span>coe<span class="string">f&#x27;:0, &#x27;</span>att<span class="string">r&#x27;:&#x27;</span><span class="built_in">abs</span><span class="string">&#x27;&#125;], &#x27;</span>kurtosis<span class="string">&#x27;: None, &#x27;</span>skewness<span class="string">&#x27;: None&#125;</span></span><br></pre></td></tr></table></figure>

<p>后续可以在extractfeatures中设置defaultparameters = params，具体用法见<a href="https://tsfresh.readthedocs.io/en/latest/text/feature_extraction_settings.html">操作文档</a>。</p>
<h5 id="3-减小内存使用"><a href="#3-减小内存使用" class="headerlink" title="3. 减小内存使用"></a>3. 减小内存使用</h5><p>tsfresh默认参数太吃内存，且耗时长，笔者i7的16G笔记本最多只能跑到60%的进度就会卡住，天池notebook和谷歌colab都是没跑出结果就断线了，硬要跑的话只能租个高配服务器，或者调整衍生特征的数量，通过<strong>chunksize</strong>设置，具体用法见<a href="https://tsfresh.readthedocs.io/en/latest/text/feature_extraction_settings.html">操作文档</a>。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Feature engineering</tag>
      </tags>
  </entry>
  <entry>
    <title>图神经网络——基本图论与PyG库</title>
    <url>/2021/07/05/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%9B%BE%E8%A1%A8%E5%BE%81%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="图神经网络——基于图神经网络的图表征学习方法"><a href="#图神经网络——基于图神经网络的图表征学习方法" class="headerlink" title="图神经网络——基于图神经网络的图表征学习方法"></a>图神经网络——基于图神经网络的图表征学习方法</h3><p>图表征学习要求在输入节点属性、边和边的属性（如果有的话）得到一个向量作为图的表征，基于图表征进一步的我们可以做图的预测，而图同构网络（Graph Isomorphism Network, GIN）的图表征网络是当前最经典的图表征学习网络。</p>
<h4 id="1-GNN的邻域聚合-消息传递"><a href="#1-GNN的邻域聚合-消息传递" class="headerlink" title="1.GNN的邻域聚合(消息传递)"></a>1.GNN的邻域聚合(消息传递)</h4><p>GNN的目标是以图结构数据和节点特征作为输入，以学习到节点（或图）的embedding，用于分类任务。<br>基于邻域聚合的GNN可以拆分为以下三个模块：</p>
<ul>
<li>Aggregate：聚合一阶邻域特征。</li>
<li>Combine：将邻居聚合的特征 与 当前节点特征合并， 以更新当前节点特征。</li>
<li>Readout（可选）：如果是对graph分类，需要将graph中所有节点特征转变成graph特征。</li>
</ul>
<p>但是Aggregate的三种方式sum、mean、max的表征能力不够强大。</p>
<span id="more"></span>

<p><img src="https://i.loli.net/2021/07/12/XQxKfkPsL14g2O5.jpg" alt="FFFF.jpg"><br>如上图，节点v和v’为中心节点，通过聚合邻居特征生成embedding来分析不同aggregate设置下是否能区分不同的结构。设红绿蓝色节点特征值分别为r,g,b，不考虑combine。</p>
<blockquote>
<p>图a中：<br>mean：左$\frac{1}{2}(b+b)=b$，右$\frac{1}{3}(b+b+b)=b$，无法区分；<br>max：左$b$，右$b$，无法区分；<br>sum：左$2b$，右$3b$，可以区分。</p>
</blockquote>
<blockquote>
<p>图b中：<br>mean：左$\frac{1}{2}(r+g)$，右$\frac{1}{3}(g+2r)=b$，可以区分；<br>max：左$max(r,g)$，右$max(r,r,g)$，无法区分；<br>sum：左$r+g$，右$2r+g$，可以区分。</p>
</blockquote>
<blockquote>
<p>图c中：<br>mean：左$\frac{1}{2}(r+g)$，右$\frac{1}{4}(2g+2r)=b$，无法区分；<br>max：左$max(r,g)$，右$max(r,r,g,g)$，无法区分；<br>sum：左$r+g$，右$2r+2g$，可以区分。</p>
</blockquote>
<p>这说明，sum基本可以学习精确的结构信息、mean偏向学习分布信息，max偏向学习有代表性的元素信息，无法区分某些结构的图，故性能会比sum差一点。</p>
<h4 id="2-Weisfeiler-Lehman-Test-WL-Test"><a href="#2-Weisfeiler-Lehman-Test-WL-Test" class="headerlink" title="2.Weisfeiler-Lehman Test (WL Test)"></a>2.Weisfeiler-Lehman Test (WL Test)</h4><p>图的同构性测试算法（Weisfeiler-Lehman），简称WL Test，是一种用于测试两个图是否同构的算法。<br>WL Test 的一维形式，类似GNN中的邻接节点聚合。WL Test先迭代地聚合节点及其邻接节点的标签，然后将聚合的标签散列（hash）成新标签，该过程形式化为下方的公示，<br>$$<br>L^{h}<em>{u} \leftarrow \operatorname{hash}\left(L^{h-1}</em>{u} + \sum_{v \in \mathcal{N}(U)} L^{h-1}<em>{v}\right)<br>$$<br>上式中，$L^{h}</em>{u}$表示节点$u$的第$h$次迭代的标签，第$0$次迭代的标签为节点原始标签。</p>
<p>在迭代过程中，发现两个图之间的节点的标签不同时，就可以确定这两个图是非同构的。需要注意的是节点标签可能的取值只能是有限个数。</p>
<p>WL测试不能保证对所有图都有效，特别是对于具有高度对称性的图，如链式图、完全图、环图和星图，它会判断错误。</p>
<p>给定两个图$G$和$G^{\prime}$，每个节点拥有标签（实际中，一些图没有节点标签，我们可以以节点的度作为标签）。</p>
<p><img src="https://i.loli.net/2021/07/12/yr3axiC4PFOdqkJ.png" alt="C1.png"></p>
<p><strong>Weisfeiler-Leman Test 算法通过重复执行以下给节点打标签的过程来实现图是否同构的判断</strong>：</p>
<ol>
<li>聚合自身与邻接节点的标签得到一串字符串，自身标签与邻接节点的标签中间用<code>,</code>分隔，邻接节点的标签按升序排序。<strong>排序的原因在于要保证单射性，即保证输出的结果不因邻接节点的顺序改变而改变。</strong></li>
</ol>
<p><img src="https://i.loli.net/2021/07/12/wREO2ejIZMWicHv.png" alt="C2.png"></p>
<ol start="2">
<li><strong>标签散列，即标签压缩，将较长的字符串映射到一个简短的标签。</strong></li>
</ol>
<p><img src="https://i.loli.net/2021/07/12/pgdboxL6BKAr9Rz.png" alt="C3.png"></p>
<ol start="3">
<li><strong>给节点重新打上标签。</strong><br><img src="https://i.loli.net/2021/07/12/TOFRUV2INngGCxo.png" alt="C4.png"></li>
</ol>
<p>每重复一次以上的过程，就完成一次节点自身标签与邻接节点标签的聚合。</p>
<p><strong>当出现两个图相同节点标签的出现次数不一致时，即可判断两个图不相似</strong>。如果上述的步骤重复一定的次数后，没有发现有相同节点标签的出现次数不一致的情况，那么我们无法判断两个图是否同构。</p>
<p>当两个节点的$h$层的标签一样时，表示分别以这两个节点为根节点的WL子树是一致的。<strong>WL子树与普通子树不同</strong>，WL子树包含重复的节点。下图展示了一棵以1节点为根节点高为2的WL子树。</p>
<p><img src="https://i.loli.net/2021/07/12/KVkxiSlCvDf63F8.png" alt="C5.png"></p>
<h4 id="3-图相似性评估"><a href="#3-图相似性评估" class="headerlink" title="3.图相似性评估"></a>3.图相似性评估</h4><p>WL Test只能判断两个图的相似性，无法衡量图之间的相似性。要衡量两个图的相似性，需要用WL Subtree Kernel方法。该方法的思想是用WL Test算法得到节点的多层的标签，分别统计图中各类标签出现的次数，存于一个向量，这个向量可以作为图的表征<strong>。</strong>两个图的表征向量的内积，即可作为这两个图的相似性估计，内积越大表示相似性越高。</p>
<p><img src="https://i.loli.net/2021/07/12/IbyZ7h8JEXYRk3t.jpg" alt="gggg.jpg"></p>
<h4 id="4-图同构网络模型的构建"><a href="#4-图同构网络模型的构建" class="headerlink" title="4.图同构网络模型的构建"></a>4.图同构网络模型的构建</h4><p>通过GIN学习的节点表征向量可以用于类似于节点分类、边预测这样的任务。而对于图分类任务。READOUT函数：给定独立的节点的表征向量集，生成整个图的表征向量。</p>
<p>GIN的READOUT模块使用concat+sum，对每次迭代得到的所有节点特征求和得到图的特征，然后拼接起来，公式如下：<br>$$<br>h_{G} = \text{CONCAT}(\text{READOUT}\left({h_{v}^{(k)}|v\in G}\right)|k=0,1,\cdots, K)<br>$$</p>
<h4 id="5-基于图同构网络（GIN）的图表征网络的实现"><a href="#5-基于图同构网络（GIN）的图表征网络的实现" class="headerlink" title="5.基于图同构网络（GIN）的图表征网络的实现"></a>5.基于图同构网络（GIN）的图表征网络的实现</h4><p>基于图同构网络的图表征学习主要包含以下两个过程：</p>
<ol>
<li>计算得到节点表征；</li>
<li>对图上各个节点的表征做图池化（Graph Pooling），或称为图读出（Graph Readout），得到图的表征（Graph Representation）。</li>
</ol>
<p>基于图同构网络的图表征模块（GINGraphRepr Module），首先采用<code>GINNodeEmbedding</code>模块对图上每一个节点做节点嵌入（Node Embedding），得到节点表征；然后对节点表征做图池化得到图的表征；最后用一层线性变换对图表征转换为对图的预测。代码实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch_geometric.nn <span class="keyword">import</span> global_add_pool, global_mean_pool, global_max_pool, GlobalAttention, Set2Set</span><br><span class="line"><span class="keyword">from</span> gin_node <span class="keyword">import</span> GINNodeEmbedding</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GINGraphRepr</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_tasks=<span class="number">1</span>, num_layers=<span class="number">5</span>, emb_dim=<span class="number">300</span>, residual=<span class="literal">False</span>, drop_ratio=<span class="number">0</span>, JK=<span class="string">&quot;last&quot;</span>, graph_pooling=<span class="string">&quot;sum&quot;</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        num_tasks(int, optional)：图表征的维度；</span></span><br><span class="line"><span class="string">    	num_layers(int, optional)：卷积层数；</span></span><br><span class="line"><span class="string">        emb_dim(int, optional)：node embedding的维度；</span></span><br><span class="line"><span class="string">        residual(bool, optional)：是否添加剩余的连接；</span></span><br><span class="line"><span class="string">        drop_ratio (float, optional)：dropout rate；</span></span><br><span class="line"><span class="string">        JK (str, optional)：可选的值为&quot;last&quot;和&quot;sum&quot;。选&quot;last&quot;，只取最后一层的结点的嵌入，选&quot;sum&quot;对各层的结点的嵌入求和。</span></span><br><span class="line"><span class="string">        raph_pooling (str, optional)：node embedding的池化方法，可选的值为&quot;sum&quot;，&quot;mean&quot;，&quot;max&quot;，&quot;attention&quot;和&quot;set2set&quot;。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>(GINGraphPooling, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.num_layers = num_layers</span><br><span class="line">        self.drop_ratio = drop_ratio</span><br><span class="line">        self.JK = JK</span><br><span class="line">        self.emb_dim = emb_dim</span><br><span class="line">        self.num_tasks = num_tasks</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.num_layers &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;Number of GNN layers must be greater than 1.&quot;</span>)</span><br><span class="line"></span><br><span class="line">        self.gnn_node = GINNodeEmbedding(num_layers, emb_dim, JK=JK, drop_ratio=drop_ratio, residual=residual)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Pooling function to generate whole-graph embeddings</span></span><br><span class="line">        <span class="keyword">if</span> graph_pooling == <span class="string">&quot;sum&quot;</span>:</span><br><span class="line">            self.pool = global_add_pool</span><br><span class="line">        <span class="keyword">elif</span> graph_pooling == <span class="string">&quot;mean&quot;</span>:</span><br><span class="line">            self.pool = global_mean_pool</span><br><span class="line">        <span class="keyword">elif</span> graph_pooling == <span class="string">&quot;max&quot;</span>:</span><br><span class="line">            self.pool = global_max_pool</span><br><span class="line">        <span class="keyword">elif</span> graph_pooling == <span class="string">&quot;attention&quot;</span>:</span><br><span class="line">            self.pool = GlobalAttention(gate_nn=nn.Sequential(</span><br><span class="line">                nn.Linear(emb_dim, emb_dim), nn.BatchNorm1d(emb_dim), nn.ReLU(), nn.Linear(emb_dim, <span class="number">1</span>)))</span><br><span class="line">        <span class="keyword">elif</span> graph_pooling == <span class="string">&quot;set2set&quot;</span>:</span><br><span class="line">            self.pool = Set2Set(emb_dim, processing_steps=<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;Invalid graph pooling type.&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> graph_pooling == <span class="string">&quot;set2set&quot;</span>:</span><br><span class="line">            self.graph_pred_linear = nn.Linear(<span class="number">2</span>*self.emb_dim, self.num_tasks)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.graph_pred_linear = nn.Linear(self.emb_dim, self.num_tasks)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, batched_data</span>):</span></span><br><span class="line">        h_node = self.gnn_node(batched_data)</span><br><span class="line"></span><br><span class="line">        h_graph = self.pool(h_node, batched_data.batch)</span><br><span class="line">        output = self.graph_pred_linear(h_graph)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.training:</span><br><span class="line">            <span class="keyword">return</span> output</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># At inference time, relu is applied to output to ensure positivity</span></span><br><span class="line">            <span class="comment"># 因为预测目标的取值范围就在 (0, 50] 内</span></span><br><span class="line">            <span class="keyword">return</span> torch.clamp(output, <span class="built_in">min</span>=<span class="number">0</span>, <span class="built_in">max</span>=<span class="number">50</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>attention：基于Attention对节点表征加权求和，使用模块 <a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/nn.html#torch_geometric.nn.glob.GlobalAttention">torch_geometric.nn.glob.GlobalAttention</a>。<br>set2set：另一种基于Attention对节点表征加权求和的方法，使用模块 <a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/nn.html#torch_geometric.nn.glob.Set2Set">torch_geometric.nn.glob.Set2Set</a>。</p>
</blockquote>
<h4 id="6-基于图同构网络的节点嵌入模块（GINNodeEmbedding-Module）"><a href="#6-基于图同构网络的节点嵌入模块（GINNodeEmbedding-Module）" class="headerlink" title="6.基于图同构网络的节点嵌入模块（GINNodeEmbedding Module）"></a>6.基于图同构网络的节点嵌入模块（GINNodeEmbedding Module）</h4><p>此节点嵌入模块基于多层<code>GINConv</code>实现结点嵌入的计算。首先用<code>AtomEncoder</code>对其做嵌入得到第0层节点表征然后我们逐层计算节点表征，从第1层开始到第num_layers层，每一层节点表征的计算都以上一层的节点表征<code>h_list[layer]</code>、边<code>edge_index</code>和边的属性<code>edge_attr</code>为输入。<br>需要注意的是，<code>GINConv</code>的层数越多，此节点嵌入模块的感受野（receptive field）越大，结点<code>i</code>的表征最远能捕获到结点<code>i</code>的距离为<code>num_layers</code>的邻接节点的信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> mol_encoder <span class="keyword">import</span> AtomEncoder</span><br><span class="line"><span class="keyword">from</span> gin_conv <span class="keyword">import</span> GINConv</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="comment"># GNN to generate node embedding</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GINNodeEmbedding</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Output:</span></span><br><span class="line"><span class="string">        node representations</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_layers, emb_dim, drop_ratio=<span class="number">0.5</span>, JK=<span class="string">&quot;last&quot;</span>, residual=<span class="literal">False</span></span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>(GINNodeEmbedding, self).__init__()</span><br><span class="line">        self.num_layers = num_layers</span><br><span class="line">        self.drop_ratio = drop_ratio</span><br><span class="line">        self.JK = JK</span><br><span class="line">        self.residual = residual</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.num_layers &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;Number of GNN layers must be greater than 1.&quot;</span>)</span><br><span class="line"></span><br><span class="line">        self.atom_encoder = AtomEncoder(emb_dim)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># List of GNNs</span></span><br><span class="line">        self.convs = torch.nn.ModuleList()</span><br><span class="line">        self.batch_norms = torch.nn.ModuleList()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> <span class="built_in">range</span>(num_layers):</span><br><span class="line">            self.convs.append(GINConv(emb_dim))</span><br><span class="line">            self.batch_norms.append(torch.nn.BatchNorm1d(emb_dim))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, batched_data</span>):</span></span><br><span class="line">        x, edge_index, edge_attr = batched_data.x, batched_data.edge_index, batched_data.edge_attr</span><br><span class="line"></span><br><span class="line">        <span class="comment"># computing input node embedding</span></span><br><span class="line">        h_list = [self.atom_encoder(x)]  <span class="comment"># 先将类别型原子属性转化为原子表征</span></span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> <span class="built_in">range</span>(self.num_layers):</span><br><span class="line">            h = self.convs[layer](h_list[layer], edge_index, edge_attr)</span><br><span class="line">            h = self.batch_norms[layer](h)</span><br><span class="line">            <span class="keyword">if</span> layer == self.num_layers - <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># remove relu for the last layer</span></span><br><span class="line">                h = F.dropout(h, self.drop_ratio, training=self.training)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                h = F.dropout(F.relu(h), self.drop_ratio, training=self.training)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.residual:</span><br><span class="line">                h += h_list[layer]</span><br><span class="line"></span><br><span class="line">            h_list.append(h)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Different implementations of Jk-concat</span></span><br><span class="line">        <span class="keyword">if</span> self.JK == <span class="string">&quot;last&quot;</span>:</span><br><span class="line">            node_representation = h_list[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">elif</span> self.JK == <span class="string">&quot;sum&quot;</span>:</span><br><span class="line">            node_representation = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> layer <span class="keyword">in</span> <span class="built_in">range</span>(self.num_layers + <span class="number">1</span>):</span><br><span class="line">                node_representation += h_list[layer]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node_representation</span><br></pre></td></tr></table></figure>
<h4 id="7-图同构卷积层（GINConv）"><a href="#7-图同构卷积层（GINConv）" class="headerlink" title="7.图同构卷积层（GINConv）"></a>7.图同构卷积层（GINConv）</h4><p>图同构卷积层<code>GINConv</code>的数学定义如下：<br>$$<br>\mathbf{x}^{\prime}<em>i = h</em>{\mathbf{\Theta}} \left( (1 + \epsilon) \cdot\mathbf{x}<em>i + \sum</em>{j \in \mathcal{N}(i)} \mathbf{x}_j \right)<br>$$<br>构建代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch_geometric.nn <span class="keyword">import</span> MessagePassing</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> ogb.graphproppred.mol_encoder <span class="keyword">import</span> BondEncoder</span><br><span class="line"></span><br><span class="line"><span class="comment"># GIN convolution along the graph structure</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GINConv</span>(<span class="params">MessagePassing</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, emb_dim</span>):</span></span><br><span class="line">        <span class="comment">#emb_dim (int): node embedding dimensionality</span></span><br><span class="line">        <span class="built_in">super</span>(GINConv, self).__init__(aggr = <span class="string">&quot;add&quot;</span>)</span><br><span class="line"></span><br><span class="line">        self.mlp = nn.Sequential(nn.Linear(emb_dim, emb_dim), nn.BatchNorm1d(emb_dim), nn.ReLU(), nn.Linear(emb_dim, emb_dim))</span><br><span class="line">        self.eps = nn.Parameter(torch.Tensor([<span class="number">0</span>]))</span><br><span class="line">        self.bond_encoder = BondEncoder(emb_dim = emb_dim)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x, edge_index, edge_attr</span>):</span></span><br><span class="line">        edge_embedding = self.bond_encoder(edge_attr) <span class="comment"># 先将类别型边属性转换为边表征</span></span><br><span class="line">        out = self.mlp((<span class="number">1</span> + self.eps) *x + self.propagate(edge_index, x=x, edge_attr=edge_embedding))</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">message</span>(<span class="params">self, x_j, edge_attr</span>):</span></span><br><span class="line">        <span class="keyword">return</span> F.relu(x_j + edge_attr)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, aggr_out</span>):</span></span><br><span class="line">        <span class="keyword">return</span> aggr_out</span><br></pre></td></tr></table></figure>

<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>1.<a href="https://github.com/datawhalechina/team-learning-nlp/tree/master/GNN">datawhale-GNN开源学习资料</a><br>2.<a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/nn.html#global-pooling-layers">Global Pooling Layers</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>GIN</tag>
        <tag>GNN</tag>
      </tags>
  </entry>
  <entry>
    <title>图神经网络——基本图论与PyG库</title>
    <url>/2021/06/15/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E5%9B%BE%E8%AE%BA%E4%B8%8EPyG%E5%BA%93/</url>
    <content><![CDATA[<p>在以往的深度学习中，主要的数据形式包括矩阵、张量、序列(sequence)和时间序列(time series)，然而还有许多数据是图的结构，如社交网络、知识图谱等。图结构数据具有以下特点：</p>
<blockquote>
<p>任意的大小和复杂的拓扑结构；<br>没有固定的节点排序或参考点；<br>通常是动态的，并具有多模态的特征；<br>图的信息包括节点信息、边信息和拓扑结构信息。</p>
</blockquote>
<h4 id="1-图结构数据"><a href="#1-图结构数据" class="headerlink" title="1. 图结构数据"></a>1. 图结构数据</h4><h5 id="1-1-图-Graphs"><a href="#1-1-图-Graphs" class="headerlink" title="1.1 图(Graphs)"></a>1.1 图(Graphs)</h5><p><strong>·</strong> 一个图记作$\mathcal{G}={\mathcal{V}, \mathcal{E}}$，其中 $\mathcal{V}=\left{v_{1}, \ldots, v_{N}\right}$是数量为$N=|\mathcal{V}|$ 的节点的集合， $\mathcal{E}=\left{e_{1}, \ldots, e_{M}\right}$ 是数量为 $M$ 的边的集合。<br><strong>·</strong> 节点表示实体(entities)，边表示实体间的关系(relations)；节点和边的信息可以是类别型或数值型的。<br><strong>·</strong> 只有一种类型的节点和一种类型的边的图称为同质图(Homogeneous Graph)。<br><strong>·</strong> 存在多种类型的节点和多种类型的边的图称为异质图(Heterogeneous Graph)</p>
<span id="more"></span>

<h5 id="1-2-图的邻接矩阵-Adjacency-Matrix"><a href="#1-2-图的邻接矩阵-Adjacency-Matrix" class="headerlink" title="1.2 图的邻接矩阵(Adjacency Matrix)"></a>1.2 图的邻接矩阵(Adjacency Matrix)</h5><p><strong>·</strong> 图$\mathcal{G}={\mathcal{V}, \mathcal{E}}$，其对应的邻接矩阵记为$\mathbf{A} \in{0,1}^{N \times N}$。$\mathbf{A}<em>{i, j}=1$表示存在从节点$v_i$到$v_j$的边，反之表示不存在从节点$v_i$到$v_j$的边。<br><strong>·</strong> 在无向图中，节点$v_i$到$v_j$的边存在，则节点$v_j$到$v_i$的边也存在，所以无向图的邻接矩阵的对称的。<br><img src="https://z3.ax1x.com/2021/06/28/RtabM8.png" alt="图1"><br>其邻接矩阵为：<br><img src="https://z3.ax1x.com/2021/06/28/RtaoGt.png" alt="图2"><br><strong>·</strong> 在无权图中，各条边的权重是等价的，都为1。<br><strong>·</strong> 在有权图中，其对应的邻接矩阵通常被记为$\mathbf{W} \in{0,1}^{N \times N}$，其中$\mathbf{W}</em>{i, j}=w_{ij}$表示从节点$v_i$到$v_j$的边的权重。若边不存在时，边的权重为$0$。</p>
<h5 id="1-3-节点的度-degree"><a href="#1-3-节点的度-degree" class="headerlink" title="1.3 节点的度(degree)"></a>1.3 节点的度(degree)</h5><p><strong>·</strong> 在有向有权图中，节点$v_i$的出度(out degree)等于从$v_i$出发的边的权重之和，节点$v_i$的入度(in degree)等于从连向$v_i$的边的权重之和；节点$v_i$的度记为$d(v_i)$，入度记为$d_{in}(v_i)$，出度记为$d_{out}(v_i)$。<br><strong>·</strong> 在无向图中，出度=入度。<br><strong>·</strong> 在无权图中，入读等于连向$v_i$的边的数量，出度等于从$v_i$出发的边的数量。</p>
<h5 id="1-4-邻接节点-neighbors"><a href="#1-4-邻接节点-neighbors" class="headerlink" title="1.4 邻接节点(neighbors)"></a>1.4 邻接节点(neighbors)</h5><p><strong>·</strong> 与节点$v_i$直接相连的节点称为邻接节点，记为**$\mathcal{N(v_i)}$**。<br><strong>·</strong> 与节点$v_i$距离$k$步的称为$k$跳远的邻接节点(neighbors with $k$-hop) [一个节点的$2$跳远的邻接节点包含自身]</p>
<h5 id="1-5-行走-walk"><a href="#1-5-行走-walk" class="headerlink" title="1.5 行走(walk)"></a>1.5 行走(walk)</h5><p><strong>·</strong> $walk(v_1, v_2) = (v_1, e_6,e_5,e_4,e_1,v_2)$，这是一次“行走”，从节点$v_1$出发，依次经过边$e_6,e_5,e_4,e_1$，最终到达节点$v_2$的“行走”。<br><strong>·</strong> “行走”中，节点允许重复。<br><img src="https://z3.ax1x.com/2021/06/28/Rta7xf.png" alt="图3"></p>
<h5 id="1-6-路径-path"><a href="#1-6-路径-path" class="headerlink" title="1.6 路径(path)"></a>1.6 路径(path)</h5><p>“路径”是节点不可重复的“行走”。</p>
<h5 id="1-7-子图-subgraph"><a href="#1-7-子图-subgraph" class="headerlink" title="1.7 子图(subgraph)"></a>1.7 子图(subgraph)</h5><p>指节点集和边集分别是整图的节点集的子集和边集的子集的图。</p>
<h5 id="1-8-连通分量-connected-component"><a href="#1-8-连通分量-connected-component" class="headerlink" title="1.8 连通分量(connected component)"></a>1.8 连通分量(connected component)</h5><p>图$\mathcal{G}={\mathcal{V}, \mathcal{E}}$的子图为$\mathcal{G}^{\prime}$，记属于图$\mathcal{G}$但不属于$\mathcal{G}^{\prime}$图的节点集合记为$\mathcal{V}/\mathcal{V}^{\prime}$，属于$\mathcal{V}^{\prime}$的任意节点对之间存在至少一条路径，但不存在一条边连接属于$\mathcal{V}^{\prime}$的节点与属于$\mathcal{V}/\mathcal{V}^{\prime}$的节点，则图$\mathcal{G}^{\prime}$是图$\mathcal{G}$的连通分量。<br><img src="https://z3.ax1x.com/2021/06/28/RtaTRP.png" alt="图4"><br>左右两个子图都是整图的连通分量。</p>
<h5 id="1-8-连通图-connected-graph"><a href="#1-8-连通图-connected-graph" class="headerlink" title="1.8 连通图(connected graph)"></a>1.8 连通图(connected graph)</h5><p>只包含一个连通分量(即其自身)的图是一个连通图。</p>
<h5 id="1-9-最短路径-shortest-path"><a href="#1-9-最短路径-shortest-path" class="headerlink" title="1.9 最短路径(shortest path)"></a>1.9 最短路径(shortest path)</h5><p>$v_{s}, v_{t} \in \mathcal{V}$ 是图$\mathcal{G}={\mathcal{V}, \mathcal{E}}$上的一对节点，节点对$v_{s}, v_{t} \in \mathcal{V}$之间所有路径集合$\mathcal{P}<em>{\mathrm{st}}$。节点对$v</em>{s}, v_{t}$之间的最短路径$p_{\mathrm{s} t}^{\mathrm{sp}}$为$\mathcal{P}<em>{\mathrm{st}}$中长度最短的一条路径，即$p</em>{\mathrm{s} t}^{\mathrm{sp}}=\arg \min <em>{p \in \mathcal{P}</em>{\mathrm{st}}}|p|$，$p$表示$\mathcal{P}_{\mathrm{st}}$中的一条路径，$|p|$是路径$p$的长度(边数量×权重)。</p>
<h5 id="1-10-直径-diameter"><a href="#1-10-直径-diameter" class="headerlink" title="1.10 直径(diameter)"></a>1.10 直径(diameter)</h5><p>一个连通图$\mathcal{G}={\mathcal{V}, \mathcal{E}}$中，其直径为其所有节点对之间的最短路径的最大值，即$\operatorname{diameter}(\mathcal{G})=\max <em>{v</em>{s}, v_{t} \in \mathcal{V}} \min <em>{p \in \mathcal{P}</em>{s t}}|p|$</p>
<h5 id="1-11-拉普拉斯矩阵-Laplacian-Matrix"><a href="#1-11-拉普拉斯矩阵-Laplacian-Matrix" class="headerlink" title="1.11 拉普拉斯矩阵(Laplacian Matrix)"></a>1.11 拉普拉斯矩阵(Laplacian Matrix)</h5><p>图$\mathcal{G}={\mathcal{V}, \mathcal{E}}$，其邻接矩阵为$A$，其拉普拉斯矩阵定义为$\mathbf{L=D-A}$，其中$\mathbf{D=diag(d(v_1), \cdots, d(v_N))}$。</p>
<h5 id="1-12-对称归一化的拉普拉斯矩阵-Symmetric-normalized-Laplacian"><a href="#1-12-对称归一化的拉普拉斯矩阵-Symmetric-normalized-Laplacian" class="headerlink" title="1.12 对称归一化的拉普拉斯矩阵(Symmetric normalized Laplacian)"></a>1.12 对称归一化的拉普拉斯矩阵(Symmetric normalized Laplacian)</h5><p>图$\mathcal{G}={\mathcal{V}, \mathcal{E}}$，其邻接矩阵为$A$，其规范化的拉普拉斯矩阵定义为$\mathbf{L=D^{-\frac{1}{2}}(D-A)D^{-\frac{1}{2}}=I-D^{-\frac{1}{2}}AD^{-\frac{1}{2}}}$。</p>
<h4 id="2-图结构数据上的机器学习"><a href="#2-图结构数据上的机器学习" class="headerlink" title="2. 图结构数据上的机器学习"></a>2. 图结构数据上的机器学习</h4><blockquote>
<p><strong>节点预测</strong>：预测节点的类别或某类属性的取值。<br><strong>边预测</strong>：预测两个节点间是否存在链接。<br><strong>图预测</strong>：对不同的图进行分类或预测图的属性。<br><strong>节点聚类</strong>：检测节点是否形成一个类。</p>
</blockquote>
<h4 id="3-环境配置"><a href="#3-环境配置" class="headerlink" title="3. 环境配置"></a>3. 环境配置</h4><p><a href="https://pytorch-geometric.readthedocs.io/en/latest/">PyTorch Geometric</a> (PyG)是面向几何深度学习的PyTorch的扩展库，基于PyG库，我们可以轻松地根据数据生成一个图对象。</p>
<h5 id="3-1-安装的pytorch和cudatoolkit"><a href="#3-1-安装的pytorch和cudatoolkit" class="headerlink" title="3.1 安装的pytorch和cudatoolkit"></a>3.1 安装的pytorch和cudatoolkit</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda install pytorch torchvision torchaudio cudatoolkit&#x3D;11.1 -c pytorch -c nvidia</span><br></pre></td></tr></table></figure>
<p>安装成功后可以验证一下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="built_in">print</span>(torch.__version__)</span><br><span class="line"><span class="built_in">print</span>(torch.version.cuda)</span><br></pre></td></tr></table></figure>
<h5 id="3-2-安装PyG"><a href="#3-2-安装PyG" class="headerlink" title="3.2 安装PyG"></a>3.2 安装PyG</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install torch-scatter -f https://pytorch-geometric.com/whl/torch-<span class="number">1.8</span><span class="number">.0</span>+cu111.html</span><br><span class="line">pip install torch-sparse -f https://pytorch-geometric.com/whl/torch-<span class="number">1.8</span><span class="number">.0</span>+cu111.html</span><br><span class="line">pip install torch-cluster -f https://pytorch-geometric.com/whl/torch-<span class="number">1.8</span><span class="number">.0</span>+cu111.html</span><br><span class="line">pip install torch-spline-conv -f https://pytorch-geometric.com/whl/torch-<span class="number">1.8</span><span class="number">.0</span>+cu111.html</span><br><span class="line">pip install torch-geometric</span><br></pre></td></tr></table></figure>

<h4 id="4-Data类——PyG中图的表示"><a href="#4-Data类——PyG中图的表示" class="headerlink" title="4. Data类——PyG中图的表示"></a>4. Data类——PyG中图的表示</h4><h5 id="4-1-构造函数"><a href="#4-1-构造函数" class="headerlink" title="4.1 构造函数"></a>4.1 构造函数</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x=<span class="literal">None</span>, edge_index=<span class="literal">None</span>, edge_attr=<span class="literal">None</span>, y=<span class="literal">None</span>, **kwargs</span>):</span></span><br><span class="line">    self.x = x</span><br><span class="line">    self.edge_index = edge_index</span><br><span class="line">    self.edge_attr = edge_attr</span><br><span class="line">    self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> key, item <span class="keyword">in</span> kwargs.items():</span><br><span class="line">        <span class="keyword">if</span> key == <span class="string">&#x27;num_nodes&#x27;</span>:</span><br><span class="line">            self.__num_nodes__ = item</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self[key] = item</span><br></pre></td></tr></table></figure>
<p>Args:<br><strong>·</strong> x (Tensor, optional): 节点属性矩阵，大小为<code>[num_nodes, num_node_features]</code><br><strong>·</strong> edge_index (LongTensor, optional): 边索引矩阵，大小为<code>[2, num_edges]</code>，第0行为尾节点，第1行为头节点，头指向尾。<br><strong>·</strong> edge_attr (Tensor, optional): 边属性矩阵，大小为<code>[num_edges, num_edge_features]</code><br><strong>·</strong> y (Tensor, optional): 节点或图的标签，任意大小(其实也可以是边的标签)</p>
<h5 id="4-2-参数"><a href="#4-2-参数" class="headerlink" title="4.2 参数"></a>4.2 参数</h5><p>一个图至少包含<code>x, edge_index, edge_attr, y, num_nodes</code>5个属性，也可以指定额外参数使<code>Data</code>对象包含其他的属性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">graph = Data(x=x, edge_index=edge_index, edge_attr=edge_attr, y=y, num_nodes=num_nodes, other_attr=other_attr)</span><br></pre></td></tr></table></figure>

<h5 id="4-3-Data对象与其他数据互转"><a href="#4-3-Data对象与其他数据互转" class="headerlink" title="4.3 Data对象与其他数据互转"></a>4.3 Data对象与其他数据互转</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#dict to Data</span></span><br><span class="line">graph_dict = &#123;</span><br><span class="line">    <span class="string">&#x27;x&#x27;</span>: x,</span><br><span class="line">    <span class="string">&#x27;edge_index&#x27;</span>: edge_index,</span><br><span class="line">    <span class="string">&#x27;edge_attr&#x27;</span>: edge_attr,</span><br><span class="line">    <span class="string">&#x27;y&#x27;</span>: y,</span><br><span class="line">    <span class="string">&#x27;num_nodes&#x27;</span>: num_nodes,</span><br><span class="line">    <span class="string">&#x27;other_attr&#x27;</span>: other_attr</span><br><span class="line">&#125;</span><br><span class="line">graph_data = Data.from_dict(graph_dict)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Data to dict</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Data_to_dict</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;key: item <span class="keyword">for</span> key, item <span class="keyword">in</span> self&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Data to namedtuple</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Data_to_namedtuple</span>(<span class="params">self</span>):</span></span><br><span class="line">    keys = self.keys</span><br><span class="line">    DataTuple = collections.namedtuple(<span class="string">&#x27;DataTuple&#x27;</span>, keys)</span><br><span class="line">    <span class="keyword">return</span> DataTuple(*[self[key] <span class="keyword">for</span> key <span class="keyword">in</span> keys])</span><br></pre></td></tr></table></figure>

<h5 id="4-4-Data对象属性"><a href="#4-4-Data对象属性" class="headerlink" title="4.4 Data对象属性"></a>4.4 Data对象属性</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#获取Data对象属性</span></span><br><span class="line">x = graph_data[<span class="string">&#x27;x&#x27;</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#获取Data对象属性关键字</span></span><br><span class="line">graph_data.keys()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#对边排序并移除重复的边</span></span><br><span class="line">graph_data.coalesce()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch_geometric.datasets <span class="keyword">import</span> KarateClub</span><br><span class="line">dataset = KarateClub()</span><br><span class="line">data = dataset[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(data.num_nodes) <span class="comment">#节点数量</span></span><br><span class="line"><span class="built_in">print</span>(data.num_edges) <span class="comment">#边数量</span></span><br><span class="line"><span class="built_in">print</span>(data.num_node_features) <span class="comment">#节点属性维度</span></span><br><span class="line"><span class="built_in">print</span>(data.num_edge_features) <span class="comment">#边属性维度</span></span><br><span class="line"><span class="built_in">print</span>(data.num_edges/data.num_nodes) <span class="comment">#平均节点度</span></span><br><span class="line"><span class="built_in">print</span>(data.is_coalesced()) <span class="comment">#是否边是有序的同时不含有重复的边</span></span><br><span class="line"><span class="built_in">print</span>(data.train_mask.<span class="built_in">sum</span>()) <span class="comment">#用作训练集的节点</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(data.train_mask.<span class="built_in">sum</span>())/data.num_nodes) <span class="comment">#用作训练集的节点数占比</span></span><br><span class="line"><span class="built_in">print</span>(data.contains_isolated_nodes()) <span class="comment">#此图是否包含孤立的节点</span></span><br><span class="line"><span class="built_in">print</span>(data.contains_self_loops()) <span class="comment">#此图是否包含自环的边</span></span><br><span class="line"><span class="built_in">print</span>(data.is_undirected()) <span class="comment">#此图是否是无向图</span></span><br></pre></td></tr></table></figure>

<h4 id="5-Dataset类——PyG中图数据集的表示"><a href="#5-Dataset类——PyG中图数据集的表示" class="headerlink" title="5.Dataset类——PyG中图数据集的表示"></a>5.Dataset类——PyG中图数据集的表示</h4><h5 id="5-1-数据集的下载"><a href="#5-1-数据集的下载" class="headerlink" title="5.1 数据集的下载"></a>5.1 数据集的下载</h5><p>首先下载PyG内置的Planetoid数据集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch_geometric.datasets <span class="keyword">import</span> Planetoid</span><br><span class="line">dataset = Planetoid(root=<span class="string">&#x27;/dataset/Cora&#x27;</span>, name=<span class="string">&#x27;Cora&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(dataset))    <span class="comment">#数据集中图的数量</span></span><br><span class="line"><span class="built_in">print</span>(dataset.num_classes)   <span class="comment">#分类任务的数量</span></span><br><span class="line"><span class="built_in">print</span>(dataset.num_node_features)   <span class="comment">##节点属性维度</span></span><br></pre></td></tr></table></figure>
<h5 id="5-1-数据集的使用"><a href="#5-1-数据集的使用" class="headerlink" title="5.1 数据集的使用"></a>5.1 数据集的使用</h5><p>定义一个名为<code>Net</code>的图神经网络模型，将节点分类图数据集加入训练。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = Net().to(device)</span><br><span class="line">data = dataset[<span class="number">0</span>].to(device)</span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">0.01</span>, weight_decay=<span class="number">5e-4</span>)</span><br><span class="line"></span><br><span class="line">model.train()</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">500</span>):</span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    out = model(data)</span><br><span class="line">    loss = F.nll_loss(out[data.train_mask], data.y[data.train_mask])</span><br><span class="line">    loss.backward()</span><br><span class="line">    optimizer.step()</span><br></pre></td></tr></table></figure>

<p>1.<a href="https://github.com/datawhalechina/team-learning-nlp/tree/master/GNN">datawhale-GNN开源学习资料</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Graph</tag>
        <tag>GNN</tag>
      </tags>
  </entry>
  <entry>
    <title>图神经网络——消息传递网络</title>
    <url>/2021/06/19/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>消息传递(Message Passing) 指的是目标节点$S1$的邻居$\mathcal{N(S1)}$——B1、B2、B3，这些邻居节点根据一定的规则将信息(特征)，汇总到目标节点上。信息汇总中最简单的规则就是逐个元素相加。<br>在pytorch-geometric的官方文档中，消息传递图神经网络被描述为:<br>$$<br>\mathbf{x}_i^{(k)} = \gamma^{(k)} \left( \mathbf{x}<em>i^{(k-1)}, \square</em>{j \in \mathcal{N}(i)} , \phi^{(k)}\left(\mathbf{x}<em>i^{(k-1)}, \mathbf{x}<em>j^{(k-1)},\mathbf{e}</em>{j,i}\right) \right),<br>$$<br>其中，$\mathbf{e}</em>{j,i} \in \mathbb{R}^D$ 表示从节点$j$到节点$i$的边的属性，$\mathbf{x}^{(k-1)}_i\in\mathbb{R}^F$表示$(k-1)$层中节点$i$的节点表征，$\square$表示聚合策略，$\gamma$和$\phi$表示一些神经网络方法，比如MLPs多层感知器、LSTM等。<br>从公式中可以看出，目标节点$x_i$在k层的特征可以通过$x_i$在上一层(k-1层)的特征与其相邻节点$x_j$在上一层(k-1层)的特征以及相邻节点到目标节点的边的特征，这三个特征在k层通过$\square$的聚合策略(aggregate)，通过一个$\gamma$在k层的分析方法来导出目标节点$x_i$的特征。</p>
<span id="more"></span>

<h4 id="2-MessagePassing基类"><a href="#2-MessagePassing基类" class="headerlink" title="2. MessagePassing基类"></a>2. MessagePassing基类</h4><p>Pytorch Geometric(PyG)提供了<a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/nn.html#torch_geometric.nn.conv.message_passing.MessagePassing">MessagePassing</a>基类，通过继承基类，并定义message()方法、update()方法、aggregate()方法，可以构造消息传递图神经网络。</p>
<h5 id="2-1-MessagePassing-init-aggr-”add”-flow-”source-to-target”-node-dim-2"><a href="#2-1-MessagePassing-init-aggr-”add”-flow-”source-to-target”-node-dim-2" class="headerlink" title="2.1 MessagePassing.__init__(aggr=”add”, flow=”source_to_target”, node_dim=-2)"></a>2.1 MessagePassing.__init__(aggr=”add”, flow=”source_to_target”, node_dim=-2)</h5><blockquote>
<p>aggr：定义聚合方案(“add”、”mean”或 “max”)，默认值”add”；<br>flow：定义消息传递方向(“source_to_target”或 “target_to_source”)，默认值”source_to_target”；<br>node_dim：定义沿哪个维度传播，指的是节点表征张量(Tensor)的哪一个维度是节点维度，默认值-2(第0维)。</p>
</blockquote>
<h5 id="2-2-MessagePassing-propagate-edge-index-size-None-kwargs"><a href="#2-2-MessagePassing-propagate-edge-index-size-None-kwargs" class="headerlink" title="2.2 MessagePassing.propagate(edge_index, size=None, **kwargs)"></a>2.2 MessagePassing.propagate(edge_index, size=None, **kwargs)</h5><blockquote>
<p>这是一个集成方法，调用其会依次调用message、aggregate、update方法。<br>edge_index：边的端点的索引，当flow=”source_to_target”时，节点edge_index[0]的信息将被传递到节点edge_index[1]；当flow=”target_to_source”时，节点edge_index[1]的信息将被传递到节点edge_index[0]。<br>size：邻接节点的数量与中心节点的数量，默认值None(对称矩阵)；<br>**kwaegs：图的其他属性或额外的数据。</p>
</blockquote>
<h5 id="2-3-MessagePassing-message-…"><a href="#2-3-MessagePassing-message-…" class="headerlink" title="2.3 MessagePassing.message(…)"></a>2.3 MessagePassing.message(…)</h5><blockquote>
<p>以函数的方式构造消息；<br>flow=”source_to_target”，此方式下，message方法负责产生source node需要传出的信息。</p>
</blockquote>
<h5 id="2-4-MessagePassing-update-aggr-out-…"><a href="#2-4-MessagePassing-update-aggr-out-…" class="headerlink" title="2.4 MessagePassing.update(aggr_out, …)"></a>2.4 MessagePassing.update(aggr_out, …)</h5><blockquote>
<p>为每个节点$i \in \mathcal{V}$更新节点表征。</p>
</blockquote>
<h5 id="2-5-MessagePassing-aggregate-…"><a href="#2-5-MessagePassing-aggregate-…" class="headerlink" title="2.5 MessagePassing.aggregate(…)"></a>2.5 MessagePassing.aggregate(…)</h5><p>将从源节点传递过来的消息聚合在目标节点上，一般可选的聚合方式有sum, mean和max。</p>
<h4 id="3-MessagePassing子类"><a href="#3-MessagePassing子类" class="headerlink" title="3. MessagePassing子类"></a>3. MessagePassing子类</h4><h5 id="3-1-GCNConv类"><a href="#3-1-GCNConv类" class="headerlink" title="3.1 GCNConv类"></a>3.1 GCNConv类</h5><p>以继承MessagePassing基类的GCNConv类为例，可以实现一个简单的GNN。<br>GCNConv的公式如下:<br>$$<br>\mathbf{x}<em>i^{(k)} = \sum</em>{j \in \mathcal{N}(i) \cup { i }} \frac{1}{\sqrt{\deg(i)} \cdot \sqrt{\deg(j)}} \cdot \left( \mathbf{\Theta} \cdot \mathbf{x}_j^{(k-1)} \right)<br>$$<br>其中，邻接节点的表征$\mathbf{x}_j^{(k-1)}$首先通过与权重矩阵$\mathbf{\Theta}$相乘进行变换，然后按端点的度(degree)$\deg(i), \deg(j)$进行归一化处理，最后进行求和。这个公式可以分为以下几个步骤：</p>
<blockquote>
<p>向邻接矩阵添加自环边。<br>对节点表征做线性转换。<br>计算归一化系数。<br>归一化邻接节点的节点表征。<br>将相邻节点表征相加（”求和 “聚合）。</p>
</blockquote>
<p>GCNConv继承了MessagePassing，并以”求和”作为领域节点信息聚合方式。该层的所有逻辑都在forward()方法中：<br>1.通过torch_geometric.utils.add_self_loops()函数向边索引添加自循环边，目的是改进原始不考虑中心节点自身的信息量的问题；<br>2.通过torch.nn.Linear实例对节点表征进行线性变换；<br>3.归一化系数是由每个节点的节点度得出的，它被转换为每条边的节点度。结果被保存在形状为[num_edges,]的变量norm中。</p>
<h5 id="3-2-实现"><a href="#3-2-实现" class="headerlink" title="3.2 实现"></a>3.2 实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch_geometric.datasets <span class="keyword">import</span> Planetoid</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch_geometric.nn <span class="keyword">import</span> MessagePassing</span><br><span class="line"><span class="keyword">from</span> torch_geometric.utils <span class="keyword">import</span> add_self_loops, degree</span><br><span class="line"><span class="keyword">from</span> torch_sparse <span class="keyword">import</span> SparseTensor</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GCNConv</span>(<span class="params">MessagePassing</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, in_channels, out_channels</span>):</span></span><br><span class="line">        <span class="comment">#in_channels可理解为输入通道数，out_channels可理解为卷积核数量</span></span><br><span class="line">        <span class="built_in">super</span>(GCNConv, self).__init__(aggr=<span class="string">&#x27;add&#x27;</span>, flow=<span class="string">&#x27;source_to_target&#x27;</span>) <span class="comment">#继承，策略为合并</span></span><br><span class="line">        <span class="comment"># &quot;Add&quot; aggregation (Step 5).</span></span><br><span class="line">        <span class="comment"># flow=&#x27;source_to_target&#x27; 表示消息从源节点传播到目标节点</span></span><br><span class="line">        self.lin = torch.nn.Linear(in_channels, out_channels)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x, edge_index</span>):</span></span><br><span class="line">        <span class="comment"># x has shape [N, in_channels]</span></span><br><span class="line">        <span class="comment"># edge_index has shape [2, E]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 1: 添加自循环到节点特征矩阵(Add self-loops to the adjacency matrix.)</span></span><br><span class="line">        edge_index, _ = add_self_loops(edge_index, num_nodes=x.size(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 节点特征矩阵的线性变换(Linearly transform node feature matrix.)</span></span><br><span class="line">        x = self.lin(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 3: Compute normalization.</span></span><br><span class="line">        row, col = edge_index <span class="comment">#用行、列描述特征矩阵</span></span><br><span class="line">        deg = degree(col, x.size(<span class="number">0</span>), dtype=x.dtype)</span><br><span class="line">        deg_inv_sqrt = deg.<span class="built_in">pow</span>(-<span class="number">0.5</span>)</span><br><span class="line">        norm = deg_inv_sqrt[row] * deg_inv_sqrt[col]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 4-5: Start propagating messages.</span></span><br><span class="line">        adjmat = SparseTensor(row=edge_index[<span class="number">0</span>], col=edge_index[<span class="number">1</span>], value=torch.ones(edge_index.shape[<span class="number">1</span>]))</span><br><span class="line">        <span class="comment"># 此处传的不再是edge_index，而是SparseTensor类型的Adjancency Matrix</span></span><br><span class="line">        <span class="keyword">return</span> self.propagate的(adjmat, x=x, norm=norm, deg=deg.view((-<span class="number">1</span>, <span class="number">1</span>)))</span><br><span class="line">		<span class="comment"># 此处省略MessagePassing.propagate的代码.</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">message</span>(<span class="params">self, x_j, norm</span>):</span></span><br><span class="line">        <span class="comment"># x_j has shape [E, out_channels]</span></span><br><span class="line">        <span class="comment"># deg_i has shape [E, 1]</span></span><br><span class="line">        <span class="comment"># Step 4: Normalize node features.</span></span><br><span class="line">        <span class="keyword">return</span> norm.view(-<span class="number">1</span>, <span class="number">1</span>) * x_j</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">aggregate</span>(<span class="params">self, inputs, index, ptr, dim_size</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;self.aggr:&#x27;</span>, self.aggr)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;`aggregate` is called&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().aggregate(inputs, index, ptr=ptr, dim_size=dim_size)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">message_and_aggregate</span>(<span class="params">self, adj_t, x, norm</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;`message_and_aggregate` is called&#x27;</span>)</span><br><span class="line">        <span class="comment"># 没有实现真实的消息传递与消息聚合的操作</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, inputs, deg</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(deg)</span><br><span class="line">        <span class="keyword">return</span> inputs</span><br><span class="line"></span><br><span class="line">dataset = Planetoid(root=<span class="string">&#x27;dataset&#x27;</span>, name=<span class="string">&#x27;Cora&#x27;</span>)</span><br><span class="line">data = dataset[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">net = GCNConv(data.num_features, <span class="number">64</span>)</span><br><span class="line">h_nodes = net(data.x, data.edge_index)</span><br><span class="line"><span class="comment"># print(h_nodes.shape)</span></span><br></pre></td></tr></table></figure>

<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>1.<a href="https://github.com/datawhalechina/team-learning-nlp/tree/master/GNN">datawhale-GNN开源学习资料</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>GCN</tag>
      </tags>
  </entry>
  <entry>
    <title>图神经网络——节点分类与边预测</title>
    <url>/2021/06/27/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%8A%82%E7%82%B9%E5%88%86%E7%B1%BB%E4%B8%8E%E8%BE%B9%E9%A2%84%E6%B5%8B/</url>
    <content><![CDATA[<h4 id="1-InMemoryDataset基类"><a href="#1-InMemoryDataset基类" class="headerlink" title="1.InMemoryDataset基类"></a>1.InMemoryDataset基类</h4><p>在PyG中，可以通过继承InMemoryDataset类来自定义一个数据可全部存储到内存的数据集类。(继承Dataset是分次加载到内存，继承InMemoryDataset是一次性加载所有数据到内存)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InMemoryDataset</span>(<span class="params">root: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>, transform: <span class="type">Optional</span>[<span class="type">Callable</span>] = <span class="literal">None</span>, pre_transform: <span class="type">Optional</span>[<span class="type">Callable</span>] = <span class="literal">None</span>, pre_filter: <span class="type">Optional</span>[<span class="type">Callable</span>] = <span class="literal">None</span></span>)</span></span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<blockquote>
<p>transform：数据转换函数，用于转换Data对象，每一次数据获取过程中都会被执行。<br>pre_transform：数据转换函数，用于转换Data对象，在Data对象被保存到文件前调用。<br>pre_filter：检查数据是否要保留的函数，接收一个Data对象，返回此Data对象是否应该被包含在最终的数据集中，在Data对象被保存到文件前调用。</p>
</blockquote>
<span id="more"></span>
<h4 id="2-Sequential容器"><a href="#2-Sequential容器" class="headerlink" title="2.Sequential容器"></a>2.Sequential容器</h4><p>nn.Sequential是nn.module的容器，用于按顺序包装一组网络层。参数说明：</p>
<blockquote>
<p>args(str)：模型的全局输入参数；<br>modules ([(str, Callable) or Callable]) ：模块列表。</p>
</blockquote>
<h4 id="3-节点分类"><a href="#3-节点分类" class="headerlink" title="3. 节点分类"></a>3. 节点分类</h4><p>定义一个GAT图神经网络，通过hidden_channels_list参数来设置每一层GATConv的outchannel，所以hidden_channels_list长度即为GATConv的层数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#载入数据集</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch_geometric.datasets <span class="keyword">import</span> Planetoid</span><br><span class="line"><span class="keyword">from</span> torch_geometric.transforms <span class="keyword">import</span> NormalizeFeatures</span><br><span class="line">dataset = Planetoid(root=<span class="string">&#x27;dataset&#x27;</span>, ame=<span class="string">&#x27;Cora&#x27;</span>,transform=NormalizeFeatures())</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Linear,ReLU</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torch_geometric.nn <span class="keyword">import</span> GATConv, Sequential</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用Sequential容器定义一个GAT网络</span></span><br><span class="line"><span class="keyword">from</span> torch_geometric.nn <span class="keyword">import</span> GATConv</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GAT</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_features, hidden_channels_list, num_classes</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(GAT, self).__init__()</span><br><span class="line">        torch.manual_seed(<span class="number">2021</span>)</span><br><span class="line">        hns = [num_features] + hidden_channels_list</span><br><span class="line">        conv_list = []</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(hidden_channels_list)):</span><br><span class="line">            conv_list.append((GATConv(hns[idx], hns[idx+<span class="number">1</span>]), <span class="string">&#x27;x, edge_index -&gt; x&#x27;</span>))</span><br><span class="line">            conv_list.append(ReLU(inplace=<span class="literal">True</span>),)</span><br><span class="line"></span><br><span class="line">        self.convseq = Sequential(<span class="string">&#x27;x, edge_index&#x27;</span>, conv_list)</span><br><span class="line">        self.linear = Linear(hidden_channels_list[-<span class="number">1</span>], num_classes)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x, edge_index</span>):</span></span><br><span class="line">        x = self.convseq(x, edge_index)</span><br><span class="line">        x = F.dropout(x, p=<span class="number">0.5</span>, training=self.training)</span><br><span class="line">        x = self.linear(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#训练和测试</span></span><br><span class="line">device = torch.device(<span class="string">&quot;cuda:0&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line">model = GAT(num_features=dataset.num_features, hidden_channels_list=[<span class="number">200</span>, <span class="number">100</span>], num_classes=dataset.num_classes).to(device)</span><br><span class="line"><span class="built_in">print</span>(model)</span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">0.01</span>, weight_decay=<span class="number">5e-4</span>)</span><br><span class="line">criterion = torch.nn.CrossEntropyLoss()</span><br><span class="line"><span class="comment">#train()、test()省略，与上章一致</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">201</span>):</span><br><span class="line">    loss = train()</span><br><span class="line">    <span class="keyword">if</span> epoch % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Epoch: <span class="subst">&#123;epoch:03d&#125;</span>, Loss: <span class="subst">&#123;loss:<span class="number">.4</span>f&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">test_acc = test()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Test Accuracy: <span class="subst">&#123;test_acc:<span class="number">.4</span>f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>构建2层GAT，Accuracy为0.7640；构建2层GCN，Accuracy为0.6490。<br>构造3层GAT(将hidden_channels_list的值改为[200,100,50])，Accuracy为0.7680；构建3层GCN，Accuracy为0.5190。</p>
</blockquote>
<h4 id="4-边预测"><a href="#4-边预测" class="headerlink" title="4 边预测"></a>4 边预测</h4><p>边预测任务的目标是预测两个节点间是否有边。做边预测任务首先需要获取正负样本数量平衡的数据集(edge_index存储的是正样本，需要采样一些不存在边的节点对作为负样本边)，PyG中可以通过train_test_split_edges(data, val_ratio=0.05, test_ratio=0.1)采样负样本边。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#构造边预测神经网络</span></span><br><span class="line"><span class="keyword">import</span> os.path <span class="keyword">as</span> osp</span><br><span class="line"><span class="keyword">from</span> torch_geometric.utils <span class="keyword">import</span> negative_sampling</span><br><span class="line"><span class="keyword">from</span> torch_geometric.datasets <span class="keyword">import</span> Planetoid</span><br><span class="line"><span class="keyword">import</span> torch_geometric.transforms <span class="keyword">as</span> T</span><br><span class="line"><span class="keyword">from</span> torch_geometric.utils <span class="keyword">import</span> train_test_split_edges</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch_geometric.nn <span class="keyword">import</span> GCNConv</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, in_channels, out_channels</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        self.conv1 = GCNConv(in_channels, <span class="number">128</span>)</span><br><span class="line">        self.conv2 = GCNConv(<span class="number">128</span>, out_channels)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">encode</span>(<span class="params">self, x, edge_index</span>):</span></span><br><span class="line">        x = self.conv1(x, edge_index)</span><br><span class="line">        x = x.relu()</span><br><span class="line">        <span class="keyword">return</span> self.conv2(x, edge_index)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decode</span>(<span class="params">self, z, pos_edge_index, neg_edge_index</span>):</span></span><br><span class="line">        edge_index =  torch.cat([pos_edge_index, neg_edge_index], dim=-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> (z[edge_index[<span class="number">0</span>]] * z[edge_index[<span class="number">1</span>]]).<span class="built_in">sum</span>(dim=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decode_all</span>(<span class="params">self, z</span>):</span></span><br><span class="line">        <span class="comment">#对所有的节点对预测存在边的几率</span></span><br><span class="line">        prob_adj = z @ z.t()    <span class="comment"># @ 表示矩阵乘法</span></span><br><span class="line">        <span class="keyword">return</span> (prob_adj &gt; <span class="number">0</span>).nonzero(as_tuple=<span class="literal">False</span>).t()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义单个epoch的训练过程</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_link_labels</span>(<span class="params">pos_edge_index, neg_edge_index</span>):</span></span><br><span class="line">    num_links = pos_edge_index.size(<span class="number">1</span>) + neg_edge_index.size(<span class="number">1</span>)</span><br><span class="line">    link_labels = torch.zeros(num_links, dtype=torch.<span class="built_in">float</span>)</span><br><span class="line">    link_labels[:pos_edge_index.size(<span class="number">1</span>)] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> link_labels</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">data, model, optimizer</span>):</span></span><br><span class="line">    model.train()</span><br><span class="line"></span><br><span class="line">    neg_edge_index = negative_sampling(</span><br><span class="line">        edge_index = data.train_pos_edge_index,</span><br><span class="line">        num_nodes = data.num_nodes,</span><br><span class="line">        num_neg_samples = data.train_pos_edge_index.size(<span class="number">1</span>)</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    train_neg_edge_set = <span class="built_in">set</span>(<span class="built_in">map</span>(<span class="built_in">tuple</span>, neg_edge_index.T.tolist()))</span><br><span class="line">    val_pos_edge_set = <span class="built_in">set</span>(<span class="built_in">map</span>(<span class="built_in">tuple</span>, data.val_pos_edge_index.T.tolist()))</span><br><span class="line">    test_pos_edge_set = <span class="built_in">set</span>(<span class="built_in">map</span>(<span class="built_in">tuple</span>, data.test_pos_edge_index.T.tolist()))</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">len</span>(train_neg_edge_set &amp; val_pos_edge_set) &gt; <span class="number">0</span>) <span class="keyword">or</span> (<span class="built_in">len</span>(train_neg_edge_set &amp; test_pos_edge_set) &gt; <span class="number">0</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;wrong!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    z = model.encode(data.x, data.train_pos_edge_index)</span><br><span class="line">    link_logits = model.decode(z, data.train_pos_edge_index, neg_edge_index)</span><br><span class="line">    link_labels = get_link_labels(data.train_pos_edge_index, neg_edge_index).to(data.x.device)</span><br><span class="line">    loss = F.binary_cross_entropy_with_logits(link_logits, link_labels)</span><br><span class="line">    loss.backward()</span><br><span class="line">    optimizer.step()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> loss</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义单个epoch验证与测试过程</span></span><br><span class="line"><span class="meta">@torch.no_grad()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">data, model</span>):</span></span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line">    z = model.encode(data.x, data.train_pos_edge_index)</span><br><span class="line"></span><br><span class="line">    results = []</span><br><span class="line">    <span class="keyword">for</span> prefix <span class="keyword">in</span> [<span class="string">&#x27;val&#x27;</span>, <span class="string">&#x27;test&#x27;</span>]:</span><br><span class="line">        pos_edge_index = data[<span class="string">f&#x27;<span class="subst">&#123;prefix&#125;</span>_pos_edge_index&#x27;</span>]</span><br><span class="line">        neg_edge_index = data[<span class="string">f&#x27;<span class="subst">&#123;prefix&#125;</span>_neg_edge_index&#x27;</span>]</span><br><span class="line">        link_logits = model.decode(z, pos_edge_index, neg_edge_index)</span><br><span class="line">        link_probs = link_logits.sigmoid()</span><br><span class="line">        link_labels = get_link_labels(pos_edge_index, neg_edge_index)</span><br><span class="line">        results.append(roc_auc_score(link_labels.cpu(), link_probs.cpu()))</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#完整的训练、验证与测试</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_auc_score</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    device = torch.device(<span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line">	dataset = Planetoid(<span class="string">&#x27;/Dataset/Planetoid/Cora&#x27;</span>, <span class="string">&#x27;Cora&#x27;</span>, transform=T.NormalizeFeatures())</span><br><span class="line">    data = dataset[<span class="number">0</span>]</span><br><span class="line">    ground_truth_edge_index = data.edge_index.to(device)</span><br><span class="line">    data.train_mask = data.val_mask = data.test_mask = data.y = <span class="literal">None</span></span><br><span class="line">    data = train_test_split_edges(data)</span><br><span class="line">    data = data.to(device)</span><br><span class="line"></span><br><span class="line">    model = Net(dataset.num_features, <span class="number">64</span>).to(device)</span><br><span class="line">    optimizer = torch.optim.Adam(params=model.parameters(), lr=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">    best_val_auc = test_auc = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">101</span>):</span><br><span class="line">        loss = train(data, model, optimizer)</span><br><span class="line">        val_auc, tmp_test_auc = test(data, model)</span><br><span class="line">        <span class="keyword">if</span> val_auc &gt; best_val_auc:</span><br><span class="line">            best_val_auc = val_auc</span><br><span class="line">            test_auc = tmp_test_auc</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Epoch: <span class="subst">&#123;epoch:03d&#125;</span>, Loss: <span class="subst">&#123;loss:<span class="number">.4</span>f&#125;</span>, Val: <span class="subst">&#123;val_auc:<span class="number">.4</span>f&#125;</span>, &#x27;</span></span><br><span class="line">              <span class="string">f&#x27;Test: <span class="subst">&#123;test_auc:<span class="number">.4</span>f&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    z = model.encode(data.x, data.train_pos_edge_index)</span><br><span class="line">    final_edge_index = model.decode_all(z)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果：Epoch: 100, Loss: 0.4414, Val: 0.9330, Test: 0.8943</p>
</blockquote>
<p>将Sequential容器用于边预测，需要在Net类定义中将__init_函数和main()做部分修改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#替换上面的对应代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, in_channels, hidden_channels_list, out_channels</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        torch.manual_seed(<span class="number">2021</span>)</span><br><span class="line">        hns = [in_channels] + hidden_channels_list</span><br><span class="line">        conv_list = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(hidden_channels_list)-<span class="number">1</span>):</span><br><span class="line">            conv_list.append((GCNConv(hns[idx], hns[idx+<span class="number">1</span>]), <span class="string">&#x27;x, edge_index -&gt; x&#x27;</span>))</span><br><span class="line">            conv_list.append(ReLU(inplace=<span class="literal">True</span>), )</span><br><span class="line">        conv_list.append((GCNConv(hns[-<span class="number">2</span>], hns[-<span class="number">1</span>]), <span class="string">&#x27;x, edge_index -&gt; x&#x27;</span>))</span><br><span class="line"></span><br><span class="line">        self.convseq = Sequential(<span class="string">&#x27;x, edge_index&#x27;</span>, conv_list)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">        model = Net(dataset.num_features,[<span class="number">200</span>,<span class="number">100</span>],dataset.num_classes).to(device)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在边预测任务用Sequential容器的结果：<br>Epoch: 100, Loss: 0.4226, Val: 0.9123, Test: 0.8958</p>
</blockquote>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>1.<a href="https://github.com/datawhalechina/team-learning-nlp/tree/master/GNN">datawhale-GNN开源学习资料</a><br>2.<a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/nn.html#torch_geometric.nn.sequential.Sequential">GNN官方文档</a><br>3.<a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/nn.html#torch_geometric.nn.sequential.Sequential">Sequential官网文档</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>PyG</tag>
        <tag>GCN</tag>
        <tag>GAT</tag>
      </tags>
  </entry>
  <entry>
    <title>图神经网络——超大图上的节点表征学习</title>
    <url>/2021/07/01/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%B6%85%E5%A4%A7%E5%9B%BE%E4%B8%8A%E7%9A%84%E8%8A%82%E7%82%B9%E8%A1%A8%E5%BE%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>图卷积网络(GCN)已经成功地应用于许多基于图形的应用，然而大规模的GCN的训练仍然具有挑战性。目前基于SGD的算法要么面临着随GCN层数呈指数增长的高计算成本，要么面临着保存整个图形和每个节点的embedding到内存的巨大空间(显存)需求。于是论文<a href="https://arxiv.org/abs/1905.07953">Cluster-GCN: An Efficient Algorithm for Training Deep and Large Graph Convolutional Network</a>提出了Cluster-GCN方法来解决超大图的训练问题。</p>
<h4 id="1-Cluster-GCN方法简单概括"><a href="#1-Cluster-GCN方法简单概括" class="headerlink" title="1.Cluster-GCN方法简单概括"></a>1.Cluster-GCN方法简单概括</h4><ul>
<li>利用图节点聚类算法将一个图的节点划分为$c$个簇，每一次选择几个簇的节点和这些节点对应的边构成一个子图，然后对子图做训练。</li>
<li>由于是利用图节点聚类算法将节点划分为多个簇，所以簇内边的数量要比簇间边的数量多得多，所以可以提高表征利用率，并提高图神经网络的训练效率。</li>
<li>每一次随机选择多个簇来组成一个batch，这样不会丢失簇间的边，同时也不会有batch内类别分布偏差过大的问题。</li>
<li>基于小图进行训练，不会消耗很多内存空间，于是我们可以训练更深的神经网络，进而可以达到更高的精度。</li>
</ul>
<span id="more"></span>
<h4 id="2-GCN回顾"><a href="#2-GCN回顾" class="headerlink" title="2.GCN回顾"></a>2.GCN回顾</h4><p>论文<a href="https://arxiv.org/abs/1609.02907">2017. Semi-supervised classification with graph convolutional networks</a>中提出了GCN。作者定义了一种类似卷积的运算，称为谱图卷积。这使得CNN可以直接在图形上操作。GCN中的每一层通过考虑相邻节点的embedding，来更新Graph中的每个节点的特征向量表示。GCN的逐层正向传播可以总结为：<br>$$<br>X^{\left( l+1 \right)}=f\left( X^l,A \right) =\sigma \left( \tilde{D}^{-\frac{1}{2}}\tilde{A}D^{-\frac{1}{2}}X^{\left( l \right)}W^{\left( l \right)} \right)<br>$$</p>
<ul>
<li>$X$是所有节点的特征向量构成的特征矩阵。</li>
<li>$X^l$和$X^{l+1}$分别是$l$层的输入和输出矩阵，$X^l$也是第$l$层对于所有节点的embedding。</li>
<li>A是图的邻接矩阵。</li>
<li>${A}=A+I_N$是带有自环的无向图的邻接矩阵。</li>
<li>$I_N$是单位矩阵。</li>
<li>$\tilde{D}<em>{ii}=\sum{\tilde{A}</em>{ij}}$是带有自环的无向图的度矩阵，是一个对角矩阵。</li>
<li>$W^{(l)}$是一个可训练权重矩阵或参数矩阵。</li>
<li>$\sigma(\cdot)$是激活函数，通常被设为<code>ReLU</code>。</li>
</ul>
<p>为了简化计算，假设所有层的表征维度都是F，上式写为：<br>$$<br>Z^{(l+1)}=A^{\prime} X^{(l)} W^{(l)}, X^{(l+1)}=\sigma\left(Z^{(l+1)}\right)<br>$$</p>
<ul>
<li>$A^{\prime}$是归一化和规范化后的邻接矩阵</li>
</ul>
<p>将GCN用于半监督节点分类时，目标是通过最小化损失函数来学习上式中的权重矩阵：<br>$$<br>\mathcal{L}=\frac{1}{\left|\mathcal{Y}<em>{L}\right|} \sum</em>{i \in \mathcal{Y}<em>{L}} \operatorname{loss}\left(y</em>{i}, z_{i}^{L}\right)<br>$$</p>
<ul>
<li>$\mathcal{Y}_{\mathcal{L}}$是节点类别。</li>
<li>$z_{i}^{(L)}$是$Z^{(L)}$的第$i$行，表示节点$i$的最终层预测。</li>
<li>$y_{i}$为节点$i$的真实类别。<h4 id="3-Cluster-GCN的速度"><a href="#3-Cluster-GCN的速度" class="headerlink" title="3.Cluster-GCN的速度"></a>3.Cluster-GCN的速度</h4>原始的GCN的训练使用的是全批量梯度下降(Full Gradient Descent)，它的计算和内存成本很高:</li>
<li>在内存方面，通过反向传播来计算full gradient需要存储所有的embedding矩阵，这需要O(NFL)的内存空间（F是特征数量，N是结点数量，L是网络层数）。</li>
<li>在收敛速度方面，由于在每个epoch模型才更新一次，所以需要很多个epoch才会使模型达到收敛。</li>
</ul>
<p>mini-batch SGD可以提高GCN的训练速度，其不需要计算整个梯度，只需要计算每次更新的mini-batch的梯度。使用大小为$b=|\mathcal{B}|$的$\mathcal{B} \subseteq[N]$来表示一个batch的节点索引。SGD的每一步都将计算梯度估计值$\frac{1}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \nabla \operatorname{loss}\left(y_{i}, z_{i}^{(L)}\right)$来进行参数更新。</p>
<p>尽管在每个epoch收敛得更快，但SGD在GCN训练上引入了另一个计算开销（邻域扩展），这使得SGD的每个epoch时间内比全梯度下降（full gradient descent）要慢得多——计算一个节点$i$的梯度，需要节点$i$的embedding，而节点$i$的embedding的依赖于前面的层里的它的邻居的embeddings，为了提取前面的层中它的邻居节点embeddings，还需要进一步聚合每个邻居节点的邻居节点的embeddings。假设一个图神经网络有$L+1$层，节点的平均的度为$d$。为了得到节点$i$的梯度，需要聚合图上$O\left(d^{L}\right)$的节点的表征，与权重矩阵$W^{(l)}$相乘，所以计算任意节点表征的时间开销是$O\left(F^{2}\right)$。所以SGD一个节点的梯度的计算需要$O\left(d^{L} F^{2}\right)$的时间。</p>
<h4 id="4-Cluster-GCN详解"><a href="#4-Cluster-GCN详解" class="headerlink" title="4.Cluster-GCN详解"></a>4.Cluster-GCN详解</h4><p>在mini-batch SGD更新中，设计一个batch和相应的计算sub graph来最大限度地提高embedding utilization。Cluster-GCN通过将embedding utilization连接到一个聚类目标上来实现。</p>
<p>对于一个Graph$G$，我们将其节点划分为$c$个簇：$\mathcal{V}=\left[\mathcal{V}<em>{1}, \cdots \mathcal{V}</em>{c}\right]$，其中$\mathcal{V}<em>{t}$由第$t$个簇中的节点组成，得到$c$个子图:<br>$$<br>\bar{G}=\left[G</em>{1}, \cdots, G_{c}\right]=\left[\left{\mathcal{V}<em>{1}, \mathcal{E}</em>{1}\right}, \cdots,\left{\mathcal{V}<em>{c}, \mathcal{E}</em>{c}\right}\right]<br>\notag<br>$$<br>其中$\mathcal{E}<em>{t}$只由$\mathcal{V}</em>{t}$中的节点之间的边组成。经过节点重组，邻接矩阵被划分为大小为$c^{2}$的块矩阵，如下所示<br>$$<br>A=\bar{A}+\Delta=\left[\begin{array}{ccc}<br>A_{11} &amp; \cdots &amp; A_{1 c} \<br>\vdots &amp; \ddots &amp; \vdots \<br>A_{c 1} &amp; \cdots &amp; A_{c c}<br>\end{array}\right]<br>$$<br>其中<br>$$<br>\bar{A}=\left[\begin{array}{ccc}<br>A_{11} &amp; \cdots &amp; 0 \<br>\vdots &amp; \ddots &amp; \vdots \<br>0 &amp; \cdots &amp; A_{c c}<br>\end{array}\right], \Delta=\left[\begin{array}{ccc}<br>0 &amp; \cdots &amp; A_{1 c} \<br>\vdots &amp; \ddots &amp; \vdots \<br>A_{c 1} &amp; \cdots &amp; 0<br>\end{array}\right]<br>$$</p>
<ul>
<li>对角线上的块$A_{t t}$是大小为$\left|\mathcal{V}<em>{t}\right| \times\left|\mathcal{V}</em>{t}\right|$的邻接矩阵，它由$G_{t}$内部的边构成。</li>
<li>$\bar{A}$是图$\bar{G}$的邻接矩阵。</li>
<li>$A_{s t}$由两个簇$\mathcal{V}<em>{s}$和$\mathcal{V}</em>{t}$之间的边构成。</li>
<li>$\Delta$是由$A$的所有非对角线块组成的矩阵。</li>
</ul>
<p>用块对角线邻接矩阵$\bar{A}$去近似邻接矩阵$A$之后，完整的损失函数可以根据batch分解成多个部分之和：</p>
<p><a href="https://imgtu.com/i/W2fREV"><img src="https://z3.ax1x.com/2021/07/25/W2fREV.png" alt="W2fREV.png"></a></p>
<p><a href="https://imgtu.com/i/W2fX4O"><img src="https://z3.ax1x.com/2021/07/25/W2fX4O.png" alt="W2fX4O.png"></a></p>
<p>Cluster-GCN使用了Graph聚类算法来划分Graph。Graph聚类的方法，如metis和graclus等，旨在在Graph中的顶点上构建分区，使得簇内连接远大于簇间连接，从而更好的捕捉聚类和区分结构。</p>
<p><img src="https://i.loli.net/2021/07/12/h2CLbu9VMEzyNTa.jpg" alt="LAYER.jpg"></p>
<h4 id="5-Cluster-GCN实践"><a href="#5-Cluster-GCN实践" class="headerlink" title="5.Cluster-GCN实践"></a>5.Cluster-GCN实践</h4><p>PyG库中提供了Cluster-GCN的接口，可以像训练普通神经网络一样在超大图上训练图神经网络。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导入库和数据集</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> ModuleList</span><br><span class="line"><span class="keyword">from</span> torch_geometric.nn <span class="keyword">import</span> SAGEConv</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> torch_geometric.datasets <span class="keyword">import</span> Reddit, Reddit2</span><br><span class="line"><span class="keyword">from</span> torch_geometric.data <span class="keyword">import</span> ClusterData, ClusterLoader, NeighborSampler</span><br><span class="line"></span><br><span class="line">dataset = Reddit(<span class="string">&#x27;../dataset/Reddit&#x27;</span>)</span><br><span class="line">data = dataset[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(dataset.num_classes)</span><br><span class="line"><span class="built_in">print</span>(data.num_nodes)</span><br><span class="line"><span class="built_in">print</span>(data.num_edges)</span><br><span class="line"><span class="built_in">print</span>(data.num_features)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果：<br>41, 232965, 114615892, 602</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#图节点聚类并生成数据加载器</span></span><br><span class="line">cluster_data = ClusterData(data, num_parts=<span class="number">1500</span>, recursive=<span class="literal">False</span>, save_dir=dataset.processed_dir)</span><br><span class="line"></span><br><span class="line">train_loader = ClusterLoader(cluster_data, batch_size=<span class="number">20</span>, shuffle=<span class="literal">True</span>, num_workers=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">subgraph_loader = NeighborSampler(data.edge_index, sizes=[-<span class="number">1</span>], batch_size=<span class="number">1024</span>, shuffle=<span class="literal">False</span>,num_workers=<span class="number">12</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#构建网络</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, in_channels, out_channels</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        self.convs = ModuleList(</span><br><span class="line">            [SAGEConv(in_channels, <span class="number">128</span>),</span><br><span class="line">             SAGEConv(<span class="number">128</span>, out_channels)])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x, edge_index</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i, conv <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.convs):</span><br><span class="line">            x = conv(x, edge_index)</span><br><span class="line">            <span class="keyword">if</span> i != <span class="built_in">len</span>(self.convs) - <span class="number">1</span>:</span><br><span class="line">                x = F.relu(x)</span><br><span class="line">                x = F.dropout(x, p=<span class="number">0.5</span>, training=self.training)</span><br><span class="line">        <span class="keyword">return</span> F.log_softmax(x, dim=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inference</span>(<span class="params">self, x_all</span>):</span></span><br><span class="line">        pbar = tqdm(total=x_all.size(<span class="number">0</span>) * <span class="built_in">len</span>(self.convs))</span><br><span class="line">        pbar.set_description(<span class="string">&#x27;Evaluating&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i, conv <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.convs):</span><br><span class="line">            xs = []</span><br><span class="line">            <span class="keyword">for</span> batch_size, n_id, adj <span class="keyword">in</span> subgraph_loader:</span><br><span class="line">                edge_index, _, size = adj.to(device)</span><br><span class="line">                x = x_all[n_id].to(device)</span><br><span class="line">                x_target = x[:size[<span class="number">1</span>]]</span><br><span class="line">                x = conv((x, x_target), edge_index)</span><br><span class="line">                <span class="keyword">if</span> i != <span class="built_in">len</span>(self.convs) - <span class="number">1</span>:</span><br><span class="line">                    x = F.relu(x)</span><br><span class="line">                xs.append(x.cpu())</span><br><span class="line"></span><br><span class="line">                pbar.update(batch_size)</span><br><span class="line"></span><br><span class="line">            x_all = torch.cat(xs, dim=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        pbar.close()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x_all</span><br></pre></td></tr></table></figure>
<p>此神经网络的forward函数的定义与普通的图神经网络并无区别，而inference方法应用于推理阶段，为了获取更高的预测精度，所以使用subgraph_loader。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#训练、验证、测试</span></span><br><span class="line">device = torch.device(<span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line">model = Net(dataset.num_features, dataset.num_classes).to(device)</span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">0.005</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>():</span></span><br><span class="line">    model.train()</span><br><span class="line"></span><br><span class="line">    total_loss = total_nodes = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> train_loader:</span><br><span class="line">        batch = batch.to(device)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        out = model(batch.x, batch.edge_index)</span><br><span class="line">        loss = F.nll_loss(out[batch.train_mask], batch.y[batch.train_mask])</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        nodes = batch.train_mask.<span class="built_in">sum</span>().item()</span><br><span class="line">        total_loss += loss.item() * nodes</span><br><span class="line">        total_nodes += nodes</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total_loss / total_nodes</span><br><span class="line"></span><br><span class="line"><span class="meta">@torch.no_grad()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span>  <span class="comment"># Inference should be performed on the full graph.</span></span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line">    out = model.inference(data.x)</span><br><span class="line">    y_pred = out.argmax(dim=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    accs = []</span><br><span class="line">    <span class="keyword">for</span> mask <span class="keyword">in</span> [data.train_mask, data.val_mask, data.test_mask]:</span><br><span class="line">        correct = y_pred[mask].eq(data.y[mask]).<span class="built_in">sum</span>().item()</span><br><span class="line">        accs.append(correct / mask.<span class="built_in">sum</span>().item())</span><br><span class="line">    <span class="keyword">return</span> accs</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">31</span>):</span><br><span class="line">    loss = train()</span><br><span class="line">    <span class="keyword">if</span> epoch % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">        train_acc, val_acc, test_acc = test()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Epoch: <span class="subst">&#123;epoch:02d&#125;</span>, Loss: <span class="subst">&#123;loss:<span class="number">.4</span>f&#125;</span>, Train: <span class="subst">&#123;train_acc:<span class="number">.4</span>f&#125;</span>, &#x27;</span></span><br><span class="line">              <span class="string">f&#x27;Val: <span class="subst">&#123;val_acc:<span class="number">.4</span>f&#125;</span>, test: <span class="subst">&#123;test_acc:<span class="number">.4</span>f&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Epoch: <span class="subst">&#123;epoch:02d&#125;</span>, Loss: <span class="subst">&#123;loss:<span class="number">.4</span>f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果：<br>Epoch: 10, Loss: 0.2893, Train: 0.9620, Val: 0.9516, test: 0.9496<br>Epoch: 20, Loss: 0.2478, Train: 0.9664, Val: 0.9546, test: 0.9560<br>Epoch: 30, Loss: 0.2397, Train: 0.9689, Val: 0.9515, test: 0.9502</p>
</blockquote>
<p>在训练过程中，使用train_loader获取batch，每次根据多个簇组成的batch进行训练；在验证阶段，使用subgraph_loader，在计算一个节点的表征时会计算该节点的距离从$0$到$L$的邻接节点，可以更好地测试神经网络的性能。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>1.<a href="https://github.com/datawhalechina/team-learning-nlp/tree/master/GNN">datawhale-GNN开源学习资料</a><br>2.<a href="https://arxiv.org/abs/1905.07953">Cluster-GCN论文</a> </p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>GCN</tag>
      </tags>
  </entry>
  <entry>
    <title>图神经网络——基本图论与PyG库</title>
    <url>/2021/07/09/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%B6%85%E5%A4%A7%E8%A7%84%E6%A8%A1%E6%95%B0%E6%8D%AE%E9%9B%86%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%9B%BE%E9%A2%84%E6%B5%8B%E4%BB%BB%E5%8A%A1%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h3 id="图神经网络——超大规模数据集类的创建和图预测任务实践"><a href="#图神经网络——超大规模数据集类的创建和图预测任务实践" class="headerlink" title="图神经网络——超大规模数据集类的创建和图预测任务实践"></a>图神经网络——超大规模数据集类的创建和图预测任务实践</h3><p>当数据集规模超级大时，很难有足够大的内存完全存下所有数据。因此需要一个按需加载样本到内存的数据集类。</p>
<h4 id="1-Dataset基类"><a href="#1-Dataset基类" class="headerlink" title="1 Dataset基类"></a>1 <code>Dataset</code>基类</h4><h5 id="1-1-Dataset基类介绍"><a href="#1-1-Dataset基类介绍" class="headerlink" title="1.1 Dataset基类介绍"></a>1.1 <code>Dataset</code>基类介绍</h5><p>在PyG中，通过继承<code>torch_geometric.data.Dataset</code>基类来自定义一个按需加载样本到内存的数据集类。<br>继承此基类相比较继承<code>torch_geometric.data.InMemoryDataset</code>基类要多实现以下方法：</p>
<ul>
<li><code>len()</code>：返回数据集中的样本的数量。</li>
<li><code>get()</code>：实现加载单个图的操作。注意：在内部，getitem()返回通过调用get()来获取Data对象，并根据transform参数对它们进行选择性转换。</li>
</ul>
<span id="more"></span>
<h5 id="1-2-继承torch-geometric-data-Dataset基类的代码实现"><a href="#1-2-继承torch-geometric-data-Dataset基类的代码实现" class="headerlink" title="1.2 继承torch_geometric.data.Dataset基类的代码实现"></a>1.2 继承torch_geometric.data.Dataset基类的代码实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os.path <span class="keyword">as</span> osp</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch_geometric.data <span class="keyword">import</span> Dataset, download_url</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyOwnDataset</span>(<span class="params">Dataset</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, root, transform=<span class="literal">None</span>, pre_transform=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(MyOwnDataset, self).__init__(root, transform, pre_transform)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">raw_file_names</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;some_file_1&#x27;</span>, <span class="string">&#x27;some_file_2&#x27;</span>, ...]</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">processed_file_names</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;data_1.pt&#x27;</span>, <span class="string">&#x27;data_2.pt&#x27;</span>, ...]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">download</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># Download to `self.raw_dir`.</span></span><br><span class="line">        path = download_url(url, self.raw_dir)</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self</span>):</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> raw_path <span class="keyword">in</span> self.raw_paths:</span><br><span class="line">            <span class="comment"># Read data from `raw_path`.</span></span><br><span class="line">            data = Data(...)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.pre_filter <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> self.pre_filter(data):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.pre_transform <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                data = self.pre_transform(data)</span><br><span class="line"></span><br><span class="line">            torch.save(data, osp.join(self.processed_dir, <span class="string">&#x27;data_&#123;&#125;.pt&#x27;</span>.<span class="built_in">format</span>(i)))</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">len</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.processed_file_names)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, idx</span>):</span></span><br><span class="line">        data = torch.load(osp.join(self.processed_dir, <span class="string">&#x27;data_&#123;&#125;.pt&#x27;</span>.<span class="built_in">format</span>(idx)))</span><br><span class="line">        <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>
<h5 id="1-3-特殊情况"><a href="#1-3-特殊情况" class="headerlink" title="1.3 特殊情况"></a>1.3 特殊情况</h5><ul>
<li>download/process步骤可以跳过<br>对于无需下载数据集原文件的情况，不重写（override）<code>download</code>方法即可跳过下载。<br>对于无需对数据集做预处理的情况，不重写<code>process</code>方法即可跳过预处理。</li>
<li>有些Dataset类无需定义<br>可以不用定义一个<code>Dataset</code>类，而直接生成一个<code>Dataloader</code>对象，直接用于训练：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch_geometric.data <span class="keyword">import</span> Data, DataLoader</span><br><span class="line"></span><br><span class="line">data_list = [Data(...), ..., Data(...)]</span><br><span class="line">loader = DataLoader(data_list, batch_size=<span class="number">32</span>)</span><br></pre></td></tr></table></figure>
或者将一个列表的<code>Data</code>对象组成一个<code>batch</code>：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch_geometric.data <span class="keyword">import</span> Data, Batch</span><br><span class="line"></span><br><span class="line">data_list = [Data(...), ..., Data(...)]</span><br><span class="line">loader = Batch.from_data_list(data_list, batch_size=<span class="number">32</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-图样本封装成批（BATCHING）与DataLoader类"><a href="#2-图样本封装成批（BATCHING）与DataLoader类" class="headerlink" title="2 图样本封装成批（BATCHING）与DataLoader类"></a>2 图样本封装成批（BATCHING）与<code>DataLoader</code>类</h4><h5 id="2-1-合并小图组成大图"><a href="#2-1-合并小图组成大图" class="headerlink" title="2.1 合并小图组成大图"></a>2.1 合并小图组成大图</h5><p>PyTorch Geometric中采用的是将多个图封装成批的方式，将小图作为连通组件（connected component）的形式合并，构建一个大图。于是小图的邻接矩阵存储在大图邻接矩阵的对角线上。<br>该方法的优势在于：</p>
<ul>
<li>依靠消息传递方案的GNN运算不需要被修改。</li>
<li>没有额外的计算或内存的开销。（因为它们是以稀疏的方式保存的，只保留非零项）</li>
</ul>
<p>通过<a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/data.html#torch_geometric.data.DataLoader"><code>torch_geometric.data.DataLoader</code></a>类，多个小图被封装成一个大图。</p>
<h5 id="2-2-小图的属性增值与拼接"><a href="#2-2-小图的属性增值与拼接" class="headerlink" title="2.2 小图的属性增值与拼接"></a>2.2 小图的属性增值与拼接</h5><p>将小图存储到大图中时需要对小图的属性做一些修改，比如对节点序号增值，PyTorch Geometric的<code>DataLoader</code>类会自动对<code>edge_index</code>张量增值，增加的值为当前被处理图的前面的图的累积节点数量。</p>
<h5 id="2-3-图的匹配（Pairs-of-Graphs）"><a href="#2-3-图的匹配（Pairs-of-Graphs）" class="headerlink" title="2.3 图的匹配（Pairs of Graphs）"></a>2.3 图的匹配（Pairs of Graphs）</h5><p>不同类型的节点数量不一致，<code>edge_index</code>边的源节点与目标节点进行增值操作不同。</p>
<h5 id="2-4-二部图（Bipartite-Graphs）"><a href="#2-4-二部图（Bipartite-Graphs）" class="headerlink" title="2.4 二部图（Bipartite Graphs）"></a>2.4 二部图（Bipartite Graphs）</h5><p>部图是图论中的一种特殊模型。设$G=(V,E)$是一个无向图，如果顶点$V$可分割为两个互不相交的子集$(A,B)$，并且图中的每条边$(i,j)$所关联的两个顶点i和j分别属于这两个不同的顶点集$(i in A,j in B)$，则称图$G$为一个二部图。它的邻接矩阵定义两种类型的节点之间的连接关系。一般来说，不同类型的节点数量不需要一致，于是二部图的邻接矩阵$A \in {0,1}^{N \times M}$可能为平方矩阵，即可能有$N \neq M$。</p>
<h5 id="2-5-在新的维度上做拼接"><a href="#2-5-在新的维度上做拼接" class="headerlink" title="2.5 在新的维度上做拼接"></a>2.5 在新的维度上做拼接</h5><p>图级别属性或预测目标,<code>Data</code>对象的属性需要在一个新的维度上做拼接，此时形状为<code>[num_features]</code>的属性列表应该被返回为<code>[num_examples, num_features]</code>，而不是<code>[num_examples * num_features]</code>。</p>
<h4 id="3-创建超大规模数据集类实践"><a href="#3-创建超大规模数据集类实践" class="headerlink" title="3 创建超大规模数据集类实践"></a>3 创建超大规模数据集类实践</h4><p><a href="https://ogb.stanford.edu/kddcup2021/pcqm4m/"><strong>PCQM4M-LSC</strong></a>是一个分子图的量子特性回归数据集，它包含了3,803,453个图。<br>定义的数据集类如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> os.path <span class="keyword">as</span> osp</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> ogb.utils <span class="keyword">import</span> smiles2graph</span><br><span class="line"><span class="keyword">from</span> ogb.utils.torch_util <span class="keyword">import</span> replace_numpy_with_torchtensor</span><br><span class="line"><span class="keyword">from</span> ogb.utils.url <span class="keyword">import</span> download_url, extract_zip</span><br><span class="line"><span class="keyword">from</span> rdkit <span class="keyword">import</span> RDLogger</span><br><span class="line"><span class="keyword">from</span> torch_geometric.data <span class="keyword">import</span> Data, Dataset</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line">RDLogger.DisableLog(<span class="string">&#x27;rdApp.*&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPCQM4MDataset</span>(<span class="params">Dataset</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        self.url = <span class="string">&#x27;https://dgl-data.s3-accelerate.amazonaws.com/dataset/OGB-LSC/pcqm4m_kddcup2021.zip&#x27;</span></span><br><span class="line">        <span class="built_in">super</span>(MyPCQM4MDataset, self).__init__(root)</span><br><span class="line"></span><br><span class="line">        filepath = osp.join(root, <span class="string">&#x27;raw/data.csv.gz&#x27;</span>)</span><br><span class="line">        data_df = pd.read_csv(filepath)</span><br><span class="line">        self.smiles_list = data_df[<span class="string">&#x27;smiles&#x27;</span>]</span><br><span class="line">        self.homolumogap_list = data_df[<span class="string">&#x27;homolumogap&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">raw_file_names</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;data.csv.gz&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">download</span>(<span class="params">self</span>):</span></span><br><span class="line">        path = download_url(self.url, self.root)</span><br><span class="line">        extract_zip(path, self.root)</span><br><span class="line">        os.unlink(path)</span><br><span class="line">        shutil.move(osp.join(self.root, <span class="string">&#x27;pcqm4m_kddcup2021/raw/data.csv.gz&#x27;</span>), osp.join(self.root, <span class="string">&#x27;raw/data.csv.gz&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">len</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.smiles_list)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, idx</span>):</span></span><br><span class="line">        smiles, homolumogap = self.smiles_list[idx], self.homolumogap_list[idx]</span><br><span class="line">        graph = smiles2graph(smiles)</span><br><span class="line">        <span class="keyword">assert</span>(<span class="built_in">len</span>(graph[<span class="string">&#x27;edge_feat&#x27;</span>]) == graph[<span class="string">&#x27;edge_index&#x27;</span>].shape[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">assert</span>(<span class="built_in">len</span>(graph[<span class="string">&#x27;node_feat&#x27;</span>]) == graph[<span class="string">&#x27;num_nodes&#x27;</span>])</span><br><span class="line"></span><br><span class="line">        x = torch.from_numpy(graph[<span class="string">&#x27;node_feat&#x27;</span>]).to(torch.int64)</span><br><span class="line">        edge_index = torch.from_numpy(graph[<span class="string">&#x27;edge_index&#x27;</span>]).to(torch.int64)</span><br><span class="line">        edge_attr = torch.from_numpy(graph[<span class="string">&#x27;edge_feat&#x27;</span>]).to(torch.int64)</span><br><span class="line">        y = torch.Tensor([homolumogap])</span><br><span class="line">        num_nodes = <span class="built_in">int</span>(graph[<span class="string">&#x27;num_nodes&#x27;</span>])</span><br><span class="line">        data = Data(x, edge_index, edge_attr, y, num_nodes=num_nodes)</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取数据集划分</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_idx_split</span>(<span class="params">self</span>):</span></span><br><span class="line">        split_dict = replace_numpy_with_torchtensor(torch.load(osp.join(self.root, <span class="string">&#x27;pcqm4m_kddcup2021/split_dict.pt&#x27;</span>)))</span><br><span class="line">        <span class="keyword">return</span> split_dict</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    dataset = MyPCQM4MDataset(<span class="string">&#x27;dataset2&#x27;</span>)</span><br><span class="line">    <span class="keyword">from</span> torch_geometric.data <span class="keyword">import</span> DataLoader</span><br><span class="line">    <span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line">    dataloader = DataLoader(dataset, batch_size=<span class="number">256</span>, shuffle=<span class="literal">True</span>, num_workers=<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> tqdm(dataloader):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>在生成一个该数据集类的对象时:</p>
<ul>
<li>首先会检查指定的文件夹下是否存在<code>data.csv.gz</code>文件，如果不在，则会执行<code>download</code>方法，这一过程是在运行<code>super</code>类的<code>__init__</code>方法中发生的。</li>
<li>然后程序继续执行<code>__init__</code>方法的剩余部分，读取<code>data.csv.gz</code>文件，获取存储图信息的<code>smiles</code>格式的字符串，以及回归预测的目标<code>homolumogap</code>。由<code>smiles</code>格式的字符串转成图的过程在<code>get()</code>方法中实现，这样在生成一个<code>ataLoader</code>变量时，通过指定<code>num_workers</code>可以实现并行执行生成多个图。</li>
</ul>
<h4 id="4-图预测任务实践"><a href="#4-图预测任务实践" class="headerlink" title="4 图预测任务实践"></a>4 图预测任务实践</h4><h5 id="4-1-通过试验寻找最佳超参数"><a href="#4-1-通过试验寻找最佳超参数" class="headerlink" title="4.1 通过试验寻找最佳超参数"></a>4.1 通过试验寻找最佳超参数</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">python main.py  --task_name GINGraphPooling\    # 为当前试验取名</span><br><span class="line">                --device 0\                     </span><br><span class="line">                --num_layers 5\                 # 使用GINConv层数</span><br><span class="line">                --graph_pooling sum\            # 图读出方法</span><br><span class="line">                --emb_dim 256\                  # 节点嵌入维度</span><br><span class="line">                --drop_ratio 0.\</span><br><span class="line">                --save_test\                    # 是否对测试集做预测并保留预测结果</span><br><span class="line">                --batch_size 512\</span><br><span class="line">                --epochs 100\</span><br><span class="line">                --weight_decay 0.00001\</span><br><span class="line">                --early_stop 10\                # 当有early_stop个epoches验证集结果没有提升，则停止训练</span><br><span class="line">                --num_workers 4\</span><br><span class="line">                --dataset_root dataset          # 存放数据集的根目录</span><br></pre></td></tr></table></figure>
<p>这段代码运行后，程序会在<code>saves</code>目录下创建一个<code>task_name</code>参数指定名称的文件夹用于记录试验过程。试验运行过程中，所有的<code>print</code>输出都会写入到试验文件夹下的<code>output</code>文件，<code>tensorboard.SummaryWriter</code>记录的信息也存储在试验文件夹下的文件中。<br>修改上方的命令再执行，即可试验不同的超参数，所有试验的过程与结果信息都存储于<code>saves</code>文件夹下。启动<code>TensorBoard</code>会话，选择<code>saves</code>文件夹，即可查看所有试验的过程与结果信息。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>1.<a href="https://github.com/datawhalechina/team-learning-nlp/tree/master/GNN">datawhale-GNN开源学习资料</a><br>2.<a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/data.html#torch_geometric.data.InMemoryDataset"><code>Dataset</code>类官方文档</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>GNN</tag>
      </tags>
  </entry>
  <entry>
    <title>地理数据分析常用工具</title>
    <url>/2021/04/15/%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>在地理空间数据分析中，常用一些模块进行地理数据分析、特征提取及可视化，包括shapely、geopandas、folium、kepler.gl、geohash等工具。</p>
<h4 id="1-shapely"><a href="#1-shapely" class="headerlink" title="1. shapely"></a>1. shapely</h4><p>shapely是基于笛卡尔坐标的几何对象操作和分析Python库，底层基于GEOS和JTS拓扑运算库。</p>
<h5 id="1-1-Point对象"><a href="#1-1-Point对象" class="headerlink" title="1.1 Point对象"></a>1.1 Point对象</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> shapely.geometry <span class="keyword">import</span> Point</span><br><span class="line"></span><br><span class="line">point1 = Point(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">point2 = Point(<span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">point3 = Point(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#点的可视化</span></span><br><span class="line">geo.GeometryCollection([point1,point2,point3])</span><br><span class="line"></span><br><span class="line"><span class="comment">#Point转为numpy数组</span></span><br><span class="line"><span class="built_in">print</span>(np.array(point))</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h5 id="1-2-LineString对象"><a href="#1-2-LineString对象" class="headerlink" title="1.2 LineString对象"></a>1.2 LineString对象</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建LineString对象</span></span><br><span class="line">line1 = geo.LineString([(<span class="number">0</span>,<span class="number">0</span>),(<span class="number">2</span>,-<span class="number">2.2</span>),(<span class="number">3</span>,<span class="number">3.3</span>),(<span class="number">4</span>,-<span class="number">4.4</span>),(<span class="number">5</span>,-<span class="number">5.5</span>),(<span class="number">6</span>,<span class="number">6.6</span>)])</span><br><span class="line">line1 </span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#点和线的可视化</span></span><br><span class="line">geo.GeometryCollection([line1,Point(<span class="number">1</span>,<span class="number">1</span>)])</span><br><span class="line"></span><br><span class="line"><span class="comment">#计算点线或线线的最短距离</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;点线距离:&#x27;</span>+<span class="built_in">str</span>(Point(<span class="number">1</span>,<span class="number">1</span>).distance(line1)))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#几何中心</span></span><br><span class="line">center = line1.centroid </span><br><span class="line">geo.GeometryCollection([line1,center])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#几何对象的最小外接矩形</span></span><br><span class="line">b_rect = line1.envelope </span><br><span class="line">geo.GeometryCollection([line1,b_rect]) </span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="comment">#简化线(Douglas-Pucker算法)</span></span><br><span class="line">line1_simplify = line1.simplify(<span class="number">0.4</span>, preserve_topology=<span class="literal">False</span>) </span><br><span class="line">line1</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#生成线的缓冲区</span></span><br><span class="line">buffer_with_circle = line1.buffer(<span class="number">0.3</span>)  </span><br><span class="line">geo.GeometryCollection([line1,buffer_with_circle])</span><br></pre></td></tr></table></figure>
<h5 id="1-3-LinearRings对象"><a href="#1-3-LinearRings对象" class="headerlink" title="1.3 LinearRings对象"></a>1.3 LinearRings对象</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> shapely.geometry.polygon <span class="keyword">import</span> LinearRing</span><br><span class="line"></span><br><span class="line">ring = geo.polygon.LinearRing([(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">1</span>, -<span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>)])</span><br><span class="line">geo.GeometryCollection([ring])</span><br></pre></td></tr></table></figure>

<h5 id="1-4-Polygon对象"><a href="#1-4-Polygon对象" class="headerlink" title="1.4 Polygon对象"></a>1.4 Polygon对象</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> shapely.geometry <span class="keyword">import</span> Polygon</span><br><span class="line"></span><br><span class="line">poly1 = Polygon([(<span class="number">0</span>,<span class="number">0</span>),(<span class="number">2</span>,<span class="number">0</span>),(<span class="number">1</span>,-<span class="number">1</span>),(-<span class="number">3</span>,<span class="number">1</span>),(<span class="number">0</span>,<span class="number">0</span>)]) <span class="comment">#起点和终点相同</span></span><br><span class="line">poly1</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#通过numpy生成多边形</span></span><br><span class="line">coords = np.array([(<span class="number">0</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0.1</span>),(<span class="number">2</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">0</span>,<span class="number">0</span>)])</span><br><span class="line">poly2 = Polygon(coords)</span><br><span class="line">poly2 </span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#多个polygon的集合</span></span><br><span class="line">geo.GeometryCollection([poly1,poly2])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#几何中心</span></span><br><span class="line">center = poly1.centroid <span class="comment">#几何中心</span></span><br><span class="line">geo.GeometryCollection([center,poly1]) </span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#最小外接矩形</span></span><br><span class="line">rect = poly1.minimum_rotated_rectangle <span class="comment">#最小外接矩形</span></span><br><span class="line">geo.GeometryCollection([rect,poly1])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">poly1.boundary<span class="comment">#边缘</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">poly2.simplify(<span class="number">0.5</span>)<span class="comment">#简化面</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r1 = poly2.contains(point2) <span class="comment">#面点关系</span></span><br><span class="line"><span class="built_in">print</span>(r1)</span><br><span class="line"></span><br><span class="line">r2 = poly2.intersects(line1) <span class="comment">#面线关系</span></span><br><span class="line"><span class="built_in">print</span>(r2)</span><br><span class="line"></span><br><span class="line">r3 = poly1.intersects(poly2) <span class="comment">#面面关系</span></span><br><span class="line"><span class="built_in">print</span>(r3)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">poly1.intersection(poly2) <span class="comment">#面面交集</span></span><br><span class="line">poly1.union(poly2) 		  <span class="comment">#面面并集</span></span><br><span class="line">poly2.difference(poly1)   <span class="comment">#面面补集</span></span><br></pre></td></tr></table></figure>
<h4 id="2-geopandas"><a href="#2-geopandas" class="headerlink" title="2. geopandas"></a>2. geopandas</h4><p>geopandas是pandas在地理数据处理领域的扩展包，其核心数据结构是GeoSeries和GeoDataFrame。<br>geopandasd 主要功能为:</p>
<blockquote>
<p>1.文件读写<br>2.空间查询<br>3.坐标转换<br>4.空间join<br>5.地理数据可视化</p>
</blockquote>
<h5 id="2-1-文件读写"><a href="#2-1-文件读写" class="headerlink" title="2.1 文件读写"></a>2.1 文件读写</h5><p>geopandas可读geojson和shp等空间文件，也可读含有geometry字段的csv文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line"><span class="keyword">import</span> shapely </span><br><span class="line"><span class="keyword">import</span> geopandas <span class="keyword">as</span> gpd </span><br><span class="line"><span class="keyword">from</span> shapely <span class="keyword">import</span> wkt </span><br><span class="line"><span class="keyword">from</span> shapely <span class="keyword">import</span> geometry <span class="keyword">as</span> geo</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#读取geojson</span></span><br><span class="line">countries = gpd.read_file(<span class="string">&quot;dfcountries.geojson&quot;</span>,bbox = [-<span class="number">180</span>,-<span class="number">80</span>,<span class="number">180</span>,<span class="number">80</span>])</span><br><span class="line">countries.plot()<span class="comment">#显示图</span></span><br><span class="line">countries		<span class="comment">#显示表格</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#读取shp</span></span><br><span class="line">cities = gpd.GeoDataFrame.from_file(<span class="string">&#x27;./cities.shp&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">cities.plot()<span class="comment">#显示图</span></span><br><span class="line">cities		 <span class="comment">#显示表格</span></span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/U1e0d77ed2da2455cb9957e8ed6f59c20a.jpg" alt="f1"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#保存成geojson</span></span><br><span class="line">countries.to_file(<span class="string">&quot;dfcountries.geojson&quot;</span>,driver = <span class="string">&quot;GeoJSON&quot;</span>)</span><br><span class="line"><span class="comment">#保存成csv</span></span><br><span class="line">cities.to_csv(<span class="string">&quot;dfcountries.csv&quot;</span>,index = <span class="literal">False</span>,sep = <span class="string">&quot;\t&quot;</span>)</span><br><span class="line"><span class="comment">#保存成shp</span></span><br><span class="line">cities.to_file(<span class="string">&quot;.a/cities.shp&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#按值的大小填充颜色</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">9</span>,<span class="number">6</span>),dpi = <span class="number">100</span>)</span><br><span class="line">cities.plot(<span class="string">&#x27;area&#x27;</span>,ax = ax,legend = <span class="literal">True</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/U31c06924a773420bb62cc56d2ee9442ft.jpg" alt="f2"></p>
<h4 id="3-Folium"><a href="#3-Folium" class="headerlink" title="3.Folium"></a>3.Folium</h4><p>folium是一种交互式动态地图接口，可以用来画热力图、填充地图、路径图、散点标记等图。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> folium</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment">#指定坐标中心和缩放尺寸，生成交互式地图</span></span><br><span class="line">m = folium.Map(location=[<span class="number">30.33</span>,<span class="number">120.37</span>],zoom_start=<span class="number">10</span>)</span><br><span class="line">m</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/Uc6be8164498d4fda99801e6d30ac676eV.jpg" alt="f3"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> folium.plugins <span class="keyword">import</span> HeatMap</span><br><span class="line"><span class="comment">#生成随机数据，指定坐标中心和缩放尺寸，生成热力图</span></span><br><span class="line">data=(np.random.normal(size=(<span class="number">100</span>,<span class="number">3</span>))*np.array([[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]])+np.array([[<span class="number">30.33</span>,<span class="number">120.37</span>,<span class="number">1</span>]])).tolist()</span><br><span class="line">m=folium.Map([<span class="number">30.33</span>,<span class="number">120.37</span>],tiles=<span class="string">&#x27;Stamen Toner&#x27;</span>,zoom_start=<span class="number">6</span>)</span><br><span class="line">HeatMap(data).add_to(m)</span><br><span class="line">m </span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/U1fe179343a464ab1926cd10582207986X.jpg" alt="f4"></p>
<p>folium的MarkerCluster()聚类函数，可以用来反映一个区域的拥挤程度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> folium.plugins <span class="keyword">import</span> MarkerCluster</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建对象</span></span><br><span class="line">marker_cluster = MarkerCluster().add_to(m)</span><br><span class="line"></span><br><span class="line"><span class="comment">#将经纬度加入聚类</span></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> data:</span><br><span class="line">    folium.Marker(location=[element[<span class="number">0</span>], element[<span class="number">1</span>]],icon=<span class="literal">None</span>).add_to(marker_cluster)</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加至地图</span></span><br><span class="line">m.add_child(marker_cluster)</span><br><span class="line">m</span><br></pre></td></tr></table></figure>

<h4 id="4-Kepler-gl"><a href="#4-Kepler-gl" class="headerlink" title="4.Kepler.gl"></a>4.Kepler.gl</h4><p>Kepler.gl是Uber联合Mapbox推出的地理空间可视化工具，支持3种数据格式：CSV、JSON、GeoJSON。接下来将以杭州市OSM路网为例，制作路径流动动画。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keplergl <span class="keyword">import</span> KeplerGl</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#读取geojson</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./hzroad.json&#x27;</span>,encoding=<span class="string">&#x27;gb18030&#x27;</span>, errors=<span class="string">&#x27;ignore&#x27;</span>) <span class="keyword">as</span> g:</span><br><span class="line">    raw_roads = json.load(g)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#生成虚构时间戳信息和高度0</span></span><br><span class="line">start_time = time.mktime(time.strptime(<span class="string">&#x27;2020-05-29 20:00:00&#x27;</span>, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(raw_roads[<span class="string">&#x27;features&#x27;</span>].__len__()):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(raw_roads[<span class="string">&#x27;features&#x27;</span>][i][<span class="string">&#x27;geometry&#x27;</span>][<span class="string">&#x27;coordinates&#x27;</span>].__len__()):</span><br><span class="line">        <span class="comment"># 更新当前对应的时间戳</span></span><br><span class="line">        shift_time = <span class="built_in">int</span>((j / raw_roads[<span class="string">&#x27;features&#x27;</span>][i][<span class="string">&#x27;geometry&#x27;</span>][<span class="string">&#x27;coordinates&#x27;</span>].__len__())*<span class="number">3600</span>) </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 高度设置为0</span></span><br><span class="line">        raw_roads[<span class="string">&#x27;features&#x27;</span>][i][<span class="string">&#x27;geometry&#x27;</span>][<span class="string">&#x27;coordinates&#x27;</span>][j] \</span><br><span class="line">            .extend([<span class="number">0</span>, </span><br><span class="line">                     <span class="built_in">int</span>(start_time) + shift_time])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keplergl <span class="keyword">import</span> KeplerGl</span><br><span class="line"><span class="comment"># 生成KeplerGl对象</span></span><br><span class="line">m = KeplerGl(height=<span class="number">400</span>, </span><br><span class="line">                data=&#123;<span class="string">&#x27;flow&#x27;</span>: raw_roads&#125;) <span class="comment"># data以图层名为键，对应的矢量数据为值</span></span><br><span class="line">m</span><br><span class="line">m.save_to_html(file_name=<span class="string">&#x27;./hangzhou.html&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="5-Geohash"><a href="#5-Geohash" class="headerlink" title="5.Geohash"></a>5.Geohash</h4><p>GeoHash是一种地址编码方法，可以将地理经纬度坐标编码为由字母和数字所构成的字符串。其原理类似哈希表：由于遍历列表查找时间复杂度高，而创建散列函数能够更高效地定位数据。而GeoHash将二维的经纬度坐标编码到一维的字符串中，在做地理位置索引时只需匹配字符串，便于信息的缓存和压缩。</p>
<p>GeoHash采用二分法不断缩小经度和纬度的区间来进行二进制编码，最后将经纬度分别产生的编码奇偶位交叉合并，再用字母数字表示。</p>
<p><img src="https://ae01.alicdn.com/kf/Uf288553e6d2c43038976764613dd1cc1x.jpg" alt="f6"></p>
<blockquote>
<p>p.s. 酷炫动图见公众号</p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>geopandas</tag>
        <tag>shapely</tag>
        <tag>Kepler.gl</tag>
        <tag>folium</tag>
        <tag>geohash</tag>
      </tags>
  </entry>
  <entry>
    <title>异常检测——基于相似度的方法</title>
    <url>/2021/05/20/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E%E7%9B%B8%E4%BC%BC%E5%BA%A6%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>异常值通常具有更高的离群程度分数值，同时也更具有可解释性。在基于相似度的异常检测方法中，主要思想是异常点的表示与正常点不同。</p>
<h4 id="1-基于距离的度量"><a href="#1-基于距离的度量" class="headerlink" title="1.  基于距离的度量"></a>1.  基于距离的度量</h4><p>基于距离的异常检测有这样一个前提假设，即异常点的k近邻距离要远大于正常点。常见的方法是嵌套循环，第一层循环遍历每个数据，第二层循环进行异常判断计算当前点与其他点的距离，一旦发现多于k个数据点与当前点的距离在D之内，则将该点标记为非异常值。 此法计算的时间复杂度为O(N<sup>2</sup>)，当数据量比较大时需要修剪方法以加快距离计算。</p>
<span id="more"></span>
<h5 id="1-1-基于单元的方法"><a href="#1-1-基于单元的方法" class="headerlink" title="1.1 基于单元的方法"></a>1.1 基于单元的方法</h5><p>在基于单元格的技术中，数据空间被划分为单元格，单元格的宽度是阈值D和数据维数d的函数。<br><img src="https://z3.ax1x.com/2021/05/25/gzuzmn.jpg" alt="xx"><br>L1邻居表示通过最多1个单元间的边界可从该单元到达的单元格的集合，L2邻居表示通过跨越2个或3个边界而获得的那些单元格。<br>以二维数据为例，网格间的距离为D/2√d，其具有以下性质：<br>①单元格中两点之间的距离最多为D/2 。<br>②一个点与L1邻接点之间的距离最大为D。<br>③一个点与它的Lr邻居(其中r&gt;2)中的一个点之间的距离至少为D。</p>
<p>但是L2中并不能直接得出结论，需要另外定义规则，如：<br>①如果一个单元格中包含超过k个数据点及其L1邻居，那么这些数据点都不是异常值。<br>②如果单元A及其相邻L1和L2中包含少于k个数据点，则单元A中的所有点都是异常值。<br>利用第二条规则的修剪能力，对于包含至少一个数据点的每个单元格A，计算其中的点数及其L1和L2邻居的总和。 如果该数字不超过k，则将单元格A中的所有点标记为离群值。</p>
<p>对于此时仍未标记为异常值或非异常值的单元格中的数据点，需要明确计算其k最近邻距离，在L1和L2中不超过k个且距离小于D的数据点，则声明为异常值。</p>
<h5 id="1-2-基于索引的方法"><a href="#1-2-基于索引的方法" class="headerlink" title="1.2 基于索引的方法"></a>1.2 基于索引的方法</h5><p>对于一个给定数据集，基于索引的方法利用多维索引结构(如R树、k-d树)来搜索每个数据对象A在半径范围D内的相邻点。设M是一个异常值在其D-邻域内允许含有对象数的最大值，若发现某个数据对象A的D-邻域内出现M+1甚至更多个相邻点， 则判定对象A不是异常值。该算法时间复杂度在最坏情况下为O(kN<sup>2</sup>)，其中k是数据集维数，N是数据集包含对象的个数。但是构造索引的任务本身也需要密集复杂的计算量。</p>
<h4 id="2-基于密度的度量"><a href="#2-基于密度的度量" class="headerlink" title="2.  基于密度的度量"></a>2.  基于密度的度量</h4><p>基于密度的算法主要有局部离群因子(LocalOutlierFactor，LOF)，以及LOCI、CLOF等基于LOF的改进算法。LOF的关键步骤在于给每个数据点都分配一个离散度，其主要思想是：针对给定的数据集，对其中的任意一个数据点，如果在其局部邻域内的点都很密集，那么认为此数据点为正常数据点；而离群点则是距离正常数据点最近邻的点都比较远的数据点。</p>
<h5 id="2-1-k-距离"><a href="#2-1-k-距离" class="headerlink" title="2.1 k-距离"></a>2.1 k-距离</h5><p>类似k近邻的思路，首先定义一个k-距离，对于数据集D中的给定对象p，对象p与数据集D中任意点o的距离为d(po)。我们把数据集D中与对象p距离最近的k个相邻点的最远距离表示为k-distance(p)，把距离对象p距离第k近的点表示为o<sub>k</sub>，那么给定对象p和点o<sub>k</sub>之间的距离d(p,o<sub>k</sub>)=k-distance(p)，满足：<br>①在集合D中至少有不包括p在内的k个点 o’，其中o’∈D \ {p}，满足d(p,o’)≤d(p,o<sub>k</sub>)<br>②在集合D中最多有不包括p在内的k-1个点o’，其中o’∈D \ {p}，满足d(p,o’)&lt;d(po<sub>k</sub>)<br>直观一些理解，就是以对象p为中心，对数据集D中的所有点到p的距离进行排序，距离对象p第k近的点o<sub>k</sub>与p之间的距离就是k-距离。</p>
<h5 id="2-2-k-邻域"><a href="#2-2-k-邻域" class="headerlink" title="2.2 k-邻域"></a>2.2 k-邻域</h5><p>到对象p的距离小于等于k-距离的所有点的集合就是k-邻域：<br>$$<br>N_{k-dis\tan ce\left(p \right)}\left(p \right) =\left{ q\in D\backslash{q}\left| d\left(p,d \right) \right. \le k-ds\tan ce\left(p \right) \right}<br>$$<br>k-邻域包含对象p的第k距离以内的所有点，包括第k距离点；对象p的第k邻域点的个数丨N<sub>k</sub>(p)≥3丨。<br>在二维平面上展示，对象p的k-邻域是以对象p为圆心、k-距离为半径围成的圆形区域。<br><img src="https://www.hualigs.cn/image/608950de59262%E3%80%82jpg" alt="img"></p>
<h5 id="2-3-可达距离"><a href="#2-3-可达距离" class="headerlink" title="2.3  可达距离"></a>2.3  可达距离</h5><p>按照到对象o的距离远近，将数据集D内的点按照到o 的距离分为两类:<br>①若p<sub>i</sub>在对象o的k-邻域内，则可达距离就是给定点p<sub>i</sub>关于对象o的k-距离；<br>②若p<sub>i</sub>在对象o的k-邻域外，则可达距离就是给定点p<sub>i</sub>关于对象o的实际距离。<br>给定点p<sub>i</sub>关于对象o的可达距离用数学公式可以表示为：<br>$$<br>r e a c h−d i s t_ k (p,o) = max {k−distance(o),d (p,o)}<br>$$<br>这样的分类处理可以简化后续的计算，同时让得到的数值区分度更高。<br><img src="https://www.hualigs.cn/image/608951ddb06ae%E3%80%82jpg" alt="可达距离。jpg"><br>如图所示：<br>①p<sub>1</sub>在对象o的k-邻域内，d(p<sub>1</sub>,o)&lt;k−distance(o)，<br>可达距离reach−dist<sub>k</sub>(p<sub>1</sub>,o)=k−distance(o) ;<br>②p<sub>2</sub>在对象o的k-邻域外，d (p<sub>2</sub>,o)&gt;k−distance(o)，<br>可达距离reach−dist<sub>k</sub>(p<sub>2</sub>,o)= d(p<sub>2</sub>,o) ;</p>
<blockquote>
<p>需要注意的是:为了减少距离的计算开销，对象的k-邻域内的所有对象的k-距离计算量可以被显著降低，相当于使用一个阈值把需要计算的部分“截断”了， 的值越高，无需计算的邻近点越多，计算开销越小。但是另一方面，k的值变高，可能意味着可达距离变远，对集群点和离群点的区分度可能变低。因此，如何选择k值，是LOF算法能否达到效率与效果平衡的重要因素。</p>
</blockquote>
<h5 id="3-4-局部可达密度"><a href="#3-4-局部可达密度" class="headerlink" title="3.4 局部可达密度"></a>3.4 局部可达密度</h5><p>可以将“密度”直观地理解为点的聚集程度，简单来说，点与点之间距离越短，则密度越大。我们使用数据集D中对象p与对象o的k-邻域内所有点的可达距离平均值的倒数来定义局部可达密度。<br>在进行局部可达密度的计算的时候，我们需要避免数据集内所有数据落在同一点上，即所有可达距离之和为0的情况：此时局部密度为∞，后续计算将无法进行。</p>
<p>LOF算法中针对这一问题进行了如下的定义：对于数据集D内的给定对象p，存在至少MinPts(p)≥1个不同于p的点。因此，我们使用对象p到o∈N_{MinPts}(p)的可达距离reach-dist<sub>{MinPts}</sub>(p, o)作为度量对象p邻域的密度的值。点p的局部可达密度计算公式为：<br>$$<br>lrd_{MinPts}(p)=1/(\frac {\sum\limits_{o∈N_{MinPts}(p)} reach-dist_{MinPts}(p,o)} {\left\vert N_{MinPts}(p) \right\vert})<br>$$<br>由公式可看出，这里是对给定点p进行度量，计算其邻域内的所有对象o到给定点p的可达距离平均值。给定点p的局部可达密度越高，越可能与其邻域内的点p属于同一簇；密度越低，越可能是离群点。  </p>
<h5 id="3-5-局部异常因子"><a href="#3-5-局部异常因子" class="headerlink" title="3.5 局部异常因子"></a>3.5 局部异常因子</h5><p>得到lrd(局部可达密度)以后就可以将每个点的lrd将与它们的k个邻点的lrd进行比较，得到局部异常因子LOF。 LOF是对象p的邻居点o(o∈N<sub>MinPts</sub>(p))的lrd平均值与p的lrd的比值。</p>
<p>p的局部可达密度越低，且它的MinPts近邻的平均局部可达密度越高，则p的LOF值越高。如果这个比值越接近1，说明o的邻域点密度差不多，o可能和邻域同属一簇；如果这个比值小于1，说明o的密度高于其邻域点密度，o为密集点；如果这个比值大于1，说明o的密度小于其邻域点密度，o可能是异常点。<br><img src="https://www.hualigs.cn/image/6089531d9e0f7.jpg" alt="局部异常因子公式.png"><br>由上述公式计算出的LOF数值，就是我们所需要的离群点分数。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>1.<a href="https://github.com/datawhalechina/team-learning-data-mining/tree/master/AnomalyDetection">datawhale-异常检测开源学习资料</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>LOF</tag>
      </tags>
  </entry>
  <entry>
    <title>异常检测——基于统计学的方法</title>
    <url>/2021/05/14/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E%E7%BB%9F%E8%AE%A1%E5%AD%A6%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>异常检测的统计方法包含两种主要类型：参数方法和非参数方法。<br><strong>参数方法：</strong>假定数据服从以θ为参数的参数分布，该参数分布的概率密度函数f(x,θ)给出x属于该分布的概率，该值越小，x越可能是异常点。(仅对数据做的统计假定满足实际约束时可行)<br><strong>非参数方法</strong>：不假定先验统计模型，假定参数的个数较为灵活，并非完全无参。</p>
<span id="more"></span>
<h4 id="1-参数方法"><a href="#1-参数方法" class="headerlink" title="1. 参数方法"></a>1. 参数方法</h4><h5 id="1-1-基于正态分布的一元异常点检测"><a href="#1-1-基于正态分布的一元异常点检测" class="headerlink" title="1.1 基于正态分布的一元异常点检测"></a>1.1 基于正态分布的一元异常点检测</h5><p>仅涉及单变量的数据称为一元数据，假定数据由正态分布产生，由输入数据学习正态分布的参数，并把低概率的点识别为异常点。<br>输入数据集<img src="https://ae01.alicdn.com/kf/U0f09d41be5f54bc4892bab4863e0cc3b6.jpg" alt="公式1"> ，根据公式可以求出参数均值μ和方差σ，和概率密度函数p(x)。<br>$$<br>\mu =\frac{1}{n}\sum_{i=1}^n{x_i}<br>$$<br>$$<br>\sigma ^2=\frac{1}{n}\sum_{i=1}^n{\left( x_i-\mu \right)}^2<br>$$<br>$$<br>p\left( x \right) =\frac{1}{\sqrt{2\pi}\sigma}\exp \left( -\frac{\left( x-\mu \right) ^2}{2\sigma ^2} \right)<br>$$<br>在正太分布的假设中，可以为p(x)取值设置阈值来判断异常点。<br>或者简单地用3σ法则来判断，(μ-3σ，μ+3σ)包含99.7%的数据，某数据超出这个范围，可以简单的标记为异常点(Outlier)。</p>
<h5 id="1-2-多元离群点的检测方法"><a href="#1-2-多元离群点的检测方法" class="headerlink" title="1.2 多元离群点的检测方法"></a>1.2 多元离群点的检测方法</h5><p>一元异常点检测的方法可以扩展为多元异常点检测。<br>对于一个n维数据集合<img src="https://ae01.alicdn.com/kf/U22473047196a4af9b6ebca2d9ed966d3A.jpg" alt="公式2">，当各个维度的特征之间相互独立，可以按上述公式计算每个维度的均值和方差。基于正态分布的假设，根据概率<img src="https://ae01.alicdn.com/kf/U98b94844e25b4646a6538fab43facfbc8.jpg" alt="公式3">的大小判断x是否属于异常值。<br>$$<br>p\left(\vec{x} \right) =\prod_{j=1}^n{p\left(x_j;\mu _j;\sigma <em>{j}^{2} \right)}=\prod</em>{j=1}^n{\frac{1}{\sqrt{2\pi}\sigma _j}}\exp \left(-\frac{\left(x_j-\mu <em>j \right) ^2}{2\sigma <em>{j}^{2}} \right)<br>$$<br>当各个维度的特征相关时，需要用到基于多元正太分布来进行异常点检测，首先计算n维的均值向量<br>$$<br>\vec{\mu}=\left( E\left( x_1 \right) ,…,E\left( x_n \right) \right)<br>$$<br>和n×n的协方差矩阵：<br>$$<br>\sum{=\frac{1}{m}}\sum</em>{i=1}^m{\left( \vec{x}-\vec{\mu} \right) \left( \vec{x}-\vec{\mu} \right) ^T}<br>$$<br>如有新数据，可以计算<img src="https://ae01.alicdn.com/kf/U98b94844e25b4646a6538fab43facfbc8.jpg" alt="公式3">,根据概率值大小判断是否属于异常值。<br>$$<br>p\left( \vec{x} \right) =\frac{1}{\left( 2\pi ^{\frac{n}{2}}\left| \sum{} \right|^{</em>{2}^{1}} \right)}\exp \left( -\frac{1}{2}\left( \vec{x}-\vec{\mu} \right) ^T\sum{^{-1}\left( \vec{x}-\vec{\mu} \right)} \right)<br>$$</p>
<h4 id="2-非参数方法"><a href="#2-非参数方法" class="headerlink" title="2. 非参数方法"></a>2. 非参数方法</h4><p>非参数方法是对数据做较少的假定，因而适合多数情况。</p>
<h5 id="2-1-基于角度的方法"><a href="#2-1-基于角度的方法" class="headerlink" title="2.1 基于角度的方法"></a>2.1 基于角度的方法</h5><p>基于角度的方法往往在高维空间里会很有效，其主要思想是：数据边界上的数据很可能将整个数据包围在一个较小的角度内，而内部的数据点则可能以不同的角度围绕着他们。如下图所示，其中点A是一个异常点，点B位于数据内部。<br><img src="https://z3.ax1x.com/2021/05/25/gzJbtA.png" alt="a"><br>如果数据点与其余点离得较远，则潜在角度可能越小。因此，具有较小角度谱的数据点较有可能异常值，而具有较大角度谱的数据点不太可能是异常值。</p>
<h5 id="2-2-基于频数直方图的无监督异常点检测算法-HBOS"><a href="#2-2-基于频数直方图的无监督异常点检测算法-HBOS" class="headerlink" title="2.2 基于频数直方图的无监督异常点检测算法(HBOS)"></a>2.2 基于频数直方图的无监督异常点检测算法(HBOS)</h5><p>HBOS(Histogram-based Outlier Score)是一种单变量方法组合，HBOS在全局异常检测问题上表现良好，但不能检测局部异常值。但是HBOS比标准算法快得多，尤其是在大数据集上。<br>HOBS不能对特征之间的依赖关系进行建模，其基本假设是数据集的每个维度相互独立。然后对每个维度进行区间(bin)划分，对每一个bin进行评分。区间的密度越低，异常评分越高，越可能是异常点。<br>①等宽分桶：标准直方图构建，在值范围内构造k个等宽箱，样本若如每个箱的概率作为密度的估计[时间复杂度O(n)]<br>②动态宽度分桶：对所有值进行排序，将固定数量的N/k个连续值装进一个箱。N是总实例数，k是箱个数，所有箱面积一样，跨度大的箱的高度低，即密度小(例外情况：超过k个数相等，此时允许在同一个箱里超过N/k值)<br>对每个维度都计算一个独立的直方图，其中每个箱子的高度表示密度的估计，对直方图进行归一化处理，最后计算每一个实例的HBOS值。<br>$$<br>HBOS\left( p \right) =\sum_{i=0}^d{\log \left( \frac{1}{hist_i\left( p \right)} \right)}<br>$$<br>详细推导过程：<br>假设样本o的第i个特征概率密度为<img src="https://ae01.alicdn.com/kf/U3264e024f94c45a0bbe5110c82bca661k.jpg" alt="x">，则o的概率密度为：<br>$$<br>P\left( p \right) =P_1\left( p \right) P_2\left( p \right) …P_d\left( p \right)<br>$$<br>两边取对数<br>$$<br>\log \left( P\left( p \right) \right) =\log \left( P_1\left( p \right) P_2\left( p \right) …P_d\left( p \right) \right) =\sum_{i=1}^d{\log \left( P_i\left( p \right) \right)}<br>$$<br>为了达到概率密度越大异常评分越小，两边同乘-1。<br>$$<br>-\log \left( P\left( p \right) \right) =-\sum_{i=1}^d{\log \left( P_i\left( p \right) \right)}=\sum_{i=1}^d{\frac{1}{\log \left( P_i\left( p \right) \right)}}<br>$$<br>最后：<br>$$<br>HOBS\left( p \right) =-\log \left( P\left( p \right) \right) =\sum_{i=1}^d{\frac{1}{\log \left( P_i\left( p \right) \right)}}<br>$$</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>1.<a href="https://github.com/datawhalechina/team-learning-data-mining/tree/master/AnomalyDetection">datawhale-异常检测开源学习资料</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Normal distribution</tag>
        <tag>HBOS</tag>
      </tags>
  </entry>
  <entry>
    <title>异常检测——线性相关方法</title>
    <url>/2021/05/17/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>真实数据集中不同维度的特征可能具有高度相关性，这是因为不同的特征往往是由相同的基础过程以密切相关的方式产生的。这被称为——回归建模，是一种参数化的相关性分析。<br>一类相关性分析通过其他变量预测单独的属性值，另一类方法用一些潜在变量来代表整个数<br>据。前者的代表是<strong>线性回归</strong>，后者一个典型的例子是<strong>主成分分析</strong>。<br>线性相关分析基于的假设是：①近似线性相关假设；②子空间假设。为了确定线性模型是否适合数据集，需要进行探索性和可视化分析。</p>
<span id="more"></span>
<h4 id="0-探索性和可视化分析"><a href="#0-探索性和可视化分析" class="headerlink" title="0. 探索性和可视化分析"></a>0. 探索性和可视化分析</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_data.describe()</span><br><span class="line">train_data.info()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#相关性分析</span></span><br><span class="line">numeric_features = [<span class="string">&#x27;f&#x27;</span>+<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>)]</span><br><span class="line">numeric = train_data[numeric_features]</span><br><span class="line">correlation.numeric.corr()</span><br><span class="line"></span><br><span class="line">f,ax = plt.subplots(figsize=(<span class="number">15</span>,<span class="number">15</span>))</span><br><span class="line">sns.heatmap(correlation,square=<span class="literal">True</span>)</span><br><span class="line">plt.tile(<span class="string">&#x27;Correlation of Numeric features&#x27;</span>,y=<span class="number">1</span>,size=<span class="number">16</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://z3.ax1x.com/2021/05/25/gzuhyd.jpg" alt="xx"></p>
<h4 id="1-线性回归"><a href="#1-线性回归" class="headerlink" title="1. 线性回归"></a>1. 线性回归</h4><p>线性回归：假设不同维度的变量具有一定的相关性，并可以通过一个相关系数矩阵进行衡量。<br>在线性回归中，异常值是根据自变量对因变量的影响来定义的，自变量之间相互关系中的异常则不那么重要。(此处的异常点检测是基于数据点的整体分布)</p>
<h5 id="1-1-最小二乘法"><a href="#1-1-最小二乘法" class="headerlink" title="1.1 最小二乘法"></a>1.1 最小二乘法</h5><p>基于最小二乘拟合的线性回归可以如下定义：带标签数据集<br>$$<br>D=\left{ \left( x_1,y_1 \right) ,…,\left( x_m,y_m \right) \right}<br>$$<br>m个样本的特征组成矩阵X；m个样本的标签组成标签向量<br>$$<br>y=\left( y_1,…,y_m \right) ^T<br>$$<br>目的是求出θ，使得目标函数J(θ)最小。<br>$$<br>J\left( \theta \right) =\lVert \left. X\theta -y \rVert <em>{2}^{2} \right.<br>$$<br>为什么目标函数J(θ)是残差向量的2-范数的平方？可以这样解释：<br>某个样本(x<sub>i</sub>,y<sub>i</sub>)在θ确定情况下满足：<br>$$<br>y_i=\theta ^Tx_i+\epsilon <em>i<br>$$<br>ϵi为误差项，可以看作独立同分布的随机变量，且服从高斯分布。可以以计算yi的概率密度函数：<br>$$<br>L\left( \theta \right) =p\left( y_i\left| x_i;\theta \right. \right) =\frac{1}{\sqrt{2\pi}\sigma}\exp \left( -\frac{\left( y_i-\theta ^Tx_i \right) ^2}{2\sigma ^2} \right)<br>$$<br>要使J(θ)最小，就要使使L(θ)最大，可使用最大似然估计法。<br>$$<br>L\left( \theta \right) =\log \prod</em>{i=1}^m{\frac{1}{\sqrt{2\pi}\sigma}\exp \left( -\frac{\left( y_i-\theta ^Tx_i \right) ^2}{2\sigma ^2} \right)}=m\log \frac{1}{\sqrt{2\pi}\sigma}-\frac{1}{\sigma ^2}·\frac{1}{2}\sum</em>{i-=1}^m{\left( y_i-\theta ^Tx_i \right)}^2<br>$$<br>通常做法是对似然函数求导，使导数为0。上述也证明了要让L(θ)最大就是要让J(θ)最小。<br>$$<br>\sum_{i-=1}^m{\left( y_i-\theta ^Tx_i \right)}^2=\lVert \left. X\theta -y \rVert \right. _{2}^{2}<br>$$<br>说回最小二乘，目的是求出最优点θ使J(θ)最小。<br>设残差向量r=Xθ−y，在二维空间中讨论，Xθ为一条直线，y为一个向量，存在最优点θ<sup>✲</sup>使得J(θ)最小，这个θ<sup>✲</sup>是最小二乘解集合中的一个元素，如图所示：<br><img src="https://z3.ax1x.com/2021/05/25/gzufQH.png" alt="xx"><br>由图看出这个θ<sup>✲</sup>是r垂直于Xθ时取到。由定义，Xθ是矩阵X的列空间C(X)，与C(X)垂直的是矩阵X的左零空间N(X<sup>T</sup>)，由左零空间定义：<br>$$<br>X^Tr=0<br>$$<br>把r=Xθ−y带入，得到：<br>$$<br>X^T\left( X\theta -y \right) =0<br>$$<br>整理得最优参数θ为：<br>$$<br>\theta =\left( X^T·X \right) ^{-1}·\left( X^T·y \right)<br>$$<br>个人觉得J(θ)也可以认为是某种异常得分。</p>
<h5 id="1-2-梯度下降"><a href="#1-2-梯度下降" class="headerlink" title="1.2 梯度下降"></a>1.2 梯度下降</h5><p>线性回归的优化目标是损失函数，就需要一种优化算法。<br>线性回归中的常用损失函数是均方误差MSE，表达式为：<br>$$<br>L\left( w,b \right) =\frac{1}{2}\left( \hat{y}^{\left( i \right)}-y^{\left( i \right)} \right) ^2 = \frac{1}{n}\sum_{i=1}^n{l^{\left( i \right)}}\left( w,b \right) =\frac{1}{n}\sum_{i=1}{\frac{1}{2}\left( W^Tx^{\left( i \right)}+b-y^{\left( i \right)} \right)}^2<br>$$<br>当模型和损失函数形式较为简单时，面的误差最小化问题的解可以直接用公式表达出来。然而，大多数深度学习模型并没有解析解，只能通过优化算法有限次迭代模型参数来尽可能降低损失函数的值。<br>在求数值解的优化算法中，小批量随机梯度下降（mini-batch stochastic gradient descent）被广泛使用。他的算法是：先选取一组模型参数的初始值，如随机选取；接下来对参数进行多次迭代，使每次迭代都可能降低损失函数的值。在每次迭代中，先随机均匀采样一个由固定数目训练数据样本所组成的小批量（mini-batch），然后求小批量中数据样本的平均损失和有关模型参数的导数（梯度），最后用此结果与预先设定的学习率的乘积作为模型参数在本次迭代的减小量。如下式所示：<br>$$<br>\left( w,b \right) \gets \left( w,b \right) -\frac{\eta}{\left| \left. \mathbb{B} \right| \right.}\sum_{i\in \mathbb{B}}{\partial _{\left( w,b \right)}}l^{\left( i \right)}\left( w,b \right)<br>$$<br>B表示批量大小batch size；η表示学习率，代表每次学习的步长大小。</p>
<h4 id="2-主成分分析"><a href="#2-主成分分析" class="headerlink" title="2. 主成分分析"></a>2. 主成分分析</h4><p>最小二乘法试图找到一个与数据具有最佳匹配(d-1)维超平面；主成分分析方法可用于解决这一问题的广义版本，它可以找到任意k(k&lt;d)维的最优表示超平面，从而使平方投<br>影误差最小化。</p>
<h5 id="2-1-原理"><a href="#2-1-原理" class="headerlink" title="2.1 原理"></a>2.1 原理</h5><p>对于d维，包含N个样本的数据，用R<sub>i</sub>表示其中第i行[x<sub>i1</sub>,…x<sub>id</sub>]，可得到d×d的协方差矩阵：<br>$$<br>\sum{=\left( R-\bar{R} \right)}^T·\left( R-\bar{R} \right)<br>$$<br>∑是对称并且半正定的，因此可以进行相似对角化：<br>$$<br>\sum{=P·D·P^T}<br>$$<br>这里的D为对角矩阵，对角元素为特征值。P为标准正交矩阵，每一行为对应的特征向量；这些标准正交向量提供了数据应该投影的轴线方向。<br>将样本的协方差矩阵特征值分解以后，特征值就是样本投影到这个轴上后对应的方差，特征值越小，说明投影以后在这个轴上样本点分布集中，而异常点在这种情况下更容易偏移，利用这一点可以作为衡量样本异常的一个指标。在PCA做降维的时候，起作用的是大的特征值对应的特征向量，而在异常检测中，起作用的是特征值小的对应的特征向量。根据以上思想，我们可以定义PCA中一个点x的异常评分：<br>$$<br>Score\left( x \right) =\sum_{i=1}^d{\frac{\left| \left. x^Te_i \right| \right.}{\lambda _i}}<br>$$<br>其中，e<sub>i</sub>为第i个特征向量，λ为沿该方向的方差(也是特征值)，可以看出对异常得分的大部分贡献是由λ值较小的主成分的提供的。</p>
<h5 id="2-2-PyOD实例"><a href="#2-2-PyOD实例" class="headerlink" title="2.2 PyOD实例"></a>2.2 PyOD实例</h5><p>测试PCA和HBOS的性能对比。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> pyod.models.pca <span class="keyword">import</span> PCA</span><br><span class="line"><span class="keyword">from</span> pyod.models.hbos <span class="keyword">import</span> HBOS</span><br><span class="line"><span class="keyword">from</span> pyod.utils.data <span class="keyword">import</span> evaluate_print</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    data = pd.read_csv(<span class="string">&#x27;dataverse_files/breast-cancer-unsupervised-ad.csv&#x27;</span>, header=<span class="literal">None</span>)</span><br><span class="line">    data_x=data[[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>)]].values <span class="comment">#特征</span></span><br><span class="line">    data_y=data[<span class="number">30</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="number">1</span> <span class="keyword">if</span> x==<span class="string">&#x27;o&#x27;</span> <span class="keyword">else</span> <span class="number">0</span>).values <span class="comment">#标签</span></span><br><span class="line">    X_train, X_test, y_train, y_test = train_test_split(data_x, data_y, test_size=<span class="number">0.3</span>,stratify=data_y)<span class="comment">#使用分层抽样，构建训练集和测试集</span></span><br><span class="line">    train_number=X_train.shape[<span class="number">0</span>]<span class="comment">#训练集样本的个数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">#PCA方法</span></span><br><span class="line">    clf1 = PCA(n_components=<span class="number">15</span>)</span><br><span class="line">    clf1.fit(X_train)</span><br><span class="line">    y_train_scores_clf1 = clf1.decision_scores_</span><br><span class="line">    y_test_scores_clf1 = clf1.decision_function(X_test)</span><br><span class="line"></span><br><span class="line">	<span class="comment">#HBOS方法</span></span><br><span class="line">    clf2 = HBOS(n_bins=(<span class="built_in">int</span>)(np.sqrt(train_number)))</span><br><span class="line">    clf2.fit(X_train)</span><br><span class="line">    y_train_scores_clf2 = clf2.decision_scores_</span><br><span class="line">    y_test_scores_clf2 = clf2.decision_function(X_test)</span><br><span class="line"></span><br><span class="line">	<span class="comment">#结果对比</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Training Data:&quot;</span>)</span><br><span class="line">    evaluate_print(<span class="string">&#x27;PCA&#x27;</span>, y_train, y_train_scores_clf1)</span><br><span class="line">    evaluate_print(<span class="string">&#x27;HBOS&#x27;</span>, y_train, y_train_scores_clf2)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Test Data:&quot;</span>)</span><br><span class="line">    evaluate_print(<span class="string">&#x27;PCA&#x27;</span>, y_test, y_test_scores_clf1)</span><br><span class="line">    evaluate_print(<span class="string">&#x27;HBOS&#x27;</span>, y_test, y_test_scores_clf2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果发现，PCA的性能优于HBOS。</p>
<blockquote>
<p>局限性:<br>1.回归分析作为检测离群值的工具有一些局限性：为了使回归分析技术有效，数据需要高度相关，并沿着低维子空间对齐。当数据不相关，但在某些区域高度聚集时，这种方法可能不会有效。<br>2.数据中的相关性在本质上可能不是全局性的。子空间相关性可能是特定于数<br>据的特定位置的。在这种情况下，由主成分分析发现的全局子空间对于异常检测是次优的。因此，为了创建更一般的局部子空间模型，有时将线性模型与邻近模型结合起来是有用的。</p>
</blockquote>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>1.<a href="https://github.com/datawhalechina/team-learning-data-mining/tree/master/AnomalyDetection">datawhale-异常检测开源学习资料</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>OLSE</tag>
        <tag>Linear Regression</tag>
        <tag>Gradient descent</tag>
        <tag>PCA</tag>
        <tag>PyOD</tag>
      </tags>
  </entry>
  <entry>
    <title>异常检测——集成方法</title>
    <url>/2021/05/23/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E2%80%94%E2%80%94%E9%9B%86%E6%88%90%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>一般情况下，可以把异常检测看成是数据不平衡下的分类问题，如果数据条件允许，优先使用有监督异常检测如XGBOOST；仅有少量标签时，可以用无监督学习作为一种特征抽取方式，最后喂给有监督的分类模型。<br>之前介绍的统计与概率模型、线性模型、基于相似度的模型，和今天要介绍的集成学习都是无监督模型。</p>
</blockquote>
<p>为什么要使用集成学习？——①适合高维度数据(空间稀疏)，②提高模型鲁棒性。<br>值得注意的时，异常检测没有标签，所以feature bagging、bagging比boosting多。而使用boosting进行异常检测，需要生成伪标签。</p>
<span id="more"></span>
<h4 id="1-Feature-Bagging"><a href="#1-Feature-Bagging" class="headerlink" title="1. Feature Bagging"></a>1. Feature Bagging</h4><p>Feature Bagging，基本思想与bagging相似，只是对象是feature。<br>基本检测器可以彼此完全不同，或不同的参数设置，或使用不同采样的子数据集。Feature bagging常用lof算法为基算法。</p>
<h5 id="1-1-算法原理"><a href="#1-1-算法原理" class="headerlink" title="1.1 算法原理"></a>1.1 算法原理</h5><p><img src="https://z3.ax1x.com/2021/05/25/gzMCDA.png" alt="x"></p>
<h5 id="1-2-不同检测器的分数标准化"><a href="#1-2-不同检测器的分数标准化" class="headerlink" title="1.2 不同检测器的分数标准化"></a>1.2 不同检测器的分数标准化</h5><p>不同检测器可能会在不同的尺度上产生分数。例如，平均k近邻检测器会输出原始距离分数，而LOF算法会输出归一化值。另外，检测器输出的异常值分数大小不一，因此需要归一化，常见方法包括平均和最大化组合函数。<br>以累积求和法和广度优先法为例，简单介绍下：<br>①累积求和：针对每组样本，分别累加对应的全部基本检测器的结果；共输出T组求和结果。<br>②广度优先：枚举每一种基本检测器(共m种)，再嵌套枚举每一组异常值输出（共T种），每种异常检测算法分别检测T组样本数据，共有m*T种组合，按照广度优先搜索，先到先占位，重复数据取后来的异常值的最大值、平均值等。</p>
<h5 id="1-3-Feature-Bagging的缺陷"><a href="#1-3-Feature-Bagging的缺陷" class="headerlink" title="1.3 Feature Bagging的缺陷"></a>1.3 Feature Bagging的缺陷</h5><p>①bagging有放回抽样，会损失部分特征的信息，或者特征始终无法被采样也无法被模型训练到。因此使用bagging实际上需要处理偏差和方差之间的一种微妙的均衡。<br>②bagging的比例通常在0.5到0.99之间，如果存在过多的相关性特征，会导致泛化能力下降。所以进行异常检测之前，必须进行严格的相关性分析或者主成分分析。</p>
<h4 id="2-Isolation-Forest"><a href="#2-Isolation-Forest" class="headerlink" title="2. Isolation Forest"></a>2. Isolation Forest</h4><p>周志华老师在2008年提出的算法，在工业界应用广泛，其不需要定义数学模型也不需要训练数据有标签。<br>这种算法在全局和局部都通过采样引入了随机性，往往要比单纯的feature bagging的效果更好。</p>
<h5 id="2-1-关于异常的定义"><a href="#2-1-关于异常的定义" class="headerlink" title="2.1 关于异常的定义"></a>2.1 关于异常的定义</h5><p>使用孤立森林(Isolation Forests)的前提是，将异常点定义为那些 <em>“容易被孤立的离群点”</em> —— 可以理解为分布稀疏，且距离高密度群体较远的点。即默认①异常数据占总样本量的比例很小，②异常点的特征值与正常点的差异很大。</p>
<h5 id="2-2-查找孤立点的策略"><a href="#2-2-查找孤立点的策略" class="headerlink" title="2.2 查找孤立点的策略"></a>2.2 查找孤立点的策略</h5><p>用一个随机超平面来切割数据空间，切一次可以生成两个子空间。继续用随机超平面来切割每个子空间并循环，直到每个子空间只有一个数据点为止。<br>以二维空间作为演示，点B’跟其他数据点比较疏离，只需要很少的几次操作就可以将它细分出来；点A’需要的切分次数会更多一些。<br><img src="https://z3.ax1x.com/2021/05/25/gzK31e.png" alt="xx"></p>
<h5 id="2-3-树的构造方法"><a href="#2-3-树的构造方法" class="headerlink" title="2.3 树的构造方法"></a>2.3 树的构造方法</h5><p><strong>训练：</strong>构建一棵 iTree 时，先从全量数据中抽取一批样本，然后随机选择一个特征作为起始节点，并在该特征的最大值和最小值之间随机选择一个值，将样本中小于该取值的数据划到左分支，大于等于该取值的划到右分支。然后，在左右两个分支数据中，重复上述步骤，直到满足如下条件：①数据不可再分，即：只包含一条数据，或者全部数据相同。②二叉树达到限定的最大深度。</p>
<p><strong>预测：</strong>计算数据 x 的异常分值时，先要估算它在每棵 iTree 中的路径深度。先沿着一棵 iTree，从根节点开始按不同特征的取值从上往下，直到到达某叶子节点。假设 iTree 的训练样本中同样落在 x 所在叶子节点的样本数为 T.size，则数据 x 在这棵 iTree 上的路径深度 h(x)，可以用下面这个公式计算：<br>$$<br>h\left( x \right) =e+C\left( T.size \right)<br>$$<br>式中，e 表示数据 x 从 iTree 的根节点到叶节点过程中经过的边的数目，C(T.size) 可以认为是一个修正值，它表示在一棵用 T.size 条样本数据构建的二叉树的平均路径长度。C(n) 的计算公式如下：<br>$$<br>C\left( n \right) =2H\left( n-1 \right) -\frac{2\left( n-1 \right)}{n}<br>$$<br>其中，H(n-1) 可用 ln(n-1)+0.5772156649(欧拉常数)估算。数据 x 最终的异常分值 Score(x) 综合了多棵 iTree 的结果：<br>$$<br>Score\left( x \right) =2^{-\frac{E\left( h\left( x \right) \right)}{C\left( \varPsi \right)}}<br>$$<br>公式中，E(h(x)) 表示数据 x 在多棵 iTree 的路径长度的均值，ψ表示单棵 iTree 的训练样本的样本数，C(ψ)表示用ψ条数据构建的二叉树的平均路径长度，它在这里主要用来做归一化。</p>
<p>从异常分值的公式看，如果数据 x 在多棵 iTree 中的平均路径长度越短，得分越接近 1，表明数据 x 越异常；如果数据 x 在多棵 iTree 中的平均路径长度越长，得分越接近 0，表示数据 x 越正常；如果数据 x 在多棵 iTree 中的平均路径长度接近整体均值，则打分会在 0.5 附近。</p>
<blockquote>
<p>在实际情况中，不同模型在不同的数据集上表现不一。但是总体而言KNN等基于位置和距离度量的算法原理不太复杂，表现也较为稳定。<br>唯一的缺点是，KNN等基于距离度量模型受到数据维度的影响较大，当维度比较低时表现很好。如果异常特征隐藏在少数维度上时，KNN和LOF类的效果就不会太好，此时该选择Isolation Forest(适合高维空间)。</p>
</blockquote>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>1.<a href="https://github.com/datawhalechina/team-learning-data-mining/tree/master/AnomalyDetection">datawhale-异常检测开源学习资料</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Feature Bagging</tag>
        <tag>Isolation Forest</tag>
      </tags>
  </entry>
  <entry>
    <title>李宏毅机器学习——反向传播</title>
    <url>/2021/07/18/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/</url>
    <content><![CDATA[<h3 id="李宏毅机器学习——反向传播"><a href="#李宏毅机器学习——反向传播" class="headerlink" title="李宏毅机器学习——反向传播"></a>李宏毅机器学习——反向传播</h3><h4 id="1-反向传播原理"><a href="#1-反向传播原理" class="headerlink" title="1 反向传播原理"></a>1 反向传播原理</h4><p>神经网络中求解权重W的算法，分为信号的前向传播（Forward propagation，FP）和反向传播（Back propagation，BP）。前向传播得到预测值，计算输出误差，然后计算每个神经元节点对误差的贡献；反向传播根据前向传播的误差来求梯度，然后根据贡献调整原来的权重，最终达到最小化损失函数的目的。<br><a href="https://imgtu.com/i/W2hxoV"><img src="https://z3.ax1x.com/2021/07/25/W2hxoV.png" alt="W2hxoV.png"></a></p>
<span id="more"></span>

<p>假设只有一个隐含层，设L为损失函数。<br>在输出层上的误差（这里$O_{k}$就是输出值$y_{out}$。）：<br>$$<br>L_{total}=\frac{1}{2}(d-O)^{2}=\frac{1}{2} \sum_{k=1}^{\ell}\left(d_{k}-O_{k}\right)^{2}<br>$$</p>
<p>在隐含层上的误差（这里$net_{k}=\sum(w_i*O_{k})+b$。）：<br>$$<br>L_{total}=\frac{1}{2} \sum_{k=1}^{c}(d_{k}-f[\sum_{j=0}^{m} w_{j k} f(n e t_{j})])^{2}=\frac{1}{2} \sum_{k=1}^{c}(d_{k}-f[\sum_{j=0}^{m} w_{j k} f(\sum_{i=1}^{n} v_{i j} x_{i}))^{2}<br>$$</p>
<p>在输入层上的误差：<br>$$<br>L_{total}=\frac{1}{2} \sum_{k=1}^{c}\left(d_{k}-f\left[\sum_{j=0}^{m} w_{j k} f\left(n e t_{j}\right)\right]\right)^{2}=\frac{1}{2} \sum_{k=1}^{c}\left(d_{k}-f\left[\sum_{j=0}^{m} w_{j k} f\left(\sum_{i=1}^{n} v_{i j} x_{i}\right)\right]\right)^{2}<br>$$</p>
<p>用误差L对每一个权重$w$求偏导（链式法则），就是代表该权重$w$对总体误差产生了多少影响。<br>$$<br>w_{i}^{+}=w_{i}-\eta * \frac{\partial L_{\text {total }}}{\partial w_{i}}<br>$$<br>用同样的方法更新所有权重$w$，最后不停地迭代使误差降低。</p>
<h4 id="2-numpy实现反向传播"><a href="#2-numpy实现反向传播" class="headerlink" title="2 numpy实现反向传播"></a>2 numpy实现反向传播</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scaling</span>(<span class="params">data</span>):</span>	<span class="comment">#数据归一化</span></span><br><span class="line">    <span class="built_in">max</span> = np.<span class="built_in">max</span>(data,<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">min</span> = np.<span class="built_in">min</span>(data,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> (data-<span class="built_in">min</span>)/(<span class="built_in">max</span>-<span class="built_in">min</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span>(<span class="params">data</span>):</span>	<span class="comment">#激活函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span>+np.exp(-data))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wb_calc</span>(<span class="params">X,y,alpha=<span class="number">0.1</span>,maxIter=<span class="number">10000</span>,n_hidden_dim=<span class="number">3</span>,reg_lamda=<span class="number">0</span></span>):</span></span><br><span class="line">	<span class="comment">#FP</span></span><br><span class="line">	<span class="comment">#初始化</span></span><br><span class="line">    W1 = np.mat(np.random.randn(<span class="number">2</span>,n_hidden_dim))</span><br><span class="line">    b1 = np.mat(np.random.randn(<span class="number">1</span>,n_hidden_dim))</span><br><span class="line">    W2 = np.mat(np.random.randn(n_hidden_dim,<span class="number">1</span>))</span><br><span class="line">    b2 = np.mat(np.random.randn(<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> stepi <span class="keyword">in</span> <span class="built_in">range</span>(maxIter):</span><br><span class="line">        z1 = x*W1 + b1</span><br><span class="line">        a1 = sigmoid(z1)</span><br><span class="line">        z2 = a1*W2 + b2</span><br><span class="line">        a2 = sigmoid(z2)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#BP</span></span><br><span class="line">    	<span class="comment">#初始化</span></span><br><span class="line">        a0 = X.copy()</span><br><span class="line">		deltal2 = a2 - ymat</span><br><span class="line">        deltal1 = np.mat((deltal2*W2.T).A * a1.A(<span class="number">1</span>-a1).A)	<span class="comment">#.A表示转化为数组</span></span><br><span class="line">    	dW1 = a0.T+deltal1 + reg_lambda*W1</span><br><span class="line">        db1 = np.<span class="built_in">sum</span>(deltal1,<span class="number">0</span>)</span><br><span class="line">        dW2 = a1.T+deltal2 + reg_lambda*W2</span><br><span class="line">        db2 = np.<span class="built_in">sum</span>(deltal2,<span class="number">0</span>)</span><br><span class="line">        <span class="comment">#更新w,b</span></span><br><span class="line">        W1 = W1 - alpha*dW1</span><br><span class="line">        b1 = b1 - alpha*db1</span><br><span class="line">        W2 = W2 - alpha*dW2</span><br><span class="line">        b2 = b2 - alpha*db2</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> W1,b1,W2,b2</span><br></pre></td></tr></table></figure>


<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>1.<a href="https://www.bilibili.com/video/av59538266">b站李宏毅《机器学习》</a><br>2.<a href="https://datawhalechina.github.io/leeml-notes/#/">datawhale李宏毅机器学习笔记(LeeML-Notes)</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Back Propagation</tag>
      </tags>
  </entry>
  <entry>
    <title>异常检测(Anomaly Detection)简介</title>
    <url>/2021/05/12/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>异常检测顾名思义就是检测出与正常数据不同的数据，检测给定的新数据是否属于这组数据集。</p>
<h4 id="1-异常检测的任务类型"><a href="#1-异常检测的任务类型" class="headerlink" title="1. 异常检测的任务类型"></a>1. 异常检测的任务类型</h4><p><strong>无监督</strong>：训练集无标签<br><strong>有监督</strong>：训练集的正例和反例均有标签<br><strong>半监督</strong>：在训练集中只有正例，异常实例不参与训练</p>
<span id="more"></span>
<h4 id="2-异常检测的难点"><a href="#2-异常检测的难点" class="headerlink" title="2. 异常检测的难点"></a>2. 异常检测的难点</h4><p><strong>数据量少</strong>：异常检测任务通常情况下负样本（abnormal）较少，0、1两类样本严重不均衡，有时候依赖于人工标签。<br><strong>噪音</strong>：异常和噪音有时容易混淆，如两幅图中的A点识别难度就不一样。<br><img src="https://z3.ax1x.com/2021/05/25/gzuSPO.png" alt="xx"></p>
<h4 id="3-异常检测方法简介"><a href="#3-异常检测方法简介" class="headerlink" title="3. 异常检测方法简介"></a>3. 异常检测方法简介</h4><h5 id="3-1-基于统计学的方法"><a href="#3-1-基于统计学的方法" class="headerlink" title="3.1 基于统计学的方法"></a>3.1 基于统计学的方法</h5><p>通常做法是假设样本服从高斯分布，计算p(x)=ϵ作为判定正常和异常的阈值。<br><img src="https://z3.ax1x.com/2021/05/25/gzu9Re.png" alt="xx"></p>
<h5 id="3-2-线性模型"><a href="#3-2-线性模型" class="headerlink" title="3.2 线性模型"></a>3.2 线性模型</h5><p>在线性模型中，有2个假设：<br>①不同维度的变量近似线性相关，可以通过一个相关系数矩阵进行衡量。<br>②数据是镶嵌在低维子空间中的，线性建模是为了找到某个低维子空间使异常点区别于正常点。<br>常用模型的包括：<br><strong>最小二乘法</strong>——最小化目标函数得到直线方程,计算每个变量与回归方程之间的残差,可通过3σ 法则判断异常值.<br><strong>PCA</strong>——将样本的协方差矩阵特征值分解后，特征值是样本投影到轴上对应的方差，特征值越小，投影后样本点分布越集中，异常点容易偏离，以此作为判定异常值的一个指标。</p>
<h5 id="3-3-基于邻近度的方法"><a href="#3-3-基于邻近度的方法" class="headerlink" title="3.3 基于邻近度的方法"></a>3.3 基于邻近度的方法</h5><p>这类算法适用于数据点的聚集程度高、离群点较少的情况，不适用于数据量大、维度高的数据。<br>①基于集群（簇）的检测——DBSCAN，核心点距离ℇ内最小包含点数、距离ℇ与阈值比较。<br>②基于距离的度量——KNN，将K-近邻距离与阈值比较。<br>③基于密度的度量——LOF(局部离群因子)，邻域点密度与阈值比较。<br><img src="https://z3.ax1x.com/2021/05/25/gzupGD.png" alt="xx"></p>
<h5 id="3-4-集成方法"><a href="#3-4-集成方法" class="headerlink" title="3.4 集成方法"></a>3.4 集成方法</h5><p>①<strong>孤立森林（Isolation Forest）</strong>——不停地使用随机超平面分隔每个子空间，直到每个子空间只有一个数据点为止，低密度的点被单独分配到一个子空间，孤立数低于阈值时，定义为异常值。<br><img src="https://z3.ax1x.com/2021/05/25/gznxIK.png" alt="xx"><br>②树模型——通过树不断划分子空间,数据点在多个树上的平均深度越浅,越可能为异常值。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>1.<a href="https://github.com/datawhalechina/team-learning-data-mining/tree/master/AnomalyDetection">datawhale-异常检测开源学习资料</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>LOF</tag>
        <tag>OLSE</tag>
        <tag>Isolation Forest</tag>
        <tag>PCV</tag>
        <tag>KNN</tag>
        <tag>DBSCAN</tag>
      </tags>
  </entry>
  <entry>
    <title>李宏毅机器学习——机器学习介绍</title>
    <url>/2021/07/12/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="李宏毅机器学习——机器学习介绍"><a href="#李宏毅机器学习——机器学习介绍" class="headerlink" title="李宏毅机器学习——机器学习介绍"></a>李宏毅机器学习——机器学习介绍</h3><h4 id="1-机器学习简介"><a href="#1-机器学习简介" class="headerlink" title="1. 机器学习简介"></a>1. 机器学习简介</h4><p>机器学习是人工智能的一部分, 研究如何让计算机从数据学习某种规律。机器学习的目的是通过计算机程序根据数据去优化某一个评价指标，自动的从数据发现规律, 使用这些规律做出预测。<br><a href="https://imgtu.com/i/W2huKs"><img src="https://z3.ax1x.com/2021/07/25/W2huKs.png" alt="W2huKs.png"></a><br>如图，机器学习可以简化为三个步骤，一、找一个function，二、让machine评价这个function，三、让machine自动地挑出最好的function。</p>
<h4 id="2-机器学习分类"><a href="#2-机器学习分类" class="headerlink" title="2. 机器学习分类"></a>2. 机器学习分类</h4><p><a href="https://imgtu.com/i/W2hlV0"><img src="https://z3.ax1x.com/2021/07/25/W2hlV0.png" alt="W2hlV0.png"></a><br>机器学习可大致分为监督学习、无监督学习、半监督学习、迁移学习和强化学习。</p>
<h5 id="2-1-监督学习"><a href="#2-1-监督学习" class="headerlink" title="2.1 监督学习"></a>2.1 监督学习</h5><p>监督学习是机器学习任务的一种。它从有标签的训练数据中推导出预测函数。有标签的训练数据是指每个训练实例都包括输入和期望的输出。简单来说就是给定数据，预测标签。<br>监督学习包括<code>分类</code>和<code>回归</code>。</p>
<span id="more"></span>

<h5 id="2-2-无监督学习"><a href="#2-2-无监督学习" class="headerlink" title="2.2 无监督学习"></a>2.2 无监督学习</h5><p>无监督学习是机器学习任务的一种。它从无标签的训练数据中推断结论。它可以在探索性数据分析阶段用于发现隐藏的模式或者对数据进行分组。简单来说就是给定数据，寻找隐藏的结构。<br>无监督学习包括<code>聚类</code>和<code>降维</code>。</p>
<h5 id="2-3-半监督学习"><a href="#2-3-半监督学习" class="headerlink" title="2.3 半监督学习"></a>2.3 半监督学习</h5><p>半监督学习介于监督学习与无监督学习之间。半监督学习的任务与监督学习一致，任务中包含有明确的目标，如分类。但其所采用的数据既包括有标签的数据，也包括无标签的数据。简单来说，半监督学习是同时运用了标签数据和无标签数据来进行训练的监督学习。</p>
<h5 id="2-5-迁移学习"><a href="#2-5-迁移学习" class="headerlink" title="2.5 迁移学习"></a>2.5 迁移学习</h5><p>迁移学习是把已训练好的或者模型（预训练模型）参数或者标注数据迁移到新的模型来帮助新模型训练。其中需要关注的是源领域与目标领域之间相关性。</p>
<h5 id="2-6-强化学习"><a href="#2-6-强化学习" class="headerlink" title="2.6 强化学习"></a>2.6 强化学习</h5><p>强化学习是机器学习的另一个领域。它关注的是软件代理如何在一个环境中采取行动以便最大化某种累积的回报。简单来说就是给定数据，学习如何选择一系列行动，以最大化长期收益。<br>强化学习包括<code>马尔可夫决策过程</code>和<code>动态规划</code>。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>1.<a href="https://www.bilibili.com/video/av59538266">b站李宏毅《机器学习》</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
  </entry>
  <entry>
    <title>李宏毅机器学习——回归</title>
    <url>/2021/07/14/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<h3 id="李宏毅机器学习——回归"><a href="#李宏毅机器学习——回归" class="headerlink" title="李宏毅机器学习——回归"></a>李宏毅机器学习——回归</h3><p>回归大致可以理解为根据数据集$D$，拟合出近似的曲线，所以回归也常称为拟合（Fit）。按照自变量的数量可以分为一元回归和多元回归，按照自变量与因变量之间的函数表达式可以分为线性回归(Linear Regression)和非线性回归(Non-linear Regression)。</p>
<h4 id="1-模型步骤"><a href="#1-模型步骤" class="headerlink" title="1 模型步骤"></a>1 模型步骤</h4><ul>
<li>Step1：模型假设，选择模型框架（线性模型）</li>
<li>Step2：模型评估，如何判断众多模型的好坏（损失函数）</li>
<li>Step3：模型优化，如何筛选最优的模型（梯度下降）</li>
</ul>
<h5 id="1-1-模型假设（多元线性模型）"><a href="#1-1-模型假设（多元线性模型）" class="headerlink" title="1.1 模型假设（多元线性模型）"></a>1.1 模型假设（多元线性模型）</h5><p>多元线性模型就是特征x的线性组合的函数，可以表示为$y=\sum{w_ix_i}+b$，$x_i$为特征，$w_i$为权重，b为偏移量。</p>
<span id="more"></span>

<h5 id="1-2-模型评估（损失函数）"><a href="#1-2-模型评估（损失函数）" class="headerlink" title="1.2 模型评估（损失函数）"></a>1.2 模型评估（损失函数）</h5><p>常用的损失函数是均方误差（mean-square error, MSE），也被称为最小二乘法 (least square method)，其几何意义就是欧氏距离。</p>
<blockquote>
<p>不同的loss函数，具有不同的拟合特性：<br>Hinge Loss——SVM；<br>exp-Loss ——Boosting；<br>log-Loss——Logistic Regression。</p>
</blockquote>
<p>Square loss损失函数表示为：<br>$$<br>L\left( w,b \right) =\sum_{i=1}^m{\left( f\left( x_i \right) -y_i \right) ^2}，<br>$$<br>我们需要找到令结果最小的$w^*$和$b^*$，即<br>$$<br>\left( w^*,b^* \right) =arg\min <em>{\left( w,b \right)}\sum</em>{i=1}^m{\left( f\left( x_i \right) -y_i \right) ^2}。<br>$$</p>
<h5 id="1-3-最佳模型（解析解）"><a href="#1-3-最佳模型（解析解）" class="headerlink" title="1.3 最佳模型（解析解）"></a>1.3 最佳模型（解析解）</h5><p>多元（多个特征）的情况下，损失函数可以引入矩阵表示为：<br>$$<br>L\left( w,b \right) =\sum_{i=1}^m{\left( f\left( x_i \right) -y_i \right) ^2}=\left( XW-y \right) ^T\left( XW-y \right)<br>$$<br>式中，$X$是一组样本形成的样本矩阵，$W$是权重矩阵，$y$是样本真实值形成的矩阵。<br>上式可以展开为：<br>$$<br>L\left( w,b \right) =\left( XW-y \right) ^T\left( XW+y \right)<br>$$<br>$$<br>=\left( \left( XW \right) ^T-y^T \right) \left( XW-y \right)<br>$$<br>$$<br>=\left( X^TW^T-y^T \right) \left( XW-y \right)<br>$$<br>$$<br>=X^TW^TXW-y^TXW-W^TX^Ty+y^Ty<br>$$<br>对$w$求导：<br>$$<br>\frac{\partial L\left( W \right)}{\partial W}=2X^TXW-\left( y^TX \right) ^T-X^Ty<br>$$<br>$$<br>=2X^TXW-2X^Ty<br>$$<br>偏导等于零时可以求得损失函数最小时对应的$W$，即我们最终想要获得的系数矩阵：<br>$$<br>X^TXW-X^Ty=0<br>$$<br>$$<br>X^TXW=X^Ty<br>$$<br>$$<br>((X^TX)^{-1}X^TX)W=(X^TX)^{-1}X^Ty<br>$$<br>$$<br>IW=(X^TX)^{-1}X^Ty<br>$$<br>$$<br>W=(X^TX)^{-1}X^Ty<br>$$</p>
<p>上式必须满足矩阵的逆存在，而矩阵可逆需要方正且满秩。但是因为不能保证所选的特征是完全线性无关的，所以矩阵不一定满秩，这导致线性回归有解析解但存在无穷多解，还是无法求得一个准确的解，这时候就需要使用梯度下降法来逼近一个解。</p>
<h5 id="1-4-最佳模型（梯度下降法）"><a href="#1-4-最佳模型（梯度下降法）" class="headerlink" title="1.4 最佳模型（梯度下降法）"></a>1.4 最佳模型（梯度下降法）</h5><p>首先设置初始的$w_0$和$b_0$，然后通过求$L$对$w$和$b$的偏导不断地更新$w$和$b$，直到找到$L$的最小值。<br>整个过程可以表示为：<br>$$<br>repeat,,until,,converge{w_i:=w_i-\eta \frac{\partial L\left( w_i \right)}{w_i};\ b_i:=b_i-\eta \frac{\partial L\left( b_i \right)}{b_i}}<br>$$<br>其中$\eta $是学习率，用来控制每步下降的距离（太小收敛会很慢，太大则可能跳过最优点），一般按照对数的方法来选择，例如0.1, 0.03, 0.01, 0.003…这种方法称为批量梯度下降（batch gradient descent, BGD）</p>
<p>original-loss存在很多奇点，而BGD每次下降的方向就是original-loss的负梯度，因此BGD很容易陷入某个奇点，而无法达到global minimal（或者比较好的local minimal）。随机梯度下降（stochastic gradient descent, SGD）一定程度上可以避免这个情况——不容易陷入original-loss和minibatch-loss的奇点：</p>
<ul>
<li>引入randomness，SGD中计算的梯度是对original-loss梯度的近似，相当于在original-loss梯度的基础上加了randomness，因此即使当前走到了original-loss的奇点，SGD计算的梯度因为引入了randomness，所以也不接近0，比较容易跳出奇点。</li>
<li>SGD计算的不是original-loss的梯度，而是minibatch-loss的梯度，original-loss和minibatch-loss的形状不同，奇点分布也不同，如果当前这个点在original-loss上是奇点，但这个点在minibatch-loss中并不是奇点，此时使用minibatch-loss的负梯度作为下降方向，自然不会陷入这个点。</li>
<li>每次迭代，都会使用不同的mini batch，而不同的minibatch-loss的形状不同。就算此时陷入了当前minibatch-loss的奇点，那么下一次迭代，这个点也不一定就是下一个minibatch-loss的奇点，如果不是的话，自然就跳出来了。</li>
</ul>
<h5 id="1-5-正则化"><a href="#1-5-正则化" class="headerlink" title="1.5 正则化"></a>1.5 正则化</h5><p>当我们筛选出模型进行拟合数据时，可能会没有很好地拟合数据，称为欠拟合（underfitting），或者叫做高偏差（bias）；也可能对训练集拟合得很好，但在测试集上拟合不好，称为过拟合（overfitting），也叫高方差（variance）。</p>
<p>对于过拟合，我们可以</p>
<ul>
<li>1.减少选取变量的数量（通过特征选择保留更为重要的特征变量）</li>
</ul>
<p>特征选择的缺点在于：舍弃一部分特征变量的同时，也舍弃了问题中的一些信息。<br>如果我们不想舍弃这些信息，可以使用正则化。</p>
<ul>
<li>2.正则化</li>
</ul>
<p>当线性回归从1次变成高次的过程中，在训练集上的拟合越来越好，但在测试集上并不是这样。于是我们可以采用正则化，去惩罚$w_1$到$w_n$，以L2正则化为例，原始的损失函数$L$上加上$\lambda \sum{\left( w_i \right) ^2}$，使得权重的绝对值大小整体倾向于减小（权重衰减），这样可以使函数更加平滑，也就是更加简单，不容易发生过拟合。形象一点看，损失函数曲面通过L2正则化的加持，最小值所在的位置从一条山岭变成一个山谷，故L2正则化在机器学习中也叫做“岭回归”（ridge regression）。<br><a href="https://imgtu.com/i/W2hcxH"><img src="https://z3.ax1x.com/2021/07/25/W2hcxH.png" alt="W2hcxH.png"></a></p>
<p>L1正则化则是加上$\lambda \sum{\left| \left. w_i \right| \right.}$，L1 正则化除了和L2正则化一样可以约束数量级外，还能使参数更加稀疏，参数一部分为0，另一部分为非零实值。非零实值的那部分参数值可起到选择重要参数或特征维度的作用，同时可起到去除噪声的效果。</p>
<h4 id="2-sklearn实现多元线性回归"><a href="#2-sklearn实现多元线性回归" class="headerlink" title="2 sklearn实现多元线性回归"></a>2 sklearn实现多元线性回归</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> pltfrom sklearn.linear_model</span><br><span class="line"><span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;./data.csv&#x27;</span>)</span><br><span class="line">X_train,X_test,Y_train,Y_test = train_test_split(train_size = <span class="number">0.7</span>)</span><br><span class="line">model = LinearRegression()model.fit(X_train,Y_train)</span><br><span class="line"></span><br><span class="line">a = model.intercept_</span><br><span class="line">b = model.coef_</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最佳拟合线:截距&quot;</span>,a,<span class="string">&quot;,回归系数：&quot;</span>,b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;拟合函数: y = %f * x+%f * x+%f * x+ %f&#x27;</span>%(b[<span class="number">0</span>],b[<span class="number">1</span>],b[<span class="number">2</span>],a))</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = <span class="string">&#x27;SimHei&#x27;</span></span><br><span class="line">score = model.score(X_test,Y_test)</span><br><span class="line"><span class="built_in">print</span>(score)</span><br><span class="line">Y_test_pred = model.predict(X_test)</span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="built_in">len</span>(Y_test_pred))</span><br><span class="line">Y_test,label = <span class="string">&#x27;test&#x27;</span>,color = <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="built_in">len</span>(Y_test_pred)),Y_test_pred,color = <span class="string">&#x27;r&#x27;</span>,label = <span class="string">&#x27;predict&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.legend()</span><br></pre></td></tr></table></figure>


<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>1.<a href="https://www.bilibili.com/video/av59538266">b站李宏毅《机器学习》</a><br>2.<a href="https://datawhalechina.github.io/leeml-notes/#/">datawhale李宏毅机器学习笔记(LeeML-Notes)</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Regression</tag>
      </tags>
  </entry>
  <entry>
    <title>李宏毅机器学习——梯度下降</title>
    <url>/2021/07/16/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/</url>
    <content><![CDATA[<h3 id="李宏毅机器学习——梯度下降"><a href="#李宏毅机器学习——梯度下降" class="headerlink" title="李宏毅机器学习——梯度下降"></a>李宏毅机器学习——梯度下降</h3><h4 id="1-偏差与方差"><a href="#1-偏差与方差" class="headerlink" title="1 偏差与方差"></a>1 偏差与方差</h4><p>使用样本数据拟合函数，由于样本数据使采样而并非真实值本身，采样本身会带来误差。经过研究发现，其误差的期望值可以分解为三个部分：样本<strong>噪音</strong>、模型预测值的<strong>方差</strong>、预测值相对真实值的<strong>偏差</strong>，公式为：<br>$$<br>E\left((y-\hat{f}(x))^{2}\right)=\sigma^{2}+\operatorname{Var}[\hat{f}(x)]+(\operatorname{Bias}[\hat{f}(x)])^{2}<br>$$<br>其中$Bias[\hat{f}(x)] = E[\hat{f}(x) - f(x)]$，即误差的期望值 = 噪音的方差 + 模型预测值的方差 + 预测值相对真实值的偏差的平方，如下图所示。</p>
<p><a href="https://imgtu.com/i/W2h4dP"><img src="https://z3.ax1x.com/2021/07/25/W2h4dP.png" alt="W2h4dP.png"></a></p>
<span id="more"></span>
<p>靶心（红点）是测试样本的真实值，测试样本的y（橙色点）是真实值加上噪音，特定模型重复多次训练会得到多个具体的模型，每一个具体模型对测试样本进行一次预测，就在靶上打出一个预测值（图上蓝色的点）。所有预测值的平均就是预测值的期望（较大的浅蓝色点），浅蓝色的圆圈表示预测值的离散程度，即预测值的方差。</p>
<h4 id="2-调整梯度下降的学习率"><a href="#2-调整梯度下降的学习率" class="headerlink" title="2 调整梯度下降的学习率"></a>2 调整梯度下降的学习率</h4><p>如果每次调的太大，loss变化就很快：调的太小，loss变化的太慢，这样都找不到最小的loss。<br><a href="https://imgtu.com/i/W2h5If"><img src="https://z3.ax1x.com/2021/07/25/W2h5If.png" alt="W2h5If.png"></a><br>此时我们可以采用自适应学习率，即刚开始时，初始点距离最低点较远，采用较大的学习率，在每次更新参数后，更接近最低点了，调小学习率。于是就有了不同的优化梯度下降的方法，这类优化梯度下降的方法有SGD、AdaGrad、Adam等等。</p>
<h5 id="2-1-SGD"><a href="#2-1-SGD" class="headerlink" title="2.1 SGD"></a>2.1 SGD</h5><p>批量梯度下降（Batch Gradient Descent，BGD）是在全部训练集上计算准确的梯度，即<br>$$<br>\sum_{i=1}^{n} \nabla_{\theta} f\left(\theta ; x_{i}, y_{i}\right)+\nabla_{\theta} \phi(\theta)<br>$$<br>而随机梯度下降（Stochastic Gradient Descent，SGD）则是采样单个样本来估计当前的梯度，即<br>$$<br>\nabla_{\theta} f\left(\theta ; x_{i}, y_{i}\right)+\nabla_{\theta} \phi(\theta)<br>$$<br>SGD最大的缺点是下降速度慢和不稳定，而且可能会在沟壑的两边持续震荡，停留在一个局部最优点。</p>
<h5 id="2-2-SGD-with-Momentum"><a href="#2-2-SGD-with-Momentum" class="headerlink" title="2.2 SGD with Momentum"></a>2.2 SGD with Momentum</h5><p>为了抑制SGD的震荡，SGDM认为梯度下降过程可以加入惯性。下坡的时候，如果发现是陡坡，那就利用惯性跑的快一些。SGDM在SGD基础上引入了一阶动量：<br>$$<br>m_{t}=\beta_{1} \cdot m_{t-1}+\left(1-\beta_{1}\right) \cdot g_{t}<br>$$<br>一阶动量是各个时刻梯度方向的指数移动平均值，约等于最近$1 /\left(1-\beta_{1}\right)$个时刻的梯度向量和的平均值。也就是说，t时刻的下降方向，不仅由当前点的梯度方向决定，而且由此前累积的下降方向决定。这就意味着下降方向主要是此前累积的下降方向，并略微偏向当前时刻的下降方向。</p>
<h5 id="2-3-SGD-with-Nesterov-Acceleration"><a href="#2-3-SGD-with-Nesterov-Acceleration" class="headerlink" title="2.3 SGD with Nesterov Acceleration"></a>2.3 SGD with Nesterov Acceleration</h5><p>SGD 还有一个问题是困在局部最优的沟壑里面震荡。因此，我们不能停留在当前位置去观察未来的方向，而要向前一步、多看一步、看远一些。<br>NAG全称Nesterov Accelerated Gradient，是在SGD、SGD-M的基础上的进一步改进。NAG不计算当前位置的梯度方向，而是计算如果按照累积动量走了一步，那个时候的下降方向：<br>$$<br>g_{t}=\nabla f\left(w_{t}-\alpha \cdot m_{t-1} / \sqrt{V_{t-1}}\right)<br>$$</p>
<h5 id="2-5-Adgrad"><a href="#2-5-Adgrad" class="headerlink" title="2.5 Adgrad"></a>2.5 Adgrad</h5><p>Adagrad是解决不同参数应该使用不同的更新速率的问题。Adagrad自适应地为各个参数分配不同学习率的算法。<br>其公式如下：<br><a href="https://imgtu.com/i/W2hTJS"><img src="https://z3.ax1x.com/2021/07/25/W2hTJS.png" alt="W2hTJS.png"></a><br>Adagrad设置全局学习率之后，每次通过全局学习率逐参数的除以历史梯度平方和的平方根，使得每个参数的学习率不同。这里的梯度平方和就是二阶动量。</p>
<p>Adagrad起到的效果是在参数空间更为平缓的方向会取得更大的进步（因为平缓，所以历史梯度平方和较小，对应学习下降的幅度较小），并且能够使得陡峭的方向变得平缓，从而加快训练速度。</p>
<p>Adagrad的缺点是由于是累积平方梯度，平方梯度是单调递增函数，会使得学习率单调递减至0，从而使训练过程提前结束。</p>
<h5 id="2-6-AdaDelta-RMSProp"><a href="#2-6-AdaDelta-RMSProp" class="headerlink" title="2.6 AdaDelta / RMSProp"></a>2.6 AdaDelta / RMSProp</h5><p>由于AdaGrad单调递减的学习率变化过于激进，可以改进二阶动量计算方法：不累积全部历史梯度，而只关注过去一段时间窗口的下降梯度。（这也是AdaDelta名称中Delta的来历。）</p>
<p>指数移动平均值大约就是过去一段时间的平均值，因此可以用这一方法来计算二阶累积动量：<br>$$<br>V_{t}=\beta_{2} * V_{t-1}+\left(1-\beta_{2}\right) g_{t}^{2}<br>$$<br>这可以避免二阶动量持续累积、导致训练过程提前结束的问题。</p>
<h5 id="2-7-Adam"><a href="#2-7-Adam" class="headerlink" title="2.7 Adam"></a>2.7 Adam</h5><p>SGD-M在SGD基础上增加了一阶动量，AdaGrad和AdaDelta在SGD基础上增加了二阶动量。把一阶动量和二阶动量都用起来，就是Adam了——Adaptive + Momentum。<br>SGD的一阶动量：<br>$$<br>m_{t}=\beta_{1} \cdot m_{t-1}+\left(1-\beta_{1}\right) \cdot g_{t}<br>$$<br>加上AdaDelta的二阶动量：<br>$$<br>V_{t}=\beta_{2} * V_{t-1}+\left(1-\beta_{2}\right) g_{t}^{2}<br>$$<br>其中$\beta_{1}$控制一阶动量，$\beta_{2}$控制二阶动量。</p>
<h5 id="2-8-Nadam"><a href="#2-8-Nadam" class="headerlink" title="2.8 Nadam"></a>2.8 Nadam</h5><p>在Adam的基础上增加了Nesterov，即同时用上一二阶动量，且按照累积动量走了一步。<br>$$<br>g_{t}=\nabla f\left(w_{t}-\alpha \cdot m_{t-1} / \sqrt{V_{t}}\right)<br>$$</p>
<h4 id="3-特征缩放（Feature-Scaling）"><a href="#3-特征缩放（Feature-Scaling）" class="headerlink" title="3 特征缩放（Feature Scaling）"></a>3 特征缩放（Feature Scaling）</h4><p>特征缩放（Feature Scaling）包括标准化（Standardization/Z-Score Normalization）和归一化（Normalization）。特征缩放可以同一量纲和数量级，可以提高某些基于距离的算法（Distance-Based Algorithms），如KNN、K-Means、SVM、PCA等距离计算算法的性能，但对基于树的算法（Tree-Based Algorithms）、线性判别分析、朴素贝叶斯等算法无帮助。</p>
<p>特征缩放对于基于梯度下降的算法（Gradient Descent Based Algorithms）有加速作用——未经标准化的特征的损失函数是椭圆形，梯度下降方向垂直于等高线，形成zigzag的路线，并非指向local mininum。对特征进行归一化Normalization后，其损失函数的等高线图更接近圆形，梯度下降的方向震荡更小，收敛更快。<br><a href="https://imgtu.com/i/W2hHzQ"><img src="https://z3.ax1x.com/2021/07/25/W2hHzQ.png" alt="W2hHzQ.png"></a></p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>1.<a href="https://www.bilibili.com/video/av59538266">b站李宏毅《机器学习》</a><br>2.<a href="https://datawhalechina.github.io/leeml-notes/#/">datawhale李宏毅机器学习笔记(LeeML-Notes)</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Gradient Descent</tag>
      </tags>
  </entry>
  <entry>
    <title>李宏毅机器学习——神经网络设计技巧</title>
    <url>/2021/07/20/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h3 id="李宏毅机器学习——神经网络设计技巧"><a href="#李宏毅机器学习——神经网络设计技巧" class="headerlink" title="李宏毅机器学习——神经网络设计技巧"></a>李宏毅机器学习——神经网络设计技巧</h3><h4 id="1-鞍点-Saddle-Point"><a href="#1-鞍点-Saddle-Point" class="headerlink" title="1 鞍点(Saddle Point)"></a>1 鞍点(<em>Saddle</em> <em>Point</em>)</h4><p>神经网络中，Gradient为0(或不存在)的点称为临界点(critical point)，其有两种可能性：局部极小(local minima)和鞍点(saddle point)。</p>
<p>长期以来，人们普遍认为，神经网络优化问题困难是因为较大的神经网络中包含很多局部极小值，使得算法容易陷入到其中某些点。2014年的一篇论文中提出高维非凸优化问题之所以困难，是因为存在大量的鞍点而不是局部极值。</p>
<blockquote>
<p>鞍点：</p>
<ul>
<li>一个维度向上倾斜且另一维度向下倾斜的点。这些鞍点通常被相同误差值的平面所包围，这使得算法陷入其中很难脱离出来，因为梯度在所有维度上接近于零</li>
<li>梯度等于零，在其附近Hessian矩阵有正的和负的特征值，行列式小于0，即是不定的。</li>
</ul>
</blockquote>
<p><a href="https://imgtu.com/i/W24pJU"><img src="https://z3.ax1x.com/2021/07/25/W24pJU.png" alt="W24pJU.png"></a></p>
<span id="more"></span>

<p>在鞍点附近，基于梯度的优化算法会遇到较为严重的问题：鞍点处的梯度为零，鞍点通常被相同误差值的平面所包围（这个平面称为Plateaus，Plateaus是梯度接近于零的平缓区域，会降低神经网络学习速度），在高维的情形，这个鞍点附近的平坦区域范围可能非常大，这使得SGD算法很难脱离区域，即可能会长时间卡在该点附近（因为梯度在所有维度上接近于零）。</p>
<p>在鞍点数目极大的时候，这个问题会变得非常严重。高维非凸优化问题之所以困难，是因为高维参数空间存在大量的鞍点。</p>
<p>鞍点和局部极小值相同的是，在该点处的梯度都等于零，不同在于在鞍点附近Hessian矩阵是不定的(行列式小于0)，而在局部极值附近的Hessian矩阵是正定的。</p>
<blockquote>
<p>Hessian矩阵是一个多元函数的二阶偏导数构成的方阵，描述了函数的局部曲率。可用于判定多元函数的极值。</p>
</blockquote>
<blockquote>
<p>$$<br>H(f)=\left[\begin{array}{cccc}<br>\frac{\partial^{2} f}{\partial x_{1}^{2}} &amp; \frac{\partial^{2} f}{\partial x_{1} \partial x_{2}} &amp; \cdots &amp; \frac{\partial^{2} f}{\partial x_{1} \partial x_{n}} \<br>\frac{\partial^{2} f}{\partial x_{2} \partial x_{1}} &amp; \frac{\partial^{2} f}{\partial x_{2}^{2}} &amp; \cdots &amp; \frac{\partial^{2} f}{\partial x_{2} \partial x_{n}} \<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>\frac{\partial^{2} f}{\partial x_{n} \partial x_{1}} &amp; \frac{\partial^{2} f}{\partial x_{n} \partial x_{2}} &amp; \cdots &amp; \frac{\partial^{2} f}{\partial x_{n}^{2}}<br>\end{array}\right]<br>$$</p>
</blockquote>
<ul>
<li>当函数的Hessian矩阵在梯度为零的位置上的特征值全为正(正定矩阵)时，该函数得到局部最小值。</li>
<li>当函数的Hessian矩阵在梯度为零的位置上的特征值全为负(负定矩阵)时，该函数得到局部最⼤值。</li>
<li>当函数的Hessian矩阵在梯度为零的位置上的特征值有正有负(不定矩阵)时，该函数得到鞍点。</li>
</ul>
<h4 id="2-批次和动量-Batch-and-Momentum"><a href="#2-批次和动量-Batch-and-Momentum" class="headerlink" title="2 批次和动量(Batch and Momentum)"></a>2 批次和动量(Batch and Momentum)</h4><h5 id="2-1-Batch"><a href="#2-1-Batch" class="headerlink" title="2.1 Batch"></a>2.1 Batch</h5><p>批梯度下降（Batch gradient descent，BGD）遍历全部数据集算一次损失函数，然后算函数对各个参数的梯度，然后更新梯度。BGD的优点在于由全数据集确定的方向能够更好地代表样本总体，如果函数为凸函数，BGD一定能得到全局最优。其缺点在于每更新一次参数都要把数据集里的所有样本都看一遍，计算量开销大，计算速度慢。</p>
<p>随机梯度下降（stochastic gradient descent，SGD）每看一个数据就算一下损失函数，然后求梯度更新参数，这个称为随机梯度下降。SGD方法速度比较快，但是由于单个样本并不能代表全体样本的趋势，所以其收敛性能不太好，遇上噪声则容易陷入局部最优解，也可能在最优点附近晃来晃去，收敛不到最优点。两次参数的更新也有可能互相抵消掉，造成目标函数震荡的比较剧烈。</p>
<p>小批量梯度下降（mini-batch gradient descent，mini-batch GD）每次选取一定数目(mini-batch)的样本组成一个小批量样本，然后用这个小批量来更新梯度。每次使用一个batch可以大大减小收敛所需要的迭代次数，同时可以使收敛到的结果更加接近梯度下降的效果，可以提高算法稳定性。</p>
<h5 id="2-2-Momentum"><a href="#2-2-Momentum" class="headerlink" title="2.2 Momentum"></a>2.2 Momentum</h5><p>动量梯度下降法（Gradient descent with Momentum）或者叫做Momentum，通过计算梯度的指数加权平均数，并利用该梯度更新权重。<br><a href="https://imgtu.com/i/W2TLVA"><img src="https://z3.ax1x.com/2021/07/25/W2TLVA.png" alt="W2TLVA.png"></a></p>
<p>其每一次梯度下降都会有一个之前的速度的作用，如果这次的方向与之前相同，则会因为之前的速度继续加速；如果这次的方向与之前相反，则会由于之前存在速度的作用不会产生一个急转弯。简而言之，Momentum对原始梯度做了修正和平滑，具有更快的收敛速度。</p>
<h4 id="3-自动调整学习速率-Adaptive-Learning-rate"><a href="#3-自动调整学习速率-Adaptive-Learning-rate" class="headerlink" title="3 自动调整学习速率(Adaptive Learning rate)"></a>3 自动调整学习速率(Adaptive Learning rate)</h4><h5 id="2-1-AdaGrad"><a href="#2-1-AdaGrad" class="headerlink" title="2.1 AdaGrad"></a>2.1 AdaGrad</h5><p>设置全局学习率之后，每次通过全局学习率逐参数的除以历史梯度平方和的平方根，使得每个参数的学习率不同，可以使参数空间更为平缓的方向，会取得更大的进步（因为平缓，所以历史梯度平方和较小，对应学习下降的幅度较小），并且能够使得陡峭的方向变得平缓，从而加快训练速度。<br><a href="https://imgtu.com/i/W27CrQ"><img src="https://z3.ax1x.com/2021/07/25/W27CrQ.png" alt="W27CrQ.png"></a></p>
<h5 id="2-2-RMSprop"><a href="#2-2-RMSprop" class="headerlink" title="2.2 RMSprop"></a>2.2 RMSprop</h5><p>Adagrad会记录过去所有梯度的平方和。因此，学习越深入，更新的幅度就越小。实际上，如果无止境地学习，更新量就会变为0，完全不再更新。为了改善这个问题，可以使用 RMSProp方法。RMSProp方法并不是将过去所有的梯度一视同仁地相加，而是逐渐地遗忘过去的梯度，在做加法运算时将新梯度的信息更多地反映出来。这种方法也被称为“指数移动平均”，呈指数函数式地减小过去的梯度的尺度。</p>
<p>RMSProp算法不是像AdaGrad算法那样暴力直接的累加平方梯度，而是加了一个衰减系数来控制历史信息的获取多少。相比于AdaGrad的历史梯度$r \leftarrow r+g \odot g$，RMSProp增加了一个衰减系数来控制历史信息的获取多少：$r \leftarrow \rho r+(1-\rho) \boldsymbol{g} \odot \boldsymbol{g}$。</p>
<p><a href="https://imgtu.com/i/W27FVs"><img src="https://z3.ax1x.com/2021/07/25/W27FVs.png" alt="W27FVs.png"></a></p>
<p>第一个等式类似Momentum，计算了梯度平方的指数平均；第二个等式根据指数平均决定步幅大小，初始化学习率η，接着除以平均数；第三个等式是权重更新步骤。其中超参数ρ一般取0.9，ε一般取1e-10。</p>
<p>RMSProp隐式地应用了模拟退火。在向最小值移动的过程中，RMSProp会自动降低学习步幅，以免跳过最小值。</p>
<h5 id="2-3-Adam"><a href="#2-3-Adam" class="headerlink" title="2.3 Adam"></a>2.3 Adam</h5><p>Adam（Adaptive Moment Estimation）相当于RMSprop+Momentum，</p>
<p><a href="https://imgtu.com/i/W27Kr4"><img src="https://z3.ax1x.com/2021/07/25/W27Kr4.png" alt="W27Kr4.png"></a></p>
<p>等式1和等式2计算了梯度的指数平均和梯度平方的指数平均；等式3在学习率上乘以梯度的平均（类似动量），除以梯度平方平均的均方根（类似RMSProp），得出学习步幅；等式4是权重更新步骤。其中超参数β1一般取0.9，β2一般取0.99，ε一般取1e-10。</p>
<h5 id="2-4-Learning-Rate-Scheduling"><a href="#2-4-Learning-Rate-Scheduling" class="headerlink" title="2.4 Learning Rate Scheduling"></a>2.4 Learning Rate Scheduling</h5><ul>
<li>学习率衰减（Learning Rate Decay）——为了防止学习率过大，在收敛到全局最优点的时候会来回摆荡，所以要让学习率随着训练轮数不断下降，收敛梯度下降的学习步长。其中包括线性衰减（例如：每过5个epochs学习率减半）、指数衰减（随着迭代轮数的增加学习率自动发生衰减）、分段常数衰减等方法。</li>
<li>热启动（Warm up）——warmup是初始阶段使用较小学习率启动，后期恢复正常；而decay是初始时使用较大的学习率，之后进行衰减。其有助于减缓模型在初始阶段对mini-batch的提前过拟合现象，保持分布的平稳。</li>
</ul>
<h4 id="4-损失函数-Loss-的影响"><a href="#4-损失函数-Loss-的影响" class="headerlink" title="4 损失函数(Loss)的影响"></a>4 损失函数(Loss)的影响</h4><p>均方误差（Mean Square Error，MSE）适用于回归问题，而交叉熵（Cross Entropy）适用于分类问题。<br>在分类问题中，MSE损失函数为$\text { loss }=\frac{1}{2 m} \sum_{i}^{m}\left(y_{i}-y^{\prime}\right)^{2}$，加上softmax之后为$\operatorname{los} s_{i}=\left(c_{1}-\frac{e^{y i^{\prime}}}{c_{2}}\right)^{2}$，是一个非凸函数，梯度下降算法难以达到全局最优解。所以MSE在分类问题中，并不是一个好的loss函数；而交叉熵损失函数为$\operatorname{loss}=-\sum_{i=1}^{n} y_{i} * \log \left(y_{i}\right)$，加入softmax得到$\operatorname{loss}<em>{i}=-\log \left(c</em>{1}-\frac{e^{x}}{c_{2}}\right)$。</p>
<p><a href="https://imgtu.com/i/W27DII"><img src="https://z3.ax1x.com/2021/07/25/W27DII.jpg" alt="W27DII.jpg"></a></p>
<p>相对MSE而言，交叉熵曲线整体呈单调性，loss越大，梯度越大。便于梯度下降反向传播，利于优化。所以一般针对分类问题采用交叉熵作为loss函数。（P.S.在广义伯努利分布下，最小化交叉熵损失等同于极大似然估计）</p>
<h4 id="5-批量标准化-归一化-Batch-Normalization，BN"><a href="#5-批量标准化-归一化-Batch-Normalization，BN" class="headerlink" title="5 批量标准化/归一化(Batch Normalization，BN)"></a>5 批量标准化/归一化(Batch Normalization，BN)</h4><p>Batch Normalization，简称BatchNorm或BN，翻译为“批归一化”，是神经网络中一种特殊的层，如今已是各种流行网络的标配。在原始论文中，BN被建议插入在（每个）ReLU激活层前面。</p>
<p><a href="https://imgtu.com/i/W27cz8"><img src="https://z3.ax1x.com/2021/07/25/W27cz8.png" alt="W27cz8.png"></a></p>
<p>BN操作分为两步：</p>
<ol>
<li>Standardization：首先对$m$个$x$进行Standardization，得到zero mean unit variance的分布$\hat{x}$。</li>
<li>scale and shift：然后再对$\hat{x}$进行scale and shift，缩放并变换回原始的分布$y$。（这样的目的是为了补偿网络的非线性表达能力，因为经过标准化之后，偏移量丢失。均值$\beta$方差$\gamma$相当于输入数据分布的方差和偏移。）</li>
</ol>
<p>Batch Normalization有以下几点优势：</p>
<ul>
<li>BN使得网络中每层输入数据的分布相对稳定，加速模型学习速度</li>
<li>BN使得模型对网络中的参数不那么敏感，简化调参过程，使得网络学习更加稳定</li>
<li>BN允许网络使用饱和性激活函数（例如sigmoid，tanh等），缓解梯度消失问题</li>
<li>BN具有一定的正则化效果</li>
</ul>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>1.<a href="https://www.bilibili.com/video/av59538266">b站李宏毅《机器学习》</a><br>2.<a href="https://datawhalechina.github.io/leeml-notes/#/">datawhale李宏毅机器学习笔记(LeeML-Notes)</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Neural Networks</tag>
      </tags>
  </entry>
  <entry>
    <title>模型融合_1</title>
    <url>/2021/03/15/%E6%A8%A1%E5%9E%8B%E8%9E%8D%E5%90%88_1/</url>
    <content><![CDATA[<p>Kaggle和天池比赛中常用提高成绩的三种方法：</p>
<blockquote>
<p>1.特征工程<br>2.模型调参<br>3.模型融合<br>模型融合主要有以下几种方式：</p>
</blockquote>
<h4 id="简单加权融合"><a href="#简单加权融合" class="headerlink" title="简单加权融合:"></a>简单加权融合:</h4><blockquote>
<p>①回归（分类概率）：算术平均融合（Arithmetic mean），几何平均融合（Geometric mean）；<br>②分类：投票（Voting)<br>③综合：排序融合(Rank averaging)，log融合</p>
</blockquote>
<h4 id="stacking-blending"><a href="#stacking-blending" class="headerlink" title="stacking/blending:"></a>stacking/blending:</h4><blockquote>
<p>构建多层模型，把初级学习器的输出当作下一层的输入。</p>
</blockquote>
<span id="more"></span>
<h4 id="boosting-bagging（在xgboost-Adaboost-GBDT中已经用到）"><a href="#boosting-bagging（在xgboost-Adaboost-GBDT中已经用到）" class="headerlink" title="boosting/bagging（在xgboost,Adaboost,GBDT中已经用到）:"></a>boosting/bagging（在xgboost,Adaboost,GBDT中已经用到）:</h4><blockquote>
<p>多个分类器的整合</p>
</blockquote>
<h4 id="部分代码案例"><a href="#部分代码案例" class="headerlink" title="部分代码案例:"></a>部分代码案例:</h4><h5 id="1-简单加权平均"><a href="#1-简单加权平均" class="headerlink" title="1.简单加权平均"></a>1.简单加权平均</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Weighted_method</span>(<span class="params">test_pre1,test_pre2,test_pre3,w=[<span class="number">1</span>/<span class="number">3</span>,<span class="number">1</span>/<span class="number">3</span>,<span class="number">1</span>/<span class="number">3</span>]</span>):</span></span><br><span class="line">    Weighted_result = w[<span class="number">0</span>]*pd.Series(test_pre1)+w[<span class="number">1</span>]*pd.Series(test_pre2)+w[<span class="number">2</span>]*pd.Series(test_pre3)</span><br><span class="line">    <span class="keyword">return</span> Weighted_result</span><br><span class="line">    </span><br><span class="line">Weighted_pre = Weighted_method(test_pre1,test_pre2,test_pre3,w)</span><br></pre></td></tr></table></figure>
<h5 id="2-Stacking融合-回归"><a href="#2-Stacking融合-回归" class="headerlink" title="2.Stacking融合(回归)"></a>2.Stacking融合(回归)</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Stacking_method</span>(<span class="params">train_reg1,train_reg2,train_reg3,y_train_true,test_pre1,test_pre2,test_pre3,model_L2= linear_model.LinearRegression(<span class="params"></span>)</span>):</span>    model_L2.fit(pd.concat([pd.Series(train_reg1),pd.Series(train_reg2),pd.Series(train_reg3)],axis=<span class="number">1</span>).values,y_train_true)</span><br><span class="line">    Stacking_result = model_L2.predict(pd.concat([pd.Series(test_pre1),pd.Series(test_pre2),pd.Series(test_pre3)],axis=<span class="number">1</span>).values)</span><br><span class="line">    <span class="keyword">return</span> Stacking_result</span><br><span class="line"></span><br><span class="line">Stacking_pre = Stacking_method(train_reg1,train_reg2,train_reg3,y_train_true,</span><br><span class="line">                               test_pre1,test_pre2,test_pre3,model_L2)</span><br></pre></td></tr></table></figure>
<h5 id="3-Voting投票机制"><a href="#3-Voting投票机制" class="headerlink" title="3.Voting投票机制"></a>3.Voting投票机制</h5><blockquote>
<p>硬投票：对多个模型直接进行投票，不区分模型结果的相对重要度，最终投票数最多的类为最终被预测的类。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">eclf = VotingClassifier(estimators=[(<span class="string">&#x27;lgb&#x27;</span>, clf1), (<span class="string">&#x27;rf&#x27;</span>, clf2), (<span class="string">&#x27;svc&#x27;</span>, clf3)], voting=<span class="string">&#x27;hard&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> clf, label <span class="keyword">in</span> <span class="built_in">zip</span>([clf1, clf2, clf3, eclf], [<span class="string">&#x27;LGB&#x27;</span>, <span class="string">&#x27;Random Forest&#x27;</span>, <span class="string">&#x27;SVM&#x27;</span>, <span class="string">&#x27;Ensemble&#x27;</span>]):</span><br><span class="line">    scores = cross_val_score(clf, x, y, cv=<span class="number">5</span>, scoring=<span class="string">&#x27;accuracy&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Accuracy: %0.2f (+/- %0.2f) [%s]&quot;</span> % (scores.mean(), scores.std(), label))</span><br></pre></td></tr></table></figure>
<h5 id="4-分类模型的Stacking融合"><a href="#4-分类模型的Stacking融合" class="headerlink" title="4.分类模型的Stacking融合"></a>4.分类模型的Stacking融合</h5><blockquote>
<p>Stacking与Blending相比存在一定优势:<br>1.充分使用数据<br>2.使用多次的交叉验证会比较稳健<br>3.不容易过拟合</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clfs = [LogisticRegression(solver=<span class="string">&#x27;lbfgs&#x27;</span>),</span><br><span class="line">        RandomForestClassifier(n_estimators=<span class="number">5</span>, n_jobs=-<span class="number">1</span>, criterion=<span class="string">&#x27;gini&#x27;</span>),</span><br><span class="line">        RandomForestClassifier(n_estimators=<span class="number">5</span>, n_jobs=-<span class="number">1</span>, criterion=<span class="string">&#x27;entropy&#x27;</span>),</span><br><span class="line">        ExtraTreesClassifier(n_estimators=<span class="number">5</span>, n_jobs=-<span class="number">1</span>, criterion=<span class="string">&#x27;gini&#x27;</span>),</span><br><span class="line">        GradientBoostingClassifier(learning_rate=<span class="number">0.05</span>, subsample=<span class="number">0.5</span>, max_depth=<span class="number">6</span>, n_estimators=<span class="number">5</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j, clf <span class="keyword">in</span> <span class="built_in">enumerate</span>(clfs):</span><br><span class="line">    <span class="comment">#依次训练各个单模型</span></span><br><span class="line">    clf.fit(X_d1, y_d1)</span><br><span class="line">    y_submission = clf.predict_proba(X_d2)[:, <span class="number">1</span>]</span><br><span class="line">    dataset_d1[:, j] = y_submission</span><br><span class="line">    <span class="comment">#对于测试集，直接用这k个模型的预测值作为新的特征。</span></span><br><span class="line">    dataset_d2[:, j] = clf.predict_proba(X_predict)[:, <span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;val auc Score: %f&quot;</span> % roc_auc_score(y_predict, dataset_d2[:, j]))</span><br><span class="line"></span><br><span class="line"><span class="comment">#融合使用的模型</span></span><br><span class="line">clf = GradientBoostingClassifier(learning_rate=<span class="number">0.02</span>, subsample=<span class="number">0.5</span>, max_depth=<span class="number">6</span>, n_estimators=<span class="number">30</span>)</span><br><span class="line">clf.fit(dataset_d1, y_d2)</span><br></pre></td></tr></table></figure>
<h5 id="5-其他Stacking"><a href="#5-其他Stacking" class="headerlink" title="5.其他Stacking"></a>5.其他Stacking</h5><blockquote>
<p>将特征放进模型中预测，并将预测结果变换并作为新的特征加入原有特征中再经过模型预测结果</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Ensemble_add_feature</span>(<span class="params">train,test,target,clfs</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j,clf <span class="keyword">in</span> <span class="built_in">enumerate</span>(clfs):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;依次训练各个单模型&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># print(j, clf)</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;使用第1个部分作为预测，第2部分来训练模型，获得其预测的输出作为第2部分的新特征。&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># X_train, y_train, X_test, y_test = X[train], y[train], X[test], y[test]</span></span><br><span class="line"></span><br><span class="line">        clf.fit(train,target)</span><br><span class="line">        y_train = clf.predict(train)</span><br><span class="line">        y_test = clf.predict(test)</span><br><span class="line"></span><br><span class="line">        <span class="comment">## 新特征生成</span></span><br><span class="line">        train_[:,j*<span class="number">2</span>] = y_train**<span class="number">2</span></span><br><span class="line">        test_[:,j*<span class="number">2</span>] = y_test**<span class="number">2</span></span><br><span class="line">        train_[:, j+<span class="number">1</span>] = np.exp(y_train)</span><br><span class="line">        test_[:, j+<span class="number">1</span>] = np.exp(y_test)</span><br><span class="line">        <span class="comment"># print(&quot;val auc Score: %f&quot; % r2_score(y_predict, dataset_d2[:, j]))</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Method &#x27;</span>,j)</span><br><span class="line"></span><br><span class="line">    train_ = pd.DataFrame(train_)</span><br><span class="line">    test_ = pd.DataFrame(test_)</span><br><span class="line">    <span class="keyword">return</span> train_,test_</span><br><span class="line"></span><br><span class="line"><span class="comment">#模型融合中使用到的各个单模型</span></span><br><span class="line">clfs = [LogisticRegression(),</span><br><span class="line">        RandomForestClassifier(n_estimators=<span class="number">5</span>, n_jobs=-<span class="number">1</span>, criterion=<span class="string">&#x27;gini&#x27;</span>),</span><br><span class="line">        ExtraTreesClassifier(n_estimators=<span class="number">5</span>, n_jobs=-<span class="number">1</span>, criterion=<span class="string">&#x27;gini&#x27;</span>),</span><br><span class="line">        ExtraTreesClassifier(n_estimators=<span class="number">5</span>, n_jobs=-<span class="number">1</span>, criterion=<span class="string">&#x27;entropy&#x27;</span>),</span><br><span class="line">        GradientBoostingClassifier(learning_rate=<span class="number">0.05</span>, subsample=<span class="number">0.5</span>, max_depth=<span class="number">6</span>, n_estimators=<span class="number">5</span>)]</span><br><span class="line"></span><br><span class="line">New_train,New_test = Ensemble_add_feature(x_train,x_test,y_train,clfs)</span><br><span class="line">clf = GradientBoostingClassifier(learning_rate=<span class="number">0.02</span>, subsample=<span class="number">0.5</span>, max_depth=<span class="number">6</span>, n_estimators=<span class="number">30</span>)</span><br><span class="line">clf.fit(New_train, y_train)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>voting</tag>
        <tag>Stacking</tag>
        <tag>Blending</tag>
      </tags>
  </entry>
  <entry>
    <title>特征工程_1</title>
    <url>/2021/04/21/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B_1/</url>
    <content><![CDATA[<p>特征工程就是将原始数据空间变换到新的特征空间，在新的特征空间中，模型能够更好地学习数据中的规律。特征的选择和构造，就是人为地帮助模型学习到原本很难学好的东西，从而使模型达到更好的效果。</p>
<h4 id="1-根据现实情况构造特征"><a href="#1-根据现实情况构造特征" class="headerlink" title="1. 根据现实情况构造特征"></a>1. 根据现实情况构造特征</h4><h5 id="1-1-各点与特定点的距离"><a href="#1-1-各点与特定点的距离" class="headerlink" title="1.1 各点与特定点的距离"></a>1.1 各点与特定点的距离</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;x_dis&#x27;</span>] = (df[<span class="string">&#x27;x&#x27;</span>] - <span class="number">6165599</span>).<span class="built_in">abs</span>()</span><br><span class="line">df[<span class="string">&#x27;y_dis&#x27;</span>] = (df[<span class="string">&#x27;y&#x27;</span>] - <span class="number">5202660</span>).<span class="built_in">abs</span>()</span><br><span class="line">df[<span class="string">&#x27;base_dis] = (df[&#x27;</span>y_dis<span class="string">&#x27;]**2))**0.5 + ((df[&#x27;</span>x_dis<span class="string">&#x27;]**2)</span></span><br><span class="line"><span class="string">del df[&#x27;</span>x_dis<span class="string">&#x27;],df[&#x27;</span>y_dis<span class="string">&#x27;] </span></span><br><span class="line"><span class="string">df[&#x27;</span>base_dis_dif<span class="string">f&#x27;].head()</span></span><br></pre></td></tr></table></figure>
<h5 id="1-2-将时间划分为白天与黑夜"><a href="#1-2-将时间划分为白天与黑夜" class="headerlink" title="1.2 将时间划分为白天与黑夜"></a>1.2 将时间划分为白天与黑夜</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;day_night&#x27;</span>] = <span class="number">0</span></span><br><span class="line">df.loc[(df[<span class="string">&#x27;hour&#x27;</span>] &gt; <span class="number">5</span>) &amp; (df[<span class="string">&#x27;hour&#x27;</span>] &lt; <span class="number">20</span>),<span class="string">&#x27;day_night&#x27;</span>] = <span class="number">1</span></span><br><span class="line">df[<span class="string">&#x27;day_night&#x27;</span>].head()</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h5 id="1-3-将月份划分为季度"><a href="#1-3-将月份划分为季度" class="headerlink" title="1.3 将月份划分为季度"></a>1.3 将月份划分为季度</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;quarter&#x27;</span>] = <span class="number">0</span></span><br><span class="line">df.loc[(df[<span class="string">&#x27;month&#x27;</span>].isin([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])), <span class="string">&#x27;quarter&#x27;</span>] = <span class="number">1</span></span><br><span class="line">df.loc[(df[<span class="string">&#x27;month&#x27;</span>].isin([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, ])), <span class="string">&#x27;quarter&#x27;</span>] = <span class="number">2</span></span><br><span class="line">df.loc[(df[<span class="string">&#x27;month&#x27;</span>].isin([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])), <span class="string">&#x27;quarter&#x27;</span>] = <span class="number">3</span></span><br><span class="line">df.loc[(df[<span class="string">&#x27;month&#x27;</span>].isin([<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>])), <span class="string">&#x27;quarter&#x27;</span>] = <span class="number">4</span></span><br></pre></td></tr></table></figure>
<h5 id="1-4-特征变化量之间的相似性"><a href="#1-4-特征变化量之间的相似性" class="headerlink" title="1.4 特征变化量之间的相似性"></a>1.4 特征变化量之间的相似性</h5><p>①统计每个ship的对应速度等级的个数.<br>②对方位进行16均分.<br>③统计速度为0的个数，以及速度不为0的统计量.<br>④加入x，v，d，y的中位数和各种位数,并删去count\mean\min\max\std等多余统计特征.<br>⑤以shift为主键,求相邻差异值(偏移量).</p>
<h4 id="2-构造分箱特征"><a href="#2-构造分箱特征" class="headerlink" title="2. 构造分箱特征"></a>2. 构造分箱特征</h4><h5 id="2-1-经纬度和速度的分箱特征"><a href="#2-1-经纬度和速度的分箱特征" class="headerlink" title="2.1 经纬度和速度的分箱特征"></a>2.1 经纬度和速度的分箱特征</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;v_bin&#x27;</span>] = pd.qcut(df[<span class="string">&#x27;v&#x27;</span>], <span class="number">200</span>, duplicates=<span class="string">&#x27;drop&#x27;</span>) <span class="comment"># 速度进行 200分位数分箱</span></span><br><span class="line">df[<span class="string">&#x27;v_bin&#x27;</span>] = df[<span class="string">&#x27;v_bin&#x27;</span>].<span class="built_in">map</span>(<span class="built_in">dict</span>(<span class="built_in">zip</span>(df[<span class="string">&#x27;v_bin&#x27;</span>].unique().<span class="built_in">range</span>(df[<span class="string">&#x27;v_bin&#x27;</span>].nunique())))) <span class="comment"># 分箱后映射编码</span></span><br></pre></td></tr></table></figure>

<h5 id="2-2-经纬度分箱后并构造区域"><a href="#2-2-经纬度分箱后并构造区域" class="headerlink" title="2.2 经纬度分箱后并构造区域"></a>2.2 经纬度分箱后并构造区域</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">traj.sort_values(by=<span class="string">&#x27;x&#x27;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">x_res = np.zeros((<span class="built_in">len</span>(traj), ))</span><br><span class="line">j = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, col_bins + <span class="number">1</span>):</span><br><span class="line">    low, high = x_bins[i-<span class="number">1</span>], x_bins[i]</span><br><span class="line">    <span class="keyword">while</span>( j &lt; <span class="built_in">len</span>(traj)):</span><br><span class="line">        <span class="keyword">if</span> (traj[<span class="string">&quot;x&quot;</span>].iloc[j] &lt;= high) &amp; (traj[<span class="string">&quot;x&quot;</span>].iloc[j] &gt; low - <span class="number">0.001</span>):</span><br><span class="line">            x_res[j] = i</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h4 id="3-构造DataFramte特征"><a href="#3-构造DataFramte特征" class="headerlink" title="3. 构造DataFramte特征"></a>3. 构造DataFramte特征</h4><h5 id="3-1-count计数值"><a href="#3-1-count计数值" class="headerlink" title="3.1 count计数值"></a>3.1 count计数值</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_save_unique_visit_count_table</span>(<span class="params">traj_data_df=<span class="literal">None</span>, bin_to_coord_df=<span class="literal">None</span></span>):</span></span><br><span class="line">    unique_boat_count_df = traj_data_df.groupby([<span class="string">&quot;no_bin&quot;</span>])[<span class="string">&quot;id&quot;</span>].nunique().reset_index()</span><br><span class="line">    unique_boat_count_df.rename(&#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;visit_boat_count&quot;</span>&#125;, axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    unique_boat_count_df_save = pd.merge(bin_to_coord_df, unique_boat_count_df,</span><br><span class="line">                                         on=<span class="string">&quot;no_bin&quot;</span>, how=<span class="string">&quot;left&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> unique_boat_count_d</span><br></pre></td></tr></table></figure>
<h5 id="3-2-shift偏移量"><a href="#3-2-shift偏移量" class="headerlink" title="3.2 shift偏移量"></a>3.2 shift偏移量</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>]:</span><br><span class="line">    <span class="comment">#对x,y坐标进行时间平移 1 -1 2</span></span><br><span class="line">    df[f + <span class="string">&#x27;_prev_diff&#x27;</span>] = df[f] - g[f].shift(<span class="number">1</span>)</span><br><span class="line">    df[f + <span class="string">&#x27;_next_diff&#x27;</span>] = df[f] - g[f].shift(-<span class="number">1</span>)</span><br><span class="line">    df[f + <span class="string">&#x27;_prev_next_diff&#x27;</span>] = g[f].shift(<span class="number">1</span>) - g[f].shift(-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h5 id="3-3-统计特征"><a href="#3-3-统计特征" class="headerlink" title="3.3 统计特征"></a>3.3 统计特征</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">group_feature</span>(<span class="params">df, key, target, aggs,flag</span>):</span>   </span><br><span class="line">    <span class="comment">#通过字典的形式来构建方法和重命名</span></span><br><span class="line">    agg_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> ag <span class="keyword">in</span> aggs:</span><br><span class="line">        agg_dict[<span class="string">&#x27;&#123;&#125;_&#123;&#125;_&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(target,ag,flag)] = ag</span><br><span class="line">        </span><br><span class="line">    t = df.groupby(key)[target].agg(agg_dict).reset_index()</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line"></span><br><span class="line">t = group_feature(df, <span class="string">&#x27;ship&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,[<span class="string">&#x27;max&#x27;</span>,<span class="string">&#x27;min&#x27;</span>,<span class="string">&#x27;mean&#x27;</span>,<span class="string">&#x27;median&#x27;</span>,<span class="string">&#x27;std&#x27;</span>,<span class="string">&#x27;skew&#x27;</span>],flag)</span><br><span class="line">train = pd.merge(train, t, on=<span class="string">&#x27;ship&#x27;</span>, how=<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line">t = group_feature(df, <span class="string">&#x27;ship&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,[<span class="string">&#x27;max&#x27;</span>,<span class="string">&#x27;min&#x27;</span>,<span class="string">&#x27;mean&#x27;</span>,<span class="string">&#x27;median&#x27;</span>,<span class="string">&#x27;std&#x27;</span>,<span class="string">&#x27;skew&#x27;</span>],flag)</span><br><span class="line">train = pd.merge(train, t, on=<span class="string">&#x27;ship&#x27;</span>, how=<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line">t = group_feature(df, <span class="string">&#x27;ship&#x27;</span>,<span class="string">&#x27;base_dis_diff&#x27;</span>,[<span class="string">&#x27;max&#x27;</span>,<span class="string">&#x27;min&#x27;</span>,<span class="string">&#x27;mean&#x27;</span>,<span class="string">&#x27;std&#x27;</span>,<span class="string">&#x27;skew&#x27;</span>],flag)</span><br><span class="line">train = pd.merge(train, t, on=<span class="string">&#x27;ship&#x27;</span>, how=<span class="string">&#x27;left&#x27;</span>)</span><br></pre></td></tr></table></figure>


<h4 id="4-构造Embedding特征"><a href="#4-构造Embedding特征" class="headerlink" title="4.构造Embedding特征"></a>4.构造Embedding特征</h4><p>word embedding就是将词映射到另外一个空间,相同类型的词在投影之后的向量空间距离更近,倾向于归到一起.</p>
<h5 id="4-1-Word2vec构造词向量"><a href="#4-1-Word2vec构造词向量" class="headerlink" title="4.1 Word2vec构造词向量"></a>4.1 Word2vec构造词向量</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tqdm(<span class="built_in">range</span>(num_runs)):</span><br><span class="line">    model = Word2Vec(sentences, size=embedding_size,</span><br><span class="line">                              min_count=min_count,</span><br><span class="line">                              workers=mp.cpu_count(),</span><br><span class="line">                              window=window_size,</span><br><span class="line">                              seed=seed, <span class="built_in">iter</span>=iters, sg=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    embedding_vec = []</span><br><span class="line">    <span class="keyword">for</span> ind, seq <span class="keyword">in</span> <span class="built_in">enumerate</span>(sentences):</span><br><span class="line">        seq_vec, word_count = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> seq:</span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> model:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                seq_vec += model[word]</span><br><span class="line">                word_count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> word_count == <span class="number">0</span>:</span><br><span class="line">            embedding_vec.append(embedding_size * [<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            embedding_vec.append(seq_vec / word_count)</span><br></pre></td></tr></table></figure>

<h5 id="4-2-NMF提取文本的主题分布"><a href="#4-2-NMF提取文本的主题分布" class="headerlink" title="4.2 NMF提取文本的主题分布"></a>4.2 NMF提取文本的主题分布</h5><p>TF-IDF是衡量字词的出现频率来定义其重要性的加权技术.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用tfidf对元素进行处理</span></span><br><span class="line">tfidf_vectorizer = TfidfVectorizer(ngram_range=(tf_n,tf_n))</span><br><span class="line">tfidf = tfidf_vectorizer.fit_transform(self.data[<span class="string">&#x27;title_feature&#x27;</span>].values)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用nmf算法，提取文本的主题分布</span></span><br><span class="line">text_nmf = NMF(n_components=self.nmf_n).fit_transform(tfidf)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Pandas</tag>
        <tag>Embedding</tag>
        <tag>Word2vec</tag>
        <tag>NMF</tag>
        <tag>DataFramte</tag>
      </tags>
  </entry>
  <entry>
    <title>特征选择_1</title>
    <url>/2021/03/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9_1/</url>
    <content><![CDATA[<p>在数据预处理过程中，特征选择是一个重要的过程，选择出重要的特征可以加快模型训练速度。通常可以从以下两方面来选择特征：</p>
<blockquote>
<p>1.特征是否发散（对于样本区分作用的大小）<br>2.特征与标签的相关性</p>
</blockquote>
<span id="more"></span>
<p>特征选择的方法主要有3种：</p>
<blockquote>
<p>1.Filter Method：先根据统计量设置阈值选择特征，之后再训练模型。<br>2.Wrapper Method：把最终将要使用的模型的性能作为特征子集的评价标准，多次训练模型选择有利于模型性能的特征子集。<br>3.Embedding Method：将特征选择过程与模型训练过程融为一体，在模型训练的过程中自动进行特征选择。</p>
</blockquote>
<p>常用sklearn中的feature_selection库来进行特征选择。</p>
<h4 id="1-Fliter-过滤法"><a href="#1-Fliter-过滤法" class="headerlink" title="1. Fliter 过滤法:"></a>1. Fliter 过滤法:</h4><blockquote>
<p>Fliter的优点在于只训练一次模型，速度快。但是选择与标签相关性最强的特征子集不一定是最佳特征，甚至可能对结果负优化。</p>
</blockquote>
<h5 id="1-1-方差选择法"><a href="#1-1-方差选择法" class="headerlink" title="1.1 方差选择法"></a>1.1 方差选择法</h5><p>计算各个特征的方差，设置阈值，选择方差大于阈值的特征。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> VarianceThreshold</span><br><span class="line"><span class="comment">#参数threshold为方差的阈值</span></span><br><span class="line">VarianceThreshold(threshold=<span class="number">3</span>).fit_transform(iris.data)</span><br></pre></td></tr></table></figure>

<h5 id="1-2-Pearson相关系数法"><a href="#1-2-Pearson相关系数法" class="headerlink" title="1.2 Pearson相关系数法"></a>1.2 Pearson相关系数法</h5><p>计算各个特征对于标签的Pearson相关系数和p值，选择前k名的特征。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> pearsonr</span><br><span class="line"><span class="comment">#参数k为选择的特征个数</span></span><br><span class="line">SelectKBest(<span class="keyword">lambda</span> X, Y: array(<span class="built_in">map</span>(<span class="keyword">lambda</span> x:pearsonr(x, Y), X.T)).T, k=<span class="number">2</span>).fit_transform(iris.data, iris.target)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Pearson法的缺陷在于只对线性相关敏感，对非线性关系不敏感。</p>
</blockquote>
<h5 id="1-3-卡方检验-互信息法等方法"><a href="#1-3-卡方检验-互信息法等方法" class="headerlink" title="1.3 卡方检验\互信息法等方法"></a>1.3 卡方检验\互信息法等方法</h5><p>也是用来评价X与y的相关性，先构建评价函数，再选择前K名的特征。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#chi2</span></span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> chi2</span><br><span class="line">SelectKBest(chi2, k=<span class="number">2</span>).fit_transform(iris.data, iris.target)</span><br><span class="line"></span><br><span class="line"><span class="comment">#MIC</span></span><br><span class="line"><span class="keyword">from</span> minepy <span class="keyword">import</span> MINE</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mic</span>(<span class="params">x, y</span>):</span></span><br><span class="line">     m = MINE()</span><br><span class="line">     m.compute_score(x, y)</span><br><span class="line">     <span class="keyword">return</span> (m.mic(), <span class="number">0.5</span>)</span><br><span class="line">SelectKBest(<span class="keyword">lambda</span> X, Y: array(<span class="built_in">map</span>(<span class="keyword">lambda</span> x:mic(x, Y), X.T)).T, k=<span class="number">2</span>).fit_transform(iris.data, iris.target)</span><br></pre></td></tr></table></figure>

<h4 id="2-Wrapper-包装法"><a href="#2-Wrapper-包装法" class="headerlink" title="2. Wrapper 包装法:"></a>2. Wrapper 包装法:</h4><blockquote>
<p>Wrapper的优点在于能够识别模型最适宜的特征子集，缺点在于训练多次模型，算法复杂性高，且特征子集不一定是<u>大多数解释变量</u>。</p>
</blockquote>
<p>Wrapper最具代表性的方法就是RFE递归消除特征法，即使用一个基模型来进行多轮训练，每轮训练都遍历所有特征，之后消除重要性(feature_importances_)低的特征，再基于新的特征集进行下一轮训练。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#RFE</span></span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> RFE</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line">rfe = RFE(estimator=LogisticRegression(), n_features_to_select=<span class="number">2</span>).fit_transform(iris.data, iris.target)</span><br><span class="line"></span><br><span class="line"><span class="comment">#RFECV</span></span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> RFECV</span><br><span class="line">rfecv = RFECV(estimator=svc, step=<span class="number">1</span>, cv=StratifiedKFold(<span class="number">2</span>), scoring=<span class="string">&#x27;roc_auc&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="3-Embedded-嵌入法"><a href="#3-Embedded-嵌入法" class="headerlink" title="3. Embedded 嵌入法"></a>3. Embedded 嵌入法</h4><h5 id="3-1-基于惩罚项的特征选择法"><a href="#3-1-基于惩罚项的特征选择法" class="headerlink" title="3.1 基于惩罚项的特征选择法"></a>3.1 基于惩罚项的特征选择法</h5><p>使用带惩罚项的基模型，除了筛选出特征外，同时也进行了降维。由于L1正则化会产生稀疏权值矩阵，所以其自带特征选择的特性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#L1正则</span></span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectFromModel</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line">SelectFromModel(LogisticRegression(penalty=<span class="string">&quot;l1&quot;</span>, C=<span class="number">0.1</span>)).fit_transform(iris.data, iris.target)</span><br><span class="line"></span><br><span class="line"><span class="comment">#L2正则</span></span><br><span class="line">SelectFromModel(LogisticRegression(penalty=<span class="string">&quot;l2&quot;</span>,threshold=<span class="number">0.5</span>, C=<span class="number">0.1</span>)).fit_transform(iris.data, iris.target)</span><br></pre></td></tr></table></figure>

<h5 id="3-2-基于树模型的特征选择法"><a href="#3-2-基于树模型的特征选择法" class="headerlink" title="3.2 基于树模型的特征选择法"></a>3.2 基于树模型的特征选择法</h5><p>树模型中GBDT也可用来作为基模型进行特征选择。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectFromModel</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> GradientBoostingClassifier</span><br><span class="line">SelectFromModel(GradientBoostingClassifier()).fit_transform(iris.data, iris.target)</span><br></pre></td></tr></table></figure>

<h4 id="4-基于SHAP值的特征筛选"><a href="#4-基于SHAP值的特征筛选" class="headerlink" title="4. 基于SHAP值的特征筛选"></a>4. 基于SHAP值的特征筛选</h4><p>SHAP是由Shapley value启发的可加性解释模型。对于每条样本，每个特征都会对应一个SHAP value值体现其对结果的贡献。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> shap</span><br><span class="line"><span class="comment"># 创建模型解释器</span></span><br><span class="line">explainer_xgb = shap.TreeExplainer(model1)</span><br><span class="line">explainer_lgb = shap.TreeExplainer(model2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取训练集每个样本每个特征特征的SHAP值，并对特征进行整体的可视化</span></span><br><span class="line">shape_values = explainer_lgb.shap_values(data[cols])</span><br><span class="line">shap.summary_plot(shape_values, data[cols], plot_type=<span class="string">&#x27;bar&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="5-基于对抗验证-Adversarial-Validation-的特征筛选"><a href="#5-基于对抗验证-Adversarial-Validation-的特征筛选" class="headerlink" title="5. 基于对抗验证(Adversarial Validation)的特征筛选"></a>5. 基于对抗验证(Adversarial Validation)的特征筛选</h4><p>常用于训练集与测试集相差非常大的情况。实现步骤：<br>1.将训练集和测试集合并，分别打上0和1的标签。<br>2.构建模型进行训练，逐个将特征输入模型，记录AUC。<br>3.最后将AUC高的特征删除(将测试和训练样本差别很大的特征删除)，通过删掉这些特征实现模型效果提升。</p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Embedding</tag>
        <tag>Wapper</tag>
        <tag>Filter</tag>
      </tags>
  </entry>
  <entry>
    <title>复盘｜天堂硅谷·数字经济算法编程大赛</title>
    <url>/2021/07/21/%E5%A4%8D%E7%9B%98%EF%BD%9C%E5%A4%A9%E5%A0%82%E7%A1%85%E8%B0%B7%C2%B7%E6%95%B0%E5%AD%97%E7%BB%8F%E6%B5%8E%E7%AE%97%E6%B3%95%E7%BC%96%E7%A8%8B%E5%A4%A7%E8%B5%9B/</url>
    <content><![CDATA[<h1 id="复盘｜天堂硅谷·数字经济算法编程大赛"><a href="#复盘｜天堂硅谷·数字经济算法编程大赛" class="headerlink" title="复盘｜天堂硅谷·数字经济算法编程大赛"></a>复盘｜天堂硅谷·数字经济算法编程大赛</h1><h3 id="题目-01-化学反应"><a href="#题目-01-化学反应" class="headerlink" title="题目-01 化学反应"></a>题目-01 <a href="https://leetcode.cn/contest/hhrc2022/problems/o0Ma2v/">化学反应</a></h3><p>【模拟】按题意模拟（可以用大根堆或者平衡树），每次找两个最大的出来，直到没有剩余或只剩一个。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#平衡树</span></span><br><span class="line"><span class="keyword">from</span> sortedcontainers <span class="keyword">import</span> SortedList</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastMaterial</span>(<span class="params">self, material: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        s = SortedList(material)</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(s) &gt; <span class="number">1</span>:</span><br><span class="line">            a, b = s.pop(), s.pop()</span><br><span class="line">            <span class="keyword">if</span> a != b: s.add(a - b)</span><br><span class="line">        <span class="keyword">return</span> s[<span class="number">0</span>] <span class="keyword">if</span> s <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#大根堆</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastMaterial</span>(<span class="params">self, material: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        h = [-m <span class="keyword">for</span> m <span class="keyword">in</span> material]</span><br><span class="line">        heapify(h)</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(h) &gt; <span class="number">1</span>:</span><br><span class="line">            a, b = heappop(h), heappop(h)</span><br><span class="line">            <span class="keyword">if</span> a != b: heappush(h, a - b)</span><br><span class="line">        <span class="keyword">return</span> -h[<span class="number">0</span>] <span class="keyword">if</span> h <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="题目-02-销售出色区间"><a href="#题目-02-销售出色区间" class="headerlink" title="题目-02 销售出色区间"></a>题目-02 <a href="https://leetcode.cn/contest/hhrc2022/problems/0Wx4Pc/">销售出色区间</a></h3><p>【前缀和 + 单调栈】把销售产品&gt;8的天数当成增1，&lt;=8的天数当成减1，判断的同时把前缀和算出来，寻找最长presum[i] - presum[j] &gt;0的区间。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestESR</span>(<span class="params">self, sales: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(sales)</span><br><span class="line">        presum = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            presum[i] = presum[i - <span class="number">1</span>] + <span class="number">1</span> <span class="keyword">if</span> sales[i - <span class="number">1</span>] &gt; <span class="number">8</span> <span class="keyword">else</span> presum[i - <span class="number">1</span>] - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        st = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> presum[i] &lt; presum[st[-<span class="number">1</span>]]:</span><br><span class="line">                st.append(i)</span><br><span class="line">                </span><br><span class="line">        j = n</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> j &gt; ans:</span><br><span class="line">            <span class="keyword">while</span> st <span class="keyword">and</span> presum[j] &gt; presum[st[-<span class="number">1</span>]]:</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, j - st[-<span class="number">1</span>])</span><br><span class="line">                st.pop()</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="题目-03-重复的彩灯树"><a href="#题目-03-重复的彩灯树" class="headerlink" title="题目-03 重复的彩灯树"></a>题目-03 <a href="https://leetcode.cn/contest/hhrc2022/problems/VAc7h3/">重复的彩灯树</a></h3><p>【二叉树的序列化】在先序的位置递归序列化每棵树，每次用哈希表计数并找到重复次数为2的子树。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lightDistribution</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">Optional</span>[TreeNode]]:</span></span><br><span class="line">        d, res = defaultdict(<span class="built_in">int</span>), []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span></span><br><span class="line">            left, right = dfs(node.left), dfs(node.right)</span><br><span class="line">            subTree = left + <span class="string">&#x27;,&#x27;</span> + right + <span class="string">&#x27;,&#x27;</span> + <span class="built_in">str</span>(node.val)</span><br><span class="line">            <span class="keyword">if</span> d[subTree] == <span class="number">1</span>: res.append(node)</span><br><span class="line">            d[subTree] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> subTree</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="题目-04-补给覆盖"><a href="#题目-04-补给覆盖" class="headerlink" title="题目-04 补给覆盖"></a>题目-04 <a href="https://leetcode.cn/contest/hhrc2022/problems/wFtovi/">补给覆盖</a></h3><p>【后序遍历递归】对于每个root，一共有三种状态，状态0：没覆盖其他节点也没被覆盖；状态1：被覆盖了；状态2：覆盖其他节点。（空节点不需要覆盖别人也不需要被覆盖，默认状态1即可。）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSupplyStationNumber</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            left, right = dfs(node.left), dfs(node.right)</span><br><span class="line">            <span class="keyword">nonlocal</span> ans</span><br><span class="line">            <span class="keyword">if</span> left == <span class="number">0</span> <span class="keyword">or</span> right == <span class="number">0</span>:</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> left == <span class="number">2</span> <span class="keyword">or</span> right == <span class="number">2</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left == <span class="number">1</span> <span class="keyword">and</span> right == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> dfs(root) == <span class="number">0</span>: ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>复盘｜「天池 X LeetCode」在线编程专场选拔赛</title>
    <url>/2021/07/22/%E5%A4%8D%E7%9B%98%EF%BD%9C%E3%80%8C%E5%A4%A9%E6%B1%A0%20X%20LeetCode%E3%80%8D%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E4%B8%93%E5%9C%BA%E9%80%89%E6%8B%94%E8%B5%9B/</url>
    <content><![CDATA[<h1 id="复盘｜「天池-X-LeetCode」在线编程专场选拔赛"><a href="#复盘｜「天池-X-LeetCode」在线编程专场选拔赛" class="headerlink" title="复盘｜「天池 X LeetCode」在线编程专场选拔赛"></a>复盘｜「天池 X LeetCode」在线编程专场选拔赛</h1><h3 id="统计链表奇数节点"><a href="#统计链表奇数节点" class="headerlink" title="统计链表奇数节点"></a><a href="https://leetcode.cn/contest/tianchi2022/problems/yGdjWb/">统计链表奇数节点</a></h3><p>【一次遍历】遍历即可，小技巧是ans直接加0/1结果，省去if判断这一步。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numberEvenListNode</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            ans += head.val &amp; <span class="number">1</span></span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="光线反射"><a href="#光线反射" class="headerlink" title="光线反射"></a><a href="https://leetcode.cn/contest/tianchi2022/problems/8KXuKl/">光线反射</a></h3><p>【模拟】用DIRS数组存↑↓←→（对应0123四种状态）。由题意，碰到向左倾斜的镜面，←↑是一对，↓→是一对，可以通过异或操作来转换两种状态（状态 xor 2 即可，总共0123四种方向，0 xor 2=2，2 xor 2 = 0，1 xor 2 = 3，3 xor 2 = 1）；碰到向右倾斜的镜面，↓←是一对，↑→是一对，同理，状态 xor 3。初始x,y = (0,0)，d = 1即DIR = (1,0)，然后开始模拟。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLength</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="built_in">str</span>], DIRS = (<span class="params">(<span class="params">-<span class="number">1</span>, <span class="number">0</span></span>), (<span class="params"><span class="number">1</span>, <span class="number">0</span></span>), (<span class="params"><span class="number">0</span>, -<span class="number">1</span></span>), (<span class="params"><span class="number">0</span>, <span class="number">1</span></span>)</span>)</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n, m = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        ans = x = y = <span class="number">0</span></span><br><span class="line">        d = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">0</span> &lt;= x &lt; n <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; m:</span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> grid[x][y] == <span class="string">&#x27;L&#x27;</span>: d ^= <span class="number">2</span></span><br><span class="line">            <span class="keyword">elif</span> grid[x][y] == <span class="string">&#x27;R&#x27;</span>: d ^= <span class="number">3</span></span><br><span class="line">            x += DIRS[d][<span class="number">0</span>]</span><br><span class="line">            y += DIRS[d][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="整理书架"><a href="#整理书架" class="headerlink" title="整理书架"></a><a href="https://leetcode.cn/contest/tianchi2022/problems/ev2bru/">整理书架</a></h3><p>【单调栈】要求次数尽可能少，所以要把所有出现次数大于limit的元素，删除知道出现次数=limit。要求字典序最小，所以从左往右遍历如果找到更小数字就把前面更大的数去掉。用单调栈模拟，遍历的同时，要保证栈里的元素出现次数不超过limit，如果后面没有足够的元素，也不能让元素出现次数低于limit，如果遇到比栈顶小的元素，可以出栈。代码中，入栈时候要看后面有没有足够元素。如果没足够元素（cnt[x] = limit）就continue，如果栈顶比x大且栈顶 元素也够则可以出栈。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">arrangeBookshelf</span>(<span class="params">self, order: <span class="type">List</span>[<span class="built_in">int</span>], limit: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        left, st, cnt_st = Counter(order), [<span class="number">0</span>], Counter()</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> order:</span><br><span class="line">            <span class="keyword">if</span> cnt_st[x] == limit:</span><br><span class="line">                left[x] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">while</span> st[-<span class="number">1</span>] &gt; x <span class="keyword">and</span> left[st[-<span class="number">1</span>]] &gt; limit:</span><br><span class="line">                left[st[-<span class="number">1</span>]] -= <span class="number">1</span></span><br><span class="line">                cnt_st[st[-<span class="number">1</span>]] -= <span class="number">1</span></span><br><span class="line">                st.pop()</span><br><span class="line">            st.append(x)</span><br><span class="line">            cnt_st[x] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> st[<span class="number">1</span>:]</span><br></pre></td></tr></table></figure>

<h3 id="意外惊喜"><a href="#意外惊喜" class="headerlink" title="意外惊喜"></a><a href="https://leetcode.cn/contest/tianchi2022/problems/tRZfIV/">意外惊喜</a></h3><p>【贪心 + 分治 + 01背包】由于题中说每个礼物包里的礼物价值非严格递增，所以可证不存在选了两个数组但都没有选完的情况，之多只有一个数组没有选完，其余要么整个数组都选，要么都不选。枚举这个没选完的数组，其余的转为01背包（整个数组和当作一个物品的价值，数组长度当作物品体积）。为了优化时间复杂度，需要用分治来优化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">brilliantSurprise</span>(<span class="params">self, present: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], limit: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans, dp = <span class="number">0</span>, [<span class="number">0</span>] * (<span class="number">1</span> + limit)</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">a, tot</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> dp, ans</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(a) == <span class="number">1</span>:</span><br><span class="line">                sm = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(a[<span class="number">0</span>]):</span><br><span class="line">                    <span class="keyword">if</span> i &gt;= limit: <span class="keyword">break</span></span><br><span class="line">                    sm += x</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, dp[limit - (i + <span class="number">1</span>)] + sm)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">            tmp, m = dp.copy(), <span class="built_in">len</span>(a) // <span class="number">2</span></span><br><span class="line">            left, right = a[:m], a[m:]</span><br><span class="line">            <span class="keyword">for</span> i, row <span class="keyword">in</span> <span class="built_in">enumerate</span>(left):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(limit, <span class="built_in">len</span>(row) - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j], dp[j - <span class="built_in">len</span>(row)] + tot[i])</span><br><span class="line">            f(right, tot[m:])</span><br><span class="line">            </span><br><span class="line">            dp = tmp</span><br><span class="line">            <span class="keyword">for</span> i, row <span class="keyword">in</span> <span class="built_in">enumerate</span>(right, m):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(limit, <span class="built_in">len</span>(row) - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j], dp[j - <span class="built_in">len</span>(row)] + tot[i])</span><br><span class="line">            f(left, tot[:m])</span><br><span class="line">            </span><br><span class="line">        tot = [<span class="built_in">sum</span>(a) <span class="keyword">for</span> a <span class="keyword">in</span> present]</span><br><span class="line">        f(present, tot)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM总结(一) - 内存区域与内存管理</title>
    <url>/2021/08/26/JVM%E6%80%BB%E7%BB%93(%E4%B8%80)%20-%20%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="JVM总结-一-内存区域与内存管理"><a href="#JVM总结-一-内存区域与内存管理" class="headerlink" title="JVM总结(一) - 内存区域与内存管理"></a>JVM总结(一) - 内存区域与内存管理</h1><ul>
<li><a href="#%E4%B8%80jvm%E5%90%AF%E5%8A%A8%E4%BB%A5%E5%8F%8Ajvm%E4%BD%93%E7%B3%BB%E6%A6%82%E8%BF%B0">一、JVM启动以及JVM体系概述</a><ul>
<li><a href="#1jvm%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B">1、JVM启动流程</a></li>
<li><a href="#2jvm%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">2、JVM体系结构</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%80%BB%E4%BD%93%E6%A6%82%E6%8B%AC">二、运行时数据区总体概括</a><ul>
<li><a href="#1%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8">1、程序计数器</a></li>
<li><a href="#2java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88">2、Java虚拟机栈</a></li>
<li><a href="#3%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88">3、本地方法栈</a></li>
<li><a href="#4java%E5%A0%86">4、Java堆</a></li>
<li><a href="#5%E6%96%B9%E6%B3%95%E5%8C%BA">5、方法区</a></li>
<li><a href="#6%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0">6、运行时常量池</a></li>
<li><a href="#7%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98-%E4%B8%8D%E6%98%AF%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86">7、直接内存-不是运行时数据区域的一部分</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%85%B3">三、对象相关</a><ul>
<li><a href="#1%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B">1、对象的创建过程</a></li>
<li><a href="#2%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80">2、对象的内存布局</a></li>
<li><a href="#3%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D">3、对象的访问定位</a></li>
</ul>
</li>
</ul>
<hr>
<h2 id="一、JVM启动以及JVM体系概述"><a href="#一、JVM启动以及JVM体系概述" class="headerlink" title="一、JVM启动以及JVM体系概述"></a>一、JVM启动以及JVM体系概述</h2><p>概括: </p>
<ul>
<li>Java有<strong>Java编译器和Java虚拟机</strong>，编译器将Java源代码转换为<code>.class</code>文件，虚拟机加载并运行<code>.class</code>文件。</li>
<li>Java 的开发遵循“一次编写到处乱跑”理念，它运行在 VM（虚拟机）上。</li>
</ul>
<h3 id="1、JVM启动流程"><a href="#1、JVM启动流程" class="headerlink" title="1、JVM启动流程"></a>1、JVM启动流程</h3><p>JVM工作原理和特点主要是指操作系统装入JVM，是通过<code>jdk</code>中<code>java.exe</code>来完成,通过下面4步来完成JVM环境: </p>
<ul>
<li>创建JVM装载环境和配置；</li>
<li>装载<code>JVM.dll</code>；</li>
<li>初始化<code>JVM.dll</code>并挂界到<code>JNIENV</code>(JNI调用接口)实例；</li>
<li>调用<code>JNIEnv</code>实例装载并处理class类。</li>
</ul>
<p><img src="images/j1_jvm%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png" alt="jvm启动流程.png"></p>
<h3 id="2、JVM体系结构"><a href="#2、JVM体系结构" class="headerlink" title="2、JVM体系结构"></a>2、JVM体系结构</h3><p>JVM体系主要是两个JVM的内部体系结构，分为三个子系统和两大组件，分别是：</p>
<ul>
<li><strong>类装载器（ClassLoader）子系统、执行引擎子系统和GC子系统</strong>；</li>
<li>组件是<strong>内存运行数据区域</strong>和<strong>本地接口</strong>。</li>
</ul>
<p><strong>详细的结构: (<a href="https://zhuanlan.zhihu.com/p/28347393">图片来源以及详细解释</a>)</strong></p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/28347393">https://zhuanlan.zhihu.com/p/28347393</a></p>
</blockquote>
<p><img src="images/j3_%E8%AF%A6%E7%BB%86%E7%BB%93%E6%9E%84.png" alt="在这里插入图片描述"></p>
<h2 id="二、运行时数据区总体概括"><a href="#二、运行时数据区总体概括" class="headerlink" title="二、运行时数据区总体概括"></a>二、运行时数据区总体概括</h2><p><font color = green>运行时数据区:</p>
<ul>
<li>经过编译生成的字节码文件（class文件），由 <code>class loader</code>（类加载子系统）加载后交给执行引擎执行。</li>
<li>在执行引擎执行的过程中产生的数据会存储在一块内存区域。这块内存区域就是运行时区域。</li>
</ul>
<p>运行时数据区总体框架图: </p>
<p><img src="images/j2_%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="在这里插入图片描述"></p>
<p>总体概括</p>
<ul>
<li><p>堆:  存放Java 对象， <strong>线程之间共享</strong>的；</p>
</li>
<li><p>栈: 方法运行，每一个方法对应一个栈帧，每一个线程对应一个栈；每个栈由包括 <strong>操作数、局部变量表、指向运行时常量池的引用，方法返回地址、附加位区</strong>；所以是<strong>线程不共享</strong> (这个就是栈的宽度)(而栈的深度就是栈帧的个数)；</p>
</li>
<li><p>方法区 (静态区) : 被虚拟机加载的<strong>类信息、静态 (static) 变量，常量 (final) ，即时编译器编译后的代码等数据</strong>。运行常量池是方法区的一部分，class文件除了有类的版本、字段、接口、方法等描述信息之外，还有一项信息常量池保存缩译期生成的字面量和符号引用。 <strong>线程之间共享的。</strong></p>
</li>
<li><p>程序计数器: 指出某一个时候执行某一个指令、执行完毕之后要返回的位置，当执行的Java方法的时候，这里保存的当前执行的地址，如果执行的是本地方法，那么程序计数器为空。<strong>线程不共享</strong>。</p>
</li>
</ul>
<p><strong>划分线程共享和线程独占和线程共享的原因:</strong></p>
<p>先熟悉一下一个一般性的 Java 程序的工作过程。</p>
<ul>
<li><p>一个 Java 源程序文件，会被编译为字节码文件(以 class 为扩展名) ，每个java程序都需要运行在自己的JVM上；</p>
</li>
<li><p>然后告知 JVM 程序的运行入口，再被 JVM 通过字节码解释器加载运行。那么程序开始运行后，都是如何涉及到各内存区域的呢?</p>
</li>
<li><p>概括地说来，JVM初始运行的时候都会分配好 <code>Method Area</code> (方法区) 和<code>Heap</code> (堆) ，而JVM 每遇到一个线程，就为其分配一个 <code>Program Counter Register</code> (程序计数器) ，<code>VM Stack</code> (虚拟机栈) 和<code>Native Method Stack</code> (本地方法栈) ， 当线程终止时，三者(虚拟机栈，本地方法栈和程序计数器) 所占用的内存宝间也会被释放掉。这也是为什么我们把内存区域分为线程共享和非线程共享的原因，<strong>非线程共享的那三个区域的生命周周期与所属线程相同，而线程共享的区域与JAVA程序运行的生命周期相同，</strong>所以这也是系统垃圾回收的场所只发生在<strong>线程共享的区域</strong> (实际上对大部分虚拟机来说发生在Heap上) 的原因。</p>
</li>
</ul>
<h3 id="1、程序计数器"><a href="#1、程序计数器" class="headerlink" title="1、程序计数器"></a>1、程序计数器</h3><ul>
<li> 程序计数器是一块较小的内存区域，它可以看做是<strong>当前线程所执行的字节码的行号指示器；</strong></li>
<li> 程序计数器处于<strong>线程独占区</strong>(每一个线程都有一个独立的程序计数器)，各计数器不影响；</li>
<li> 如果线程正在执行的是一个Java方法，这个计数器记录的是<strong>正在执行的虚拟机的字节码指令的地址</strong>，如果线程正在执行的是一个本地Native方法，则计数器值为空；</li>
<li> 此内存区域是唯一一个在Java虚拟机规范没有规定任何OutOfMemoryError的区域;</li>
</ul>
<h3 id="2、Java虚拟机栈"><a href="#2、Java虚拟机栈" class="headerlink" title="2、Java虚拟机栈"></a>2、Java虚拟机栈</h3><ul>
<li>Java虚拟机栈描述的是<strong>Java方法执行的动态内存模型；</strong></li>
<li>栈帧: 每个方法执行都会创建一个栈帧，伴随着方法从创建到执行完成，<strong>用于存储局部变量表，操作数栈，动态链接，方法出口等；</strong></li>
<li>局部变量表 : <code>a.</code>存放编译期可知的各种基本数据类型，引用类型，returnAddress类型；<code>b.</code>局部变量表的内存空间在编译器完成分配，当进入一个方法时，这个方法需要在栈桢中分配多少内存是固定的，在方法运行期间不会改变局部变量表的大小；</li>
<li>也会有StackOverFlowError (线程请求的栈深度大于虚拟机允许的深度)，OutOfMemoryError(没有足够的内存) ;</li>
</ul>
<p><img src="images/j4_%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8.png" alt="在这里插入图片描述"><br><img src="images/j5_%E6%A0%88%E6%A1%A2.png"></p>
<blockquote>
<p><strong>局部变量表存放了编译期可知的各种基本数据类型 (boolean、byte、char、short、int、</strong><br><strong>float、long、double)、对象引用 〈reference 类型</strong>，它不等同于对象本身，可能是一个指向对<br>象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置) 和<br>TeturnAddress 类型〈指向了一条字节码指令的地址)。</p>
<p>其中 64 位长度的 long 和 double 类型的数据会占用 2 个局部变量空间 (Slot)，其余的数<br>据类型只占用 1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，<br>这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部<br>变量表的大小。</p>
<p>在 Java 虚拟机规范中，对这个区域规定了两种异常状况: 如果线程请求的栈深度大于虚<br>拟机所允许的深度，将抛出 StackOverowError 异常 ， 如果虚拟机栈可以动态扩展〈当前大<br>部分的 Java 虚拟机都可动态扩展，只不过 Java 虚拟机规范中也允许固定长度的虚拟机栈)，<br>如果扩展时无法申请到足够的内存，就会抛出 OutOftMemoryError 异常。</p>
</blockquote>
<h3 id="3、本地方法栈"><a href="#3、本地方法栈" class="headerlink" title="3、本地方法栈"></a>3、本地方法栈</h3><p>本地方法栈 (Native Method Stack) 与虚拟机栈所发挥的作用是非常相似的: </p>
<ul>
<li>它们之间的区别不过是<strong>虚拟机栈为虚拟机执行 Java 方法〈也就是字节码) 服务，而本地方法栈则为</strong></li>
</ul>
<p><strong>虚拟机使用到的 Native 方法服务。</strong></p>
<ul>
<li>在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机。(璧如Sun HotSpot 虚拟机直接就把本地方法栈和虚拟机栈合二为一)。</li>
<li>与虚拟机栈一样，本地方法栈区域也会抛出 StackOverflowError 和 OutOfMemoryError 异常。</li>
</ul>
<h3 id="4、Java堆"><a href="#4、Java堆" class="headerlink" title="4、Java堆"></a>4、Java堆</h3><ul>
<li>Java虚拟机所管理的内存中最大的一块区域，是被所有<strong>线程共享</strong>的一块区域；</li>
<li>几乎所有的对象实例都在这里分配内存(<strong>所有的对象实例以及数组</strong>)；</li>
<li>Java堆是垃圾收集器管理的主要区域，<strong>大部分收集器基于分代收集: 分为新生代和老生代</strong>，甚至更加的细分为<code>Eden</code>空间，<code>From Survivor</code>空间，<code>To Survivor</code>空间，这样分配的目的是为了更好的回收内存和分配内存；</li>
<li>Java堆可以处理物理上不连续，但是逻辑上连续的内存空间；现在的虚拟机可以通过Xms和<br>Xmx等来扩展大小；</li>
<li>如果堆中已经没有内存来分本实例，并且堆没法扩展，就会报出OutofMemoryError异常;</li>
</ul>
<p><img src="https://img-blog.csdn.net/20181018085014307?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p>
<h3 id="5、方法区"><a href="#5、方法区" class="headerlink" title="5、方法区"></a>5、方法区</h3><ul>
<li>是线程共享区;</li>
<li>存储的是虚拟机<strong>加载的类信息，常量，静态变量，即时编译器编译后的代码等数据</strong>；</li>
<li>其中类信息包括: <strong>类的版本，字段，方法，接口</strong>等；</li>
<li>方法区 <code>!=</code> 永久代，HotSpot使用永久代实现方法区，这样HotSpot的垃圾收集器可以像管理Java推</li>
</ul>
<p>一样来管理这块内存区域，省去专门为方法区编写内存管理代码的工作；</p>
<ul>
<li>根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError 异常。</li>
</ul>
<blockquote>
<p>JDK6时，String等常量信息至于方法区，JDK7时，已经移动到堆；</p>
</blockquote>
<blockquote>
<p>Java 虚拟机规范对方法区的限制非常宽松，除了和 Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，<strong>还可以选择不实现垃圾收集</strong>。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这区域的内存回收目标主要是针对常量池的回收和对类型的印载，一般来说，这个区域的回收“成绩”比较难以令人满意，尤其是类型的印载，条件相当苛刻，但是这部分区域的回收确实是必要的。在 Sun 公司的 BUG 列表中，曾出现过的若干个严重的 BUG 就是由于低版本的 HotSpot 虚拟机对此区域未完全回收而导致内存汇漏。</p>
</blockquote>
<blockquote>
<p> 关于元空间:  元空间的本质和永久代类似，都是对JVM规范中方法区的实现，不过元空间和永久代之间最大的差别在于: <font color = blue><strong>元空间并不在虚拟机中，而是使用本地内存</strong>。因此，默认情况下，元空间的大小仅受本地内存限制。</p>
</blockquote>
<h3 id="6、运行时常量池"><a href="#6、运行时常量池" class="headerlink" title="6、运行时常量池"></a>6、运行时常量池</h3><ul>
<li>用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区</li>
</ul>
<p>的运行时常量池中存放；</p>
<ul>
<li>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不</li>
</ul>
<p>要求常量一定只有编译器才能产生，运行期间也可能将新的常量放入池中，例如<code>intern()</code>。</p>
<ul>
<li>常量池无法再申请到内存时，也会抛出OutOfMemoryError异常;</li>
</ul>
<p>对<code>intern()</code>测试:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;abc&quot;</span>;  <span class="comment">//字节码常量</span></span><br><span class="line">        String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s1 == s3);</span><br><span class="line"></span><br><span class="line">        System.out.println(s1 == s3.intern()); <span class="comment">//true   运行时常量</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码的内存分配如下:  </p>
<p><img src="https://img-blog.csdn.net/20180909175633908?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h3 id="7、直接内存-不是运行时数据区域的一部分"><a href="#7、直接内存-不是运行时数据区域的一部分" class="headerlink" title="7、直接内存-不是运行时数据区域的一部分"></a>7、直接内存-不是运行时数据区域的一部分</h3><p>直接内存 (Direct Memory) 并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError 异常出现。</p>
<p>在JDK 1.4中新加入了NIO (New InputOutput) 类，引入了一种基于通道 (Channel)与缓冲区 (Buffer) 的 IO 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</p>
<p>显然，<strong>本机直接内存的分配不会受到 Java 堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存〈包括 RAM 以及SWAP 区或者分页文件) 大小以及处理器寻址空间的限制</strong>。服务器管理员在配置虚拟机参数时，会根据实际内存设置<code>-Xmx</code>等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制包括物理的和操作系统级的限制)，从而导致动态扩展时出现 OutOfMemoryError 异常。</p>
<h2 id="三、对象相关"><a href="#三、对象相关" class="headerlink" title="三、对象相关"></a>三、对象相关</h2><h3 id="1、对象的创建过程"><a href="#1、对象的创建过程" class="headerlink" title="1、对象的创建过程"></a>1、对象的创建过程</h3><h4 id="1-、对象的内存分配"><a href="#1-、对象的内存分配" class="headerlink" title="1)、对象的内存分配"></a>1)、对象的内存分配</h4><p><img src="images/j6_%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B.png" alt="这里写图片描述"></p>
<p>虚拟机在堆中分配内存有两种方式:  </p>
<p><strong>指针碰撞</strong></p>
<p>假设 Java 堆中内存是绝对规整的，<strong>所有用过的内存都放在一边，空闲的内存放在另一边</strong>，中间放着一个指针作为分界点的<strong>指示器</strong>，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为”指针碰撞”(<code>Bump the Pointer</code>)。</p>
<p><strong>空闲列表</strong></p>
<p>如果 Java 堆中的内存并不是规整的，<strong>已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的</strong>，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为”空闲列表”(Free List)。</p>
<p>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
<blockquote>
<p>因此，在使用 Serial、ParNew 等带 Compact 过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS 这种基于 Mark-Sweep 算法的收集器时，通常采用空闲列表。</p>
</blockquote>
<h4 id="2-、线程安全问题"><a href="#2-、线程安全问题" class="headerlink" title="2)、线程安全问题"></a>2)、线程安全问题</h4><p>除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，<strong>在并发情况下也并不是线程安全的</strong>，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。</p>
<p>解决这个问题有两种方案:</p>
<ul>
<li>一种是对分配内存空间的动作**进行同步处理(加锁)**一 实际上虚拟机采用 <code>CAS</code> 配上失败重试的方式保证更新操作的原子性；</li>
<li>另一种是<strong>把内存分配的动作按照线程划分在不同的空间之中进行</strong>，即每个线程在 Java堆中预先分配一小块内存，称为<strong>本地线程分配缓冲</strong>(Thread Local Allocation Buffer，TLAB)。 哪个线程要分配内存，就在哪个线程的TEAB 上分配； 只有 TEAB 用完并分配新的 TLAB 时，才需要同步锁定。虚拟机是否使用TEAB，可以通过<code>-XX:+/-UseTLAB</code> 参数来设定。            </li>
</ul>
<h4 id="3-、初始化对象"><a href="#3-、初始化对象" class="headerlink" title="3)、初始化对象"></a>3)、初始化对象</h4><p>内存分配完成后，虚拟机需要将分配到的内在空间都初始化为零值 (不包括对象头)，如果使用<code>TLAB</code>，这一工作过程也可以提前至 TLAB 分配时进行。这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<p>接下来，<strong>虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息</strong>。这些信息存放在对象的对象头 (Object Header) 之中。根据虚拟机当前的运行状态的不同。如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<h4 id="4-、调用对象的构造方法"><a href="#4-、调用对象的构造方法" class="headerlink" title="4)、调用对象的构造方法"></a>4)、调用对象的构造方法</h4><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚刚开始:</p>
<ul>
<li>即<code>&lt;init&gt;</code>方法还没有执行，所有的字段都还为零。</li>
<li>所以一般来说( 由字节码中是否跟随<code>invokespecial</code> 指令所决定)，执行 <code>new</code>s 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</li>
</ul>
<h3 id="2、对象的内存布局"><a href="#2、对象的内存布局" class="headerlink" title="2、对象的内存布局"></a>2、对象的内存布局</h3><p>对象在内存中存储的布局可以分为3块区域: <strong>对象头、实例数据和对其填充</strong>。</p>
<h4 id="1-、对象头-Header"><a href="#1-、对象头-Header" class="headerlink" title="1)、对象头(Header)"></a>1)、对象头(Header)</h4><ul>
<li>自身的运行数据(Mark Word):<ul>
<li>包括: 哈希值、GC分代年龄，锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳；</li>
</ul>
</li>
<li>类型指针: 通过这个指针来确定这个对象是哪个类的实例；</li>
</ul>
<h4 id="2-、实例数据-InstanceData"><a href="#2-、实例数据-InstanceData" class="headerlink" title="2)、实例数据(InstanceData)"></a>2)、实例数据(InstanceData)</h4><ul>
<li>实例数据是对象真正存储的有效信息；</li>
<li>也是程序代码中所定义的各种类型的字段内容；</li>
</ul>
<h4 id="3-、对齐填充-Paddings"><a href="#3-、对齐填充-Paddings" class="headerlink" title="3)、对齐填充(Paddings)"></a>3)、对齐填充(Paddings)</h4><ul>
<li>对齐填充并不是必然存在的，也没有特别的含义；</li>
<li>仅仅起着占位符的作用；</li>
</ul>
<h3 id="3、对象的访问定位"><a href="#3、对象的访问定位" class="headerlink" title="3、对象的访问定位"></a>3、对象的访问定位</h3><p>对象访问方式取决于虚拟机实现而定的。目前主流的访问方式有使用句柄和直接指针两种。</p>
<ul>
<li>句柄访问</li>
<li>直接指针</li>
</ul>
<h4 id="1-、句柄访问"><a href="#1-、句柄访问" class="headerlink" title="1)、句柄访问"></a>1)、句柄访问</h4><ul>
<li>如果使用句柄访问的话，那么 Java 堆中将会划分出一块内存来作为句柄池，<code>reference</code>中存储的就是对象的句柄地址；</li>
<li>而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</li>
</ul>
<p>如图:</p>
<p><img src="images/j7_%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE.png" alt="这里写图片描述"></p>
<h4 id="2-、直接指针"><a href="#2-、直接指针" class="headerlink" title="2)、直接指针"></a>2)、直接指针</h4><ul>
<li>如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息。</li>
<li>而<code>reference</code>中存储的直接就是<strong>对象地址</strong>。</li>
</ul>
<p><img src="images/j8_%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.png" alt="这里写图片描述"></p>
<h4 id="3-、各自的优势"><a href="#3-、各自的优势" class="headerlink" title="3)、各自的优势"></a>3)、各自的优势</h4><p>这两种对象访问方式各有优势。</p>
<p>使用句柄来访问的最大好处就是 <code>reference</code> 中<strong>存储的是稳定的句柄地址</strong>，在对象被移动垃圾收集时移动对象是非常普遍的行为) 时<strong>只会改变句柄中的实例数据指针，而 reference 本身不需要修改</strong>。</p>
<p>使用直接指针访问方式的最大好处就是<strong>速度更快</strong>，它节省了一次指针定位的时间开销，由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM Architecture</tag>
        <tag>Heap Memory</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM总结(二) - 垃圾收集器与内存分配策略</title>
    <url>/2021/09/05/JVM%E6%80%BB%E7%BB%93(%E4%BA%8C)%20-%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h1 id="JVM总结-二-垃圾收集器与内存分配策略"><a href="#JVM总结-二-垃圾收集器与内存分配策略" class="headerlink" title="JVM总结(二) - 垃圾收集器与内存分配策略"></a>JVM总结(二) - 垃圾收集器与内存分配策略</h1><ul>
<li><a href="#%E4%B8%80%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0">一、垃圾回收概述</a></li>
<li><a href="#%E4%BA%8C%E5%A6%82%E4%BD%95%E5%88%A4%E5%AE%9A%E5%AF%B9%E8%B1%A1%E4%B8%BA%E5%9E%83%E5%9C%BE%E5%AF%B9%E8%B1%A1">二、如何判定对象为垃圾对象</a><ul>
<li><a href="#1%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95">1、引用计数法</a></li>
<li><a href="#2%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95">2、可达性分析算法</a></li>
<li><a href="#3%E5%BC%95%E7%94%A8%E5%88%86%E7%B1%BB">3、引用分类</a></li>
<li><a href="#4%E7%94%9F%E5%AD%98%E8%BF%98%E6%98%AF%E6%AD%BB%E4%BA%A1-finalize%E6%96%B9%E6%B3%95">4、生存还是死亡-finalize()方法</a></li>
<li><a href="#5%E5%9B%9E%E6%94%B6%E6%96%B9%E6%B3%95%E5%8C%BA">5、回收方法区</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95">三、垃圾回收算法</a><ul>
<li><a href="#1%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95">1、标记清除算法</a></li>
<li><a href="#2%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95">2、复制算法</a></li>
<li><a href="#3%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95">3、标记整理算法</a></li>
<li><a href="#4%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95">4、分代收集算法</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8">四、垃圾收集器</a><ul>
<li><a href="#1%E5%90%84%E4%B8%AA%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E8%81%94%E7%B3%BB">1、各个垃圾收集器的联系</a></li>
<li><a href="#2serial%E6%94%B6%E9%9B%86%E5%99%A8">2、Serial收集器</a></li>
<li><a href="#3parnew%E6%94%B6%E9%9B%86%E5%99%A8">3、ParNew收集器</a></li>
<li><a href="#4parallel-scavenge%E6%94%B6%E9%9B%86%E5%99%A8">4、Parallel Scavenge收集器</a></li>
<li><a href="#5serial-old%E6%94%B6%E9%9B%86%E5%99%A8">5、Serial Old收集器</a></li>
<li><a href="#6paralell-old%E6%94%B6%E9%9B%86%E5%99%A8">6、Paralell Old收集器</a></li>
<li><a href="#7cms%E6%94%B6%E9%9B%86%E5%99%A8">7、CMS收集器</a></li>
<li><a href="#8g1%E6%94%B6%E9%9B%86%E5%99%A8">8、G1收集器</a></li>
<li><a href="#9%E5%90%84%E7%A7%8D%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E7%9A%84%E5%AF%B9%E6%AF%94">9、各种垃圾收集算法的对比</a></li>
</ul>
</li>
<li><a href="#%E5%85%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5">五、内存分配与回收策略</a><ul>
<li><a href="#1%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%85%88%E5%9C%A8eden%E5%88%86%E9%85%8D">1、对象优先在Eden分配</a></li>
<li><a href="#2%E5%A4%A7%E5%AF%B9%E8%B1%A1%E7%9B%B4%E6%8E%A5%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3">2、大对象直接进入老年代</a></li>
<li><a href="#3%E9%95%BF%E6%9C%9F%E5%AD%98%E6%B4%BB%E5%AF%B9%E8%B1%A1%E5%B0%86%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3">3、长期存活对象将进入老年代</a></li>
<li><a href="#4%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D">4、空间分配担保</a></li>
<li><a href="#5%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1%E5%B9%B4%E9%BE%84%E5%88%A4%E5%AE%9A">5、动态对象年龄判定</a></li>
<li><a href="#6%E5%85%B3%E4%BA%8E%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D">6、关于逃逸分析以及栈上分配</a></li>
</ul>
</li>
</ul>
<hr>
<h2 id="一、垃圾回收概述"><a href="#一、垃圾回收概述" class="headerlink" title="一、垃圾回收概述"></a>一、垃圾回收概述</h2><p>关于垃圾回收，主要探讨下面四个问题。</p>
<ul>
<li><p>1、回收区域</p>
<ul>
<li><strong>程序计数器、虚拟机栈和本地方法栈</strong>这三个区域属于<strong>线程私有</strong>的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收；</li>
<li>垃圾回收主要是针对 <strong>Java堆和方法区</strong>进行；</li>
</ul>
</li>
<li><p>2、如何判定对象为垃圾对象</p>
<ul>
<li>引用计数法；</li>
<li>可达性分析；</li>
</ul>
</li>
<li><p>3、如何回收  </p>
<ul>
<li>回收策略: <strong>标记清除法，复制算法，标记整理法，分代收集算法；</strong></li>
<li>垃圾回收器(垃圾收集器): <strong>Serial、Parnew、Cms、G1</strong>；</li>
</ul>
</li>
<li><p>4、 何时回收</p>
</li>
</ul>
<blockquote>
<p> 下面的章节对上面的四个方面展开探讨。</p>
</blockquote>
<hr>
<h2 id="二、如何判定对象为垃圾对象"><a href="#二、如何判定对象为垃圾对象" class="headerlink" title="二、如何判定对象为垃圾对象"></a>二、如何判定对象为垃圾对象</h2><h3 id="1、引用计数法"><a href="#1、引用计数法" class="headerlink" title="1、引用计数法"></a>1、引用计数法</h3><ul>
<li>在对象中添加一个引用计数器；</li>
<li>当有地方引用这个对象的时候，引用计数器的值就<code>+1</code>，当引用失效的时候，计数器的值就<code>-1</code>； </li>
<li>当某个对象的引用计数器的值为<code>0</code>的时候，就回收这个对象；</li>
<li>这种方法不常用；</li>
</ul>
<p>示例:</p>
<p><img src="images/j9_%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95.png" alt="在这里插入图片描述"></p>
<p>简单的代码验证:</p>
<p>注意要查看JVM的内容，要在运行的时候添加相关的参数: </p>
<p><img src="images/j11_%E6%94%B9IDE.png" alt="在这里插入图片描述"></p>
<p>下面进行下图的过程:<br>  <img src="images/j10_%E6%B5%8B%E8%AF%95.png" alt="在这里插入图片描述"></p>
<p>代码如下: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Clazz</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Object val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Clazz A = <span class="keyword">new</span> Clazz();</span><br><span class="line">        Clazz B = <span class="keyword">new</span> Clazz();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//内部相互引用</span></span><br><span class="line">        A.val = B;</span><br><span class="line">        B.val = A;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//断开外部的引用</span></span><br><span class="line">        A = <span class="keyword">null</span>;</span><br><span class="line">        B = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里可以回收，说明不是使用的引用计数法</span></span><br><span class="line">        System.gc(); <span class="comment">//通知垃圾回收器回收</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用的parallel 垃圾收集器　(没有使用引用计数法)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>看到运行结果 (可以发现还是进行了回收，所以不是用的引用计数法): </p>
<p><img src="images/j12_%E7%BB%93%E6%9E%9C.png" alt="在这里插入图片描述"></p>
<p>在构造函数中添加内存(创建一个20MB的字节数组)： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Clazz</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Object val;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Clazz</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span> * <span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">//20MB</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Clazz A = <span class="keyword">new</span> Clazz();</span><br><span class="line">        Clazz B = <span class="keyword">new</span> Clazz();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//内部相互引用</span></span><br><span class="line">        A.val = B;</span><br><span class="line">        B.val = A;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//断开外部的引用</span></span><br><span class="line">        A = <span class="keyword">null</span>;</span><br><span class="line">        B = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里可以回收，说明不是使用的引用计数法</span></span><br><span class="line">        System.gc(); <span class="comment">//通知垃圾回收器回收</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行效果: </p>
<p><img src="images/j13.png" alt="在这里插入图片描述"></p>
<h3 id="2、可达性分析算法"><a href="#2、可达性分析算法" class="headerlink" title="2、可达性分析算法"></a>2、可达性分析算法</h3><p>第二种判定垃圾对象的方法: 可达性分析法，这个可以解决上面引用计数法不能判定堆内部垃圾对象的问题；</p>
<p>可达性分析算法</p>
<ul>
<li>通过一系列的称为<code>&quot;GC Roots&quot;</code>的对象为起点，从这些节点开始向下搜索，搜索走过的路径称为引用链；</li>
<li>当一个对象到GC Roots没有任何引用链的时候，则说明这个对象是垃圾对象；</li>
</ul>
<p>可以作为GC Roots的对象包括一下几个方面:</p>
<ul>
<li>虚拟机栈(栈帧中的本地变量表)中的引用的对象；</li>
<li>方法区中类静态属性引用的对象；</li>
<li>方法区中常亮对象的引用；</li>
<li>本地方法栈中JNI(即一般说的Native方法)引用的对象；</li>
</ul>
<p>如图: 上面的四个对象存活，下面的三个对象为垃圾对象: </p>
<p><img src="images/j14%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90.png" alt="在这里插入图片描述"></p>
<h3 id="3、引用分类"><a href="#3、引用分类" class="headerlink" title="3、引用分类"></a>3、引用分类</h3><p>主要分类:</p>
<ul>
<li>强引用: <code>StrongReference</code>: 引用指向对象，类似<code>&quot;Object obj = new Object();&quot;</code>这类引用，<code>gc(Garbage Collection)</code>运行时不回收；</li>
<li>软引用: <code>SoftReference</code>: gc运行时<strong>可能</strong>回收(jvm内存不够(内存溢出异常))；</li>
<li>弱引用: <code>WeakReference </code>: 描述非必须对象，强度比软引用更加弱一些，被弱引用关联的对象只能生存到下一次垃圾回收之前，当垃圾回收器工作时，<strong>无论当前内存是否足够</strong>，都会回收掉这些被弱引用关联的对象(gc运行时回收)；</li>
<li>虚引用: <code>PhantomReference</code> 类似于无引用，主要跟踪对象被回收的状态，不能单独使用，必须与引用队列(ReferenceQueue)联合使用；</li>
</ul>
<p><strong>目的: 避免对象长期驻留在内存中，解决垃圾回收机制回收时机问题；</strong></p>
<p><em>弱引用举例: WeakHashMap : 键为弱引用，回收建后自动删除key-value对象</em>；</p>
<p>测试:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line"><span class="keyword">import</span> java.util.WeakHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 强与弱引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Refclassify</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;---------------测试强引用-----------------&quot;</span>);</span><br><span class="line">        <span class="comment">//强引用: 字符串常量池 (不能回收)</span></span><br><span class="line">        String str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="comment">//弱引用管理 str 对象</span></span><br><span class="line">        WeakReference&lt;String&gt;wr = <span class="keyword">new</span> WeakReference&lt;String&gt;(str);</span><br><span class="line">        System.out.println(<span class="string">&quot;GC运行前: &quot;</span> + wr.get());</span><br><span class="line">        str = <span class="keyword">null</span>; <span class="comment">// 断开引用</span></span><br><span class="line">        <span class="comment">//通知回收</span></span><br><span class="line">        System.gc();</span><br><span class="line">        System.runFinalization();</span><br><span class="line">        System.out.println(<span class="string">&quot;GC运行后: &quot;</span> + wr.get());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;---------------测试弱引用-----------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//注意这里是new String</span></span><br><span class="line">        String str2 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        WeakReference&lt;String&gt;wr2 = <span class="keyword">new</span> WeakReference&lt;String&gt;(str2);</span><br><span class="line">        System.out.println(<span class="string">&quot;GC运行前: &quot;</span> + wr2.get());</span><br><span class="line">        str2 = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.runFinalization();</span><br><span class="line">        System.out.println(<span class="string">&quot;GC运行后: &quot;</span> + wr2.get()); <span class="comment">//弱引用管理--&gt; 被回收</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-------------WeakHashMap----------------&quot;</span>);<span class="comment">//键为弱类型，GC运行被回收</span></span><br><span class="line">        WeakHashMap&lt;String,String&gt;map = <span class="keyword">new</span> WeakHashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;a1&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;b&quot;</span>,<span class="string">&quot;b1&quot;</span>);</span><br><span class="line">        <span class="comment">//下面两个会被回收   如果map中占用内存很大，希望运行后被回收，就可以使用这个 </span></span><br><span class="line">        map.put(<span class="keyword">new</span> String(<span class="string">&quot;c&quot;</span>),<span class="string">&quot;c1&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> String(<span class="string">&quot;d&quot;</span>),<span class="string">&quot;d1&quot;</span>);</span><br><span class="line">        System.out.println(map.size());</span><br><span class="line">        System.gc();</span><br><span class="line">        System.runFinalization();</span><br><span class="line">        System.out.println(map.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：<br><img src="images/j15.png" alt="在这里插入图片描述"></p>
<h3 id="4、生存还是死亡-finalize-方法"><a href="#4、生存还是死亡-finalize-方法" class="headerlink" title="4、生存还是死亡-finalize()方法"></a>4、生存还是死亡-finalize()方法</h3><p><code>finalize()</code>方法</p>
<ul>
<li><strong>finalize() 类似 C++ 的析构函数，用来做关闭外部资源等工作。</strong></li>
<li>但是 <code>try-finally</code> 等方式可以比<code>finalize()</code>做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。</li>
<li>当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。</li>
<li><strong>自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会调用 finalize() 方法</strong>。</li>
</ul>
<blockquote>
<p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程，如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。<br>如果这个对象被判定为有必要执行 finalize() 方法，那么这个对象将会放置在一个叫做F-Queue 的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。 这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在 finalize() 方法中执行缓慢，或者发生了死循环(更极端的情况)，将很可能会导致 F-Queue 队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。<strong>finalize()方法是对象逃脱死亡命运的最后一次机会</strong>，稍后 GC 将对 F-Queue 中的对象进行第二次小规模的标记，如果对象要在 finalize()中成功拯救自己一一<strong>只要重新与引用链上的任何一个对象建立关联即可，比如把自己 (this 关键字) 赋值给某个类变量或者对象的成员变量</strong>，那在第二次标记时它将被移除出“即将回收”的集合; 如果对象这时候还没有逃脱，那基本上它就真的被回收了。</p>
</blockquote>
<p>总结: </p>
<ul>
<li>对象可以在被GC时 自我拯救；</li>
<li>这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次；<br>测试:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此代码演示了两点:</span></span><br><span class="line"><span class="comment"> *   (1) 对象可以在被GC时 自我拯救;</span></span><br><span class="line"><span class="comment"> *   (2) 这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;finalize method executed !&quot;</span>);</span><br><span class="line"></span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>; <span class="comment">//最后的自救  --&gt; 把自己(this关键字)赋值给某个类变量或者对象的成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一次成功拯救自己</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>; <span class="comment">//没用的对象</span></span><br><span class="line">        System.gc();      <span class="comment">// 通知回收</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//在finalize()中拯救对象 --&gt; 因为finalize()方法优先级很低，所以暂停0.5秒以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;yes,I&#x27;m still alive !&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;no ,I&#x27;m dead !&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 下面的代码和上面的完全相同，但是这次却自救失败，</span></span><br><span class="line"><span class="comment">         * 因为任何一个对象的finalize()方法都只会被系统自动调用一次</span></span><br><span class="line"><span class="comment">         * 如果进行下一次回收，它的finalize()方法不会再次执行;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;yes,I&#x27;m still alive !&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;no ,I&#x27;m dead !&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果: </p>
<p><img src="images/j16.png" alt="在这里插入图片描述"></p>
<h3 id="5、回收方法区"><a href="#5、回收方法区" class="headerlink" title="5、回收方法区"></a>5、回收方法区</h3><p>很多人认为方法区 (或者 HotSpot 虚拟机中的永久代) 是没有垃圾收集的，但是并不是没有，只是在方法区中进行垃圾收集的“性价比”一般比较低 ，而在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收 70% ~ 95% 的空间，而永久代的垃圾收集效率远低于此。</p>
<p><strong>永久代的垃圾收集主要回收两部分内容 : 废弃常量和无用的类</strong>。回收废弃常量与回收Java 堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String 对象是叫做“abc”的，换句话说，就是没有任何 String 对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个“abc”常量就会被系统清理出常量地。常量池中的其他类(接口)、方法、字段的符号引用也与此类似。判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是”无用的类”:</p>
<ul>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 ClassLoader 已经被回收。</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以” 。而并不是和对象一样，不使用了就必然会回收。</p>
<p>是否对类进行回收，HotSpot 虚拟机提供了 <code>-Xnoclassgc</code> 参数进行控制，还可以使用 <code>-verbose:class</code> 以及 <code>-XX:HTraceClassLoading</code>、<code>-XX:HTraceClassUnLoading</code> 查看类加载和印载信息。</p>
<hr>
<h2 id="三、垃圾回收算法"><a href="#三、垃圾回收算法" class="headerlink" title="三、垃圾回收算法"></a>三、垃圾回收算法</h2><h3 id="1、标记清除算法"><a href="#1、标记清除算法" class="headerlink" title="1、标记清除算法"></a>1、标记清除算法</h3><ul>
<li>分为”标记”和”清除”两个阶段: 首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象；</li>
<li>主要的两个不足: <strong>(1)效率问题，标记和清除的效率都不高；(2) 空间问题，标记清除之后会产生大量的不连续的内存碎片</strong>，空间碎片太多可能导致以后在程序运行过程中需要分配较大对象时，无法找到足够的内存而不得不提前触发另一次垃圾收集动作；</li>
</ul>
<p>标记清除算法执行过程如下:</p>
<p><img src="images/j17.png" alt="在这里插入图片描述"></p>
<h3 id="2、复制算法"><a href="#2、复制算法" class="headerlink" title="2、复制算法"></a>2、复制算法</h3><p>为了解决效率问题，一种称为“复制”(Copying) 的收集算法出现了，它的工作流程如下:</p>
<ul>
<li>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块；</li>
<li>当这一块的内存用完了，就将还存活着的对象复制到另外一块上面；</li>
<li>然后再把已使用过的内存空间一次清理掉。</li>
</ul>
<p>这样使得每次都是对整个<strong>半区进行内存回收</strong>，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半，未免太高了一点。</p>
<p>两块的复制过程:</p>
<p><img src="images/j18%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="在这里插入图片描述"></p>
<p>现在的商业虚拟机都采用这种收集算法来回收新生代，IBM 公司的专门研究表明，新生代中的对象 98% 是“朝生夕死”的，所以并不需要按照 1 : 1 的比例来划分内存空间，<strong>而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivors</strong>。当回收时，将 Eden 和 Survivor 中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。<strong>HotSpot 虚拟机默认 Eden和 Survivor 的大小比例是 8 : 1</strong>，也就是每次新生代中可用内存空间为整个新生代容量的 **90%(80%+10%)<strong>，只有 10% 的内存会被“浪费”。当然，98% 的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10% 的对象存活，当 Survivor 空间不够用时，</strong>需要依赖其他内存 (这里指老年代) 进行分配担保 (HandIe Promotion7)**。</p>
<p><img src="images/j19.png" alt="pic"></p>
<blockquote>
<p> 拓展，关于新生代，老年代和持久代，具体看<a href="https://tech.meituan.com/jvm_optimize.html"><strong>这篇博客</strong></a>。</p>
<p> <img src="images/j20.png" alt="在这里插入图片描述"></p>
<ul>
<li>① 新生代（Young Generation）：大多数对象在新生代中被创建，其中很多对象的生命周期很短。每次新生代的垃圾回收（又称Minor GC）后只有少量对象存活，所以选用<strong>复制算法</strong>，只需要少量的复制成本就可以完成回收。新生代内分三个区：一个Eden区，两个Survivor区（一般而言），<strong>大部分对象在Eden区中生成</strong>。当Eden区满时，还存活的对象将被复制到两个Survivor区（中的一个）。当这个Survivor区满时，此区的存活且不满足“晋升”条件的对象将被复制到另外一个Survivor区。对象每经历一次Minor GC，年龄加1，达到“晋升年龄阈值”后，被放到老年代，这个过程也称为“晋升”。显然，“晋升年龄阈值”的大小直接影响着对象在新生代中的停留时间，在Serial和ParNew GC两种回收器中，“晋升年龄阈值”通过参数MaxTenuringThreshold设定，默认值为15。</li>
<li>② 老年代（Old Generation）：在新生代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代，该区域中对象存活率高。老年代的垃圾回收（又称Major GC）通常使用“标记-清理”或“标记-整理”算法。整堆包括新生代和老年代的垃圾回收称为Full GC（HotSpot VM里，除了CMS之外，其它能收集老年代的GC都会同时收集整个GC堆，包括新生代）。</li>
<li>③ 永久代（Perm Generation）：主要存放元数据，例如Class、Method的元信息，与垃圾回收要回收的Java对象关系不大。相对于新生代和年老代来说，该区域的划分对垃圾回收影响比较小。</li>
</ul>
</blockquote>
<h3 id="3、标记整理算法"><a href="#3、标记整理算法" class="headerlink" title="3、标记整理算法"></a>3、标记整理算法</h3><p>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费 <code>50%</code> 的空间，就需要有额扰的空间进行分配担保，以应对被使用的内存中所有对象都 100% 存活的极端情况，所以在老年代一般不能直接选用这种算法。</p>
<p>根据老年代的特点，有人提出于另外一种“标记 - 整理”(<code>Mark-Compact</code>) 算法，标记过程仍然与“标记 - 清除”算法一样，<strong>但后续步又不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</strong>。 <img src="images/j21.png" alt="在这里插入图片描述"></p>
<h3 id="4、分代收集算法"><a href="#4、分代收集算法" class="headerlink" title="4、分代收集算法"></a>4、分代收集算法</h3><p>当前商业虚拟机的垃圾收集都采用“分代收集”(Generational Collection) 算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。<strong>一般是把 Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法</strong>。</p>
<p>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记一清理”或者“标记一整理”算法来进行回收。  </p>
<hr>
<h2 id="四、垃圾收集器"><a href="#四、垃圾收集器" class="headerlink" title="四、垃圾收集器"></a>四、垃圾收集器</h2><h3 id="1、各个垃圾收集器的联系"><a href="#1、各个垃圾收集器的联系" class="headerlink" title="1、各个垃圾收集器的联系"></a>1、各个垃圾收集器的联系</h3><p>下图展示了7种垃圾收集器，如果有连线表示可以同时使用，上面是新生代，下面是老年代</p>
<p><img src="images/j22.png" alt="在这里插入图片描述"></p>
<p>注意，这些收集器都有下面的原则: </p>
<ul>
<li>单线程与多线程收集的不同：单线程指的是垃圾收集器只使用一个线程进行收集，而多线程使用多个线程；</li>
<li>串行与并发：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并发指的是垃圾收集器和用户程序同时执行。<strong>除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</strong></li>
</ul>
<p>**以下收集器图片均来自<a href="https://hellojz.me/2017/10/10/jvm/gc/">这篇博客</a>**。</p>
<h3 id="2、Serial收集器"><a href="#2、Serial收集器" class="headerlink" title="2、Serial收集器"></a>2、Serial收集器</h3><p>概括: </p>
<ul>
<li>是单线程且串行的收集器；</li>
<li>它的优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率；</li>
<li><strong>现在依然是虚拟机运行在 Client 模式下的默认新生代收集器；</strong>(因为在用户的桌面应用场景下，分配给虚拟机管理的内存一般来说不会很大。Serial 收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。) </li>
</ul>
<p><img src="images/j23.png" alt="在这里插入图片描述"></p>
<h3 id="3、ParNew收集器"><a href="#3、ParNew收集器" class="headerlink" title="3、ParNew收集器"></a>3、ParNew收集器</h3><p>概括</p>
<ul>
<li><p>它是 Serial 收集器的多线程版本；</p>
</li>
<li><p>是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作：</p>
<blockquote>
<p>在JDK1.5 时期，HotSpot 推出了 CMS 收集器（Concurrent Mark Sweep），它是 HotSpot 虚拟机中第一款真正意义上的并发收集器（收集线程和用户线程同时执行）。不幸的是，CMS 作为老年代的收集器，却无法与 JDK1.4.0 中已经存在的新生代收集器 Parallel Scavenge 配合工作，所以在 JDK1.5中使用 CMS 来收集老年代的时候，新生代只能选择 ParNew 或者 Serial 收集器中的一个。</p>
</blockquote>
</li>
<li><p>默认开启的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。</p>
</li>
<li><p>Parallel Scavenge 收集器以及后面提到的 G1 收集器都没有使用传统的 GC 收集器代码框架，而另外独立实现，其余集中收集器则共用了部分的框架代码。</p>
</li>
</ul>
<p><img src="images/j24.png" alt="在这里插入图片描述"></p>
<p>并发和并行在垃圾收集器中的概念: </p>
<blockquote>
<p>并发和并行。这两个名词都是并发编程中的概念，<strong>在谈论垃圾收集器的上下文语境中</strong>，它们可以解释如下:</p>
<ul>
<li>并行 (Parallel): 指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态；</li>
<li>并发(Concurrent) : 指用户线程与垃圾收集线程同时执行，(但不一定是并行的，可能会交替执行)，用户程序在继续运行，而垃圾收集程序运行于另一个CPU 上；</li>
</ul>
</blockquote>
<h3 id="4、Parallel-Scavenge收集器"><a href="#4、Parallel-Scavenge收集器" class="headerlink" title="4、Parallel Scavenge收集器"></a>4、Parallel Scavenge收集器</h3><p>概括：</p>
<ul>
<li>是新生代复制算法，多线程收集器、吞吐量优先的收集器；</li>
<li>吞吐量指 CPU 用于运行用户代码的时间占总时间的比值 ；**(吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间) )；**</li>
</ul>
<p>Parallel Scavenge 收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器……看上去和 ParNew 都一样，那它有什么特别之处呢?</p>
<p>Parallel Scavenge 收集器的特点是它的关注点与其他收集器不同，CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，**而 Parallel Scavenge 收集器的目标则是达到一个可控制的吞吐量 (Throughput)<strong>。所谓吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即</strong>吞吐量 = 运行用户代码时间 / (运行用户代码时间 +垃圾收集时间)**，例如，虚拟机总共运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是99%。</p>
<p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p>
<p><img src="images/j25.png" alt="在这里插入图片描述"></p>
<p>Parallel Scavenge 收集器提供了两个参数用于精确控制委吐量，分别是控制最大垃圾收集停顿时间的 <code>-XX:MaxGCPauseMillis</code> 参数以及直接设置吞吐量大小的<code> -XX:GCTimeRatio</code> 参数。</p>
<p><code>MaxGCPauseMillis</code> 参数允许的值是一个大于 0 的毫秒数，收集器将尽可能地保证内存回收花费的时间不超过设定值。不过大家不要认为如果把这个参数的值设置得稍小一点就能使得系统的垃圾收集速度变得更快，GC 停顿时间缩短是以牺牲吞吐量和新生代空间来换取的 : 系统把新生代调小一些，收集 300MB 新生代肯定比收集 500MB 快吧，这也直接导致垃圾收集发生得更频繁一些，原来 10 秒收集一次、每次停顿 100 毫秒，现在变成 5 秒收集一次、每次停顿 70 毫秒。停顿时间的确在下降，但吞吐量也降下来了。</p>
<p><strong><code>GCTimeRatio</code> 参数的值应当是一个大于 0 且小于 100 的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数</strong>。如果把此参数设置为 19，那允许的最大 GC 时间就占总时间的 5%（即 <code>1 / (1+19)</code>)，默认值为 99，就是允许最大 <code>1%</code> ( 即 <code>1/(1+99)</code>) 的垃圾收集时间。</p>
<p>由于与吞吐量关系密切，Parallel Scavenge 收集器也经常<strong>称为“吞吐量优先”收集器</strong>。除上述两个参数之外，Parallel Scavenge 收集器还有一个参数 <code>-XX:+UseAdaptiveSizePolicy</code>值得关注。这是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小 (-Xmn)、Eden 与 Survivor 区 的 比 例 (<code>-XX:SurvivorRatio</code>)、晋升老年代对象年龄(<code>-XX:PretenureSizeThreshold</code>) 等细节参数了，<strong>虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大吞吐量，这种调节方式成为GC自适应的调节策略。</strong></p>
<p><img src="images/j26.png" alt="在这里插入图片描述"></p>
<h3 id="5、Serial-Old收集器"><a href="#5、Serial-Old收集器" class="headerlink" title="5、Serial Old收集器"></a>5、Serial Old收集器</h3><p>概括: </p>
<ul>
<li><p>Serial Old是<strong>Serial 收集器的老年代版本</strong>，它同样是一个<strong>单线程收集器</strong>，使用”标记整理算法”；</p>
</li>
<li><p>这个收集器的主要意义也是在于给Client模式下的虚拟机使用；</p>
</li>
<li><p>在Server模式下，还有两个用途: (1) 在JDK1.5版本之前和Parallel Scavenge 收集器搭配使用；(2) 作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用；</p>
</li>
</ul>
<p><img src="images/j27.png" alt="在这里插入图片描述"></p>
<h3 id="6、Paralell-Old收集器"><a href="#6、Paralell-Old收集器" class="headerlink" title="6、Paralell Old收集器"></a>6、Paralell Old收集器</h3><p>概括: </p>
<ul>
<li>Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和 ”标记-整理“ 算法；</li>
<li>在注重<strong>吞吐量以及 CPU 资源敏感</strong>的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器；</li>
</ul>
<p><img src="images/j28.png" alt="在这里插入图片描述"></p>
<h3 id="7、CMS收集器"><a href="#7、CMS收集器" class="headerlink" title="7、CMS收集器"></a>7、CMS收集器</h3><p>概括: </p>
<ul>
<li><p>CMS（Concurrent Mark Sweep），Mark Sweep 即是 标记 - 清除 算法。</font>主要优点：并发收集、低停顿，也称之为并发低停顿收集器（Concurrent Low Pause Collection）；</p>
</li>
<li><p>整个过程分为四个步骤: </p>
<ul>
<li><strong>① 初始标记(CMS initial Mark) (标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿</strong>；</li>
<li>**② 并发标记(CMS concurrent mark)(时间最长)**；</li>
<li>**③重新标记(CMS remark)(需要停顿)**；</li>
<li>**④并发清除(CMS concurrent sweep)**；</li>
</ul>
</li>
<li><p>可以注意到上面只有②和④过程是并发的，因为这两个也是最占时间的，所以这就是CMS的优点；</p>
</li>
<li><p>缺点：</p>
<ul>
<li>①吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高(对CPU资源非常敏感)。</li>
<li>②无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li>
<li>③标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li>
</ul>
</li>
<li><p>为了解决上面的由于标记清除算法产生的空间碎片的问题:  </p>
<ul>
<li><p>CMS 提供了一个开关参数<code>-XX:+UseCMSCompactAtFullCollection</code>（默认开启），用于在 CMS 收集器顶不住要进行 Full GC 时开启内存碎片的合并整理过程，内存整理的过程是无法并发的。</p>
</li>
<li><p>参数<code> -XX:CMSFullGCsBeforeCompaction</code> 用于设置执行多少次不压缩的 Full GC后，跟着来以此带压缩的，（默认值为0）。</p>
</li>
</ul>
</li>
</ul>
<p><img src="images/j29.png" alt="在这里插入图片描述"></p>
<h3 id="8、G1收集器"><a href="#8、G1收集器" class="headerlink" title="8、G1收集器"></a>8、G1收集器</h3><p>参考: <a href="http://blog.jobbole.com/109170/"><strong>文章一</strong></a>、<a href="https://tech.meituan.com/g1.html"><strong>文章二</strong></a></p>
<p>G1收集器运作步骤</p>
<ul>
<li><p>初始标记；</p>
</li>
<li><p>并发标记；</p>
</li>
<li><p>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 <code>Remembered Set Logs</code> 里面，最终标记阶段需要把 <code>Remembered Set Logs</code> 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行；</p>
</li>
<li><p>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率；</p>
</li>
</ul>
<p><img src="images/j30.png" alt="在这里插入图片描述"></p>
<p>G1收集器的特点: </p>
<p>G1 是一款面向<strong>服务端应用</strong>的垃圾收集器。HotSpot 开发团队赋予它的使命是(在比较长期的) 未来可以替换掉 JDK 1.5 中发布的 CMS 收集器。与其他 GC 收集器相比，G1 具备如下特点。</p>
<ul>
<li><p><strong>并行与并发</strong> ， G1 能充分利用多 CPU、多核环境下的硬件优势，使用多个 CPU (CPU或者 CPU 核心) 来缩短 Stop-The-World 停顿的时间，部分其他收集器原本需要停顿Java 线程执行的 GC 动作，GI1 收集器仍然可以通过并发的方式让 Java 程序继续执行。</p>
</li>
<li><p><strong>分代收集</strong> : 与其他收集器一样，分代概念在 G1 中依然得以保留。虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、效过多次 GC 的旧对象以获取更好的收集效果。</p>
</li>
<li><p><strong>空间整合</strong>: 与 CMS 的“标记一清理”算法不同，<strong>G1 从整体来看是基于“标记一整理”算法实现的收集器，从局部(两个 Region 之间) 上来看是基于“复制”算法实现的</strong>，但无论如何，这两种算法都意味着 G1 运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。</p>
</li>
<li><p><strong>可预测的停顿</strong> : 这是 G1 相对于 CMS 的另一大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N 毫秒，这几乎已经是实时 Java (RTSJ) 的垃圾收集器的特征了。</p>
</li>
</ul>
<p>G1的设计原则就是简单可行的性能调优，其次，<strong>G1将新生代，老年代的物理空间划分取消了</strong>。这样我们再也不用单独的空间对每个代进行设置了，不用担心每个代内存是否足够。</p>
<p><img src="images/j31.png" alt="在这里插入图片描述"></p>
<p>取而代之的是，G1算法将堆划分为若干个区域（Region），它仍然属于分代收集器。不过，这些区域的一部分包含新生代，新生代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间。老年代也分成很多区域，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。这就意味着，<strong>在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有cms内存碎片问题的存在了</strong>。</p>
<p><img src="images/j32.png" alt="在这里插入图片描述"></p>
<p>在G1中，还有一种特殊的区域，叫Humongous区域。 <strong>如果一个对象占用的空间超过了分区容量50%以上，G1收集器就认为这是一个巨型对象</strong>。这些巨型对象，默认直接会被分配在<strong>年老代</strong>，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动Full GC。(<strong>在java 8中，持久代也移动到了普通的堆内存空间中，改为元空间</strong>。)</p>
<p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p>
<h3 id="9、各种垃圾收集算法的对比"><a href="#9、各种垃圾收集算法的对比" class="headerlink" title="9、各种垃圾收集算法的对比"></a>9、各种垃圾收集算法的对比</h3><p><img src="images/j33.png" alt="在这里插入图片描述"></p>
<p>使用垃圾收集器常用的相关参数: </p>
<p><img src="images/j34.png" alt="在这里插入图片描述"></p>
<p>默认在Server模式下使用 <code>Paraller</code>收集器:</p>
<p><img src="images/j35.png" alt="在这里插入图片描述"></p>
<p>参数设置(设置成使用<code>Serial</code>)</p>
<p><img src="images/j36.png" alt="在这里插入图片描述"></p>
<p><img src="images/j37.png" alt="在这里插入图片描述"></p>
<hr>
<h2 id="五、内存分配与回收策略"><a href="#五、内存分配与回收策略" class="headerlink" title="五、内存分配与回收策略"></a>五、内存分配与回收策略</h2><p>Java技术体系中所说的自动内存管理归结为解决了两个问题: </p>
<ul>
<li>给对象分配内存；</li>
<li>回收分配给对象的内存；</li>
</ul>
<p>回收内存就是前面所讲的回收算法以及垃圾收集器，而<strong>对象分配内存</strong>，大方向讲，就是在堆上分配(但也可能经过JIT编译后被拆散为标量类型并间接的栈上分配)，对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程有限在TLAB上分配。<br>下面是几条普遍的<strong>内存分配规则</strong>: </p>
<ul>
<li>对象优先在Eden分配；</li>
<li>大对象直接进入老年代；</li>
<li>长期存活对象将进入老年代；</li>
<li> 空间分配担保；</li>
<li>动态对象年龄判定；</li>
</ul>
<p>下面分配看这几个分配规则。</p>
<h3 id="1、对象优先在Eden分配"><a href="#1、对象优先在Eden分配" class="headerlink" title="1、对象优先在Eden分配"></a>1、对象优先在Eden分配</h3><p>先看一个测试代码: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAllocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>];  <span class="comment">// 2MB</span></span><br><span class="line">        <span class="keyword">byte</span>[] b2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">byte</span>[] b3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">byte</span>[] b4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>先配置运行参数:<br><img src="images/j38.png" alt="在这里插入图片描述"></p>
<p>设置和对应内存的关系:</p>
<p><img src="images/j39.png" alt="在这里插入图片描述"></p>
<p>运行结果以及分析: </p>
<p><img src="images/j40.png" alt="在这里插入图片描述"></p>
<p>概括来说: </p>
<ul>
<li><p>一般直接分配到Eden区域，但是如果Eden区域不够，就进行Minor GC和分配担保； </p>
</li>
<li><p>所以原来的6MB(<code>b1、b2、b3</code>)进入了分配担保区(老年代中)，然后新的<code>b4</code>继续放入Eden区域；</p>
</li>
</ul>
<p><strong>另外，注意Minor GC和Full GC的区别</strong></p>
<ul>
<li><p>新生代 GC (<code>Minor GC</code>) : 指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，<strong>一般回收速度度也比较快</strong>。</p>
</li>
<li><p>老年代 GC (<code>Major GC / Full GC</code>) : 指发生在<strong>老年代的 GC</strong>，出现了 Major GC，经常会伴随至少一次的 Minor GC (但非绝对的，在 Parallel Scavenge 收集器的收集策略里就有直接进行 Major GC 的策略选择过程)。<strong>Major GC 的过度一般会比 Minor GC 慢 10 倍以上</strong>。</p>
</li>
</ul>
<h3 id="2、大对象直接进入老年代"><a href="#2、大对象直接进入老年代" class="headerlink" title="2、大对象直接进入老年代"></a>2、大对象直接进入老年代</h3><p>概括 </p>
<ul>
<li>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</li>
<li>大的对象不能一直放在新生代的Eden区域，因为这个区域是经常需要GC的部分，所以会降低效率，所以大的对象要放到老年代；</li>
<li>有一个默认的大小，当对象的大小超过这个值的时候，会进入老年代，也可以通过<br> <code>-XX:PretenureSizeThreshold</code>来设置这个值；<strong>大于此值的对象直接在老年代分配</strong>，避免在 Eden 区和 Survivor 区之间的大量内存复制。</li>
</ul>
<p>在上面的例子的运行参数(堆大小为20MB)的环境下测试:</p>
<p><img src="images/j41.png" alt="在这里插入图片描述"></p>
<p>再看</p>
<p><img src="https://img-blog.csdn.net/20181019140829981?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p>
<p>通过参数来修改这个默认值: </p>
<p><img src="images/j42.png" alt="在这里插入图片描述"></p>
<p>则此时7MB也会进入老年代: </p>
<p><img src="images/j43.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>注意 : PretenureSizeThreshold 参数只对 Serial 和 ParNew 两款收集器有效，<code>Parallel Scavenge</code>收集器不认识这个参数，Parallel Scavenge 收集器一般并不需要设置。如果过到必须使用此参数的场合，可以考虑 ParNew 加 CMS 的收集器组合。</p>
</blockquote>
<h3 id="3、长期存活对象将进入老年代"><a href="#3、长期存活对象将进入老年代" class="headerlink" title="3、长期存活对象将进入老年代"></a>3、长期存活对象将进入老年代</h3><ul>
<li>为对象定义<strong>年龄计数器</strong>，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</li>
<li><code>-XX:MaxTenuringThreshold</code> 用来设置年龄的阈值(到了这个年龄就进入老年代)。</li>
<li>例子和上面差不多，只有设置参数不同，这里不重复做了。</li>
</ul>
<h3 id="4、空间分配担保"><a href="#4、空间分配担保" class="headerlink" title="4、空间分配担保"></a>4、空间分配担保</h3><ul>
<li>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。</li>
<li>如果不成立的话虚拟机会查看<code>HandlePromotionFailure</code>(<code>-XX:+HandlePromotionFailure</code>(默认是开启的)) 设置值是否允许担保失败；</li>
<li>如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC(尽管有风险)；</li>
<li>如果小于，或者 <code>HandlePromotionFailure</code> 设置不允许冒险，那么就要进行一次 Full GC。</li>
</ul>
<h3 id="5、动态对象年龄判定"><a href="#5、动态对象年龄判定" class="headerlink" title="5、动态对象年龄判定"></a>5、动态对象年龄判定</h3><ul>
<li>虚拟机并不是永远地要求对象的年龄必须达到 <code>MaxTenuringThreshold</code> 才能晋升老年代；</li>
<li>如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 <code>MaxTenuringThreshold</code> 中要求的年龄。</li>
</ul>
<hr>
<h3 id="6、关于逃逸分析以及栈上分配"><a href="#6、关于逃逸分析以及栈上分配" class="headerlink" title="6、关于逃逸分析以及栈上分配"></a>6、关于逃逸分析以及栈上分配</h3><p>堆的分配已经不是唯一</p>
<ul>
<li>逃逸分析：分析对象的作用域；</li>
<li>**如果对象的作用域只是在方法体内(没有发生逃逸)**，就可以不需要在堆上分配内存，而是可以在栈上分配内存；</li>
</ul>
<p>看几个逃逸和不逃逸的例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackAllocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> StackAllocation instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**方法返回 StackAllocation对象，发生逃逸*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StackAllocation <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance == <span class="keyword">null</span> ? <span class="keyword">new</span> StackAllocation() : instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**为成员属性赋值，也发生了逃逸*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.instance = <span class="keyword">new</span> StackAllocation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**引用成员变量，也发生了逃逸*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StackAllocation s = getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**对象的作用域仅在方法中有效,没有发生逃逸*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StackAllocation s = <span class="keyword">new</span> StackAllocation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Garbage Collection Overview</tag>
        <tag>Object Identification</tag>
      </tags>
  </entry>
  <entry>
    <title>Java虚拟机性能监控工具</title>
    <url>/2021/08/19/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="Java虚拟机性能监控工具"><a href="#Java虚拟机性能监控工具" class="headerlink" title="Java虚拟机性能监控工具"></a>Java虚拟机性能监控工具</h1><ul>
<li>一、JDK的命令行工具</li>
<li>二、JDK的可视化工具</li>
<li>三、性能调优</li>
</ul>
<hr>
<h2 id="一、JDK的命令行工具"><a href="#一、JDK的命令行工具" class="headerlink" title="一、JDK的命令行工具"></a>一、JDK的命令行工具</h2><p>主要有以下几种: </p>
<ul>
<li>jps (<code>Java Process Status Tool</code>): 虚拟机进程状态工具；</li>
<li>jstat (<code>JVM Statistics Monitoring Tool</code>):  虚拟机统计信息监视工具；</li>
<li>jinfo (<code>Configuration Info for Java</code>):  Java配置信息工具；</li>
<li>jmap (<code>Memory Map for Java</code>):  Java内存映像工具；</li>
<li>jhat (<code>JVM Heap Dump Browser</code>):  虚拟机堆转存储快照工具；</li>
<li>jstack (<code>Stack Trace for Java</code>): Java堆栈跟踪工具； </li>
</ul>
<p>下面一个个来总结: </p>
<h3 id="1、jps-虚拟机进程状态工具"><a href="#1、jps-虚拟机进程状态工具" class="headerlink" title="1、jps : 虚拟机进程状态工具"></a>1、jps : 虚拟机进程状态工具</h3><ul>
<li>jps（JVM Process Status Tool，虚拟机进程监控工具），这个命令可以列出正在运行的虚拟机进程，并显示虚拟机执行主类名称，以及这些进程的本地虚拟机唯一ID。</li>
<li>这个 ID 被称为<strong>本地虚拟机唯一 ID</strong>（Local Virtual Machine Identifier，简写为LVMID）。如果你在 linux 的一台服务器上使用 jps 得到的 LVMID 其实就是和 ps 命令得到的 PID 是一样的。</li>
</ul>
<p>命令格式: </p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">jps [options] [hostid]</span><br></pre></td></tr></table></figure>
<p>jps工具主要选项：</p>
<ul>
<li>-q，只输出LVMID，省略主类的名称；</li>
<li>-m，输出虚拟机进程启动时传给主类main()函数的参数；</li>
<li>-l，输出主类的全名，如果进程执行的是Jar包，输出Jar路径；</li>
<li>-v，输出虚拟机进程启动时JVM参数；</li>
</ul>
<h3 id="2、jstat-虚拟机统计信息监视工具"><a href="#2、jstat-虚拟机统计信息监视工具" class="headerlink" title="2、jstat : 虚拟机统计信息监视工具"></a>2、jstat : 虚拟机统计信息监视工具</h3><ul>
<li>jstat（JVM Statistics Monitoring Tool，虚拟机统计信息监视工具），这个命令用于监视虚拟机各种运行状态信息。</li>
<li>它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据，虽然没有GUI图形界面，只是提供了纯文本控制台环境的服务器上，但它是运行期间定位虚拟机性能问题的首选工具。</li>
</ul>
<p> 命令格式: </p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">jstat [option vmid [interval [s | ms] [count ] ] ]</span><br></pre></td></tr></table></figure>
<p>option代表着用户希望查询的虚拟机信息，主要分为3类: 类装载、垃圾收集、运行期编译状况，具体可以参照下表:<br><img src="images/tool1.png" alt="在这里插入图片描述"></p>
<p>示例: </p>
<p><img src="images/tool2.png" alt="在这里插入图片描述"></p>
<p><strong>更多jstat的详细讲解可以参考<a href="https://blog.csdn.net/zhaozheng7758/article/details/8623549">这篇博客</a>。</strong></p>
<h3 id="3、jinfo-：Java配置信息工具"><a href="#3、jinfo-：Java配置信息工具" class="headerlink" title="3、jinfo ：Java配置信息工具"></a>3、jinfo ：Java配置信息工具</h3><ul>
<li>实时地查看和调整虚拟机各项参数。</li>
</ul>
<p>查看14838是否使用CMS收集器: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jinfo -flag UseConcMarkSweepGC <span class="number">14836</span></span><br></pre></td></tr></table></figure>
<p>查看2788的MaxPerm大小可以用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jinfo -flag MaxPermSize <span class="number">2788</span></span><br></pre></td></tr></table></figure>

<h3 id="4、jmap-Java内存映像工具"><a href="#4、jmap-Java内存映像工具" class="headerlink" title="4、jmap : Java内存映像工具"></a>4、jmap : Java内存映像工具</h3><ul>
<li>jmap（Memory Map for Java，内存映像工具），用于生成堆转存的快照，一般是 heapdump 或者 dump 文件。如果不使用 jmap 命令，可以使用 -XX:+HeapDumpOnOutOfMemoryError 参数，当虚拟机发生内存溢出的时候可以产生快照。或者使用kill -3 pid也可以产生。</li>
<li>jmap 的作用并不仅仅是为了获取 dump 文件，它可以查询 finalize 执行队列，java 堆和永久代的详细信息，如空间使用率，当前用的哪种收集器。</li>
</ul>
<p>格式: </p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">jmap [option] vmid</span><br></pre></td></tr></table></figure>
<p>生成某个pid的存储快照示例:<br><img src="images/tool3.png" alt="在这里插入图片描述"><br><img src="images/tool4.png" alt="在这里插入图片描述"></p>
<h3 id="5、jhat-虚拟机堆转存储快照工具"><a href="#5、jhat-虚拟机堆转存储快照工具" class="headerlink" title="5、jhat :  虚拟机堆转存储快照工具"></a>5、jhat :  虚拟机堆转存储快照工具</h3><ul>
<li>jhat（虚拟机堆转储快照分析工具），这个工具是用来分析 jmap dump 出来的文件。 由于这个工具功能比较简陋，运行起来也比较耗时，所以这个工具不推荐使用，推荐使用MAT。</li>
</ul>
<p>分析示例: </p>
<p><img src="images/tool5.png" alt="在这里插入图片描述"></p>
<h3 id="6、jstack-：-Java堆栈跟踪工具"><a href="#6、jstack-：-Java堆栈跟踪工具" class="headerlink" title="6、jstack ： Java堆栈跟踪工具"></a>6、jstack ： Java堆栈跟踪工具</h3><ul>
<li>jstack（Java Stack Trace，Java堆栈跟踪工具），这个命令用于查看虚拟机当前时刻的线程快照（一般是threaddump 或者 javacore文件）。<font color = green>线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。</li>
<li><font color = blue>生成线程快照的主要目的是：定位线程出现长时间停顿的原因，入线程间死锁、死循环、请求外部资源导致的长时间等待都是导致线程长时间停顿的常见原因。</li>
<li>线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情。</li>
</ul>
<p>命令格式：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">jstack [option] vmid</span><br></pre></td></tr></table></figure>

<p>使用：查看进程8024 的堆栈信息</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">jstack 8024</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="二、-JDK的可视化工具"><a href="#二、-JDK的可视化工具" class="headerlink" title="二、 JDK的可视化工具"></a>二、 JDK的可视化工具</h2><ul>
<li>Jconsole : Java监视与管理控制台</li>
<li>VisualVM: 多合一故障处理工具</li>
</ul>
<p>下面具体看这个两个工具: </p>
<h3 id="1、-Jconsole-Java监视与管理控制台"><a href="#1、-Jconsole-Java监视与管理控制台" class="headerlink" title="1、 Jconsole : Java监视与管理控制台"></a>1、 Jconsole : Java监视与管理控制台</h3><ul>
<li>JConsole可以监视<strong>JVM 内存的使用情况、线程堆栈跟踪、已装入的类和 VM 信息以及 CE MBean。</strong></li>
<li>JConsole一个 Java GUI 监视工具，可以以图表化的形式显示各种数据。并可通过远程连接监视远程的服务器VM。</li>
<li>用 Java 写的 GUI 程序，用来监控 VM，并可监控远程的 VM，非常易用，而且功能非常强。命令行里打 Jconsole，选则进程就可以了。</li>
<li>可以监控内存和线程，以及检测是否出现死锁；</li>
</ul>
<h3 id="2、VisualVM-：多合一故障处理工具"><a href="#2、VisualVM-：多合一故障处理工具" class="headerlink" title="2、VisualVM ：多合一故障处理工具"></a>2、VisualVM ：多合一故障处理工具</h3><ul>
<li>VisualVm 同 Jconsole 都是一个基于图形化界面的、可以查看本地及远程的 JAVA GUI 监控工具，VisualVm 同 Jconsole 的使用方式一样，<font color= red>直接在命令行打入JVisualVm 即可启动</font>，VisualVm 界面更美观一些，数据更实时。</li>
</ul>
<hr>
<h3 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h3><p>性能调优: </p>
<ul>
<li>知识</li>
<li>工具</li>
<li>数据</li>
<li>经验</li>
</ul>
<p><strong>关于性能调优更多的可以看看这篇<a href="https://tech.meituan.com/jvm_optimize.html">JVM性能调优案例</a>。</strong></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM Performance Monitoring</tag>
        <tag>Heap Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8 Lambda表达式总结</title>
    <url>/2021/08/01/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="Lambda表达式总结"><a href="#Lambda表达式总结" class="headerlink" title="Lambda表达式总结"></a>Lambda表达式总结</h1><ul>
<li><a href="#%E4%B8%80%E4%BD%BF%E7%94%A8%E8%8C%83%E4%BE%8B%E4%BB%A5%E5%8F%8A%E4%BE%8B%E5%AD%90">一、使用范例以及例子</a><ul>
<li><a href="#1%E5%8E%9F%E5%A7%8B%E6%96%B9%E6%B3%95">1、原始方法</a></li>
<li><a href="#2%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F%E4%B8%80-%E4%BD%BF%E7%94%A8%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E6%9D%A5%E4%BC%98%E5%8C%96">2、优化方式一-使用策略模式来优化</a></li>
<li><a href="#3%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F%E4%BA%8C-%E4%BD%BF%E7%94%A8%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E4%BC%98%E5%8C%96">3、优化方式二-使用匿名内部类优化</a></li>
<li><a href="#4%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F%E4%B8%89-%E4%BD%BF%E7%94%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F">4、优化方式三-使用Lambda表达式</a></li>
<li><a href="#5%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F%E5%9B%9B-%E4%BD%BF%E7%94%A8stream-api">5、优化方式四-使用Stream-API</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8Clambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95">二、<code>Lambda</code>表达式基础语法</a></li>
<li><a href="#%E4%B8%89%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3">三、函数式接口</a></li>
<li><a href="#%E5%9B%9Blambda%E7%BB%83%E4%B9%A0">四、<code>Lambda</code>练习</a><ul>
<li><a href="#1%E7%BB%83%E4%B9%A0%E4%B8%80-employee%E7%B1%BB%E4%B8%AD%E5%85%88%E6%8C%89%E5%B9%B4%E9%BE%84%E6%AF%94%E5%B9%B4%E9%BE%84%E7%9B%B8%E5%90%8C%E6%8C%89%E7%85%A7%E5%A7%93%E5%90%8D%E6%AF%94-%E9%83%BD%E6%98%AF%E5%8D%87%E5%BA%8F">1、练习一-<code>Employee</code>类中先按年龄比，年龄相同按照姓名比-都是升序</a></li>
<li><a href="#2%E7%BB%83%E4%B9%A0%E4%BA%8C-%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AA%E5%B8%A6%E4%B8%A4%E4%B8%AA%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%B9%B6%E4%B8%94%E5%AF%B9%E4%B8%A4%E4%B8%AAlong%E5%9E%8B%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97">2、练习二-声明一个带两个泛型的接口，并且对两个<code>Long</code>型数值计算</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94java8%E5%9B%9B%E5%A4%A7%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3">五、<code>Java8</code>四大内置函数式接口</a></li>
<li><a href="#%E5%85%AD%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E5%92%8C%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8">六、方法引用和构造器引用</a><ul>
<li><a href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8">1、方法引用</a></li>
<li><a href="#%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8">2、构造器引用</a></li>
</ul>
</li>
</ul>
<hr>
<h2 id="一、使用范例以及例子"><a href="#一、使用范例以及例子" class="headerlink" title="一、使用范例以及例子"></a>一、使用范例以及例子</h2><p>使用匿名内部类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator&lt;Integer&gt;com = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;  <span class="comment">//降序排列</span></span><br><span class="line">        <span class="keyword">return</span> Integer.compare(o2,o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用<code>Lambda</code>表达式: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; com = (x, y) -&gt; Integer.compare(y, x);</span><br></pre></td></tr></table></figure>

<p><strong>下面给出一个例子来引入<code>Lambda</code>表达式。</strong></p>
<p>给出一个<code>Employee</code>类，有<code>name、age、salary</code>三个属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, salary=&quot;</span> + salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后我们需要通过限制查询数据: </p>
<ul>
<li>比如查询年龄<code>&gt;25</code>岁的所有员工的信息；</li>
<li>再如查询工资<code>&gt;4000</code>的员工信息；</li>
</ul>
<p>首先给出一个<code>List</code>集合类模拟数据库表: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将数组转换成集合的</span></span><br><span class="line">List&lt;Employee&gt; employees = Arrays.asList(</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="string">&quot;张三&quot;</span>,<span class="number">23</span>,<span class="number">3333.33</span>),</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="string">&quot;李四&quot;</span>,<span class="number">24</span>,<span class="number">4444.44</span>),</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="string">&quot;王五&quot;</span>,<span class="number">25</span>,<span class="number">5555.55</span>),</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="string">&quot;赵六&quot;</span>,<span class="number">26</span>,<span class="number">6666.66</span>),</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="string">&quot;田七&quot;</span>,<span class="number">27</span>,<span class="number">7777.77</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="1、原始方法"><a href="#1、原始方法" class="headerlink" title="1、原始方法"></a>1、原始方法</h3><p>然后我们写分别查询出<font color =red>年龄大于<code>25</code>岁的员工信息和工资大于<code>4000</code></font>的员工信息，发现<code>findEmployeesByAge</code>和<code>findEmployeesBySalary</code>两个方法代码非常的相似，<font color =red>只有查询条件不同，所以这个方法是不太可取的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//年龄</span></span><br><span class="line">    List&lt;Employee&gt; list = findEmployeesByAge(employees);</span><br><span class="line">    <span class="keyword">for</span>(Employee emp : list)&#123;</span><br><span class="line">        System.out.println(emp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//工资</span></span><br><span class="line">    System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line">    List&lt;Employee&gt; list2 = findEmployeesBySalary(employees);</span><br><span class="line">    <span class="keyword">for</span>(Employee emp : list2)&#123;</span><br><span class="line">        System.out.println(emp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//原始方法 : 查询出年龄大于25岁的(这个是最原始的方法)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">findEmployeesByAge</span><span class="params">(List&lt;Employee&gt;list)</span></span>&#123;</span><br><span class="line">    List&lt;Employee&gt;emps = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Employee emp : list)&#123;</span><br><span class="line">        <span class="keyword">if</span>(emp.getAge() &gt; <span class="number">25</span>)&#123;</span><br><span class="line">            emps.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> emps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//原始方法 : 查询出工资大于4000的(这个是最原始的方法)</span></span><br><span class="line"><span class="comment">//和上面的方法唯一的差别只有年龄和工资的改动，代码冗余</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">findEmployeesBySalary</span><span class="params">(List&lt;Employee&gt;list)</span></span>&#123;</span><br><span class="line">    List&lt;Employee&gt;emps = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Employee emp : list)&#123;</span><br><span class="line">        <span class="keyword">if</span>(emp.getSalary() &gt; <span class="number">4000</span>)&#123;</span><br><span class="line">            emps.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> emps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2、优化方式一-使用策略模式来优化"><a href="#2、优化方式一-使用策略模式来优化" class="headerlink" title="2、优化方式一-使用策略模式来优化"></a>2、优化方式一-使用策略模式来优化</h3><p>策略模式需要行为算法族，于是我们创建查询行为的接口<code>MyPredicate&lt;T&gt;</code>: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyPredicate</span> &lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并创建相关的实现类代表不同的算法行为: (分别是年龄<code> &gt; 25</code>和工资<code>&gt; 4000</code>的 ): </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterEmployeeByAge</span> <span class="keyword">implements</span> <span class="title">MyPredicate</span>&lt;<span class="title">Employee</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  employee.getAge() &gt; <span class="number">25</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterEmployeeBySalary</span> <span class="keyword">implements</span> <span class="title">MyPredicate</span>&lt;<span class="title">Employee</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> employee.getSalary()  &gt;= <span class="number">4000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color = red>这时我们可以只需要创建通用的方法: 具体的调用只需要传入具体的实现类(接口作为参数)</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">filterEmployees</span><span class="params">(List&lt;Employee&gt;list,MyPredicate&lt;Employee&gt;mp)</span></span>&#123;</span><br><span class="line">    List&lt;Employee&gt;emps = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Employee emp : list)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mp.test(emp))&#123;  <span class="comment">//调用相应的过滤器</span></span><br><span class="line">            emps.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> emps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color =red>测试的时候就传入两个不同的类，来指定查询的行为</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优化方式一 :  使用策略设计模式进行优化  下面的方法只要写一个</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Employee&gt; list = filterEmployees(<span class="keyword">this</span>.employees, <span class="keyword">new</span> FilterEmployeeByAge());</span><br><span class="line">    <span class="keyword">for</span>(Employee emp : list)&#123;</span><br><span class="line">        System.out.println(emp);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line">    List&lt;Employee&gt; list2 = filterEmployees(<span class="keyword">this</span>.employees, <span class="keyword">new</span> FilterEmployeeBySalary());</span><br><span class="line">    <span class="keyword">for</span>(Employee emp : list2)&#123;</span><br><span class="line">        System.out.println(emp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、优化方式二-使用匿名内部类优化"><a href="#3、优化方式二-使用匿名内部类优化" class="headerlink" title="3、优化方式二-使用匿名内部类优化"></a>3、优化方式二-使用匿名内部类优化</h3><p><font color =red>这样的好处在于不需要创建接口的具体的实现类，(但是还是需要<code>MyPredicate</code>接口和<code>filterEmployees()</code>方法): </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优化方式二 ： 使用匿名内部类  这样的好处是不要创建一个额外的 策略类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Employee&gt; list = filterEmployees(<span class="keyword">this</span>.employees, <span class="keyword">new</span> MyPredicate&lt;Employee&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> employee.getSalary() &gt; <span class="number">4000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (Employee emp:list) &#123;</span><br><span class="line">        System.out.println(emp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、优化方式三-使用Lambda表达式"><a href="#4、优化方式三-使用Lambda表达式" class="headerlink" title="4、优化方式三-使用Lambda表达式"></a>4、<font color = green>优化方式三-使用Lambda表达式</h3><p><font color = red>省去匿名内部类的没用的代码，增强可读性:(注意还是需要那个<code>filterEmployees()</code>方法和<code>MyPredicate</code>接口)</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Employee&gt; list = filterEmployees(<span class="keyword">this</span>.employees, (e) -&gt; e.getSalary() &gt; <span class="number">4000</span>);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5、优化方式四-使用Stream-API"><a href="#5、优化方式四-使用Stream-API" class="headerlink" title="5、优化方式四-使用Stream-API"></a>5、<font color = green>优化方式四-使用Stream-API</h3><p><font color = red>使用<code>StreamAPI</code>完全不需要其他的代码，包括不需要<code>filterEmployees()</code>方法，代码很简洁:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">    employees.stream().filter( (e) -&gt; e.getSalary() &lt; <span class="number">4000</span> ).limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">&quot;------------------&quot;</span>);</span><br><span class="line">    employees.stream().map(Employee::getName).forEach(System.out::println); <span class="comment">//打印所有的名字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="二、Lambda表达式基础语法"><a href="#二、Lambda表达式基础语法" class="headerlink" title="二、Lambda表达式基础语法"></a>二、Lambda表达式基础语法</h2><p><strong>关于箭头操作符:</strong> </p>
<ul>
<li><code>Java8</code>中引入了一个新的操作符，<code>&quot;-&gt;&quot;</code>，该操作符称为箭头操作符或者<code>Lambda</code>操作符，箭头操作符将<code>Lambda</code>表达式拆分成两部分；</li>
<li>左侧:  <code>Lambda</code>表达式的<font color = blue>参数列表</font>，对应的是<font color = red>接口中抽象方法的参数列表</font>；</li>
<li>右侧:  <code>Lambda</code>表达式中所需要执行的功能(<font color =blue><code>Lambda</code>体</font>)，对应的是<font color = red>对抽象方法的实现；(函数式接口(只能有一个抽象方法))</li>
<li><code>Lambda</code>表达式的实质是　<font color =red>对接口的实现</font>；</li>
</ul>
<p><strong>语法格式:</strong></p>
<p>(一)、接口中的抽象方法 : 无参数，无返回值；</p>
<p>例如: <code>Runnable</code>接口中的<code>run</code>方法: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/*final */</span><span class="keyword">int</span> num = <span class="number">2</span>; <span class="comment">//jdk1.7之前必须定义为final的下面的匿名内部类中才能访问</span></span><br><span class="line"></span><br><span class="line">    Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello world!&quot;</span> + num); <span class="comment">//本质还是不能对num操作(只是jdk自己为我们设置成了final的)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    r.run();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;----------使用Lambda输出-----------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Runnable r1 = () -&gt; System.out.println(<span class="string">&quot;Hello world!&quot;</span> + num);</span><br><span class="line">    r1.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color =red>(二)、接口中的抽象方法 : 一个参数且无返回值；  (若只有一个参数，那么小括号可以省略不写)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//  Consumer&lt;String&gt;con = (x) -&gt; System.out.println(x);</span></span><br><span class="line">    Consumer&lt;String&gt;con = x -&gt; System.out.println(x);</span><br><span class="line">    con.accept(<span class="string">&quot;Lambda牛逼!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color =red>(三)、两个参数，有返回值，并且有多条语句 ：　<strong>要用大括号括起来，而且要写上<code>return</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">     Comparator&lt;Integer&gt;com = (x,y) -&gt; &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;函数式接口&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> Integer.compare(y,x); <span class="comment">//降序</span></span><br><span class="line">     &#125;;</span><br><span class="line">     </span><br><span class="line">     Integer[] nums = &#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">5</span>&#125;;</span><br><span class="line">     Arrays.sort(nums,com);</span><br><span class="line">     System.out.println(Arrays.toString(nums));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">函数式接口</span><br><span class="line">函数式接口</span><br><span class="line">函数式接口</span><br><span class="line">函数式接口</span><br><span class="line">函数式接口</span><br><span class="line">函数式接口</span><br><span class="line">函数式接口</span><br><span class="line">函数式接口</span><br><span class="line">函数式接口</span><br><span class="line">[<span class="number">8</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p><font color =red>(四)、两个参数，有返回值，但是只有一条语句:　<strong>大括号省略，<code>return</code>省略</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">     Comparator&lt;Integer&gt;com = (x,y) -&gt; Integer.compare(x,y);<span class="comment">//升序</span></span><br><span class="line">     Integer[] nums = &#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">5</span>&#125;;</span><br><span class="line">     Arrays.sort(nums,com);</span><br><span class="line">     System.out.println(Arrays.toString(nums));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>输出: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure>

<p> <font color =red>(五)、 <code>Lambda</code>表达式的参数列表的数据类型 可以省略不写，因为JVM编译器通过上下文推断出数据类型，即”类型推断”， <code>(Integer x,Integer y ) -&gt; Integer.compare(x,y)</code>可以简写成<code>(x,y) -&gt; Integer.compare(x,y)</code>；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">上联: 左右遇一括号省</span><br><span class="line">下联: 左侧推断类型省</span><br><span class="line">横批: 能省则省</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="三、函数式接口"><a href="#三、函数式接口" class="headerlink" title="三、函数式接口"></a>三、函数式接口</h2><ul>
<li><font color =red>若接口中只有一个抽象方法的接口称为函数式接口；</li>
<li><font color =red>可以使用注解<code>@FunctionlInterface</code>来标识，可以检查是否是函数式接口；</li>
</ul>
<p> 例子: 对一个进行<code>+-*/</code>的运算：　</p>
<p>函数式接口: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span> <span class="comment">//函数式接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getValue</span><span class="params">(Integer num)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通用函数: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">operation</span><span class="params">(Integer num,MyFunction mf)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mf.getValue(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">     Integer res = operation(<span class="number">200</span>, (x) -&gt; x * x);</span><br><span class="line">     System.out.println(res);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="四、Lambda练习"><a href="#四、Lambda练习" class="headerlink" title="四、Lambda练习"></a>四、Lambda练习</h2><h3 id="1、练习一-Employee类中先按年龄比，年龄相同按照姓名比-都是升序"><a href="#1、练习一-Employee类中先按年龄比，年龄相同按照姓名比-都是升序" class="headerlink" title="1、练习一-Employee类中先按年龄比，年龄相同按照姓名比-都是升序"></a>1、练习一-<code>Employee</code>类中先按年龄比，年龄相同按照姓名比-都是升序</h3><p>先给出集合，模拟数据库表: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Employee&gt; employees = Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> Employee(<span class="string">&quot;田七&quot;</span>,<span class="number">27</span>,<span class="number">7777.77</span>),</span><br><span class="line">        <span class="keyword">new</span> Employee(<span class="string">&quot;王五&quot;</span>,<span class="number">24</span>,<span class="number">5555.55</span>),</span><br><span class="line">        <span class="keyword">new</span> Employee(<span class="string">&quot;张三&quot;</span>,<span class="number">23</span>,<span class="number">3333.33</span>),</span><br><span class="line">        <span class="keyword">new</span> Employee(<span class="string">&quot;李四&quot;</span>,<span class="number">24</span>,<span class="number">4444.44</span>),</span><br><span class="line">        <span class="keyword">new</span> Employee(<span class="string">&quot;赵六&quot;</span>,<span class="number">26</span>,<span class="number">6666.66</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">   Collections.sort(employees,(x,y) -&gt;&#123;</span><br><span class="line">       <span class="keyword">if</span>(x.getAge() == y.getAge())&#123;</span><br><span class="line">           <span class="keyword">return</span> x.getName().compareTo(y.getName());</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> Integer.compare(x.getAge(),y.getAge());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (Employee emp: employees) &#123;</span><br><span class="line">       System.out.println(emp);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">name=<span class="string">&#x27;张三&#x27;</span>, age=<span class="number">23</span>, salary=<span class="number">3333.33</span></span><br><span class="line">name=<span class="string">&#x27;李四&#x27;</span>, age=<span class="number">24</span>, salary=<span class="number">4444.44</span></span><br><span class="line">name=<span class="string">&#x27;王五&#x27;</span>, age=<span class="number">24</span>, salary=<span class="number">5555.55</span></span><br><span class="line">name=<span class="string">&#x27;赵六&#x27;</span>, age=<span class="number">26</span>, salary=<span class="number">6666.66</span></span><br><span class="line">name=<span class="string">&#x27;田七&#x27;</span>, age=<span class="number">27</span>, salary=<span class="number">7777.77</span></span><br></pre></td></tr></table></figure>
<h3 id="2、练习二-声明一个带两个泛型的接口，并且对两个Long型数值计算"><a href="#2、练习二-声明一个带两个泛型的接口，并且对两个Long型数值计算" class="headerlink" title="2、练习二-声明一个带两个泛型的接口，并且对两个Long型数值计算"></a>2、练习二-声明一个带两个泛型的接口，并且对两个<code>Long</code>型数值计算</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyCalFunction</span>&lt;<span class="title">T</span>,<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">getValue</span><span class="params">(T t1,T t2)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应函数和测试: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    op(<span class="number">200L</span>,<span class="number">200L</span>,(x,y) -&gt; x + y);</span><br><span class="line">    op(<span class="number">200L</span>,<span class="number">200L</span>,(x,y) -&gt; x * y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">op</span><span class="params">(Long l1,Long l2,MyCalFunction&lt;Long,Long&gt;mc)</span></span>&#123;<span class="comment">//需求: 对于两个long型运算进行处理</span></span><br><span class="line">    System.out.println(mc.getValue(l1, l2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多的例子: (取自<code>&lt;&lt;</code>Java8<code>实战&gt;&gt;</code>)<br><img src="images/lambda1.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>根据上述语法规则，以下哪个不是有效的Lambda表达式？<br>(1)  () -&gt; {}<br>(2)  () -&gt; “Raoul”<br>(3)  () -&gt; {return “Mario”;}<br>(4)  (Integer i) -&gt; return “Alan” + i;<br>(5)  (String s) -&gt; {“IronMan”;}<br>答案：只有4和 5是无效的Lambda。</p>
<p>(1) 这个Lambda没有参数，并返回void。 它类似于主体为空的方法：public void run() {}。<br>(2) 这个Lambda没有参数，并返回String作为表达式。<br>(3) 这个Lambda没有参数，并返回String（利用显式返回语句）。</p>
<p>(4) return是一个控制流语句。要使此Lambda有效，需要使花括号，如下所示：<code>(Integer i) -&gt; &#123;return &quot;Alan&quot; + i;&#125;</code>。</p>
<p>(5)“Iron Man”是一个表达式，不是一个语句。要使此Lambda有效，你可以去除花括号和分号，如下所示：<code>(String s) -&gt; &quot;Iron Man&quot;</code>。或者如果你喜欢，可以使用显式返回语句，如下所示：<code>(String s)-&gt;&#123;return &quot;IronMan&quot;;&#125;</code>。</p>
</blockquote>
<p>(注意类型可以省略(类型推导)。</p>
<p>下面是一些使用示例:<img src="images/lambda3.png" alt="在这里插入图片描述"></p>
<p>上图的<code>Apple</code>类: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String color;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">(String color, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="五、Java8四大内置函数式接口"><a href="#五、Java8四大内置函数式接口" class="headerlink" title="五、Java8四大内置函数式接口"></a>五、Java8四大内置函数式接口</h2><p>我们发现，如果使用<code>Lambda</code>还要自己写一个接口的话太麻烦，所以<code>Java</code>自己提供了一些接口: </p>
<ul>
<li><code>Consumer&lt; T &gt;con</code> 消费性 接口:  <code>void accept(T t)</code>；</li>
<li><code>Supplier&lt; T &gt;sup</code>供给型接口 :  <code>T get()</code>；</li>
<li> <code>Function&lt; T , R &gt;fun </code> 函数式接口 :   <code>R apply (T t)</code>；</li>
<li> <code>Predicate&lt; T &gt;</code>： 断言形接口 : <code>boolean test(T t)</code>；</li>
</ul>
<h3 id="1、Consumer-lt-T-gt-con消费性接口-void-accept-T-t"><a href="#1、Consumer-lt-T-gt-con消费性接口-void-accept-T-t" class="headerlink" title="1、Consumer&lt; T &gt;con消费性接口-void accept(T t)"></a>1、<code>Consumer&lt; T &gt;con</code>消费性接口-<code>void accept(T t)</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    apply(<span class="number">1000</span>,(num) -&gt; System.out.println(<span class="string">&quot;消费了&quot;</span> + num + <span class="string">&quot;元!&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> num,Consumer&lt;Double&gt;con)</span></span>&#123;</span><br><span class="line">    con.accept(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2、Supplier-lt-T-gt-sup供给型接口-T-get"><a href="#2、Supplier-lt-T-gt-sup供给型接口-T-get" class="headerlink" title="2、Supplier&lt; T &gt;sup供给型接口-T get()"></a>2、<code>Supplier&lt; T &gt;sup</code>供给型接口-<code>T get()</code></h3><p>例子: 产生指定个数的整数，并放入集合中；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = getNumList(<span class="number">10</span>, () -&gt; (<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>));</span><br><span class="line">    System.out.println(res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需求，产生指定个数的整数，并放入集合中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">getNumList</span><span class="params">(<span class="keyword">int</span> num, Supplier&lt;Integer&gt;sup)</span></span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt;list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">        Integer e = sup.get();</span><br><span class="line">        list.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、Function-lt-T-R-gt-fun函数式接口-R-apply-T-t"><a href="#3、Function-lt-T-R-gt-fun函数式接口-R-apply-T-t" class="headerlink" title="3、Function&lt; T, R &gt;fun函数式接口- R apply (T t)"></a>3、<code>Function&lt; T, R &gt;fun</code>函数式接口-<code> R apply (T t)</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String newStr = strHandler(<span class="string">&quot;abc&quot;</span>, (str) -&gt; str.toUpperCase());</span><br><span class="line">    System.out.println(newStr);</span><br><span class="line">    newStr = strHandler(<span class="string">&quot;   abc  &quot;</span>, (str) -&gt; str.trim());</span><br><span class="line">    System.out.println(newStr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">strHandler</span><span class="params">(String str, Function&lt;String,String&gt;fun)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fun.apply(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、Predicate-lt-T-gt-断言形接口-boolean-test-T-t"><a href="#4、Predicate-lt-T-gt-断言形接口-boolean-test-T-t" class="headerlink" title="4、Predicate&lt; T &gt;断言形接口-boolean test(T t)"></a>4、<code>Predicate&lt; T &gt;</code>断言形接口-<code>boolean test(T t)</code></h3><p>判断一些字符串数组判断长度<code>&gt;2</code>的字符串: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;atguiu&quot;</span>, <span class="string">&quot;lambda&quot;</span>, <span class="string">&quot;ok&quot;</span>, <span class="string">&quot;www&quot;</span>, <span class="string">&quot;z&quot;</span>);</span><br><span class="line">    List&lt;String&gt; res = filterStr(list, (str) -&gt; str.length() &gt; <span class="number">2</span>);</span><br><span class="line">    System.out.println(res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需求</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">filterStr</span><span class="params">(List&lt;String&gt;list, Predicate&lt;String&gt;pre)</span></span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt;res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String str : list)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.test(str))&#123;</span><br><span class="line">            res.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="六、方法引用和构造器引用"><a href="#六、方法引用和构造器引用" class="headerlink" title="六、方法引用和构造器引用"></a>六、方法引用和构造器引用</h2><h3 id="1、方法引用"><a href="#1、方法引用" class="headerlink" title="1、方法引用"></a>1、方法引用</h3><p>使用前提: <strong><code>Lambda</code>体中调用方法的参数列表和返回值类型，要和函数式接口中抽象方法的参数列表和返回值类型保持一致；</strong></font></p>
<h4 id="1-、语法格式-一-对象-实例方法名"><a href="#1-、语法格式-一-对象-实例方法名" class="headerlink" title="1)、语法格式(一) 对象::实例方法名"></a>1)、语法格式(一) 对象::实例方法名</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//普通写法</span></span><br><span class="line">     PrintStream ps = System.out;</span><br><span class="line">     Consumer&lt;String&gt;con = (x) -&gt; ps.println(x);</span><br><span class="line">     con.accept(<span class="string">&quot;hello !&quot;</span>);</span><br><span class="line"></span><br><span class="line">     System.out.println(<span class="string">&quot;----------------------&quot;</span>);</span><br><span class="line">	<span class="comment">//简写</span></span><br><span class="line">     Consumer&lt;String&gt;con1 = ps::println;</span><br><span class="line">     con1.accept(<span class="string">&quot;hello ! &quot;</span>);</span><br><span class="line"></span><br><span class="line">     System.out.println(<span class="string">&quot;----------------------&quot;</span>);</span><br><span class="line">	<span class="comment">//更简单的写法</span></span><br><span class="line">     Consumer&lt;String&gt;con2 = System.out::println;</span><br><span class="line">     con2.accept(<span class="string">&quot;hello ! &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意，这样写的前提: <code>Consumer</code>中的<code>accept()</code>方法和<code>println()</code>方法的参数列表和返回类型要完全一致:</strong><br><img src="images/lambda4.png" alt="这里写图片描述"><br><img src="images/lambda5.png" alt="这里写图片描述"></p>
<p>再看一个例子:<br>三种写法的效果是一样的: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLambda</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// method 1</span></span><br><span class="line">        Consumer&lt;String&gt; consumer = s -&gt; System.out.println(s);</span><br><span class="line">        useConsumer(consumer,<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//method 2</span></span><br><span class="line">        useConsumer(s -&gt; System.out.println(s),<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//method3   method reference (方法引用)</span></span><br><span class="line">        useConsumer(System.out::println,<span class="string">&quot;123&quot;</span>); <span class="comment">//因为println和 accept 是同样的只有一个入参，没有返回值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">useConsumer</span><span class="params">(Consumer&lt;T&gt; consumer,T t)</span></span>&#123;</span><br><span class="line">        consumer.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看一个例子: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//都是输出 字符 &#x27;l&#x27;</span></span><br><span class="line">    BiFunction&lt;String,Integer,Character&gt; bf = String::charAt; <span class="comment">//这里第一个必须传入　String</span></span><br><span class="line">    Character c = bf.apply(<span class="string">&quot;hello,&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    System.out.println(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意这里使用的是Function 接口</span></span><br><span class="line">    String str = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    Function&lt;Integer,Character&gt; f = str::charAt; <span class="comment">//这里不需要String</span></span><br><span class="line">    Character c2 = f.apply(<span class="number">2</span>);</span><br><span class="line">    System.out.println(c2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再看一个例子: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Employee emp = <span class="keyword">new</span> Employee(<span class="string">&quot;zx&quot;</span>,<span class="number">23</span>,<span class="number">5555</span>);</span><br><span class="line"></span><br><span class="line">    Supplier&lt;String&gt;sup = () -&gt; emp.getName();</span><br><span class="line">    System.out.println(sup.get());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//简写</span></span><br><span class="line">    Supplier&lt;String&gt;sup2 = emp::getName;</span><br><span class="line">    System.out.println(sup2.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="images/lambda6.png" alt="这里写图片描述"></p>
<p><img src="images/lambda7.png" alt="这里写图片描述"></p>
<h4 id="2-、语法格式-二-类名-静态方法"><a href="#2-、语法格式-二-类名-静态方法" class="headerlink" title="2)、语法格式(二)  类名::静态方法"></a>2)、语法格式(二)  类名::静态方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">     Comparator&lt;Integer&gt;com = (x,y) -&gt; Integer.compare(x,y);</span><br><span class="line"></span><br><span class="line">     Comparator&lt;Integer&gt;com2 = Integer::compare;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Integer</code>类中的</p>
<p><img src="images/lambda8.png" alt="这里写图片描述"></p>
<p><code>Comparator</code>接口中的方法: </p>
<p><img src="images/lambda9.png" alt="这里写图片描述"></p>
<h4 id="3-、语法格式-三-类-实例方法名"><a href="#3-、语法格式-三-类-实例方法名" class="headerlink" title="3)、语法格式(三) 类::实例方法名"></a>3)、语法格式(三) 类::实例方法名</font></h4><p>使用注意: <strong>若Lambda参数列表中的第一个参数是实例方法的第一个调用者，而第二个参数是实例方法的参数时，可以使用<code>ClassName :: method</code>。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BiPredicate&lt;String,String&gt;bp = (x,y) -&gt; x.equals(y);</span><br><span class="line"></span><br><span class="line">    BiPredicate&lt;String,String&gt;bp2 = String::equals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="images/lambda10.png" alt="这里写图片描述"></p>
<p><img src="images/lambda11.png" alt="这里写图片描述"></p>
<h3 id="2-、构造器引用"><a href="#2-、构造器引用" class="headerlink" title="2)、构造器引用"></a>2)、构造器引用</h3><p><strong>需要调用构造器的参数列表，要与函数式接口中的抽象方法的参数列表保持一致；</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Supplier&lt;Employee&gt;sup = () -&gt; <span class="keyword">new</span> Employee();</span><br><span class="line"></span><br><span class="line">    Supplier&lt;Employee&gt;sup2 = Employee::<span class="keyword">new</span>; <span class="comment">//调用的是默认的</span></span><br><span class="line">    System.out.println(sup2.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">name=<span class="string">&#x27;null&#x27;</span>, age=<span class="number">0</span>, salary=<span class="number">0.0</span></span><br></pre></td></tr></table></figure>

<p><img src="images/images12.png" alt="这里写图片描述"></p>
<p><img src="images/lambda12.png" alt="这里写图片描述"></p>
<p>再看构造器一个参数的: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Function&lt;String,Employee&gt;fun = Employee::<span class="keyword">new</span>;</span><br><span class="line">    System.out.println(fun.apply(<span class="string">&quot;zx&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">name=<span class="string">&#x27;zx&#x27;</span>, age=<span class="number">0</span>, salary=<span class="number">0.0</span></span><br></pre></td></tr></table></figure>

<p><img src="images/lambda13.png" alt="这里写图片描述"></p>
<p><img src="images/lambda14.png" alt="这里写图片描述"></p>
<p>如果想要匹配多个的，(两个的可以使用<code>BiFunction</code>)，下面看一个三个的:<br>例如想匹配这个: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComplexApple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ComplexApple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//匹配这个构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ComplexApple</span><span class="params">(String name, <span class="keyword">int</span> weight, String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>自己建一个接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreeFunction</span>&lt;<span class="title">A</span>,<span class="title">B</span>,<span class="title">C</span>,<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(A a,B b,C c)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreeFunction&lt;String,Integer,String,ComplexApple&gt; tf = ComplexApple::<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">        ComplexApple apple = tf.apply(<span class="string">&quot;蓝色&quot;</span>, <span class="number">12</span>, <span class="string">&quot;好苹果&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Lambda Expression</tag>
        <tag>Stream API</tag>
        <tag>Lazy Initialization</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8 Stream</title>
    <url>/2021/08/10/Stream/</url>
    <content><![CDATA[<h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><ul>
<li>一、引入流</li>
<li>二、使用流</li>
<li>三、Optional取代null</li>
<li>四、用流收集数据(collect)</li>
</ul>
<h2 id="一、引入流"><a href="#一、引入流" class="headerlink" title="一、引入流"></a>一、引入流</h2><h3 id="1、一个案例引入"><a href="#1、一个案例引入" class="headerlink" title="1、一个案例引入"></a>1、一个案例引入</h3><p>看一个使用<code>Stream</code>(Java8)和不使用<code>Stream</code>(Java7)代码量的区别。</p>
<p>这里需要筛选出一份菜单中<strong>卡路里&lt;400</strong>的菜的名字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_01_Java7AndJava8Compare</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 返回 热量&lt;400 的菜肴 的 名称, 返回结果按照从低到高排序， Java7的写法</span></span><br><span class="line">        System.out.println(java7());</span><br><span class="line">        System.out.println(java8());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> List&lt;String&gt; <span class="title">java7</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Dish&gt; lowCaloricDishes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Dish d : Dish.menu) &#123;</span><br><span class="line">            <span class="keyword">if</span> (d.getCalories() &lt; <span class="number">400</span>) &#123;</span><br><span class="line">                lowCaloricDishes.add(d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(lowCaloricDishes, <span class="keyword">new</span> Comparator&lt;Dish&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Dish d1, Dish d2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(d1.getCalories(), d2.getCalories());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;String&gt; lowCaloricDishesName = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Dish d : lowCaloricDishes) &#123;</span><br><span class="line">            lowCaloricDishesName.add(d.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lowCaloricDishesName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> List&lt;String&gt; <span class="title">java8</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; lowCaloricDishesName =</span><br><span class="line">                Dish.menu.stream()</span><br><span class="line">                        .filter(d -&gt; d.getCalories() &lt; <span class="number">400</span>)</span><br><span class="line">                        .sorted(Comparator.comparing(Dish::getCalories))</span><br><span class="line">                        .map(Dish::getName)</span><br><span class="line">                        .collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> lowCaloricDishesName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、流简介"><a href="#2、流简介" class="headerlink" title="2、流简介"></a>2、流简介</h3><ul>
<li>流简短的定义: 是数据渠道，用于操作数据源(集合，数组等)所生成的元素序列；<ul>
<li>元素序列 — 就像集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序<br>值。因为集合是数据结构，所以它的主要目的是以特定的时间/ 空间复杂度存储和访问元<br>素（如ArrayList 与 LinkedList） 。但<strong>流的目的在于表达计算</strong>，比如你前面见到的<br><code>filter、 sorted和 map</code>。<strong>集合讲的是数据，流讲的是计算</strong>。</li>
<li>源 — 流会使用一个提供数据的源，如集合、数组或输入/输出资源；</li>
<li>数据处理操作 — 流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中<br>的常用操作，如<code>filter、 map、 reduce、 find、 match、 sort</code>等；</li>
</ul>
</li>
<li>流的重要的特点<ul>
<li>流水线 — 很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大<br>的流水线；流水线的操作可以看作对数据源进行数据库式查询；</li>
<li>内部迭代 — 与使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的；</li>
<li><strong>①<code>Stream</code>自己不会存储元素；② <code>Stream</code>不会改变原对象，相反，他们会返回一个持有结果的新<code>Stream</code>；③Stream操作是延迟执行的，这意味着他们会等到需要结果的时候才执行</strong>；</li>
</ul>
</li>
</ul>
<p><img src="images/stream1.png"></p>
<h3 id="3、流与集合"><a href="#3、流与集合" class="headerlink" title="3、流与集合"></a>3、流与集合</h3><h4 id="1-、只能遍历一次"><a href="#1-、只能遍历一次" class="headerlink" title="1)、只能遍历一次"></a>1)、只能遍历一次</h4><p>请注意，<strong>和迭代器类似，流只能遍历一次</strong></p>
<ul>
<li>遍历完之后，我们就说这个流已经被消费掉了；</li>
<li>你可以从原始数据源那里再获得一个新的流来重新遍历一遍，就像迭代器一样（这里假设它是集<br>合之类的可重复的源，如果是I/O通道就没戏了）；</li>
</ul>
<h4 id="2-、外部迭代与内部迭代"><a href="#2-、外部迭代与内部迭代" class="headerlink" title="2)、外部迭代与内部迭代"></a>2)、外部迭代与内部迭代</h4><ul>
<li>使用<code>Collection</code>接口需要用户去做迭代（比如用<code>for-each</code>） ，这称为外部迭代；</li>
<li>相反， Streams库使用内部迭代；</li>
</ul>
<p>外部迭代和内部迭代的区别:</p>
<p><img src="images/stream2.png"></p>
<h3 id="4、流操作"><a href="#4、流操作" class="headerlink" title="4、流操作"></a>4、流操作</h3><p>主要分为两类操作: 中间操作和终端操作。</p>
<p><img src="images/stream3.png"></p>
<h4 id="1-、中间操作"><a href="#1-、中间操作" class="headerlink" title="1)、中间操作"></a>1)、中间操作</h4><p>中间操作就是产生的结果(仍然是一个流)。</p>
<p>诸如<code>filter</code>或<code> sorted</code>等中间操作会返回另一个流。这让多个操作可以连接起来形成一个查询。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 除非流水线上触发一个终端操作，否则中间操作不会执行任何处理</span></span><br><span class="line"><span class="comment">// 流的延迟性质。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_02_StreamDelayFeature</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; names =</span><br><span class="line">                Dish.menu.stream()</span><br><span class="line">                        .filter(d -&gt; &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;filtering&quot;</span> + d.getName());</span><br><span class="line">                            <span class="keyword">return</span> d.getCalories() &gt; <span class="number">300</span>;</span><br><span class="line">                        &#125;)</span><br><span class="line">                        .map(d -&gt; &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;mapping&quot;</span> + d.getName());</span><br><span class="line">                            <span class="keyword">return</span> d.getName();</span><br><span class="line">                        &#125;)</span><br><span class="line">                        .limit(<span class="number">3</span>)</span><br><span class="line">                        .collect(Collectors.toList());</span><br><span class="line">        System.out.println(names);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        // 终端操作</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;-------Terminal Operation------&quot;);</span></span><br><span class="line"><span class="comment">//        Dish.menu.stream().forEach(System.out::println);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看运行结果，可以发现<code>Stream</code>是有延迟的性质。</p>
<p><img src="images/stream4.png"></p>
<h4 id="2-、终止操作"><a href="#2-、终止操作" class="headerlink" title="2)、终止操作"></a>2)、终止操作</h4><p>终止操作会从流的流水线生成结果。其结果是任何不是流的值，比如List、 Integer，甚至 void。</p>
<h4 id="3-、流的使用步骤"><a href="#3-、流的使用步骤" class="headerlink" title="3)、流的使用步骤"></a>3)、流的使用步骤</h4><p>流的流水线背后的理念类似于构建器模式。</p>
<p>三个基本步骤: </p>
<ul>
<li>创建Stream : 需要一个数据源(如：集合，数组)，获取一个流；</li>
<li>中间操作: 一个中间操作链，对数据源的数据进行处理；</li>
<li>终止操作(终端操作): 一个终止操作，执行中间操作链，并产生结果；</li>
</ul>
<h2 id="二、使用流"><a href="#二、使用流" class="headerlink" title="二、使用流"></a>二、使用流</h2><h3 id="1、构建流"><a href="#1、构建流" class="headerlink" title="1、构建流"></a>1、构建流</h3><p>构建的流的方式有:</p>
<ul>
<li><p>从Collection中构建；</p>
</li>
<li><p>从值<code>value</code>(<code>Stream.of()</code>)中构建；</p>
</li>
<li><p>从数组中构建(<code>Arrays.stream()</code>)；</p>
</li>
<li><p>从文件中构建；</p>
</li>
<li><p>由函数生成: 创建无限流；</p>
</li>
</ul>
<p>创建的几种方法的示例代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 创建流的几种方法 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_03_CreateStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        PrintStream out = System.out;</span><br><span class="line"></span><br><span class="line">        out.println(<span class="string">&quot;--------fromCollection--------&quot;</span>);</span><br><span class="line">        fromCollection().forEach(x -&gt; out.print(x + <span class="string">&quot; &quot;</span>)); <span class="comment">// 从Collection中创建Stream</span></span><br><span class="line">        out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;-------fromValues---------&quot;</span>);</span><br><span class="line">        fromValues().forEach(x -&gt; out.print(x + <span class="string">&quot; &quot;</span>)); <span class="comment">// 从Collection中创建Stream</span></span><br><span class="line">        out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;--------fromArrays--------&quot;</span>);</span><br><span class="line">        fromArrays().forEach(x -&gt; out.print(x + <span class="string">&quot; &quot;</span>)); <span class="comment">// 从Collection中创建Stream</span></span><br><span class="line">        out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;--------fromFile--------&quot;</span>);</span><br><span class="line">        fromFile().forEach(out::println); <span class="comment">// 从函数中创建</span></span><br><span class="line">        out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;--------fromIterate--------&quot;</span>);</span><br><span class="line">        fromIterate().forEach(x -&gt; out.print(x + <span class="string">&quot; &quot;</span>)); <span class="comment">// 从函数中创建</span></span><br><span class="line">        out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;--------fromGenerate--------&quot;</span>);</span><br><span class="line">        fromGenerate().forEach(x -&gt; out.print(x + <span class="string">&quot; &quot;</span>)); <span class="comment">// 从函数中创建</span></span><br><span class="line">        out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;--------fromCustom--------&quot;</span>);</span><br><span class="line">        fromCustom().forEach(x -&gt; out.print(x + <span class="string">&quot; &quot;</span>));</span><br><span class="line">        out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;----------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Stream&lt;String&gt; <span class="title">fromCollection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> list.stream();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Stream&lt;String&gt; <span class="title">fromValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.of(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Stream&lt;String&gt; <span class="title">fromArrays</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String[] str = &#123;<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Stream&lt;String&gt; <span class="title">fromFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Path path = Paths.get(<span class="string">&quot;/home/zxzxin/Main.java&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; stream = Files.lines(path);</span><br><span class="line">        <span class="keyword">return</span> stream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Stream <span class="title">fromIterate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>).limit(<span class="number">5</span>); <span class="comment">// 函数创建的无限流</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Stream&lt;Double&gt; <span class="title">fromGenerate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.generate(Math::random).limit(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Custom的流  (CusSupplier)</span></span><br><span class="line">    <span class="keyword">static</span> Stream&lt;Custom&gt;fromCustom()&#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.generate(<span class="keyword">new</span> CusSupplier()).limit(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CusSupplier</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Custom</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Custom <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            index = random.nextInt(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Custom(index, <span class="string">&quot;name-&quot;</span> + index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Custom</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Custom</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Obj&#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                    <span class="string">&quot;, id=&quot;</span> + id +</span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">--------fromCollection--------</span><br><span class="line">aa bb cc </span><br><span class="line">-------fromValues---------</span><br><span class="line">aa bb cc </span><br><span class="line">--------fromArrays--------</span><br><span class="line">aa bb cc </span><br><span class="line">--------fromFile--------</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line">        PrintStream out = System.out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------fromIterate--------</span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> </span><br><span class="line">--------fromGenerate--------</span><br><span class="line"><span class="number">0.18018050075496417</span> <span class="number">0.948721748467966</span> <span class="number">0.37983036182518304</span> <span class="number">0.679145483357325</span> <span class="number">0.21520045208568783</span> </span><br><span class="line">--------fromCustom--------</span><br><span class="line">Obj&#123;name=<span class="string">&#x27;name-73&#x27;</span>, id=<span class="number">73</span>&#125; Obj&#123;name=<span class="string">&#x27;name-84&#x27;</span>, id=<span class="number">84</span>&#125; Obj&#123;name=<span class="string">&#x27;name-14&#x27;</span>, id=<span class="number">14</span>&#125; Obj&#123;name=<span class="string">&#x27;name-79&#x27;</span>, id=<span class="number">79</span>&#125; Obj&#123;name=<span class="string">&#x27;name-51&#x27;</span>, id=<span class="number">51</span>&#125; </span><br><span class="line">----------------</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2、filter、limit、skip、map、flatMap"><a href="#2、filter、limit、skip、map、flatMap" class="headerlink" title="2、filter、limit、skip、map、flatMap"></a>2、filter、limit、skip、map、flatMap</h3><ul>
<li>filter : 该操作会接受一个谓词（一个返回boolean的函数）(<code>Predicate</code>)作为参数，并返回一个包括所有符合谓词的元素的流；</li>
<li>limit : 流支持<code>limit(n)</code>方法，该方法会返回一个不超过给定长度的流；</li>
<li>skip : 流还支持<code>skip(n)</code>方法，返回一个扔掉了前n 个元素的流；</li>
<li>map : 流支持map方法，它会接受一个函数(<code>Function</code>)作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素（使用映射一词，是因为它和转换类似，但其中的细微差别在于它是“创建一个新版本”而不是去“修改”）；</li>
<li>flatMap (<strong>扁平化</strong>): <code>flatmap()</code>方法让你<strong>把一个流中的每个值都换成另一个流，然后把所有的流连接</strong><br><strong>起来成为一个流</strong>；</li>
</ul>
<p>测试代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_04_StreamOperations1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> PrintStream out;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        out = System.out;</span><br><span class="line">        out.println( <span class="string">&quot;-------filterTest---------&quot;</span>);</span><br><span class="line">        filterTest();</span><br><span class="line">        out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;-------limitTest---------&quot;</span>);</span><br><span class="line">        limitTest();</span><br><span class="line">        out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;-------skipTest---------&quot;</span>);</span><br><span class="line">        skipTest();</span><br><span class="line">        out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;-------mapTest---------&quot;</span>);</span><br><span class="line">        mapTest();</span><br><span class="line">        out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;-------flatMapTest---------&quot;</span>);</span><br><span class="line">        flatMapTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filterTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 山选出偶数且没有重复</span></span><br><span class="line">        numbers.stream()</span><br><span class="line">                .filter(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                .distinct() <span class="comment">// 去重</span></span><br><span class="line">                .forEach(x -&gt; out.print(x + <span class="string">&quot; &quot;</span>));</span><br><span class="line">        out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">limitTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">        numbers.stream().</span><br><span class="line">                limit(<span class="number">3</span>). <span class="comment">// 取前3个</span></span><br><span class="line">                forEach(x -&gt; out.print(x + <span class="string">&quot; &quot;</span>));</span><br><span class="line">        out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">skipTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">        numbers.stream().</span><br><span class="line">                skip(<span class="number">3</span>). <span class="comment">// 跳过前3个</span></span><br><span class="line">                forEach(x -&gt; out.print(x + <span class="string">&quot; &quot;</span>));</span><br><span class="line">        out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map里面需要的是 Function</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mapTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 例子1</span></span><br><span class="line">        List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">        numbers.stream().</span><br><span class="line">                map(i -&gt; i * <span class="number">2</span>). <span class="comment">// 跳过前3个</span></span><br><span class="line">                collect(Collectors.toList()).</span><br><span class="line">                forEach(x -&gt; out.print(x + <span class="string">&quot; &quot;</span>));</span><br><span class="line">        out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 例子2</span></span><br><span class="line">        List&lt;String&gt; words = Arrays.asList(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;cccc&quot;</span>, <span class="string">&quot;ddddd&quot;</span>); <span class="comment">// 长度分别为 2, 3, 4, 5</span></span><br><span class="line">        words.stream()</span><br><span class="line">                .map(String::length)</span><br><span class="line">                .collect(Collectors.toList())</span><br><span class="line">                .forEach(x -&gt; out.print(x + <span class="string">&quot; &quot;</span>));</span><br><span class="line">        out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 words去重输出字符</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">flatMapTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String[] words = &#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">// &#123;h, e, l, l, o&#125;, &#123;w, o, r, l, d&#125;</span></span><br><span class="line">        Stream&lt;String[]&gt; stream = Arrays.stream(words).map(x -&gt; x.split(<span class="string">&quot;&quot;</span>));</span><br><span class="line">        Stream&lt;String&gt; stringStream = stream.flatMap(s -&gt; Arrays.stream(s));</span><br><span class="line">        stringStream.distinct().forEach(x -&gt; out.print(x + <span class="string">&quot; &quot;</span>));</span><br><span class="line">        out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">-------filterTest---------</span><br><span class="line"><span class="number">2</span> <span class="number">4</span> </span><br><span class="line"></span><br><span class="line">-------limitTest---------</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span> </span><br><span class="line"></span><br><span class="line">-------skipTest---------</span><br><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="number">2</span> <span class="number">4</span> </span><br><span class="line"></span><br><span class="line">-------mapTest---------</span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">2</span> <span class="number">6</span> <span class="number">6</span> <span class="number">4</span> <span class="number">8</span> </span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br><span class="line"></span><br><span class="line">-------flatMapTest---------</span><br><span class="line">H e l o W r d </span><br></pre></td></tr></table></figure>

<h3 id="3、match、find、reduce"><a href="#3、match、find、reduce" class="headerlink" title="3、match、find、reduce"></a>3、match、find、reduce</h3><ul>
<li>match：查看元素是否匹配(返回boolean)，包括<code>allMatch(), anyMatch()、noneMatch()</code>；</li>
<li>find : <ul>
<li> <code>isPresent()</code>将在Optional包含值的时候返回true, 否则返回false；</li>
<li> <code>ifPresent(Consumer&lt;T&gt; block)</code>会在值存在的时候执行给定的代码块；</li>
<li><code>T get()</code>会在值存在时返回值，否则抛出一个NoSuchElement异常；</li>
<li><code>T orElse(T other)</code>会在值存在时返回值，否则返回一个默认值；</li>
<li><code>Optional&lt;T&gt; of(T value)</code>  : 通过value构造一个Optional；</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_05_StreamOperations2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> PrintStream out;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        out = System.out;</span><br><span class="line">        out.println(<span class="string">&quot;-------matchTest---------&quot;</span>);</span><br><span class="line">        matchTest();</span><br><span class="line">        out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;-------findTest---------&quot;</span>);</span><br><span class="line">        findTest();</span><br><span class="line">        out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;-------reduceTest---------&quot;</span>);</span><br><span class="line">        reduceTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">matchTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; arr = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">        out.println(arr.stream().allMatch(i -&gt; i &gt; <span class="number">10</span>));</span><br><span class="line">        out.println(arr.stream().anyMatch(i -&gt; i &gt; <span class="number">6</span>));</span><br><span class="line">        out.println(arr.stream().noneMatch(i -&gt; i &lt; <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; arr = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">        Optional&lt;Integer&gt; any = arr.stream().filter(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>).findAny();</span><br><span class="line">        out.println(any.get());</span><br><span class="line">        Optional&lt;Integer&gt; first = arr.stream().filter(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>).findFirst();</span><br><span class="line">        first.ifPresent(out::println);</span><br><span class="line">        out.println(first.get()); <span class="comment">//没有就抛出 NoSuchElementException</span></span><br><span class="line">        out.println(first.orElse(-<span class="number">1</span>)); <span class="comment">// 如果first为空就输出-1</span></span><br><span class="line">        System.out.println(first.filter(i -&gt; i == <span class="number">2</span>).get()); <span class="comment">// Optional还会产生一个stream</span></span><br><span class="line">        System.out.println(find(arr, -<span class="number">1</span>, i -&gt; i &gt; <span class="number">10</span>)); <span class="comment">// 自己写的一个防止空指针的，而Optional中有一个已经存在的</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(List&lt;Integer&gt; values, <span class="keyword">int</span> defaultValue, Predicate&lt;Integer&gt; predicate)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> val : values)&#123;</span><br><span class="line">            <span class="keyword">if</span>(predicate.test(val))</span><br><span class="line">                <span class="keyword">return</span> val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> defaultValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reduce 也是一个terminal的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reduceTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; arr = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">        System.out.println(arr.stream().reduce(<span class="number">0</span>, (a, b) -&gt; a + b)); <span class="comment">//计算数组的和 ,有初始值就是Integer</span></span><br><span class="line">        arr.stream().reduce((a, b) -&gt; a + b).ifPresent(out::println); <span class="comment">// 没有初始值就是 Optional</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提取所有的偶数相乘</span></span><br><span class="line">        <span class="keyword">int</span> res = arr.stream().filter(x -&gt; x%<span class="number">2</span> == <span class="number">0</span>).reduce(<span class="number">1</span>, (a, b) -&gt; a*b);</span><br><span class="line">        Optional.of(res).ifPresent(out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-------matchTest---------</span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">-------findTest---------</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">-------reduceTest---------</span><br><span class="line"><span class="number">28</span></span><br><span class="line"><span class="number">28</span></span><br><span class="line"><span class="number">48</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4、数值流"><a href="#4、数值流" class="headerlink" title="4、数值流"></a>4、数值流</h3><p>Java 8引入了三个原始类型特化流接口来解决这个问题：<code>IntStream、 DoubleStream和LongStream</code>，分别将流中的元素特化为<code>int、 long和 double</code>，从而避免了暗含的装箱成本。这些特化的原因并不在于流的复杂性，而是装箱造成的复杂性——即类似int和 Integer之间的效率差异。</p>
<p>映射方法:</p>
<ul>
<li>映射到数值流<ul>
<li>将流转换为特化版本的常用方法是mapToInt、 mapToDouble和 mapToLong；</li>
<li>例如mapToInt返回一个IntStream（而不是一个<code>Stream&lt;Integer&gt;</code>）；</li>
</ul>
</li>
<li> 转换回对象流</li>
<li>使用<code>boxed()</code>方法；</li>
<li>用处: 例如，IntStream上的操作只能产生原始整数。</li>
</ul>
<p>例子(勾股数):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_06_NumericStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------example1---------&quot;</span>);</span><br><span class="line">        example1();</span><br><span class="line">        System.out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;-------example2---------&quot;</span>);</span><br><span class="line">        example2();</span><br><span class="line">        System.out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;-------example3---------&quot;</span>);</span><br><span class="line">        example3();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">example1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; arr = Arrays.asList(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        Stream&lt;Integer&gt; integerStream = arr.stream().filter(i -&gt; i.intValue() &gt; <span class="number">3</span>);</span><br><span class="line">        Integer res = integerStream.reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line"></span><br><span class="line">        IntStream intStream = arr.stream().mapToInt(i -&gt; i.intValue());</span><br><span class="line">        <span class="keyword">int</span> res2 = intStream.filter(i -&gt; i &gt; <span class="number">3</span>).sum();</span><br><span class="line"></span><br><span class="line">        System.out.println(res + <span class="string">&quot; &quot;</span> + res2); <span class="comment">// 一样的，但是转换成IntStream效率更高</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 产生 a = 5 勾股数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">example2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">        Stream&lt;<span class="keyword">int</span>[]&gt; triples1 = IntStream.rangeClosed(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">                .filter(b -&gt; Math.sqrt(a * a + b * b) % <span class="number">1</span> == <span class="number">0</span>)</span><br><span class="line">                .boxed()</span><br><span class="line">                .map(b -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a, b, (<span class="keyword">int</span>) Math.sqrt(a * a + b * b)&#125;);</span><br><span class="line"></span><br><span class="line">        triples1.forEach(t -&gt;</span><br><span class="line">                System.out.println(t[<span class="number">0</span>] + <span class="string">&quot;, &quot;</span> + t[<span class="number">1</span>] + <span class="string">&quot;, &quot;</span> + t[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 产生100以内的所有勾股数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">example3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Stream&lt;<span class="keyword">int</span>[]&gt; triples2 =</span><br><span class="line">                IntStream.rangeClosed(<span class="number">1</span>, <span class="number">100</span>).boxed()</span><br><span class="line">                        .flatMap(a -&gt; IntStream.rangeClosed(a, <span class="number">100</span>) <span class="comment">// a也是100内随机产生的</span></span><br><span class="line">                                .filter(b -&gt; Math.sqrt(a*a + b*b) % <span class="number">1</span> == <span class="number">0</span>)</span><br><span class="line">                                .mapToObj(b -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a, b, (<span class="keyword">int</span>)Math.sqrt(a * a + b * b)&#125;)</span><br><span class="line">                        );</span><br><span class="line">        triples2.limit(<span class="number">10</span>).</span><br><span class="line">                forEach(t -&gt;</span><br><span class="line">                System.out.println(t[<span class="number">0</span>] + <span class="string">&quot;, &quot;</span> + t[<span class="number">1</span>] + <span class="string">&quot;, &quot;</span> + t[<span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-------example1---------</span><br><span class="line"><span class="number">9</span> <span class="number">9</span></span><br><span class="line"></span><br><span class="line">-------example2---------</span><br><span class="line"><span class="number">5</span>, <span class="number">12</span>, <span class="number">13</span></span><br><span class="line"></span><br><span class="line">-------example3---------</span><br><span class="line"><span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span></span><br><span class="line"><span class="number">5</span>, <span class="number">12</span>, <span class="number">13</span></span><br><span class="line"><span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span></span><br><span class="line"><span class="number">7</span>, <span class="number">24</span>, <span class="number">25</span></span><br><span class="line"><span class="number">8</span>, <span class="number">15</span>, <span class="number">17</span></span><br><span class="line"><span class="number">9</span>, <span class="number">12</span>, <span class="number">15</span></span><br><span class="line"><span class="number">9</span>, <span class="number">40</span>, <span class="number">41</span></span><br><span class="line"><span class="number">10</span>, <span class="number">24</span>, <span class="number">26</span></span><br><span class="line"><span class="number">11</span>, <span class="number">60</span>, <span class="number">61</span></span><br><span class="line"><span class="number">12</span>, <span class="number">16</span>, <span class="number">20</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="三、Optional取代null"><a href="#三、Optional取代null" class="headerlink" title="三、Optional取代null"></a>三、Optional取代null</h2>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Stream API</tag>
        <tag>Optional</tag>
      </tags>
  </entry>
  <entry>
    <title>Http协议</title>
    <url>/2021/11/05/Http%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a>Http协议</h1><ul>
<li><a href="#%E4%B8%80web%E5%92%8C%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80">一、Web和网络基础</a></li>
</ul>
<h2 id="一、Web和网络基础"><a href="#一、Web和网络基础" class="headerlink" title="一、Web和网络基础"></a>一、Web和网络基础</h2><h3 id="1、使用HTTP协议访问Web"><a href="#1、使用HTTP协议访问Web" class="headerlink" title="1、使用HTTP协议访问Web"></a>1、使用HTTP协议访问Web</h3><ul>
<li>客户端: 通过发送请求获取服务器资源的 Web 浏览器等，都可称为客户端（ client ）。</li>
<li>Web 使用一种名为 HTTP （ <code>HyperText Transfer Protocol</code> ，超文本传输协议）的协议作为规范，完成从客户端到服务器端等一系列运作流程。而协议是指规则的约定。Web是建立在Http协议上通信的；</li>
</ul>
<p><img src="images/http/1_%E5%AE%A2%E6%88%B7%E7%AB%AF.png"></p>
<h3 id="2、TCP-IP"><a href="#2、TCP-IP" class="headerlink" title="2、TCP/IP"></a>2、TCP/IP</h3><p>TCP/IP 协议族按层次分别分为以下 4 层：应用层、传输层、网络层和数据链路层；</p>
<ul>
<li>应用层: TCP/IP 协议族内预存了各类通用的应用服务。比如， FTP （ File Transfer Protocol ，文件传输协议）和 DNS （ Domain Name System ，域名系统）服务就是其中两类。<strong>HTTP 协议也处于该层</strong>。</li>
<li>传输层: 传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。在传输层有两个性质不同的协议： TCP （ Transmission Control Protocol ，传输控制协议）和 UDP （ User Data Protocol ，用户数据报协议）；</li>
<li>网络层: 网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。</li>
<li>数据链路层: 用来处理连接网络的硬件部分。</li>
</ul>
<p>通信传输流:</p>
<p><img src="images/http/2_.png"></p>
<p>传输过程:</p>
<p>利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。</p>
<p><strong>发送端从应用层往下走，接收端则往应用层往上走</strong>。</p>
<p>我们用 HTTP 举例来说明，首先作为发送端的客户端在应用层（ HTTP 协议）发出一个想看某个 Web 页面的HTTP 请求。</p>
<p>接着，为了传输方便，<strong>在传输层（ TCP 协议）把从应用层处收到的数据（ HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层</strong>。</p>
<p><strong>在网络层（ IP 协议），增加作为通信目的地的 MAC 地址后转发给链路层</strong>。这样一来，发往网络的通信请求就准备齐全了。</p>
<p>接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP请求。</p>
<p><img src="images/http/3_.png"></p>
<p>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。<br>这种把数据信息包装起来的做法称为<strong>封装（ encapsulate ）</strong>。</p>
<h3 id="3、IP、TCP和DNS"><a href="#3、IP、TCP和DNS" class="headerlink" title="3、IP、TCP和DNS"></a>3、IP、TCP和DNS</h3><h4 id="1-、IP-负责传输"><a href="#1-、IP-负责传输" class="headerlink" title="1)、IP(负责传输)"></a>1)、IP(负责传输)</h4><p>按层次分， <strong>IP （ Internet Protocol ）网际协议位于网络层</strong>。几乎所有使用网络的系统都会用到 IP 协议。 </p>
<p>可能有人会把 “IP” 和 “IP 地址 ” 搞混， “IP” 其实是一种协议的名称。</p>
<ul>
<li>IP 协议的作用是把<strong>各种数据包传送给对方</strong>。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是 <strong>IP 地址和 MAC地址</strong>（ Media Access Control Address ）。</li>
<li><strong>IP 地址指明了节点被分配到的地址， MAC 地址是指网卡所属的固定地址</strong>。 IP 地址可以和 MAC 地址进行配对。 IP 地址可变换，但 MAC地址基本上不会更改。</li>
</ul>
<p>使用 ARP 协议凭借 MAC 地址进行通信</p>
<ul>
<li>IP 间的通信依赖 MAC 地址。在网络上，通信的双方在同一局域网（ LAN ）内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，<strong>会利用下一站中转设备的 MAC地址来搜索下一个中转目标。这时，会采用 ARP 协议（ Address Resolution Protocol ）</strong>。 </li>
<li>ARP 是一种用以解析地址的协议，<strong>根据通信方的 IP 地址就可以反查出对应的 MAC 地址</strong>。没有人能够全面掌握互联网中的传输状况，在到达通信目标前的中转过程中，那些计算机和路由器等网络设备只能获悉很粗略的传输路线。这种机制称为路由选择（ routing ）。</li>
</ul>
<blockquote>
<p>路由选择：有点像快递公司的送货过程。想要寄快递的人，只要将自己的货物送到集散中心，就可以知道快递公司是否肯收件发货，该快递公司的集散中心检查货物的送达地址，明确下站该送往哪个区域的集散中心。接着，那个区域的集散中心自会判断是否能送到对方的家中。</p>
</blockquote>
<p><img src="images/http/4_.png"></p>
<h4 id="2-、TCP协议-确保可靠性"><a href="#2-、TCP协议-确保可靠性" class="headerlink" title="2)、TCP协议(确保可靠性)"></a>2)、TCP协议(确保可靠性)</h4><p>按层次分， TCP 位于传输层，提供可靠的字节流服务。</p>
<ul>
<li>所谓的字节流服务（ Byte Stream Service ）是指，为了方便传输，<strong>将大块数据分割成以报文段（ segment ）为单位的数据包</strong>进行管理；</li>
<li>而可靠的传输服务是指，能够把数据准确可靠地传给对方。一言以蔽之，TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方。确保数据能到达目标；</li>
</ul>
<p>为了准确无误地将数据送达目标处， TCP 协议采用了<strong>三次握手（ three-way handshaking ）策略</strong>。</p>
<ul>
<li>用 TCP 协议把数据包送出去后， TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。</li>
<li>握手过程中使用了 TCP 的标志（ flag ） —— SYN （ synchronize ） 和ACK （ acknowledgement ）。发送端首先发送一个带 <strong>SYN</strong> 标志的数据包给对方。接收端收到后，回传一个带有 <strong>SYN/ACK</strong> 标志的数据包以示传达确认信息。最后，发送端再回传一个带 <strong>ACK</strong> 标志的数据包，代表 “ 握手 ” 结束。</li>
</ul>
<p>若在握手过程中某个阶段莫名中断， TCP 协议会再次以相同的顺序发送相同的数据包。</p>
<p><img src="images/http/5_.png"></p>
<h4 id="3-、DNS-负责域名解析"><a href="#3-、DNS-负责域名解析" class="headerlink" title="3)、DNS(负责域名解析)"></a>3)、DNS(负责域名解析)</h4><p>DNS （ Domain Name System ）服务是和 HTTP 协议一样位于应用层的协议。它提供<strong>域名到 IP 地址之间</strong>的解析服务。</p>
<p>用户通常使用<strong>主机名或域名</strong>来访问对方的计算机，而不是直接通过 IP地址访问。因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯。</p>
<p>为了解决上述的问题， DNS 服务应运而生。 DNS 协议提供<strong>通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务</strong>。</p>
<p><img src="images/http/6_DNS.png"></p>
<h3 id="4-、各种协议与Http协议的关系"><a href="#4-、各种协议与Http协议的关系" class="headerlink" title="4)、各种协议与Http协议的关系"></a>4)、各种协议与Http协议的关系</h3><p><img src="images/http/7_.png"><img src="images/http/8_.png"></p>
<h3 id="5、URI和URL"><a href="#5、URI和URL" class="headerlink" title="5、URI和URL"></a>5、URI和URL</h3><p>与 URI （统一资源标识符）相比，我们更熟悉 URL （ UniformResource Locator ，统一资源定位符）。</p>
<p>URL 正是使用 Web 浏览器等访问 Web 页面时需要输入的网页地址。</p>
<h4 id="1-、URI-统一资源标识符"><a href="#1-、URI-统一资源标识符" class="headerlink" title="1)、URI(统一资源标识符)"></a>1)、URI(统一资源标识符)</h4><p>URI 是 Uniform Resource Identifier 的缩写。 </p>
<blockquote>
<p>Uniform</p>
<p>规定统一的格式可方便处理多种不同类型的资源，而不用根据上下文环境来识别资源指定的访问方式。另外，加入新增的协议方案（如http: 或 ftp: ）也更容易。</p>
<p>Resource</p>
<p>资源的定义是 “ 可标识的任何东西 ” 。除了文档文件、图像或服务（例如当天的天气预报）等能够区别于其他类型的，全都可作为资源。另外，资源不仅可以是单一的，也可以是多数的集合体。</p>
<p>Identifier</p>
<p>表示可标识的对象。也称为标识符。</p>
</blockquote>
<p> <strong>URI 就是由某个协议方案表示的资源的定位标识符</strong>。协议方案是指访问资源所使用的协议类型名称。采用 HTTP 协议时，协议方案就是 http 。除此之外，还有 <code>ftp 、mailto 、 telnet 、 file</code> 等。标准的 URI 协议方案有 30 种左右。</p>
<p><strong>URI 用字符串标识某一互联网资源，而 URL 表示资源的地点（互联网上所处的位置）。可见 URL 是 URI 的子集</strong>。<br>“ RFC3986：统一资源标识符（ URI ）通用语法 “ 中列举了几种 URI 例子，如下所示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ftp:<span class="comment">//ftp.is.co.za/rfc/rfc1808.txt</span></span><br><span class="line">http:<span class="comment">//www.ietf.org/rfc/rfc2396.txt</span></span><br><span class="line">ldap:<span class="comment">//[2001:db8::7]/c=GB?objectClass?one</span></span><br><span class="line">mailto:John.Doe@example.com</span><br><span class="line">news:comp.infosystems.www.servers.unix</span><br><span class="line">tel:+<span class="number">1</span><span class="number">-816</span><span class="number">-555</span><span class="number">-1212</span></span><br><span class="line">telnet:<span class="comment">//192.0.2.16:80/</span></span><br><span class="line">urn:oasis:names:specification:docbook:dtd:xml:<span class="number">4.1</span><span class="number">.2</span></span><br></pre></td></tr></table></figure>

<h4 id="2-、URI格式"><a href="#2-、URI格式" class="headerlink" title="2)、URI格式"></a>2)、URI格式</h4><p>表示指定的 URI ，要使用涵盖全部必要信息的绝对 URI 、绝对 URL 以及相对 URL 。相对 URL ，是指从浏览器中基本 URI 处指定的 URL ，形如<code> /image/logo.gif</code> 。</p>
<p>绝对 URI 的格式如下:</p>
<p><img src="images/http/9_.png"></p>
<p>使用 <code>http: </code>或<code>https:</code>等协议方案名获取访问资源时要指定协议类型。不区分字母大小写，最后附一个冒号（<code> :</code> ）。也可使用 data: 或 javascript: 这类指定数据或脚本程序的方案名。</p>
<ul>
<li>登录信息（认证）: 指定用户名和密码作为从服务器端获取资源时必要的登录信息（身份认证）。此项是可选项。</li>
<li>服务器地址 : <strong>使用绝对 URI 必须指定待访问的服务器地址</strong>。地址可以是类似<code>baidu.com</code> 这种 DNS 可解析的名称，或是 192.168.1.1 这类 IPv4 地址名，还可以是 <code>[0:0:0:0:0:0:0:1]</code> 这样用方括号括起来的 IPv6 地址名。</li>
<li>服务器端口号 : <strong>指定服务器连接的网络端口号</strong>。此项也是可选项，若用户省略则自动使用默认端口号。</li>
<li>带层次的文件路径 : 指定服务器上的文件路径来定位特指的资源。这与 UNIX 系统的文件目录结构相似。</li>
<li>查询字符串 : 针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数。此项可选。</li>
<li>片段标识符 : 使用片段标识符通常可标记出已获取资源中的子资源（文档内的某个位置）。但在 RFC 中并没有明确规定其使用方法。该项也为可选项。</li>
</ul>
]]></content>
      <categories>
        <category>Computer Network</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>Instrction Arrangement以及关键路径详解</title>
    <url>/2022/02/17/Instrction%20Arrangement%E4%BB%A5%E5%8F%8A%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="Instrction-Arrangement以及关键路径详解"><a href="#Instrction-Arrangement以及关键路径详解" class="headerlink" title="Instrction Arrangement以及关键路径详解"></a>Instrction Arrangement以及关键路径详解</h2><ul>
<li><a href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E8%AF%A6%E8%A7%A3">关键路径详解</a></li>
<li><a href="#hdu4109-instrction-arrangement%E9%A2%98%E8%A7%A3">Hdu4109-Instrction Arrangement题解</a></li>
</ul>
<hr>
<h3 id="关键路径详解"><a href="#关键路径详解" class="headerlink" title="关键路径详解"></a><font color  = red id = "1">关键路径详解</h3><h5 id="AOE网"><a href="#AOE网" class="headerlink" title="AOE网"></a><code>AOE</code>网</h5><p><font color = purple>概念: </p>
<ul>
<li>在一个表示工程的带权有向图中，<font color = red>用顶点表示事件，用有向边表示活动</fonT>，边上的权值表示活动的持续时间，称这样的有向图叫做边表示活动的网，简称<code>AOE</code>(<code>Activity On Edge</code>)网。AOE网中没有入边的顶点称为始点（或源点），没有出边的顶点称为终点（或汇点）。</li>
</ul>
<p>如下图的 <code>V...</code>表示事件，<code>a...</code>表示活动。<br><img src="images/g1.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>对比<code>AOV</code> (<code>Activity On Vertex Network</code>)网: 用顶点表示活动，用弧表示活动间的优先关系的有向图。</p>
</blockquote>
<ul>
<li><code>AOE</code>网可用来估算工程的完成时间，对于<code>AOE</code>网，有两个关键的问题:<ul>
<li>① 完成整个工程至少需要多少时间？</li>
<li>② 哪些活动是影响工程进度的关键？（或者说，为缩短完成工程所需要的时间，应该加快哪些活动 ?）</li>
</ul>
</li>
</ul>
<p><font color = purple>性质:</p>
<ul>
<li><p>只有在某顶点所代表的事件发生后，从该顶点出发的各活动才能开始；</p>
</li>
<li><p>只有在进入某顶点的各活动都结束，该顶点所代表的事件才能发生。</p>
</li>
</ul>
<h5 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h5><ul>
<li><p>在<code>AOE</code>网中，从始点到终点具有<font color = red>最大路径长度（该路径上的各个活动所持续的时间之和）的路径称为关键路径</font> (<code>ee[ai]=le[ai]</code>(<font color = blue>活动最早开始时间和最晚开始时间相等（没有一点商量的余地）</font>))，在关键路径上的活动叫关键活动。</p>
</li>
<li><p>由于<code>AOE</code>网中的某些活动能够同时进行，故完成整个工程所必须花费的时间应该为<font color = red>始点到终点的最大路径长度。关键路径长度是整个工程所需的最短工期。</font></p>
</li>
</ul>
<h5 id="关键路径相关的四个量"><a href="#关键路径相关的四个量" class="headerlink" title="关键路径相关的四个量"></a>关键路径相关的四个量</h5><ul>
<li>事件的最早发生时间<code>ev</code>(<code>earliest time of vertex</code>): 即顶点<code>Vk</code>的最早发生时间。</li>
<li>事件的最晚发生时间<code>lv</code>(<code>latest time of vertex</code>)  : 即顶点<code>Vk</code>的最晚发生时间。(<font color = green>也就是每个顶点对应的事件最晚需要开始的时间，超出此时间将会延误整个工期。</font>)</li>
<li>活动的最早开工时间<code>ee</code>(<code>earliest time of edge</code>): 即边<code>ak</code>的最早发生时间。</li>
<li>活动的最晚开工时间<code>le</code>(<code>latest time of edge</code>): 即弧<code>ak</code>的最晚发生时间。(<font color = green>也就是不推迟工期的最晚开工时间。</font>)</li>
</ul>
<p><font color = blue>只要求出了这四个量。然后根据活动最早开工时间<code>ee[ak]</code>和活动最晚开工时间<code>le[ak]</code>相等判断<code>ak</code>是否是关键活动(确定关键路径)。</font></p>
<h5 id="四个量的求解"><a href="#四个量的求解" class="headerlink" title="四个量的求解"></a>四个量的求解</h5><p><font color = purple><strong>①事件的最早发生时间<code>ev</code></strong></p>
<ul>
<li><code>ev[k]</code>是指从始点开始到顶点<code>vk</code>的<font color = blue>最大路径长度</font>。这个长度决定了所有从顶点<code>vk</code>发出的活动能够开工的最早时间。</li>
<li>要想求得当前的<code>ev[k]</code>，必须保证之前经过的顶点也是最大的路径，所以这是一个动态规划问题，转移方程<code>ev[k] = max&#123;ev[j] + lev&lt;Vj, Vk&gt; &#125;</code>（其中<code>Vj</code>就是<code>Vk</code>的所有前一个事件(顶点)）。</li>
<li>要想求出上面的<code>ev</code>数组，由于<code>Vk</code>发生之前要发生<code>Vj</code>，所以我们可以使用拓扑排序来辅助这一过程，也就是说， 求事件的最早发生时间<code>ev</code>的过程，就是从头至尾找拓扑序列，然后顺便维护<code>ev</code>数组的过程。</li>
</ul>
<p><img src="images/g2.png" alt="在这里插入图片描述"></p>
<p>看一个求解的例子:<br><img src="images/g3.png" alt="在这里插入图片描述"></p>
<ul>
<li><code>V0</code>最早发生时间是<code>0</code>时刻，即<code>ev[0] = 0</code>；</li>
<li><code>V1</code>最早发生时间是当<code>a0</code>完成后，也就是<code>ev[1] = 0 + a0 = 6</code>；</li>
<li>同<code>V1</code>，<code>V2 = 4、V3 = 5</code>；</li>
<li><code>V4</code>和前四个不同，前面有两条路径<code>V0 ~ V1 ~ V4</code>、<code>V0 ~ V2 ~ V4</code>到达<code>V4</code>，但是更长的一条是第一条<code>V0 ~ V1 ~ V4</code>，所以取更大<code>max</code>的，即<code>ev[4] = 7</code>；</li>
<li>后面的<code>V7</code>、<code>V8</code>和<code>V4</code>同理。</li>
</ul>
<p> <font color = purple><strong>②事件的最晚发生时间<code>lv</code></strong></p>
<ul>
<li><code>lv[k]</code>是指在不推迟整个工期的前提下,事件<code>vk</code>允许的最晚发生时间。</li>
<li>和<code>ev</code>相反，求<code>lv</code>数组是从<font color = blue>终点</font>开始求，<code>lv[n-1] = ev[n-1]</code>，然后对于前面的顶点，也是采用动态规划的方式，<code>lv[k] = min&#123; lv[j] - len&lt;Vk, Vj&gt;&#125;</code>；</li>
</ul>
<p><img src="images/g4.png" alt="在这里插入图片描述"><br><img src="images/g5.png" alt="在这里插入图片描述"><br><font color = purple><strong>③活动的最早发生时间<code>ee</code></strong></p>
<p>这个最简单：　</p>
<ul>
<li>因为活动<code>ai</code>是由弧<code>&lt;vk , vj&gt;</code>表示，则活动<code>ai</code>的最早开始时间应等于事件<code>vk</code>的最早发生时间。因此，有：<code>ee[i]=ev[k]</code></li>
</ul>
<p><font color = purple><strong>④活动的最早发生时间<code>le</code></strong></p>
<ul>
<li>活动<code>ai</code>的最晚开始时间是指，在不推迟整个工期的前提下， <code>ai</code>必须开始的最晚时间。</li>
<li>若<code>ai</code>由弧<code>&lt;vk，vj&gt;</code>表示，则<code>ai</code>的最晚开始时间要保证事件<code>vj</code>的最迟发生时间不拖后。因此，有：<code>le[ai]=lv[j]-len&lt;vk,vj&gt;</code>；</li>
</ul>
<p><img src="images/g6.png" alt="在这里插入图片描述"></p>
<h5 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h5><p>这里是按照上面的图(索引从<code>0</code>开始)，也可以按照索引从<code>1</code>开始: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CriticalPathMethod2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] in;     <span class="comment">// 入度</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] ev, lv; <span class="comment">// 事件(顶点)的最早，最晚时间</span></span><br><span class="line">        <span class="keyword">public</span> ArrayList&lt;Edge&gt; g[];</span><br><span class="line">        <span class="keyword">public</span> Stack&lt;Integer&gt;vStack; <span class="comment">//存拓扑排序的顶点</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.n = n;</span><br><span class="line">            in = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            g = <span class="keyword">new</span> ArrayList[n];</span><br><span class="line">            ev = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            lv = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            vStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                g[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                ev[i] = <span class="number">0</span>;</span><br><span class="line">                lv[i] = <span class="number">0</span>;</span><br><span class="line">                in[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> to;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> w;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.to = to;</span><br><span class="line">            <span class="keyword">this</span>.w = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**求事件的最早发生时间ev的过程，就是从头至尾找拓扑序列的过程。**/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortedTopology</span><span class="params">(Graph G)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(G.in[i] == <span class="number">0</span>)</span><br><span class="line">                queue.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> curNode = queue.poll();</span><br><span class="line">            G.vStack.push(curNode);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.g[curNode].size(); i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> to = G.g[curNode].get(i).to;</span><br><span class="line">                <span class="keyword">int</span> w = G.g[curNode].get(i).w;</span><br><span class="line">                <span class="keyword">if</span>(--G.in[to] == <span class="number">0</span>)</span><br><span class="line">                    queue.add(to);</span><br><span class="line">                <span class="comment">//ev事件最早发生: ve[to] = max&#123;ev[curNode] + len&lt;V[curNode],V[to]&gt;)&#125;</span></span><br><span class="line">                <span class="keyword">if</span>(G.ev[curNode] + w &gt; G.ev[to])  <span class="comment">// 更新的不是curNode，而是to</span></span><br><span class="line">                    G.ev[to] = G.ev[curNode] + w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;ev(事件最早)数组: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.n; i++)</span><br><span class="line">            System.out.print(G.ev[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">criticalPath</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.n; i++)</span><br><span class="line">            G.lv[i] = G.ev[G.n-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(!G.vStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> curNode = G.vStack.pop();</span><br><span class="line">            <span class="comment">//lv[curNode] = min&#123;lv[to] - len&lt;V[curNode],V[to]&gt;&#125;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.g[curNode].size(); i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> to = G.g[curNode].get(i).to;</span><br><span class="line">                <span class="keyword">int</span> w = G.g[curNode].get(i).w;</span><br><span class="line">                <span class="keyword">if</span>(G.lv[to] - w &lt; G.lv[curNode]) <span class="comment">//注意更新的不是 to 而是 curNode</span></span><br><span class="line">                    G.lv[curNode] = G.lv[to] - w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;lv(事件最迟)数组: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.n; i++)</span><br><span class="line">            System.out.print(G.lv[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求解活动最早、最晚发生时间</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ee, le; <span class="comment">//活动(边)最早、晚发生时间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;关键活动(边): &lt;左端点,右端点&gt;: 权值&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.n; v++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.g[v].size(); i++)&#123;</span><br><span class="line">                ee = G.ev[v];       <span class="comment">// 活动ai 由&lt;Vk, Vj&gt;组成，则ai(ee) = ev[k] --&gt; 活动最早发生就是前面的事件最早发生</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> to = G.g[v].get(i).to;</span><br><span class="line">                <span class="keyword">int</span> w = G.g[v].get(i).w;</span><br><span class="line"></span><br><span class="line">                le = G.lv[to] - w;  <span class="comment">// 活动ai 由&lt;Vk, Vj&gt;组成，则ai(le) = lv[j] - len&lt;Vk, Vj&gt;</span></span><br><span class="line">                <span class="keyword">if</span>(ee == le)   <span class="comment">//关键活动</span></span><br><span class="line">                    System.out.format(<span class="string">&quot;&lt;V%d,V%d&gt;: %d\n&quot;</span>, v, to, w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line">        <span class="keyword">int</span> n = cin.nextInt();</span><br><span class="line">        <span class="keyword">int</span> m = cin.nextInt();</span><br><span class="line"></span><br><span class="line">        Graph G = <span class="keyword">new</span> Graph(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> from = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> to = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> w = cin.nextInt();</span><br><span class="line">            G.g[from].add(<span class="keyword">new</span> Edge(to, w));</span><br><span class="line">            G.in[to]++;</span><br><span class="line">        &#125;</span><br><span class="line">        sortedTopology(G); <span class="comment">//拓扑排序求 G.ev : 每个顶点(事件)的最早发生时间</span></span><br><span class="line">        criticalPath(G); <span class="comment">// 求解关键路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上图的测试结果:<br><img src="images/g7.png" alt="在这里插入图片描述"></p>
<hr>
<h3 id="Hdu4109-Instrction-Arrangement题解"><a href="#Hdu4109-Instrction-Arrangement题解" class="headerlink" title="Hdu4109-Instrction Arrangement题解"></a><font color  = red id = "2">Hdu4109-Instrction Arrangement题解</h3><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4109">题目链接</a></h4><h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>给你<code>n</code>和<code>m</code>代表编号<code>0 ~ n-1</code>个任务(顶点)，和<code>m</code>条关系(边)，每条关系由<code>X、Y、Z</code>，代表想要完成<code>Y</code>必须先完成<code>X</code>并花费<code>Z</code>个时间、<code>CPU</code>可以同时完成多个任务处理，一次花费一个单位时间。问完成<code>0 ~ n-1</code>个任务需要多少时间。</p>
<p><img src="images/g8.png" alt="在这里插入图片描述"></p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><ul>
<li>这个比关键路径更加简单，其实就是求一个<code>ev</code>数组的最大值；</li>
<li>也就是求这个图(<font color = red>可能不连通，但是我们求一个最大值即可</font>)这些连通分量的最长路径长度的最大值.</li>
<li>所以我们只需要通过拓扑排序求出<code>ev</code>数组即可。</li>
<li>值得注意的是，因为这里不是<font color = red>“时刻”</font>，所以起点不是<code>0</code>，而是<code>1</code>；<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] in;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] ev;</span><br><span class="line">        <span class="keyword">public</span> ArrayList&lt;Edge&gt; g[];</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.n = n;</span><br><span class="line">            in = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            g = <span class="keyword">new</span> ArrayList[n];</span><br><span class="line">            ev = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                in[i] = <span class="number">0</span>;</span><br><span class="line">                g[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                ev[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> to;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> w;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.to = to;</span><br><span class="line">            <span class="keyword">this</span>.w = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**求事件的最早发生时间ev的过程，就是从头至尾找拓扑序列的过程。**/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortedTopology</span><span class="params">(Graph G)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(G.in[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.add(i);</span><br><span class="line">                G.ev[i] = <span class="number">1</span>; <span class="comment">// this is important   不是时间，而是CPU的花费，所以初始化不是0而是1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> curNode = queue.poll();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.g[curNode].size(); i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> to = G.g[curNode].get(i).to;</span><br><span class="line">                <span class="keyword">int</span> w = G.g[curNode].get(i).w;</span><br><span class="line">                <span class="keyword">if</span>(--G.in[to] == <span class="number">0</span>)</span><br><span class="line">                    queue.add(to);</span><br><span class="line">                <span class="comment">//ev事件最早发生: ve[to] = max&#123;ev[curNode] + len&lt;V[curNode],V[to]&gt;)&#125;</span></span><br><span class="line">                <span class="keyword">if</span>(G.ev[curNode] + w &gt; G.ev[to])  <span class="comment">// 更新的不是curNode，而是to</span></span><br><span class="line">                    G.ev[to] = G.ev[curNode] + w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line">        <span class="keyword">while</span>(cin.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> m = cin.nextInt();</span><br><span class="line">            Graph G = <span class="keyword">new</span> Graph(n);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> from = cin.nextInt();</span><br><span class="line">                <span class="keyword">int</span> to = cin.nextInt();</span><br><span class="line">                <span class="keyword">int</span> w = cin.nextInt();</span><br><span class="line">                G.g[from].add(<span class="keyword">new</span> Edge(to, w));</span><br><span class="line">                G.in[to]++;</span><br><span class="line">            &#125;</span><br><span class="line">            sortedTopology(G);</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.n; i++)</span><br><span class="line">                res = Math.max(res, G.ev[i]);</span><br><span class="line">            System.out.println(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Graph</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言基础知识总结(一)</title>
    <url>/2021/10/01/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93(%E4%B8%80)/</url>
    <content><![CDATA[<h2 id="C语言基础知识总结-一"><a href="#C语言基础知识总结-一" class="headerlink" title="C语言基础知识总结(一)"></a>C语言基础知识总结(一)</h2><ul>
<li><a href="#%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C">编译、运行</a><ul>
<li><a href="#%E7%BC%96%E8%AF%91%E6%A0%BC%E5%BC%8F">编译格式</a></li>
<li><a href="#c%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B">C语言编译过程</a></li>
<li><a href="#cpu%E5%AF%84%E5%AD%98%E5%99%A8">CPU、寄存器</a></li>
<li><a href="#%E5%85%B3%E4%BA%8Evs%E7%9A%84c4996%E9%94%99%E8%AF%AF">关于VS的C4996错误</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E5%88%B6%E5%8E%9F%E5%8F%8D%E8%A1%A5%E7%A0%81">进制，原、反、补码</a><ul>
<li><a href="#%E8%BF%9B%E5%88%B6%E7%9B%B8%E5%85%B3">进制相关</a></li>
<li><a href="#%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81">原码、反码、补码</a></li>
<li><a href="#%E5%8E%9F%E7%A0%81%E5%92%8C%E8%A1%A5%E7%A0%81%E4%BA%92%E6%8D%A2">原码和补码互换</a></li>
<li><a href="#%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB">有符号和无符号的区别</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%96%E5%80%BC%E5%88%86%E6%9E%90">数据类型取值分析</a></li>
<li><a href="#%E8%B6%8A%E7%95%8C%E9%97%AE%E9%A2%98">越界问题</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BF%90%E7%AE%97%E7%AC%A6%E7%AD%89%E5%9F%BA%E7%A1%80">数据类型、运算符等基础</a><ul>
<li><a href="#c%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">C语言数据类型</a></li>
<li><a href="#sizeof%E5%85%B3%E9%94%AE%E5%AD%97">sizeof关键字</a></li>
<li><a href="#char%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-char%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%B0%B1%E6%98%AF%E4%B8%80%E4%B8%AA1%E5%AD%97%E8%8A%82%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%95%B4%E5%9E%8B">char数据类型-char的本质就是一个1字节大小的整型</a></li>
<li><a href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8D%E5%87%86%E7%A1%AE%E7%B1%BB%E5%9E%8B%E9%99%90%E5%AE%9A%E7%AC%A6">浮点数不准确、类型限定符</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E9%97%AE%E9%A2%98">字符的输入问题</a></li>
<li><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%85%88%E7%BA%A7">运算符以及优先级</a></li>
<li><a href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">类型转换</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E7%BB%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0">数组、字符串、函数</a><ul>
<li><a href="#%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F">数组初始化的几种方式</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2">字符数组与字符串</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%87%BA%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E4%B8%80%E7%B3%BB%E5%88%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98">字符串输出乱码问题以及一系列字符串要注意的问题</a></li>
<li><a href="#%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90">随机数生成</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0">字符串相关函数</a></li>
<li><a href="#%E5%87%BD%E6%95%B0">函数</a></li>
</ul>
</li>
</ul>
<hr>
<h3 id="编译、运行"><a href="#编译、运行" class="headerlink" title="编译、运行"></a>编译、运行</h3><h5 id="编译格式"><a href="#编译格式" class="headerlink" title="编译格式"></a>编译格式</h5><p> <code>gcc -o main main.cpp</code>生成<code>main</code>可执行文件，可以有两种运行方式: </p>
<ul>
<li>当前目录运行<code>./main</code>；</li>
<li><font color = red>绝对路径运行</font>，例如<code>/home/zxzxin/C/main</code>，要注意的是绝对路 径没有<code>.</code>，因为<code>.</code>代表的是当前路径，也就是说我们只需要<font color = blue>写上完整路径即可；</font> </li>
</ul>
<p> 编译命令格式 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc [-option] ... &lt;filename&gt;   //c语言编译</span><br><span class="line">g++ [-option] ... &lt;filename&gt;   //c++编译</span><br></pre></td></tr></table></figure>
<ul>
<li>gcc、g++编译常用选项说明：</li>
</ul>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-o file</td>
<td>指定生成的输出文件名为file</td>
</tr>
<tr>
<td>-E</td>
<td>只进行预处理</td>
</tr>
<tr>
<td>-S(大写)</td>
<td>只进行预处理和编译</td>
</tr>
<tr>
<td>-c(小写)</td>
<td>只进行预处理、编译和汇编</td>
</tr>
</tbody></table>
<ul>
<li>注意下面的两种方式生成可执行文件的效果是一样的: </li>
</ul>
<p><img src="images/c1.png" alt="在这里插入图片描述"><br><strong>平台问题:</strong><br>① Linux编译后的可执行程序只能在Linux运行，Windows编译后的程序只能在Windows下运行；<br>②64位的Linux编译后的程序只能在64位Linux下运行，32位Linux编译后的程序只能在32位的Linux运行；<br>③<font color = blue>64位的Windows编译后的程序只能在64位Windows下运行，32位Windows编译后的程序<font color = red>可以</font>在64位的Windows运行；</font></p>
<p><strong>可以在程序中嵌套<code>Linux</code>的命令，会在可执行文件的对应目录执行相应的命令；</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before\n&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;ls -alh&quot;</span>); <span class="comment">// system内放置 linux的命令  甚至也可以在&quot;&quot;内放 ./a.out这种，也可以调用</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行: </p>
<p><img src="images/c2.png" alt="在这里插入图片描述"></p>
<ul>
<li><code>#include&lt; &gt;</code> 与 <code>#include &quot;&quot;</code>的区别：<br>①<code>&lt; &gt;</code> 表示系统直接按系统指定的目录检索；<br>② <code>&quot;&quot;</code> 表示系统先在 <code>&quot;&quot;</code> 指定的路径(没写路径代表当前路径)查找头文件，如果找不到，再按系统指定的目录检索；</li>
</ul>
<h5 id="C语言编译过程"><a href="#C语言编译过程" class="headerlink" title="C语言编译过程"></a>C语言编译过程</h5><p>C代码编译成可执行程序经过4步：</p>
<ul>
<li>1）预处理：宏定义展开、头文件展开、条件编译等，同时将代码中的注释删除，这里并不会检查语法；</li>
<li>2）编译：检查语法，将预处理后文件编译生成汇编文件； </li>
<li>3）汇编：将汇编文件生成目标文件(二进制文件)；</li>
<li>4）链接：C语言写的程序是需要依赖各种库的，所以编译之后还需要把库链接到最终的可执行程序中去；</li>
</ul>
<p><img src="images/c3.png" alt="在这里插入图片描述"></p>
<p><img src="images/c4.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20181106195818281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><font color = red>然而一般编译的时候都是使用的一步编译</font>。 (但是这样还是经过：<font color = red>预处理、编译、汇编、链接的过程。)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc hello.c -o hello</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Linux</code>下查找程序所依赖的动态库</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ldd hello</span><br></pre></td></tr></table></figure>
<h5 id="CPU、寄存器"><a href="#CPU、寄存器" class="headerlink" title="CPU、寄存器"></a>CPU、寄存器</h5><ul>
<li>寄存器是CPU内部最基本的存储单元；</li>
<li>CPU对外是通过总线(地址、控制、数据)来和外部设备交互的，总线的宽度是8位，同时CPU的寄存器也是8位，那么这个CPU就叫8位CPU</li>
<li>CPU计算时，先预先把要用的数据从硬盘读到内存，然后再把即将要用的数据读到寄存器。于是<code> CPU&lt;---&gt;寄存器&lt;---&gt;内存</code>，这就是它们之间的信息交换，看下面的图片说明:  </li>
</ul>
<p><font color = red> 寄存器、缓存、内存三者关系: </p>
<p><img src="images/c5.png" alt="在这里插入图片描述"></p>
<h5 id="关于VS的C4996错误"><a href="#关于VS的C4996错误" class="headerlink" title="关于VS的C4996错误"></a>关于VS的C4996错误</h5><ul>
<li>由于微软在VS2013中不建议再使用C的传统库函数scanf,strcpy,sprintf等，所以直接使用这些库函数会提示C4996错误。VS建议采用带<code>_s</code>的函数，如<code>scanf_s</code>、<code>strcpy_s</code>，但这些并不是标准C函数。</li>
<li>要想继续使用此函数，需要在源文件中添加以下两个指令中的一个就可以避免这个错误提示：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS     <span class="comment">//这个宏定义最好要放到.c文件的第一行</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable:4996)	<span class="comment">//或者使用这个</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="进制，原、反、补码"><a href="#进制，原、反、补码" class="headerlink" title="进制，原、反、补码"></a>进制，原、反、补码</h3><h5 id="进制相关"><a href="#进制相关" class="headerlink" title="进制相关"></a>进制相关</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">123</span>;		<span class="comment">//十进制方式赋</span></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0123</span>;		<span class="comment">//八进制方式赋值， 以数字0开</span></span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0xABC</span>;	<span class="comment">//十六进制方式赋值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果在printf中输出一个十进制数那么用%d，八进制用%o，十六进制是%x</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;十进制：%d\n&quot;</span>,a );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;八进制：%o\n&quot;</span>, b);	<span class="comment">// %o,为字母o,不是数字</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;十六进制：%x\n&quot;</span>, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">十进制：<span class="number">123</span></span><br><span class="line">八进制：<span class="number">123</span></span><br><span class="line">十六进制：abc</span><br></pre></td></tr></table></figure>

<h5 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h5><h6 id="原码"><a href="#原码" class="headerlink" title="原码"></a><font color = green>原码</h6><p>一个数的原码(原始的二进制码)有如下特点：</p>
<ul>
<li>最高位做为符号位，0表示正,为1表示负；</li>
<li>其它数值部分就是数值本身绝对值的二进制数；</li>
<li><font color = blue>负数的原码是在其绝对值(相反数)的基础上，最高位变为1；</li>
</ul>
<p>例如：(以一个字节(8bit)来看)　<br>|十进制数|原码|<br>|–|–|<br>|+15|0000 1111|<br>|-15|1000 1111|<br>|+0|0000 0000|<br>|-0|1000 0000|</p>
<p><font color = red>原码存储导致2个问题：</p>
<ul>
<li>0有两种存储方式；</li>
<li>正数和负数相加，结果不正确（<font color = blue>计算机只会加不会减</font>）；</li>
</ul>
<p>例如:<br>以<font color = blue>原码</font>来算不同符号的数: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="number">-1</span> = <span class="number">1</span> + <span class="number">-1</span></span><br><span class="line">  <span class="number">1</span>： <span class="number">0000</span> <span class="number">0001</span></span><br><span class="line"> <span class="number">-1</span>： <span class="number">1000</span> <span class="number">0001</span></span><br><span class="line">      <span class="number">1000</span> <span class="number">0010</span> = <span class="number">-2</span>   <span class="comment">//答案错误</span></span><br></pre></td></tr></table></figure>

<h6 id="反码"><a href="#反码" class="headerlink" title="反码"></a><font color = green>反码</h6><ul>
<li>正数的原码和反码是一样；</li>
<li>对于负数，先求原码，<font color = red>在原码基础上，符号位不变，其它位取反（0为1， 1变0）；</li>
</ul>
<p>例如：(以一个字节(8bit)来看)　</p>
<table>
<thead>
<tr>
<th>十进制数</th>
<th>原码</th>
<th>反码</th>
</tr>
</thead>
<tbody><tr>
<td>+15</td>
<td>0000 1111</td>
<td>0000 1111</td>
</tr>
<tr>
<td>-15</td>
<td>1000 1111</td>
<td>1111 0000</td>
</tr>
<tr>
<td>+0</td>
<td>0000 0000</td>
<td>0000 0000</td>
</tr>
<tr>
<td>-0</td>
<td>1000 0000</td>
<td>1111 1111</td>
</tr>
</tbody></table>
<p>反码计算两个符号不同的数:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="number">-1</span> = <span class="number">1</span> + <span class="number">-1</span></span><br><span class="line"> <span class="number">1</span>：<span class="number">0000</span> <span class="number">0001</span></span><br><span class="line"><span class="number">-1</span>：<span class="number">1111</span> <span class="number">1110</span></span><br><span class="line">    <span class="number">1111</span> <span class="number">1111</span> = <span class="number">-0</span>   <span class="comment">//答案是对的</span></span><br></pre></td></tr></table></figure>

<p><font color = blue>但是反码还是没有解决</font><font color = red>0有两种存储方式</font>的问题。 </p>
<h6 id="补码"><a href="#补码" class="headerlink" title="补码"></a><font color = green>补码</h6><p><font color = red>综上，计算机存储数字以补码方式存储（为了解决负数的存储）； </p>
<p>补码特点: </p>
<ul>
<li>对于正数，原码、反码、补码相同；</li>
<li>对于负数，其补码为它的反码加1；</li>
</ul>
<p>例如：(以一个字节(8bit)来看)　</p>
<table>
<thead>
<tr>
<th>十进制数</th>
<th>原码</th>
<th>反码</th>
<th>补码</th>
</tr>
</thead>
<tbody><tr>
<td>+15</td>
<td>0000 1111</td>
<td>0000 1111</td>
<td>0000 1111</td>
</tr>
<tr>
<td>-15</td>
<td>1000 1111</td>
<td>1111 0000</td>
<td>1111 0001</td>
</tr>
<tr>
<td>+0</td>
<td>0000 0000</td>
<td>0000 0000</td>
<td>0000 0000</td>
</tr>
<tr>
<td>-0</td>
<td>1000 0000</td>
<td>1111 1111</td>
<td>0000 0000</td>
</tr>
</tbody></table>
<p>补码计算: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="number">-1</span> = <span class="number">1</span> + <span class="number">-1</span></span><br><span class="line"> <span class="number">1</span>：<span class="number">0000</span> <span class="number">0001</span></span><br><span class="line"><span class="number">-1</span>：<span class="number">1111</span> <span class="number">1111</span></span><br><span class="line">   <span class="number">10000</span> <span class="number">0000</span>（最高位丢弃） = <span class="number">0000</span> <span class="number">0000</span>  <span class="comment">//注意1字节，所以丢弃最高位</span></span><br></pre></td></tr></table></figure>

<p><font color = red>记得一个原则: </p>
<ul>
<li>十进制数  –&gt;  站在用户的角度  –&gt; 原码；</li>
<li>二进制、八进制、十六进制   –&gt;  站在计算机角度  –&gt; 补码；</li>
</ul>
<h5 id="原码和补码互换"><a href="#原码和补码互换" class="headerlink" title="原码和补码互换"></a>原码和补码互换</h5><p><font color = purple>原码求补码：</p>
<ul>
<li>①. 先求原码: 最高位符号位，其它位就是二进制；</li>
<li>②. 在①基础上，符号位不变，其它位取反；</li>
<li>③. 在②基础上加1；</li>
</ul>
<p><font color = purple>补码求原码：</p>
<ul>
<li>①.  先得到补码；</li>
<li>②.  求补码的反码，符号位不变，其它位取反；</li>
<li>③.   在②基础上加1(<font color = blue>注意不要人为的相乘相反是减)</li>
</ul>
<p><font color  =red>综上，在计算机系统中，数值一律用补码来存储，主要原因是：</p>
<ul>
<li>统一了零的编码；</li>
<li>将符号位和其它位统一处理；</li>
<li>将减法运算转变为加法运算；</li>
<li>两个用补码表示的数相加时，如果最高位(符号位)有进位，则进位被舍弃；</li>
</ul>
<p>相关案例计算转换: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a = <span class="number">0x81</span>; <span class="comment">// 计算机的角度(补码)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>,a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> b = <span class="number">0xe5</span>;<span class="comment">//计算机的角度(补码)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %d\n&quot;</span>,b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> c = <span class="number">0x6f</span>; <span class="comment">//计算机的角度(补码)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c = %d\n&quot;</span>,c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> d = <span class="number">-123</span>; <span class="comment">//人类的角度 --&gt; 看成原码</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d = %x\n&quot;</span>,d);<span class="comment">//输出16进制(计算机的角度)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a = <span class="number">-127</span></span><br><span class="line">b = <span class="number">-27</span></span><br><span class="line">c = <span class="number">111</span></span><br><span class="line">d = ffffff85</span><br></pre></td></tr></table></figure>
<p><font color = red>对于上面程序的分析:</font> </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二进制、八进制、十六进制，站在计算机角度，补码</span></span><br><span class="line"><span class="comment">//0x81转为为二进制位1000 0001，最高位为1，说明是负数</span></span><br><span class="line"><span class="keyword">char</span> a = <span class="number">0x81</span>;</span><br><span class="line">补码：<span class="number">1000</span> <span class="number">0001</span></span><br><span class="line">反码：<span class="number">1111</span> <span class="number">1110</span></span><br><span class="line">原码：<span class="number">1111</span> <span class="number">1111</span> = <span class="number">-127</span> </span><br><span class="line"><span class="comment">//10进制数，站在用户的角度，原码</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a); <span class="comment">//-127</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制、八进制、十六进制，站在计算机角度，补码</span></span><br><span class="line"><span class="comment">//0xe5二进制为1110 0101，最高位为1，说明是负数，它是负数的补码</span></span><br><span class="line"><span class="keyword">char</span> b = <span class="number">0xe5</span>;</span><br><span class="line">补码：<span class="number">1110</span> <span class="number">0101</span></span><br><span class="line">反码：<span class="number">1001</span> <span class="number">1010</span></span><br><span class="line">原码：<span class="number">1001</span> <span class="number">1011</span> = <span class="number">-27</span></span><br><span class="line"><span class="comment">//10进制数，站在用户的角度，原码</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b);<span class="comment">// -27</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">0x6f</span>的二级制为<span class="number">0110</span> <span class="number">1111</span>，最高位为<span class="number">0</span>，它是正数</span><br><span class="line"><span class="keyword">char</span> c = <span class="number">0x6f</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, c);<span class="comment">// 111 原码、反码、补码都相同</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//10进制数，站在用户的角度，原码</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">-123</span>;<span class="comment">//注意这个是十进制，所以直接就是原码</span></span><br><span class="line">原码：<span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0111</span> <span class="number">1011</span></span><br><span class="line">反码：<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1000</span> <span class="number">0100</span></span><br><span class="line">补码：<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1000</span> <span class="number">0101</span></span><br><span class="line">	   f     f   f    f     f   f    <span class="number">8</span>     <span class="number">5</span></span><br><span class="line">%x，默认以<span class="number">4</span>个字节(<span class="number">32</span>位)大小打印</span><br><span class="line"><span class="comment">//二进制、八进制、十六进制，站在计算机角度，补码</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, a);<span class="comment">// 16进制打印 ffffff85</span></span><br></pre></td></tr></table></figure>

<h5 id="有符号和无符号的区别"><a href="#有符号和无符号的区别" class="headerlink" title="有符号和无符号的区别"></a>有符号和无符号的区别</h5><ul>
<li> 有符号，最高位是符号位，如果是1代表为负数，如果为0代表为正数；</li>
<li>无符号，最高位不是符号位，是数的一部分，无符号不可能是负数；</li>
</ul>
<p>测试: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1000 0000 0000 0000 0000 0000 0111 1011</span></span><br><span class="line">    <span class="comment">// 8000007b</span></span><br><span class="line">    <span class="comment">// %d按照有符号数来打印  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">0x8000007b</span>);</span><br><span class="line">    <span class="comment">// %u按照无符号数打印</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, <span class="number">0x8000007b</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// signed 和 unsigned</span></span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> b = <span class="number">-10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意输出结果　以%d 为准，%d表示按照有符号数来输出    </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> c = <span class="number">0x8000007b</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c[有符号] = %d\n&quot;</span>,c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c[无符号] = %u\n&quot;</span>,c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">-2147483525</span></span><br><span class="line"><span class="number">2147483771</span></span><br><span class="line">c[有符号] = <span class="number">-2147483525</span></span><br><span class="line">c[无符号] = <span class="number">2147483771</span></span><br></pre></td></tr></table></figure>
<p>分析: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0111</span> <span class="number">1011</span>   <span class="comment">//二进制</span></span><br><span class="line"><span class="number">8000007b</span>   <span class="comment">//16进制  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//有符号   ---&gt;   %d, 默认以有符号的方式打印</span></span><br><span class="line">补码：<span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0111</span> <span class="number">1011</span></span><br><span class="line">反码：<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1000</span> <span class="number">0100</span></span><br><span class="line">原码：<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1000</span> <span class="number">0101</span></span><br><span class="line">     - <span class="number">7</span>   f    f    f    f    f    <span class="number">8</span>    <span class="number">5</span> = <span class="number">-2147483525</span></span><br><span class="line">										     <span class="number">-2147483525</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">0x8000007b</span>); <span class="comment">//-2147483525</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//无符号(最高位看做是数的一部分)  ---&gt;    %u, 以无符号的方式打印</span></span><br><span class="line"><span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0111</span> <span class="number">1011</span></span><br><span class="line"><span class="number">8000007b</span> = <span class="number">2147483771</span></span><br><span class="line">		   <span class="number">2147483771</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, <span class="number">0x8000007b</span>); <span class="comment">//2147483771</span></span><br></pre></td></tr></table></figure>

<h5 id="数据类型取值分析"><a href="#数据类型取值分析" class="headerlink" title="数据类型取值分析"></a>数据类型取值分析</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">数据类型范围（站在<span class="number">10</span>进制角度，原码）：</span><br><span class="line"><span class="keyword">char</span> <span class="number">1</span>个字节（<span class="number">8</span>位，<span class="number">8b</span>it）</span><br><span class="line">有符号的范围：</span><br><span class="line">正数：</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> ~ <span class="number">0111</span> <span class="number">1111</span></span><br><span class="line"><span class="number">0</span>             <span class="number">127</span></span><br><span class="line"></span><br><span class="line">负数：</span><br><span class="line"><span class="number">1000</span> <span class="number">0000</span> ~ <span class="number">1111</span> <span class="number">1111</span></span><br><span class="line"><span class="number">-0</span> ~ <span class="number">-127</span></span><br><span class="line"></span><br><span class="line">注意这里比较特使：</span><br><span class="line"><span class="number">-0</span> 当做 <span class="number">-128</span>使用</span><br><span class="line"><span class="number">-128</span>：</span><br><span class="line">原码：  <span class="number">1</span> <span class="number">1000</span> <span class="number">0000</span> </span><br><span class="line">反码：  <span class="number">1</span> <span class="number">0111</span> <span class="number">1111</span></span><br><span class="line">补码：  <span class="number">1</span> <span class="number">1000</span> <span class="number">0000</span></span><br><span class="line">这个很特别: <span class="number">-128</span>的原码和补码是一样的，发现和<span class="number">0</span> (<span class="number">1000</span> <span class="number">0000</span>)也是一样的。</span><br><span class="line"></span><br><span class="line">无符号范围：</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> ~ <span class="number">1111</span> <span class="number">1111</span></span><br><span class="line"><span class="number">0</span> ~ <span class="number">255</span></span><br></pre></td></tr></table></figure>
<p>综上，char:</p>
<ul>
<li>有符号：-128 ~ 127；</li>
<li>无符号：0 ~ 255；<h5 id="越界问题"><a href="#越界问题" class="headerlink" title="越界问题"></a>越界问题</h5>赋值或者运算，记得不要越界，下面展示了越界的情况: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//有符号越界</span></span><br><span class="line">    <span class="keyword">char</span> a = <span class="number">127</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>,a);  <span class="comment">//-127</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//无符号越界</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> b = <span class="number">255</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %u\n&quot;</span>,b);  <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
输出: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">-127</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
分析: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a = <span class="number">127</span> + <span class="number">2</span>;</span><br><span class="line"><span class="number">129</span>转换为二进制：<span class="number">1000</span> <span class="number">0001</span>，这是负数补码(计算机角度)</span><br><span class="line">补码：<span class="number">1000</span> <span class="number">0001</span> </span><br><span class="line">反码：<span class="number">1111</span> <span class="number">1110</span></span><br><span class="line">原码：<span class="number">1111</span> <span class="number">1111</span>(最高位是符号位) = <span class="number">-127</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);<span class="comment">//-127</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> b = <span class="number">255</span> + <span class="number">2</span>; </span><br><span class="line"><span class="number">257</span>转化为二进制 ：<span class="number">0001</span> <span class="number">0000</span> <span class="number">0001</span> （只取后<span class="number">8</span>位）</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, b);<span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="数据类型、运算符等基础"><a href="#数据类型、运算符等基础" class="headerlink" title="数据类型、运算符等基础"></a>数据类型、运算符等基础</h3><h5 id="C语言数据类型"><a href="#C语言数据类型" class="headerlink" title="C语言数据类型"></a>C语言数据类型</h5><ul>
<li><p>数据类型的作用：编译器预算对象（变量）分配的内存空间大小。</p>
<p><img src="images/c6.png" alt="在这里插入图片描述"> </p>
</li>
</ul>
<p><strong>变量特点:</strong></p>
<ul>
<li><p><font color = red>变量在编译时为其分配相应的内存空间；</font></p>
</li>
<li><p><font color = red>可以通过其名字和地址访问相应内存；</p>
<p><img src="images/c7.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<p><strong>声明和定义的区别:</strong></p>
<ul>
<li><p><font color = blue>声明变量不需要建立存储空间，如：<code>extern int a</code>; (使用<code>extern</code>关键字)</p>
</li>
<li><p>定义变量需要建立存储空间，如：<code>int b</code>;</p>
</li>
<li><p>从广义的角度来讲声明中包含着定义，即定义是声明的一个特例，所以并非所有的声明都是定义：<br> ① <code>int b</code> 它既是声明，同时又是定义；<br> ②对于<code>extern int b</code>来讲它只是声明不是定义；</p>
</li>
<li><p><font color = blue>一般的情况下，把建立存储空间的声明称之为“定义”，而把不需要建立存储空间的声明称之为“声明”。</p>
</li>
</ul>
<h5 id="sizeof关键字"><a href="#sizeof关键字" class="headerlink" title="sizeof关键字"></a>sizeof关键字</h5><ul>
<li><code>sizeof</code>不是函数，所以不需要包含任何头文件，它的功能是<font color = red>计算一个数据类型的大小，单位为字节；</li>
<li><code>sizeof</code>的返回值为<code>size_t</code>；</li>
<li><code>size_t</code>类型在32位操作系统下是<code>unsigned int</code>，是一个无符号的整数；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">//数据类型的作用: 告诉编译器，分配此类型的变量需要多大的空间</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(char) = %u\n&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(a) = %d\n&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">long</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(long) = %u\n&quot;</span>,len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) = <span class="number">1</span></span><br><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span>(a) = <span class="number">4</span></span><br><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">long</span>) = <span class="number">8</span></span><br></pre></td></tr></table></figure>
<h5 id="char数据类型-char的本质就是一个1字节大小的整型"><a href="#char数据类型-char的本质就是一个1字节大小的整型" class="headerlink" title="char数据类型-char的本质就是一个1字节大小的整型"></a>char数据类型-char的本质就是一个1字节大小的整型</h5><ul>
<li><font color = red>内存中没有字符，只有数字；</li>
<li>一个数字，对应一个字符，这种规则就是<code>ascii</code>；</li>
<li>使用字符或数字给字符变量赋值是等价的；</li>
<li><font color = red>字符类型本质就是1个字节大小的整形；</li>
<li>字符变量实际上并不是把该字符本身放到变量的内存单元中去，而是将该字符对应的 ASCII 编码放到变量的存储单元中。</li>
</ul>
<p>测试: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch[c] = %c, ch[d] = %d\n&quot;</span>,ch, ch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> ch2 = <span class="number">97</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch2[c] = %c\n&quot;</span>, ch2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch2 - 32 = %c\n&quot;</span>,ch2 - <span class="number">32</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ch[c] = a, ch[d] = <span class="number">97</span></span><br><span class="line">ch2[c] = a</span><br><span class="line">ch2 - <span class="number">32</span> = A</span><br></pre></td></tr></table></figure>
<p><font color = blue>以及注意转义字符: </p>
<p><img src="images/c8.png" alt="在这里插入图片描述"></p>
<p>转义字符简单测试: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">&#x27;\r&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;abcdddd%cefg\n&quot;</span>,ch);</span><br><span class="line"></span><br><span class="line">    ch = <span class="string">&#x27;\b&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;12%c345\n&quot;</span>,ch);</span><br><span class="line"></span><br><span class="line">    ch = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ch); <span class="comment">// 打印&#x27; &#x27;的对应数字</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8进制转义字符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="string">&#x27;\123&#x27;</span>); <span class="comment">//8进制123 --&gt;　对应10进制83</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="string">&#x27;\x23&#x27;</span>); <span class="comment">//16进制23 --&gt; 对应10进制35</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// &#x27;\0&#x27;和0等价</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">efgdddd</span><br><span class="line"><span class="number">1345</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">83</span></span><br><span class="line"><span class="number">35</span></span><br><span class="line"><span class="number">0</span>,<span class="number">0</span></span><br></pre></td></tr></table></figure>
<h5 id="浮点数不准确、类型限定符"><a href="#浮点数不准确、类型限定符" class="headerlink" title="浮点数不准确、类型限定符"></a>浮点数不准确、类型限定符</h5><ul>
<li>浮点数不准确:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">float</span> a = <span class="number">100.9</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %f\n&quot;</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a = <span class="number">100.900002</span></span><br></pre></td></tr></table></figure>
<p>原因还是计算机按照<code>二进制</code>存储。</p>
<ul>
<li>类型限定符:</li>
</ul>
<p><img src="images/c9.png" alt="在这里插入图片描述"></p>
<h5 id="字符的输入问题"><a href="#字符的输入问题" class="headerlink" title="字符的输入问题"></a>字符的输入问题</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> ch1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入字符:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;ch1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch1 = %c\n&quot;</span>,ch1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> ch2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入字符:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;ch2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch2 = %c\n&quot;</span>,ch2);</span><br><span class="line">    <span class="comment">//输出ch2的ascii码</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch2[d] = %d\n&quot;</span>,ch2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出演示: </p>
<p><img src="images/c10.png" alt="在这里插入图片描述"></p>
<p>这个程序要特别注意: </p>
<ul>
<li>当我们输入完一个字符时，按下回车，会直接结束程序；</li>
<li>因为第二个字符在按下回车的时候已经输入完成了，也就是<code>ch2 = &#39;\n&#39;</code>；而<code>&#39;\n&#39;</code>的<code>ascii</code>码为10；</li>
</ul>
<p><img src="images/c11.png" alt="在这里插入图片描述"></p>
<p>处理上面的问题，可以使用另一个字符变量过滤掉<code>\n</code>，也可以使用<code>getchar()</code>来过滤一个字符: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> ch1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入字符:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;ch1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch1 = %c\n&quot;</span>,ch1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了处理上面的问题，可以自己用scanf处理这个回车</span></span><br><span class="line">    <span class="keyword">char</span> tmp;</span><br><span class="line">    <span class="comment">//scanf(&quot;%c&quot;,&amp;tmp); //或者使用下面的方法输入一个字符</span></span><br><span class="line">    <span class="comment">// tmp = getchar(); //或者也可以直接调用getchar()即可</span></span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> ch2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入字符:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;ch2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch2 = %c\n&quot;</span>,ch2);</span><br><span class="line">    <span class="comment">//输出ch2的ascii码</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch2[d] = %d\n&quot;</span>,ch2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="运算符以及优先级"><a href="#运算符以及优先级" class="headerlink" title="运算符以及优先级"></a>运算符以及优先级</h5><p><strong><font color  = red>运算符优先级: </font></strong></p>
<p><img src="images/c12.png" alt="在这里插入图片描述"></p>
<p><img src="images/c13.png" alt="在这里插入图片描述"></p>
<blockquote>
<ul>
<li> 另外，注意 逻辑判断中的  <font color = red>短路原则。</font></li>
</ul>
</blockquote>
<h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><ul>
<li>隐式转换: 编译器内部自动转换；</li>
<li>强制类型转换：把表达式的运算结果强制转换成所需的数据类型。</li>
<li>浮点型打印说明: 不要以为指定了打印的类型就会自动转换，必须要强制转换；</li>
<li>转换原则: <font color = red>数据类型小的往大的转换；<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------------隐式转换-----------\n&quot;</span>);</span><br><span class="line">    <span class="comment">//隐式转换</span></span><br><span class="line">    <span class="keyword">double</span> a;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//编译器内部自动转换，在第10行自动转换，其他地方b还是int</span></span><br><span class="line">    a = b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %lf\n&quot;</span>,a);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------------强制类型转换-----------\n&quot;</span>);</span><br><span class="line">    <span class="comment">//强制类型转换</span></span><br><span class="line">    <span class="keyword">double</span> c = (<span class="keyword">double</span>)<span class="number">1</span>/<span class="number">2</span>; <span class="comment">//强制将1转换成double</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c = %lf\n&quot;</span>,c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(int) = %u\n&quot;</span>,(<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------------浮点型打印说明-----------\n&quot;</span>);</span><br><span class="line">    <span class="comment">//浮点型打印说明</span></span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">11</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d[wrong] = %lf\n&quot;</span>,d); <span class="comment">//以为指定了%lf就会转换成浮点数，其实是错的</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d[right] = %lf\n&quot;</span>,(<span class="keyword">double</span>)d); <span class="comment">// 正确的打印是要强制类型转换的</span></span><br><span class="line">    <span class="keyword">double</span> e = <span class="number">88.14</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;e[wrong] = %d\n&quot;</span>,e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;e[right] = %d\n&quot;</span>,<span class="built_in"><span class="keyword">int</span></span>(e));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-------------转换原则----------\n&quot;</span>);</span><br><span class="line">    <span class="comment">//转换原则: 数据类型　小的往大的　转换</span></span><br><span class="line">    <span class="keyword">int</span> g = <span class="number">129</span>;</span><br><span class="line">    <span class="keyword">char</span> h = <span class="number">111</span>;</span><br><span class="line">    <span class="comment">//g = (int)h; // 这个是可以转换的</span></span><br><span class="line">    <span class="comment">//printf(&quot;g = %d\n&quot;,g);</span></span><br><span class="line">    h = (<span class="keyword">char</span>)g; <span class="comment">//这个转换是出错的，h会变成一个负数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;h = %d\n&quot;</span>,h);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
输出：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">------------隐式转换-----------</span><br><span class="line">a = <span class="number">10.000000</span></span><br><span class="line">------------强制类型转换-----------</span><br><span class="line">c = <span class="number">0.500000</span></span><br><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) = <span class="number">4</span></span><br><span class="line">------------浮点型打印说明-----------</span><br><span class="line">d[wrong] = <span class="number">0.000000</span></span><br><span class="line">d[right] = <span class="number">11.000000</span></span><br><span class="line">e[wrong] = <span class="number">1519177328</span></span><br><span class="line">e[right] = <span class="number">88</span></span><br><span class="line">-------------转换原则----------</span><br><span class="line">h = <span class="number">-127</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="数组、字符串、函数"><a href="#数组、字符串、函数" class="headerlink" title="数组、字符串、函数"></a>数组、字符串、函数</h3><h5 id="数组初始化的几种方式"><a href="#数组初始化的几种方式" class="headerlink" title="数组初始化的几种方式"></a>数组初始化的几种方式</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr1[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; <span class="comment">//数组的定义需要&#123;&#125;，只有在定义的时候才能初始化</span></span><br><span class="line">    <span class="keyword">int</span> arr2[<span class="number">5</span>];</span><br><span class="line">    <span class="comment">//arr2 = &#123;1,2,3,4,5&#125;; //err 这个是错误的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组全部元素初始化为 某个值</span></span><br><span class="line">    <span class="keyword">int</span> arr3[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果定义的同时 初始化，第一个[]内可以不写内容</span></span><br><span class="line">    <span class="keyword">int</span> arr4[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; <span class="comment">//编译器会根据用户初始化的元素来确定数组的大小</span></span><br><span class="line">    <span class="comment">//int arr4[]; //err //必须初始化的时候才能省略</span></span><br><span class="line">    <span class="keyword">int</span> arr5[][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;; <span class="comment">//第一个可以省略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>数组的名字代表着数组的首地址，以及使用<code>sizeof</code>来求数组长度的方法；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------------一维数组------------\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">//1. 数组名是数组首元素地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arr = %p, &amp;arr[0] = %p\n&quot;</span>, arr, &amp;arr[<span class="number">0</span>]); <span class="comment">//两个是一样的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 测试数组总的字节大小 : sizeof(数组名) 10 * 4 = 40</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(arr) = %u\n&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(arr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 得到数组长度 数组总大小/每个元素大小 (常用)</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>(arr)/<span class="built_in"><span class="keyword">sizeof</span></span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;len(arr) = %d\n&quot;</span>,len);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------------二维数组------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> arr2[<span class="number">5</span>][<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// 1. 数组名是常量，不能修改</span></span><br><span class="line">    <span class="comment">// a = 10; //err</span></span><br><span class="line">    <span class="comment">//2. sizeof(数组名),测数组的总大小 5*int[10] = 5*4*10</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(arr2) = %u\n&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(arr2));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 求行数</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in"><span class="keyword">sizeof</span></span>(arr2)/<span class="built_in"><span class="keyword">sizeof</span></span>(arr2[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;行数 = %d\n&quot;</span>,n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 求列数</span></span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in"><span class="keyword">sizeof</span></span>(arr2[<span class="number">0</span>])/<span class="built_in"><span class="keyword">sizeof</span></span>(arr2[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;列数 = %d\n&quot;</span>,m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 总个数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;总个数 = %d\n&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(arr2)/<span class="built_in"><span class="keyword">sizeof</span></span>(arr2[<span class="number">0</span>][<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">------------一维数组------------</span><br><span class="line">arr = <span class="number">0x7ffc86eac190</span>, &amp;arr[<span class="number">0</span>] = <span class="number">0x7ffc86eac190</span></span><br><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span>(arr) = <span class="number">40</span></span><br><span class="line"><span class="built_in">len</span>(arr) = <span class="number">10</span></span><br><span class="line">------------二维数组------------</span><br><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span>(arr2) = <span class="number">200</span></span><br><span class="line">行数 = <span class="number">5</span></span><br><span class="line">列数 = <span class="number">10</span></span><br><span class="line">总个数 = <span class="number">50</span></span><br></pre></td></tr></table></figure>
<p><font color = red>可以看出<code>arr</code>和<code>arr[0]</code>的地址是一样的。 </p>
<h5 id="字符数组与字符串"><a href="#字符数组与字符串" class="headerlink" title="字符数组与字符串"></a>字符数组与字符串</h5><ul>
<li>C语言中没有字符串这种数据类型，可以通过<code>char</code>的数组来替代；</li>
<li>字符串一定是一个<code>char</code>的数组，但<code>char</code>的数组未必是字符串；</li>
<li>数字<code>0</code>(和字符<code>‘\0’</code>等价)结尾的<code>char</code>数组就是一个字符串，但如果<code>char</code>数组没有以数字<code>0</code>结尾，那么就不是一个字符串，只是普通字符数组，所以字符串是一种特殊的<code>char</code>的数组。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. c语言没有字符串类型，用字符数组模拟</span></span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 字符串一定是字符数组，字符数组不一定是字符串</span></span><br><span class="line">    <span class="comment">// 3. 如果字符数组以&#x27;\0&#x27;(0)结尾，就是字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> str2[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;<span class="comment">//字符数组 --&gt; 注意这里[]内没有指定数字</span></span><br><span class="line">    <span class="keyword">char</span> str3[<span class="number">10</span>] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;; <span class="comment">//字符串</span></span><br><span class="line">	<span class="keyword">char</span> str4[<span class="number">10</span>] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="number">0</span>&#125;;    <span class="comment">//字符串</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="字符串输出乱码问题以及一系列字符串要注意的问题"><a href="#字符串输出乱码问题以及一系列字符串要注意的问题" class="headerlink" title="字符串输出乱码问题以及一系列字符串要注意的问题"></a>字符串输出乱码问题以及一系列字符串要注意的问题</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 字符数组打印乱码问题</span></span><br><span class="line">    <span class="keyword">char</span> a1[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;; <span class="comment">//字符数组</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a1 = %s\n&quot;</span>,a1); <span class="comment">//这个是乱码，因为字符数组后面没有&#x27;\0&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 正确的字符串</span></span><br><span class="line">    <span class="keyword">char</span> a2[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">    <span class="comment">//char a2[] = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, 0&#125;; // 0也可以</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 遇到&#x27;\0&#x27;提前截断</span></span><br><span class="line">    <span class="keyword">char</span> a3[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a3 = %s\n&quot;</span>, a3);<span class="comment">//&quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 前3个字符赋值为a, b, c, 后面自动赋值为0</span></span><br><span class="line">    <span class="keyword">char</span> a4[<span class="number">10</span>] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a4 = %s\n&quot;</span>, a4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 常用的初始化方法  --&gt; 使用字符串初始化，在字符串结尾自动加结束符数字0</span></span><br><span class="line">    <span class="comment">//    这个结束符，用户看不到（隐藏），但是是存在的</span></span><br><span class="line">    <span class="keyword">char</span> a5[<span class="number">10</span>] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a5 = %s\n&quot;</span>, a5);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 使用sizeof()测试隐藏的那个&#x27;\0&#x27;</span></span><br><span class="line">    <span class="keyword">char</span> a6[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(a6) = %d\n&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(a6));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. \0 后面最好别跟数字，不然有可能变成转义字符 例如\012 就是&#x27;\n&#x27;</span></span><br><span class="line">    <span class="keyword">char</span> a7[] = <span class="string">&quot;\012abc&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a7 = %s\n&quot;</span>, a7);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. 最多写9个字符，留一个位置放结束符</span></span><br><span class="line">    <span class="keyword">char</span> a8[<span class="number">10</span>] = <span class="string">&quot;123456789&quot;</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 9. sizeof()测数据类型大小，不会因为结束符提前结束  sizeof(&quot;123\045&quot;) = 5</span></span><br><span class="line">    <span class="keyword">char</span> a9[] = <span class="string">&quot;abc\0de&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(a9));  <span class="comment">// 7 --&gt; a b c \0 d e \0  不要忘记最后还有一个\0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 10. scanf(&quot;%s&quot;, a); //a没有&amp;，原因数组名是首元素地址，本来就是地址</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果: </p>
<p><img src="images/c14.png" alt="在这里插入图片描述"></p>
<h5 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 先设置种子，种子设置一次即可</span></span><br><span class="line">	<span class="comment">// 2. 如果srand()参数一样，随机数就一样</span></span><br><span class="line">	<span class="comment">//srand(100);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于希望产生的随机数不同，所以要使用系统时间作为随机数  </span></span><br><span class="line">    <span class="built_in">srand</span>( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>) ); <span class="comment">// 返回的是time_t类型 相当于long，单位为毫秒，注意强制转换一下</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the rand number is = %d\n&quot;</span>, <span class="built_in">rand</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="字符串相关函数"><a href="#字符串相关函数" class="headerlink" title="字符串相关函数"></a>字符串相关函数</h5><h6 id="输入函数"><a href="#输入函数" class="headerlink" title="输入函数"></a>输入函数</h6><p>① <code>gets(str)</code>与<code>scanf(“%s”,str)</code>的区别：</p>
<ul>
<li><code>gets(str)</code>允许输入的字符串含有空格；</li>
<li><code>scanf(“%s”,str)</code>不允许含有空格；</li>
</ul>
<blockquote>
<ul>
<li>注意：由于<code>scanf()</code>和<code>gets()</code>无法知道字符串s大小，必须遇到换行符或读到文件结尾为止才接收输入，因此容易导致字符数组越界(缓冲区溢出)的情况。</li>
</ul>
</blockquote>
<p>② <code>fgets函数</code>相关：
　　</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> size, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><font color = red>功能</font>：从stream指定的文件内读入字符，保存到s所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了size - 1个字符为止，最后会自动加上字符 ‘\0’ 作为字符串结束；</p>
</li>
<li><p><font color =red>参数 </font>:<br>  <font color = blue>s</font>：字符串；<br>  <font color = blue>size</font>：指定最大读取字符串的长度（size - 1）(大于这个长度就舍弃)；<br>  <font color = blue>stream</font>：文件指针，如果读键盘输入的字符串，固定写为stdin；</p>
</li>
<li><p>返回值：<br>  <font color = blue>成功</font>：成功读取的字符串；<br>  <font color = blue>读到文件尾或出错</font>： NULL；</p>
</li>
<li><p>注意，<code>fgets()</code>在读取一个用户通过键盘输入的字符串的时候，<font color = red>同时把用户输入的回车(‘\n’)也做为字符串的一部分</font>。通过scanf和gets输入一个字符串的时候，不包含结尾的“\n”，但通过fgets结尾多了“\n”。</p>
</li>
<li><p>fgets()函数是安全的，不存在缓冲区溢出的问题。</p>
</li>
</ul>
<p>简单测试：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. scanf()输入字符串 不做越界检查，此函数不安全</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. gets(已抛弃，不安全) </span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// gets(buf);  //不安全 已废弃</span></span><br><span class="line">    <span class="comment">// printf(&quot;buf = %s\n&quot;, buf);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. fgets(安全，可以指定大小)</span></span><br><span class="line">    <span class="built_in">fgets</span>(buf,<span class="built_in"><span class="keyword">sizeof</span></span>(buf),stdin);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf = &#x27;%s&#x27;\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 测试读入了　最后的换行</span></span><br><span class="line">    <span class="built_in">fgets</span>(buf,<span class="built_in"><span class="keyword">sizeof</span></span>(buf),stdin); <span class="comment">// 注意虽然这里从键盘读入，但是如果缓冲区还有内容就不会读这里的</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf2 = &#x27;%s&#x27;\n&quot;</span>, buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入输出结果: </p>
<p><img src="images/c15.png" alt="在这里插入图片描述"></p>
<h6 id="输出函数"><a href="#输出函数" class="headerlink" title="输出函数"></a>输出函数</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br><span class="line">功能：标准设备输出s字符串，在输出完成后自动输出一个<span class="string">&#x27;\n&#x27;</span>。</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * str, FILE * stream)</span></span>;  <span class="comment">//文件操作</span></span><br><span class="line">功能： 将str所指定的字符串写入到stream指定的文件中， 字符串结束符 <span class="string">&#x27;\0&#x27;</span>  不写入文件。 </span><br></pre></td></tr></table></figure>

<p>简单测试: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line">    <span class="built_in">puts</span>(str); <span class="comment">//会自动加上一个 &#x27;\n&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fputs</span>(str,stdout); <span class="comment">// 不会自动加上 &#x27;\n&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出: </p>
<p><img src="images/c16.png" alt="在这里插入图片描述"></p>
<h6 id="sizeof-和strlen-的区别"><a href="#sizeof-和strlen-的区别" class="headerlink" title="sizeof()和strlen()的区别"></a>sizeof()和strlen()的区别</h6><p>注意: </p>
<ul>
<li> <code>strlen()</code> 从首元素开始，到结束符为止的长度，结束符不算(遇到’\0’结束)；</li>
<li>而<code>sizeof()</code>则不管遇不遇到<code>&#39;\0&#39;</code>都会计算整个数据类型大小；<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// strlen 从首元素开始，到结束符为止的长度，结束符不算(遇到&#x27;\0&#x27;结束)</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;strlen(buf) = %d\n&quot;</span>, len);   <span class="comment">//5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(buf) = %d\n&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(buf)); <span class="comment">// 6 这个还包括 &#x27;\0&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf2[] = <span class="string">&quot;\0hello&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;strlen(buf2) = %d\n&quot;</span>, <span class="built_in">strlen</span>(buf2)); <span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(buf2) = %d\n&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(buf2)); <span class="comment">// 7  注意不要忘记最后还有一个 &#x27;\0&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf3[<span class="number">100</span>] = <span class="string">&quot;zxzxin&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;strlen(buf3) = %d\n&quot;</span>, <span class="built_in">strlen</span>(buf3)); <span class="comment">//6</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(buf3) = %d\n&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(buf3));  <span class="comment">//100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="字符串拷贝strcpy-和strncpy"><a href="#字符串拷贝strcpy-和strncpy" class="headerlink" title="字符串拷贝strcpy()和strncpy()"></a>字符串拷贝strcpy()和strncpy()</h6>注意两者区别: </li>
<li><code>char *strcpy(char *dest, const char *src) </code>：把src所指向的字符串复制到dest所指向的空间中，’\0’也会拷贝过去。(如果参数dest所指的内存空间不够大，可能会造成缓冲溢出的错误情况。)</li>
<li><code>char *strncpy(char *dest, const char *src, size_t n)</code>：把src指向字符串的前n个字符复制到dest所指向的空间中，<font color=  red>是否拷贝结束符看指定的长度是否包含’\0’。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//strcpy:  把src所指向的字符串复制到dest所指向的空间中，&#x27;\0&#x27;也会拷贝过去</span></span><br><span class="line">    <span class="keyword">char</span> src[] = <span class="string">&quot;hello world!&quot;</span>; </span><br><span class="line">    <span class="keyword">char</span> dest[<span class="number">100</span>] = <span class="string">&quot;aaaaaaaaaaaaaaaaaaaaaaa&quot;</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(dest,src);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dest = %s\n&quot;</span>, dest);<span class="comment">// hello world!  不会输出后面的aaaa， 因为&#x27;\0&#x27;也拷贝在后面了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// strncpy : 把src指向字符串的前n个字符复制到dest所指向的空间中，是否拷贝结束符看指定的长度是否包含&#x27;\0&#x27;。</span></span><br><span class="line">    <span class="keyword">char</span> dest2[<span class="number">100</span>] = <span class="string">&quot;aaaaaaaaaaaaaaaaaaaaaaa&quot;</span>;</span><br><span class="line">    <span class="built_in">strncpy</span>(dest2, src, <span class="built_in">strlen</span>(src));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dest2 = %s\n&quot;</span>, dest2); <span class="comment">//hello world!aaaaaaaaaaa</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//但是如果拷贝的长度大于strlen(src)</span></span><br><span class="line">    <span class="keyword">char</span> dest3[<span class="number">100</span>] = <span class="string">&quot;aaaaaaaaaaaaaaaaaaaaaaa&quot;</span>;</span><br><span class="line">    <span class="built_in">strncpy</span>(dest3, src, <span class="built_in">strlen</span>(src)+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dest3 = %s\n&quot;</span>, dest3); <span class="comment">//hello world!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
输出：</li>
</ul>
<p><img src="images/c17.png" alt="在这里插入图片描述"></p>
<h6 id="strcat-、strncat-、-strcmp-、strncmp"><a href="#strcat-、strncat-、-strcmp-、strncmp" class="headerlink" title="strcat()、strncat()、 strcmp()、strncmp()"></a>strcat()、strncat()、 strcmp()、strncmp()</h6><ul>
<li><code>char *strcat(char *dest, const char *src);</code>: 将src字符串连接到dest的尾部，<code>‘\0’</code>也会追加过去；</li>
<li><code>char *strncat(char *dest, const char *src, size_t n);</code>: 将src字符串前n个字符连接到dest的尾部，<code>‘\0’</code>也会追加过去；</li>
<li><code>int strcmp(const char *s1, const char *s2);</code>: 比较 s1 和 s2 的大小，比较的是字符ASCII码大小；</li>
<li><code>int strncmp(const char *s1, const char *s2, size_t n);</code>：比较 s1 和 s2 前n个字符的大小，比较的是字符ASCII码大小；</li>
</ul>
<p>测试:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s1[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> s2[] = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="built_in">strcmp</span>(s1, s2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;flag = %d\n&quot;</span>,flag);<span class="comment">// &lt;0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> s3[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> s4[] = <span class="string">&quot;Abcd&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> flag2 = <span class="built_in">strncmp</span>(s3, s4, <span class="number">3</span>); <span class="comment">//指定比较前3个字符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;flag2 = %d\n&quot;</span>,flag2);<span class="comment">// &gt;0s</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-------------strcat和strncat------------\n&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> src[] = <span class="string">&quot; hello mike&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> dst[<span class="number">100</span>] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="comment">//把src的内容追加到dst的后面</span></span><br><span class="line">    <span class="comment">//strcat(dst, src); //dst = &quot;abc  hello mike&quot;</span></span><br><span class="line">    <span class="built_in">strncat</span>(dst, src, <span class="built_in">strlen</span>(<span class="string">&quot; hello&quot;</span>)); <span class="comment">//指定长度追加 dst = &quot;abc  hello&quot;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dst = %s\n&quot;</span>, dst);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">flag = <span class="number">-100</span></span><br><span class="line">flag2 = <span class="number">32</span></span><br><span class="line">-------------strcat和strncat------------</span><br><span class="line">dst = abc hello</span><br></pre></td></tr></table></figure>
<h6 id="sprintf-、sscanf"><a href="#sprintf-、sscanf" class="headerlink" title="sprintf()、sscanf()"></a>sprintf()、sscanf()</h6><ul>
<li><code>int sprintf(char *str, const char *format, ...);</code>: 根据参数format字符串来转换并格式化数据，然后将结果输出到str指定的空间中，直到出现字符串结束符 ‘\0’  为止。</li>
<li><code>int sscanf(const char *str, const char *format, ...);</code>: 从str指定的字符串读取数据，并根据参数format字符串来转换并格式化数据。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------------sprintf-------------------\n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">10</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> dest[<span class="number">30</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(dest,<span class="string">&quot;n = %d, ch = %c, buf = %s\n&quot;</span>, n, ch, buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dest: %s&quot;</span>, dest);  <span class="comment">// 注意这里没有加上 &#x27;\n&#x27; 但是之前里面有</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------------sscanf-------------------\n&quot;</span>);</span><br><span class="line">    <span class="comment">// sscanf和spirnf相反  这里从dest中读取</span></span><br><span class="line">    <span class="keyword">int</span> n2;</span><br><span class="line">    <span class="keyword">char</span> ch2;</span><br><span class="line">    <span class="keyword">char</span> buf2[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">sscanf</span>(dest, <span class="string">&quot;n = %d, ch = %c, buf = %s\n&quot;</span>, &amp;n2, &amp;ch2, &amp;buf2); <span class="comment">//记得加上 &amp;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n2 = %d\n&quot;</span>, n2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch2 = %c\n&quot;</span>, ch2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf2 = %s\n&quot;</span>, buf2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-----------字符串提取注意的地方--------------\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 从字符串中提取 内容最好按照空格进行分割 ，不然有可能提取不出来</span></span><br><span class="line">    <span class="comment">// 1. 按照空格分割 --&gt; 正确</span></span><br><span class="line">    <span class="keyword">char</span> buf3[] = <span class="string">&quot;aaa bbb ccc&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">10</span>],b[<span class="number">10</span>],c[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">sscanf</span>(buf3, <span class="string">&quot;%s %s %s&quot;</span>, a,b,c); <span class="comment">//注意没有&amp;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %s, b = %s, c = %s\n&quot;</span>, a, b, c);</span><br><span class="line">    <span class="comment">// 2. 按照逗号分割 --&gt; 错误</span></span><br><span class="line">    <span class="keyword">char</span> buf4[] = <span class="string">&quot;aaa,bbb,ccc&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> a2[<span class="number">10</span>],b2[<span class="number">10</span>],c2[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">sscanf</span>(buf4, <span class="string">&quot;%s,%s,%s&quot;</span>, a2,b2,c2); <span class="comment">//注意没有&amp;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a2 = %s, b2 = %s, c2 = %s\n&quot;</span>, a2, b2, c2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
结果: </li>
</ul>
<p><img src="images/c18.png" alt="在这里插入图片描述"></p>
<h6 id="strchr-、strstr-、strtok"><a href="#strchr-、strstr-、strtok" class="headerlink" title="strchr()、strstr()、strtok()"></a>strchr()、strstr()、strtok()</h6><ul>
<li><code>char *strchr(const char *s, char c);</code>: 在字符串s中查找字母c出现的位置；</li>
<li><code>char *strstr(const char *haystack, const char *needle);</code>: 在字符串haystack中查找字符串needle出现的位置；</li>
<li><code>char *strtok(char *str, const char *delim);</code><br>①来将字符串分割成一个个片段。当strtok()在参数s的字符串中发现参数delim中包含的分割字符时, 则会将该字符改为\0 字符，当连续出现多个时只替换第一个为\0；<br>②在第一次调用时：strtok()必需给予参数s字符串；<br>③<font color =red>往后的调用则将参数s设置成NULL</font>，每次调用成功则返回指向被分割出片段的指针；<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-------------strchr------------\n&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> str1[] = <span class="string">&quot;aaabbbccc&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="built_in">strchr</span>(str1, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = %s\n&quot;</span>, p);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-------------strstr------------\n&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> str2[] = <span class="string">&quot;ddddabcd123abcd333abcd&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> *p2 = <span class="built_in">strstr</span>(str2, <span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p2 = %s\n&quot;</span>, p2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-------------strtok------------\n&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> str3[<span class="number">100</span>] = <span class="string">&quot;adc*fvcv*ebcy*hghbdfg*casdert&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> *s = <span class="built_in">strtok</span>(str3, <span class="string">&quot;*&quot;</span>);   <span class="comment">//将&quot;*&quot;分割的子串取出</span></span><br><span class="line">    <span class="keyword">while</span> (s != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);</span><br><span class="line">        s = <span class="built_in">strtok</span>(<span class="literal">NULL</span>, <span class="string">&quot;*&quot;</span>);<span class="comment">//往后的调用则将参数s设置成NULL，每次调用成功则返回指向被分割出片段的指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
输出:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">-------------strchr------------</span><br><span class="line">p = bbbccc</span><br><span class="line">-------------strstr------------</span><br><span class="line">p2 = abcd123abcd333abcd</span><br><span class="line">-------------strtok------------</span><br><span class="line">adc</span><br><span class="line">fvcv</span><br><span class="line">ebcy</span><br><span class="line">hghbdfg</span><br><span class="line">casdert</span><br></pre></td></tr></table></figure>
<h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><ul>
<li>函数内部，包括()内部的形参变量，只有在调用时分配空间，调用完毕自动释放；</li>
<li><code>return</code>和<code>exit()</code>函数区别，只要一调用 <code>exit()</code>函数(不管在什么地方)，整个程序就结束，但是只有在<code>main</code>函数中调用<code>return</code>才会结束程序；</li>
<li>声明函数加不加 <code>extern</code>关键字都一样，<font color = red>  声明函数可以不指定形参名称，只指定形参形参类型，但是定义不可以。</li>
<li>头文件一般是放函数声明；</li>
</ul>
<p>看下面两张图解释<code>.h</code>文件的作用: </p>
<p><img src="images/c19.png" alt="在这里插入图片描述"></p>
<p>解决办法: </p>
<p><img src="images/c20.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>多个文件中(同一项目)，不能出现同名函数(static除外)。<font color =red>这就是为什么 <code>.h</code>文件只放函数的声明，不放函数的定义；</p>
</li>
<li><p>防止头文件重复包含: 当一个项目比较大时，往往都是分文件，这时候有可能不小心把同一个头文件 <code>include</code> 多次，或者头文件嵌套包含。</p>
</li>
</ul>
<p><font color = blue>防止办法:<br>①<code>#ifndef</code> 方式；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SOMEFILE_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SOMEFILE_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明语句</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>②<code>#pragma once</code> 方式。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>Compilation</tag>
        <tag>C Language</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言基础知识总结(一)</title>
    <url>/2021/10/26/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93(%E4%B8%80)/</url>
    <content><![CDATA[<h2 id="C-基础知识总结-一"><a href="#C-基础知识总结-一" class="headerlink" title="C++基础知识总结(一)"></a>C++基础知识总结(一)</h2><ul>
<li><a href="#c%E5%AF%B9c%E8%AF%AD%E8%A8%80%E7%9A%84%E6%8F%90%E9%AB%98">C++对C语言的提高</a><ul>
<li><a href="#%E5%91%BD%E4%BB%A4%E7%A9%BA%E9%97%B4%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8">命令空间简单使用</a></li>
<li><a href="#const%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8A%A0%E5%BC%BA"><code>const</code>关键字的加强</a></li>
<li><a href="#%E5%BC%95%E7%94%A8-%E9%87%8D%E7%82%B9">引用-重点</a></li>
<li><a href="#%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8">指针引用</a></li>
<li><a href="#%E6%B2%A1%E6%9C%89%E5%BC%95%E7%94%A8%E6%8C%87%E9%92%88">没有引用指针</a></li>
<li><a href="#const%E5%BC%95%E7%94%A8"><code>const</code>引用</a></li>
<li><a href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%BF%90%E7%AE%97%E7%AC%A6">默认参数函数重载作用域运算符</a></li>
<li><a href="#newdelete%E7%9A%84%E4%BD%BF%E7%94%A8"><code>new</code>、<code>delete</code>的使用</a></li>
</ul>
</li>
<li><a href="#c%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80">C++面向对象基础</a><ul>
<li><a href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E6%A1%88%E4%BE%8B">一个简单案例</a></li>
<li><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0">构造函数和析构函数</a></li>
<li><a href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D">深拷贝和浅拷贝</a></li>
<li><a href="#%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88">指向对象成员函数的指针</a></li>
<li><a href="#%E5%B8%B8%E5%AF%B9%E8%B1%A1">常对象</a></li>
<li><a href="#%E5%B8%B8%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98-%E5%B8%B8%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E5%B8%B8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">常对象成员-常数据成员&amp;常成员函数</a></li>
<li><a href="#%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E6%8C%87%E9%92%88">指向对象的常指针</a></li>
<li><a href="#%E6%8C%87%E5%90%91%E5%B8%B8%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8C%87%E9%92%88">指向常变量、对象的指针</a></li>
<li><a href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98">静态成员</a></li>
<li><a href="#%E5%8F%8B%E5%85%83">友元</a></li>
</ul>
</li>
<li><a href="#c%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6">C++重载运算符</a><ul>
<li><a href="#%E9%87%8D%E8%BD%BD%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6">重载基本运算符</a></li>
<li><a href="#%E9%87%8D%E8%BD%BD%E5%8F%B7%E6%93%8D%E4%BD%9C%E7%AC%A6">重载<code>=</code>号操作符</a></li>
<li><a href="#%E9%87%8D%E8%BD%BD%E6%B5%81%E6%8F%92%E5%85%A5%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E6%B5%81%E6%8F%90%E5%8F%96%E8%BF%90%E7%AE%97%E7%AC%A6">重载流插入运算符和流提取运算符</a></li>
<li><a href="#%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B-%E7%9F%A9%E9%98%B5%E5%8A%A0%E6%B3%95%E4%BB%A5%E5%8F%8A%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA">综合案例-矩阵加法以及输入输出</a></li>
</ul>
</li>
<li><a href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%B1%BB%E6%A8%A1%E6%9D%BF">函数模板、类模板</a><ul>
<li><a href="#%E6%A1%88%E4%BE%8B-%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E7%9A%84vector%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%AD%E7%9A%84push-back">案例-简单实现的Vector类模板中的<code>push_back</code></a></li>
</ul>
</li>
<li><a href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C">文件操作</a><ul>
<li><a href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81">输入输出流</a></li>
<li><a href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99">文件读写</a></li>
</ul>
</li>
</ul>
<hr>
<h3 id="C-对C语言的提高"><a href="#C-对C语言的提高" class="headerlink" title="C++对C语言的提高"></a><font color = red id = "1">C++对C语言的提高</h3><h5 id="命令空间简单使用"><a href="#命令空间简单使用" class="headerlink" title="命令空间简单使用"></a>命令空间简单使用</h5><p>引用命令空间的三种方式: </p>
<ul>
<li><p>直接指定标识符。例如<code>std::cout&lt;&lt;&quot;hello&quot;&lt;&lt;std::endl;</code>；<br>   使用<code>using</code>关键字。例如<code>using    std::cout;    </code>；</p>
</li>
<li><p>导入整个命令空间。例如<code>using namespace std; </code>导入<code>std</code>命名空间；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个命令空间</span></span><br><span class="line"><span class="keyword">namespace</span> space1&#123; </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//using namespace std;</span></span><br><span class="line"><span class="comment">//只导入其中的cout和endl</span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;hello&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> space1;<span class="comment">//直接导入命令空间</span></span><br><span class="line">    cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="const关键字的加强"><a href="#const关键字的加强" class="headerlink" title="const关键字的加强"></a><code>const</code>关键字的加强</h5></li>
<li><p><code>C</code>语言中的<code>const</code>是一个冒牌货，即使用来修饰变量的值不能修改，但是还是可以通过指针指向这个变量，然后修改指针指向的内存来修改这个变量的值；</p>
</li>
<li><p>注意<code>const</code>和<code>#define</code>的区别: ①<code>#define</code>只是在预编译时进行字符置换，例如<code>#define PI 3.14</code>，这里的<code>PI</code>不是变量，没有类型，不占用存储单元。②而<code>const float PI = 3. 14</code>定义了常变量<code>PI</code>，它具有变量的属性，有数据类型，占用存储单元，只是在程序运行期间变量的值是固定的，不能改变(<font color=  red>真正的不能改变</font>)；</p>
</li>
</ul>
<p>测试: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//a此时是一个真正的常量 : 不能通过指针修改(C语言中的const是一个冒牌货)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//如果对一个常量取地址，编译器会临时开辟一个空间temp,让这个指针指向temp</span></span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *)&amp;a; <span class="comment">//注意要强制转换一下</span></span><br><span class="line">    *p = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, *p = %d\n&quot;</span>, a, *p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以使用const定义的&quot;常量&quot;来定义数组(C语言中不能这样)</span></span><br><span class="line">    <span class="keyword">int</span> arr[a]; <span class="comment">//ok</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出(可以看到<code>a</code>没有改变(<code>C</code>语言中会变)): </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; 100, *p &#x3D; 200</span><br></pre></td></tr></table></figure>
<h5 id="引用-重点"><a href="#引用-重点" class="headerlink" title="引用-重点"></a>引用-重点</h5><ul>
<li>变量名，本身是一段内存的引用，即别名(<code>alias</code>). 引用可以看作一个已定义变量的别名；</li>
<li>对变量声明一个引用，<font color = red>并不另外开辟内存单元</font>，例如<code>int &amp;b = a</code>，则<code>b</code>和<code>a</code>都代表同一个内存单元(使用<code>sizeof()</code>测<code>a</code>、<code>b</code>大小是相同的)。<font color= red>引用与被引用的变量有相同的地址</font>；</li>
<li>在声明一个引用时，<font color = red>必须同时初始化</font>(和常量有点类似)，即声明它代表哪一个变量；</li>
<li>当声明一个变量的引用后，改引用一直与其代表的变量相联系，<font color = red>不能再作为其他变量的别名</font>。</li>
<li><code>&amp;</code>符号前有数据类型时，是引用。其他都是代表取地址；</li>
<li>引用所占用的大小跟指针是相等的，引用可能是一个”常指针”(<code>int *const p</code>)；</li>
<li>对引用的初始化，可以是一个变量名，也可以是另一个引用。如<code>int a = 3; int &amp;b = a; int &amp;c = b；</code>此时，整形变量<code>a</code>有两个别名<code>b</code>、<code>c</code>；</li>
<li>不能建立<code>void</code>类型的引用(但是有<code>void *</code>类型指针(万能指针))。不能建立引用的数组(可以有指针数组)；</li>
</ul>
<p>使用经典的<code>swap</code>问题来看引用作为形参的简单使用: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//值传递(不行)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swap1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针(也是值传递)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span>&#123;   </span><br><span class="line">    <span class="keyword">int</span> t = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用(引用传递)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swap3</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>, b = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">swap1</span>(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d\n&quot;</span>, a , b);</span><br><span class="line">    <span class="built_in">swap2</span>(&amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d\n&quot;</span>, a , b);</span><br><span class="line">    <span class="built_in">swap3</span>(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d\n&quot;</span>, a , b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a = <span class="number">100</span>, b = <span class="number">200</span></span><br><span class="line">a = <span class="number">200</span>, b = <span class="number">100</span></span><br><span class="line">a = <span class="number">100</span>, b = <span class="number">200</span></span><br></pre></td></tr></table></figure>

<h5 id="指针引用"><a href="#指针引用" class="headerlink" title="指针引用"></a>指针引用</h5><p>可以建立指针变量的引用，如: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"><span class="keyword">int</span>* &amp;ref = p; <span class="comment">//ref是一个指向 “整形变量的指针变量” 的引用，初始化为p</span></span><br></pre></td></tr></table></figure>
<p>下面看一个使用指针引用的例子，对比使用<font color = blue>二级指针</font>和使用<font color= blue>指针引用</font>的区别: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过二级指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getMem</span><span class="params">(Student **temp)</span></span>&#123; </span><br><span class="line">    Student *p = (Student *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Student));</span><br><span class="line">    p-&gt;age = <span class="number">13</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(p-&gt;name, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    *temp = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getMem2</span><span class="params">(Student* &amp;p)</span></span>&#123; <span class="comment">//将Student*看成一个类型 </span></span><br><span class="line">    p = (Student *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Student));</span><br><span class="line">    p-&gt;age = <span class="number">14</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(p-&gt;name, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free1</span><span class="params">(Student **temp)</span></span>&#123; </span><br><span class="line">    Student *p = *temp;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>)&#123; </span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        *temp = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过指向指针的引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free2</span><span class="params">(Student* &amp;p)</span></span>&#123; <span class="comment">//指向指针的引用</span></span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>)&#123; </span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Student *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">getMem</span>(&amp;p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;age = %d, name = %s\n&quot;</span>, p-&gt;age, p-&gt;name); </span><br><span class="line">    <span class="built_in">free1</span>(&amp;p);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getMem2</span>(p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;age = %d, name = %s\n&quot;</span>, p-&gt;age, p-&gt;name);</span><br><span class="line">    <span class="built_in">free2</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">age = <span class="number">13</span>, name = zhangsan</span><br><span class="line">------------------</span><br><span class="line">age = <span class="number">14</span>, name = lisi</span><br></pre></td></tr></table></figure>

<h5 id="没有引用指针"><a href="#没有引用指针" class="headerlink" title="没有引用指针"></a>没有引用指针</h5><ul>
<li>由于引用不是一种独立的数据类型，所以不能建立指向引用类型的指针变量。 </li>
<li>但是，可以将<font color= blue>变量的引用的地址</font>赋值给一个指针，此时指针指向的是<font color= blue>原来的变量</font>。</li>
</ul>
<p>例如: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = a;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;b;  <span class="comment">//指针变量p指向变量a的引用b,相当于指向a,合法</span></span><br></pre></td></tr></table></figure>
<p>上面代码和下面一行代码相同: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure>
<p>输出<code>*p</code>的值，就是<code>b</code>的值，即<code>a</code>的值。<br>不能定义指向引用类型的指针变量，不能写成: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; *p = &amp;a; <span class="comment">//企图定义指向引用类型的指针变量，错误</span></span><br></pre></td></tr></table></figure>

<h5 id="const引用"><a href="#const引用" class="headerlink" title="const引用"></a><code>const</code>引用</h5><ul>
<li>如果想对一个常量进行引用，必须是一个<code>const</code>引用；</li>
<li><font color=  red>可以对一个变量进行 常引用(此时引用不可修改，但是原变量可以修改)。这个特征一般是用在函数形参修饰上，不希望改变原来的实参的值；</font></li>
<li>可以用常量或表达式对引用进行初始化，但此时必须用<code>const</code>作声明(<font color=  blue>内部是使用一个<code>temp</code>临时变量转换</font>)；</li>
</ul>
<p>测试:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">//对一个常量进行引用</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//int&amp; ref1 = a; //err</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;ref1 = a; <span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以对一个变量进行 常引用(此时引用不可修改，但是原变量可以修改)</span></span><br><span class="line">    <span class="comment">//这个特征一般是用在函数形参修饰上，有时候不希望改变原来的实参的值</span></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>&amp; ref2 = b;</span><br><span class="line">    <span class="comment">//ref2 = 20; //err</span></span><br><span class="line">    b = <span class="number">20</span>; <span class="comment">// ok</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %d, ref2 = %d\n&quot;</span>, b, ref2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对表达式做引用</span></span><br><span class="line">    <span class="comment">// 内部系统处理 int temp = c+10; const int&amp; ref3 = temp;</span></span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>&amp; ref3 = c + <span class="number">10</span>; <span class="comment">//合法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//也可以对不同类型进行转换</span></span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>&amp; ref4 = d; <span class="comment">// int temp = d; const int&amp; ref4 = temp</span></span><br><span class="line">    cout&lt;&lt;d&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ref4&lt;&lt;endl;<span class="comment">//b = 3.14,ref4 = 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">b = <span class="number">20</span>, ref2 = <span class="number">20</span></span><br><span class="line"><span class="number">3.14</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h5 id="默认参数、函数重载、作用域运算符"><a href="#默认参数、函数重载、作用域运算符" class="headerlink" title="默认参数、函数重载、作用域运算符"></a>默认参数、函数重载、作用域运算符</h5><ul>
<li>如果全局和局部有相同名字变量，使用<code>::</code>运算符来操作全局变量；<br>   默认参数要注意：<font color = red>    如果默认参数出现，那么右边的都必须有默认参数，也就是只有参数列表后面部分的参数才可以提供默认参数值</font>；</li>
<li>函数重载规则: ①函数名相同。②参数个数不同,参数的类型不同,参数顺序不同,均可构成重载。 ③<font color=  red>返回值类型不同则不可以构成重载。 </li>
<li>一个函数，不能既作重载，又作默认参数的函数。</li>
</ul>
<p>简单使用:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">20</span>, <span class="keyword">int</span> c = <span class="number">30</span>)</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// 作用域运算符 ::</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a2 = %d\n&quot;</span>, ::a); <span class="comment">//全局的a</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">fun</span>(<span class="number">10</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">fun</span>(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">fun</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="new、delete的使用"><a href="#new、delete的使用" class="headerlink" title="new、delete的使用"></a><code>new</code>、<code>delete</code>的使用</h5><ul>
<li><code>C</code>语言中使用<code>malloc</code>函数必须指定开辟空间的大小，即<code>malloc(size)</code>，且<code>malloc</code>函数只能从用户处知道应开辟空间的大小而不知道数据的类型，因此无法使其返回的指针指向具体的数据类型。其返回值一律为<code>void *</code>，使用时必须强制转换；</li>
<li><code>C++</code>中提供了<code>new</code>和<code>delete</code><font color= red>运算符</font>来替代<code>malloc</code>和<code>free</code>函数；</li>
<li>差别: <code>malloc</code>不会调用类的构造函数,而<code>new</code>会调用类的构造函数。②<code>free</code>不会调用类的析构函数，而<code>delete</code>会调用类的析构函数；(析构函数释放的是对象内部的内存，而<code>delete</code>释放的是对象，而<code>delete</code>也出发析构，所以都可以释放)</li>
</ul>
<p>例如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>； <span class="comment">//开辟一个存放整数的空间，返回一个指向整形数据的指针</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">100</span>); <span class="comment">//开辟一个存放整数的空间，并指定初始值为100</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>]; <span class="comment">// 开辟一个存放字符数组的空间，size = 10</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">float</span> *p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">float</span></span>(<span class="number">3.14</span>); <span class="comment">//将返回的指向实型数据的指针赋给指针变量p</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">delete</span> []p; <span class="comment">//释放对数组空间的操作(加方括号)</span></span><br></pre></td></tr></table></figure>
<p>简单测试：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// new 和 delete 使用</span></span><br><span class="line">    <span class="keyword">int</span> *p1 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p1 = %d\n&quot;</span>, *p1);</span><br><span class="line">    <span class="keyword">delete</span> p1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *p2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        p2[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p2[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> []p2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*p1 = <span class="number">10</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </span><br></pre></td></tr></table></figure>

<hr>
<h3 id="C-面向对象基础"><a href="#C-面向对象基础" class="headerlink" title="C++面向对象基础"></a><font color = red id = "2">C++面向对象基础</h3><h5 id="一个简单案例"><a href="#一个简单案例" class="headerlink" title="一个简单案例"></a>一个简单案例</h5><blockquote>
<p>题目，判断两个圆是否相交。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//点(坐标类)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setXY</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">getPointDis</span><span class="params">(Point &amp;thr)</span></span>; <span class="comment">//计算两点距离</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//圆类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setR</span><span class="params">(<span class="keyword">int</span> r)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setXY</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isInterSection</span><span class="params">(Circle &amp;thr)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        Point p0; <span class="comment">//圆心</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Point::setXY</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; </span><br><span class="line">    <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">    <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Point::getPointDis</span><span class="params">(Point &amp;thr)</span></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> dx = x - thr.x;</span><br><span class="line">    <span class="keyword">int</span> dy = y - thr.y;</span><br><span class="line">    <span class="keyword">double</span> dis = <span class="built_in">sqrt</span>(dx*dx + dy*dy);</span><br><span class="line">    <span class="keyword">return</span> dis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Circle::setR</span><span class="params">(<span class="keyword">int</span> r)</span></span>&#123; </span><br><span class="line">    <span class="keyword">this</span>-&gt;r = r; <span class="comment">//注意不能写成this.r (this是一个指针,每个对象都可以通过this指针来访问自己的地址)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Circle::setXY</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123; </span><br><span class="line">    p0.<span class="built_in">setXY</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Circle::isInterSection</span><span class="params">(Circle &amp;thr)</span></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> R = r + thr.r; <span class="comment">//两个圆的半径之和</span></span><br><span class="line">    <span class="keyword">double</span> dis = p0.<span class="built_in">getPointDis</span>(thr.p0); <span class="comment">//两个圆心的距离</span></span><br><span class="line">    <span class="keyword">if</span>(dis &lt;= R)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    Circle c1,c2;</span><br><span class="line">    c1.<span class="built_in">setR</span>(<span class="number">1</span>);</span><br><span class="line">    c1.<span class="built_in">setXY</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    c2.<span class="built_in">setR</span>(<span class="number">3</span>);</span><br><span class="line">    c2.<span class="built_in">setXY</span>(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    Circle *pc1 = &amp;c1; <span class="comment">//定义指向对象的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pc1-&gt;<span class="built_in">isInterSection</span>(c2))<span class="comment">//通过指针的方式调用</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;两圆相交!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;两圆不相交!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">两圆相交!</span><br></pre></td></tr></table></figure>
<h5 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h5><ul>
<li>如果用户没有定义默认的，系统会提供一个默认构造函数，但是如果用户已经定义了构造函数，系统就不会提供默认的构造函数；</li>
<li>系统也会提供一个默认的<font  color = blue>拷贝构造函数</font>，默认是浅拷贝，形如<code>Clazz c1(c2)</code>的使用，将<code>c1</code>拷贝给<code>c2</code>；</li>
<li><code>C++</code>有一个参数初始化列表的特性，注意不能用在数组上；</li>
<li>构造函数也可以是带有默认参数；</li>
<li>析构函数被调用的情况:① 如果用<code>new</code>运算符动态的建立了一个对象，当用<code>delete</code>运算符释放该对象时，先调用该对象的析构函数。②<code>static</code>局部对象在函数调用结束之后对象并不是放，因此也不调用析构函数。只有在调用<code>exit</code>或者<code>main</code>函数结束的时候才会调用<code>static</code>的析构函数。</li>
<li>构造函数和析构函数的顺序: ①<font color = red>先构造的后析构，后构造的先析构；</li>
</ul>
<p>拷贝构造函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clazz</span>&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Clazz</span>()&#123; </span><br><span class="line">            x = <span class="number">0</span>;</span><br><span class="line">            y = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Clazz</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123; </span><br><span class="line">            <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">            <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">printXY</span><span class="params">()</span></span>&#123; </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, x, y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//显示的拷贝构造函数  如果不写，默认也有这个</span></span><br><span class="line">        <span class="built_in">Clazz</span>(<span class="keyword">const</span> Clazz &amp;thr)&#123; </span><br><span class="line">            x = thr.x;</span><br><span class="line">            y = thr.y;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Clazz <span class="title">c1</span><span class="params">(<span class="number">100</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Clazz <span class="title">c2</span><span class="params">(c1)</span></span>; <span class="comment">//拷贝</span></span><br><span class="line">    c2.<span class="built_in">printXY</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数是对象初始化的时候调用</span></span><br><span class="line">    Clazz c3 = c1; <span class="comment">// 调用的依然是c3的拷贝构造函数</span></span><br><span class="line">    c3.<span class="built_in">printXY</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Clazz c4; <span class="comment">//调用的是无参构造器</span></span><br><span class="line">    c4 = c1; <span class="comment">//不是调用拷贝构造函数，而是重载操作符</span></span><br><span class="line">    c4.<span class="built_in">printXY</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>构造函数中的<font color = blue>参数初始化列表</font>: </p>
<ul>
<li>注意构造对象成员的 顺序跟初始化列表的顺序无关；</li>
<li>而是跟成员对象的定义顺序有关；<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Box</span>(); <span class="comment">//默认的无参</span></span><br><span class="line">        <span class="comment">//参数初始化表</span></span><br><span class="line">        <span class="built_in">Box</span>(<span class="keyword">int</span> l, <span class="keyword">int</span> w, <span class="keyword">int</span> h):<span class="built_in">l</span>(l),<span class="built_in">w</span>(w),<span class="built_in">h</span>(h)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, <span class="string">&quot;zhangsan&quot;</span>); <span class="comment">//默认</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Box</span>(<span class="keyword">int</span> l, <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">const</span> <span class="keyword">char</span> *name):<span class="built_in">l</span>(l),<span class="built_in">w</span>(w),<span class="built_in">h</span>(h)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name,name); <span class="comment">//字符串不能那样初始化</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">volume</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> l,w,h;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Box::<span class="built_in">Box</span>()</span><br><span class="line">&#123; </span><br><span class="line">    l = <span class="number">10</span>;</span><br><span class="line">    w = <span class="number">10</span>;</span><br><span class="line">    h = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Box::volume</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> l*w*h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Box b1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b1.<span class="built_in">volume</span>());</span><br><span class="line">    <span class="function">Box <span class="title">b2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b2.<span class="built_in">volume</span>());</span><br><span class="line">    <span class="function">Box <span class="title">b3</span><span class="params">(<span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="string">&quot;lisi&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b3.<span class="built_in">volume</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
输出: </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1000</span></span><br><span class="line"><span class="number">8000</span></span><br><span class="line"><span class="number">27000</span></span><br></pre></td></tr></table></figure>

<h5 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h5><ul>
<li>深拷贝是有必要的，因为析构函数释放内存的时候，如果使用浅拷贝拷贝了一个对象，释放两个对象指向得到同一个内存两次，就会产生错误。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Teacher</span>(<span class="keyword">int</span> id, <span class="keyword">const</span> <span class="keyword">char</span>* name)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;id = id;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="built_in">strlen</span>(name);</span><br><span class="line">            <span class="keyword">this</span>-&gt;name = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(len+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//显式的提供一个拷贝构造函数，完成深拷贝动作</span></span><br><span class="line">        <span class="comment">// 防止在析构函数中 释放堆区空间两次</span></span><br><span class="line">        <span class="built_in">Teacher</span>(<span class="keyword">const</span> Teacher &amp;thr)&#123; </span><br><span class="line">            id = thr.id;</span><br><span class="line">            <span class="comment">//深拷贝  </span></span><br><span class="line">            <span class="keyword">int</span> len = <span class="built_in">strlen</span>(thr.name);</span><br><span class="line">            name = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(len + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">strcpy</span>(name, thr.name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//必须要显式的提供深拷贝构造函数，不然会释放两次</span></span><br><span class="line">        ~<span class="built_in">Teacher</span>()&#123; </span><br><span class="line">            <span class="keyword">if</span>(name != <span class="literal">NULL</span>)&#123; </span><br><span class="line">                <span class="built_in">free</span>(name);</span><br><span class="line">                name = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123; </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;id: %d, name = %s\n&quot;</span>, id, name);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">char</span> *name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="function">Teacher <span class="title">t1</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;zhangsan&quot;</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">print</span>(); </span><br><span class="line">    <span class="function">Teacher <span class="title">t2</span><span class="params">(t1)</span></span>;</span><br><span class="line">    t2.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="指向对象成员函数的指针"><a href="#指向对象成员函数的指针" class="headerlink" title="指向对象成员函数的指针"></a>指向对象成员函数的指针</h5><ul>
<li>注意: 定义指向对象成员函数的指针变量的方法和定义<a href="https://blog.csdn.net/zxzxzx0119/article/details/84001021#t3"><strong>指向普通函数的指针变量</strong></a>不同，定义指向成员函数的指针变量的方法: <code>void (Time:: *p)();</code>(对比普通的: <code>void (*p)();</code>) : 定义<code>p</code>为指向<code>Time</code>类中公共成员函数的指针变量；</li>
<li>可以使用上面的<code>p</code>指针指向一个公用成员函数，只需把公用成员函数的入口地址赋给一个公用成员函数的指针即可，如<code>p = &amp;Time::get_time</code>;</li>
</ul>
<p>简单测试: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span>&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Time</span>(<span class="keyword">int</span> h, <span class="keyword">int</span> m, <span class="keyword">int</span> s):<span class="built_in">hour</span>(h),<span class="built_in">minute</span>(m),<span class="built_in">sec</span>(s)&#123; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">get_time</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> hour;</span><br><span class="line">        <span class="keyword">int</span> minute;</span><br><span class="line">        <span class="keyword">int</span> sec;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Time::get_time</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d:%d:%d\n&quot;</span>, hour, minute, sec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="function">Time <span class="title">t1</span><span class="params">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">30</span>)</span></span>; <span class="comment">//10:10:30</span></span><br><span class="line">    Time *p = &amp;t1; <span class="comment">//定义指向对象的指针</span></span><br><span class="line">    p-&gt;<span class="built_in">get_time</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (Time::*p2)(); <span class="comment">//定义指向Time类公共成员函数的指针变量</span></span><br><span class="line">    p2 = &amp;Time::get_time;</span><br><span class="line">    (t1.*p2)(); <span class="comment">// 调用对象t1中p2所指向的成员函数(即t1.get_time())</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span>:<span class="number">10</span>:<span class="number">30</span></span><br><span class="line"><span class="number">10</span>:<span class="number">10</span>:<span class="number">30</span></span><br></pre></td></tr></table></figure>
<h5 id="常对象"><a href="#常对象" class="headerlink" title="常对象"></a><font color = green>常对象</h5><ul>
<li>可以在定义对象时加上关键字<code>const</code>，指定对象为常对象。<font color= red>常对象必须要有初值，凡是希望保护数据成员不被改变的对象，都可以声明为常对象。</font></li>
<li>基本语法: <code>类名 const 对象名 [(实参表)]</code> 或者<code>const 类名 对象名 [(实参表)]</code>，举例: <code>Time const t(10, 10, 30)</code>和<code>const Time t(10, 10, 30)</code>；</li>
<li>如果一个对象被声明为常对象，则通过改对象<font color = red>只能调用它的常成员函数，不能调用对象的普通成员函数；例如<code>void get_time() const</code> </font>(常成员函数)；</li>
<li><font color= blue>常成员函数可以访问常对象中的数据成员，但不允许修改常对象中数据成员的值；</font></li>
</ul>
<h5 id="常对象成员-常数据成员-amp-常成员函数"><a href="#常对象成员-常数据成员-amp-常成员函数" class="headerlink" title="常对象成员-常数据成员&amp;常成员函数"></a><font color = green>常对象成员-常数据成员&amp;常成员函数</h5><p>①<font color = purple>常数据成员</p>
<ul>
<li>只能通过构造函数的<font color=  red>参数初始化表</font>对常数据成员进行初始化，任何其他函数都不能对常数据赋值；</li>
<li>因为常数据成员不能被赋值；</li>
</ul>
<p>②<font color = purple>常成员函数</p>
<ul>
<li>常成员函数声明: 例如<code>void get_time() const</code>，<font color= red>常成员函数只能引用本类中的数据成员，不能修改它们</font>；</li>
<li>注意: 如果定义了一个常对象，只能调用其中的<code>const</code>成员函数，不能调用非<code>const</code>成员函数(不论这些函数是否会修改对象中的数据)；</li>
<li>常成员函数不能调用另一个非<code>const</code>成员函数；</li>
</ul>
<table>
<thead>
<tr>
<th>数据成员</th>
<th>非<code>const</code>成员函数</th>
<th><code>const</code>成员函数</th>
</tr>
</thead>
<tbody><tr>
<td>非<code>const</code>数据成员</td>
<td>可以引用，可以改变值</td>
<td>可以引用，不可改变值</td>
</tr>
<tr>
<td><code>const</code>数据成员</td>
<td>可以引用，不可改变值</td>
<td>可以引用，不可改变值</td>
</tr>
<tr>
<td><code>const</code>对象</td>
<td>不允许</td>
<td>可以引用，不可改变值</td>
</tr>
</tbody></table>
<h5 id="指向对象的常指针"><a href="#指向对象的常指针" class="headerlink" title="指向对象的常指针"></a><font color = green>指向对象的常指针</h5><ul>
<li>基本语法<code>Time * const p = &amp;t1</code>和基本的常指针差不多；</li>
<li>只能指向同一个对象不能改变指针的指向；</li>
<li>意义是作为函数的形参，不允许在函数执行过程中改变指针变量，使其始终指向原来的对象；<h5 id="指向常变量、对象的指针"><a href="#指向常变量、对象的指针" class="headerlink" title="指向常变量、对象的指针"></a><font color = green>指向常变量、对象的指针</h5>①<font color = purple>指向常变量的指针</li>
<li>如果一个变量已经被声明为常变量，只能用指向常变量的指针变量指向它，而不能用非<code>const</code>指针指向它；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> c[] = <span class="string">&quot;boy&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p1 = c; <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">char</span> *p2 = c; <span class="comment">// err</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>const</code>指针除了可以指向<code>const</code>变量，<font color = blue>还可以指向非<code>const</code>变量，此时不能通过指针来改变变量的值；</li>
<li>如果函数的形参是指向非<code>const</code>变量的指针变量，实参只能使用指向非<code>const</code>变量的指针；更多形参和实参指针变量关系看下表；</li>
</ul>
<table>
<thead>
<tr>
<th><font color= blue>形参</th>
<th><font color= blue>实参</th>
<th><font color= blue>合法否</th>
<th><font color= blue>改变指针所指向的变量的值</th>
</tr>
</thead>
<tbody><tr>
<td>指向非<code>const</code>变量的指针</td>
<td>非<code>const</code>变量的地址</td>
<td>合法</td>
<td>可以</td>
</tr>
<tr>
<td>指向非<code>const</code>变量的指针</td>
<td><code>const</code>变量的地址</td>
<td>不合法</td>
<td></td>
</tr>
<tr>
<td>指向<code>const</code>变量的指针</td>
<td><code>const</code>变量的地址</td>
<td>合法</td>
<td>不可以</td>
</tr>
<tr>
<td>指向<code>const</code>变量的指针</td>
<td>非<code>const</code>变量的地址</td>
<td>合法</td>
<td>不可以</td>
</tr>
</tbody></table>
<p>②<font color = purple>指向常对象的指针</p>
<ul>
<li>和指向常变量的指针类似，只能用<font color = red>指向常对象的指针变量</font>指向它，不能用指向非<code>const</code>对象的指针指向它；</li>
<li>如果定义了一个指向常对象的指针变量，并指向了一个<font color=  red>非<code>const</code>对象</font>，则不能通过改指针变量来改变变量的值；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Time <span class="title">t1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="keyword">const</span> Time *p = &amp;t1;</span><br><span class="line">(*p).hour = <span class="number">20</span>;  <span class="comment">//err</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用意义也是在形参上，希望调用函数的时候对象的值不被改变，就把形参指定为指向常对象的指针变量；</li>
</ul>
<h5 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h5><p>①<font color = purple>静态数据成员</p>
<ul>
<li>静态数据成员在内存中只占一份空间(不是每一个对象都为它保留一份空间)，静态数据成员的值对所有对象都是一样的，如果改变它的值，在其他对象中也会改变；</li>
<li><font color = red>静态数据成员只能在类体外进行初始化。如<code>int Box::height = 10;</code>，只在类体中声明静态数据成员时加上<code>static</code>，不必在初始化语句中加<code>static</code>。</li>
<li>不能在参数初始化列表中对静态数据成员进行初始化；</li>
</ul>
<p>②<font color = purple>静态成员函数</p>
<ul>
<li><p><font color = red>静态成员函数和普通函数最大的区别就在静态成员函数没有<code>this</code>指针，决定了静态成员函数与不能访问本类中的非静态成员。</font>所以静态成员函数的作用就是用来访问静态数据成员；</p>
</li>
<li><p>但是普通成员函数(非静态)可以引用类中的静态数据成员；</p>
<h5 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h5><p>① <font color = purple>将普通函数声明为友元函数</p>
</li>
<li><p>这样这个普通函数就可以访问声明了友元函数的那个类的私有成员；</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Time</span>(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line">        <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Time&amp;)</span></span>; </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> hour;</span><br><span class="line">        <span class="keyword">int</span> minute;</span><br><span class="line">        <span class="keyword">int</span> sec;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Time::<span class="built_in">Time</span>(<span class="keyword">int</span> h, <span class="keyword">int</span> m, <span class="keyword">int</span> s)&#123; </span><br><span class="line">    hour = h;</span><br><span class="line">    minute = m;</span><br><span class="line">    sec = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通的友元函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(Time&amp; t)</span></span>&#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d:%d:%d\n&quot;</span>, t.hour, t.minute, t.sec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="function">Time <span class="title">t</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="built_in">display</span>(t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span>:<span class="number">10</span>:<span class="number">30</span></span><br></pre></td></tr></table></figure>

<p>② <font color = purple>将别的类中的成员函数声明为友元函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>;</span> <span class="comment">//对Date类声明</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span>&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Time</span>(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(Date &amp;)</span></span>; <span class="comment">//要访问Date类的成员</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> hour;</span><br><span class="line">        <span class="keyword">int</span> minute;</span><br><span class="line">        <span class="keyword">int</span> sec;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Time::<span class="built_in">Time</span>(<span class="keyword">int</span> h, <span class="keyword">int</span> m, <span class="keyword">int</span> s)&#123; </span><br><span class="line">    hour = h;</span><br><span class="line">    minute = m;</span><br><span class="line">    sec = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Date</span>(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line">        <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Time::display</span><span class="params">(Date &amp;)</span></span>; <span class="comment">//声明Time类中的display函数为本类的友元函数</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> month;</span><br><span class="line">        <span class="keyword">int</span> day;</span><br><span class="line">        <span class="keyword">int</span> year;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Date::<span class="built_in">Date</span>(<span class="keyword">int</span> m, <span class="keyword">int</span> d, <span class="keyword">int</span> y)&#123; </span><br><span class="line">    month = m;</span><br><span class="line">    day = d;</span><br><span class="line">    year = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Time::display</span><span class="params">(Date &amp;d)</span></span>&#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d/%d/%d\n&quot;</span>,d.month, d.day, d.year);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d:%d:%d\n&quot;</span>, hour, minute, sec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Time <span class="title">t</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Date <span class="title">d</span><span class="params">(<span class="number">12</span>,<span class="number">25</span>,<span class="number">2018</span>)</span></span>;</span><br><span class="line">    t.<span class="built_in">display</span>(d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>③ <font color = purple>友元类</p>
<ul>
<li>在<code>A</code>类中声明<code>B</code>类是自己的友元类，这样<code>B</code>类就可以访问<code>A</code>的所有私有成员了。</li>
<li>但是要注意友元的关系是单向的而不是双向的。且友元的关系不能传递；</li>
</ul>
<hr>
<h3 id="C-重载运算符"><a href="#C-重载运算符" class="headerlink" title="C++重载运算符"></a><font color = red id = "3">C++重载运算符</h3><h5 id="重载基本运算符"><a href="#重载基本运算符" class="headerlink" title="重载基本运算符"></a>重载基本运算符</h5><p><font color = purple><strong>案例一: 重载<code>+</code>号来计算复数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Complex</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b):<span class="built_in">a</span>(a),<span class="built_in">b</span>(b)&#123; &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 方法一.使用成员函数</span></span><br><span class="line">        <span class="comment">//不能写成返回&amp; （引用)因为temp是局部的 ,函数调用完毕就会释放 </span></span><br><span class="line">        Complex <span class="keyword">operator</span>+ (<span class="keyword">const</span> Complex &amp;thr)&#123;</span><br><span class="line">            <span class="function">Complex <span class="title">temp</span><span class="params">(a + thr.a, b + thr.b)</span></span>;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//　方法二.使用友元函数</span></span><br><span class="line">        <span class="comment">//friend Complex operator+ (const Complex &amp;c1, const Complex &amp;c2);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123; </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d,%di)\n&quot;</span>,a,b);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> a; <span class="comment">//实部</span></span><br><span class="line">        <span class="keyword">int</span> b; <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Complex operator+ (const Complex &amp;c1, const Complex &amp;c2)&#123; //注意也不能返回局部的引用 </span></span><br><span class="line"><span class="comment">//    return Complex(c1.a + c2.a, c1.b + c2.b);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">3</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">    Complex c3 = c1 + c2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面的显示调用也是和上面等同的，但是一般不会这么写</span></span><br><span class="line">    <span class="comment">//Complex c3 = c1.operator+(c2); //成员函数 </span></span><br><span class="line">    <span class="comment">//Complex c3 = operator+(c1, c2); //友元函数</span></span><br><span class="line">    c3.<span class="built_in">printC</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(<span class="number">4</span>,<span class="number">6</span>i)</span><br></pre></td></tr></table></figure>

<p><font color = purple><strong>案例二: 重载双目运算符</strong></p>
<ul>
<li>注意这个要返回的是引用，因为运算符支持连续的相加操作；</li>
<li>在成员函数中返回 <code>this</code>指针指向的内容，在友元函数中可以返回第一个参数的引用(不是局部变量的，所以可以返回)；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重载 += 运算符</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Complex</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b):<span class="built_in">a</span>(a), <span class="built_in">b</span>(b)&#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法一:使用成员函数 </span></span><br><span class="line">        <span class="comment">// 注意这里和上一个不同，这里要返回引用</span></span><br><span class="line">        <span class="comment">//Complex&amp; operator+= (const Complex &amp;thr)&#123; </span></span><br><span class="line">        <span class="comment">//    this-&gt;a += thr.a;</span></span><br><span class="line">        <span class="comment">//    this-&gt;b += thr.b;</span></span><br><span class="line">        <span class="comment">//    return *this; //注意这里返回this指针指向的内容</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法二: 使用友元函数</span></span><br><span class="line">        <span class="keyword">friend</span> Complex&amp; <span class="keyword">operator</span>+= (Complex&amp; c1, <span class="keyword">const</span> Complex&amp; c2);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123; </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d,%di)\n&quot;</span>, a, b);   </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//也要返回引用 因为要支持连续操作 类似(c1 += c2) += c3</span></span><br><span class="line">Complex&amp; <span class="keyword">operator</span>+= (Complex&amp; c1, <span class="keyword">const</span> Complex&amp; c2)&#123; </span><br><span class="line">    c1.a += c2.a;</span><br><span class="line">    c1.b += c2.b;</span><br><span class="line">    <span class="keyword">return</span> c1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">3</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">    (c1 += c2) += c2;</span><br><span class="line">    c1.<span class="built_in">printC</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><font color = purple><strong>案例三: 重载单目运算符</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Complex</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b):<span class="built_in">a</span>(a),<span class="built_in">b</span>(b)&#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重载 前置++</span></span><br><span class="line">        Complex <span class="keyword">operator</span>++ ()&#123; </span><br><span class="line">            a++;</span><br><span class="line">            b++;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载后置++  需要使用一个占位符</span></span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">const</span> Complex <span class="keyword">operator</span>++ (Complex&amp; c1, <span class="keyword">int</span>);</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123; </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d,%di)\n&quot;</span>, a, b);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">int</span> b;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置++</span></span><br><span class="line"><span class="keyword">const</span> Complex <span class="keyword">operator</span>++ (Complex&amp; c1, <span class="keyword">int</span>)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="function">Complex <span class="title">temp</span><span class="params">(c1.a, c1.b)</span></span>;</span><br><span class="line">    c1.a++;</span><br><span class="line">    c1.b++;</span><br><span class="line">    <span class="keyword">return</span> temp; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="function">Complex <span class="title">c</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    c++;</span><br><span class="line">    c.<span class="built_in">printC</span>();</span><br><span class="line">    ++c;</span><br><span class="line">    c.<span class="built_in">printC</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(<span class="number">2</span>,<span class="number">3</span>i)</span><br><span class="line">(<span class="number">3</span>,<span class="number">4</span>i)</span><br></pre></td></tr></table></figure>


<h5 id="重载-号操作符"><a href="#重载-号操作符" class="headerlink" title="重载=号操作符"></a>重载<code>=</code>号操作符</h5><ul>
<li>这个重点是在当类中有指针的时候，就要注意堆中分配空间的问题，如果不是在初始化的时候使用的<code>=</code>操作符，就是代表的赋值，其中的指针不能使用浅拷贝；</li>
<li>需要我们重写<code>=</code>操作符，实现深拷贝。(就是不能让两个对象同时指向堆中的同一块内存，因为释放内存的时候不能释放两次)；<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Student</span>() &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;id = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">this</span>-&gt;name = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Student</span>(<span class="keyword">int</span> id, <span class="keyword">const</span> <span class="keyword">char</span> *name)&#123; </span><br><span class="line">            <span class="keyword">this</span>-&gt;id = id;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> len = <span class="built_in">strlen</span>(name);</span><br><span class="line">            <span class="keyword">this</span>-&gt;name = <span class="keyword">new</span> <span class="keyword">char</span>[len+<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Student</span>(<span class="keyword">const</span> Student&amp; thr)&#123;  <span class="comment">// 拷贝构造</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;id = thr.id;</span><br><span class="line">            <span class="comment">//深拷贝</span></span><br><span class="line">            <span class="keyword">int</span> len = <span class="built_in">strlen</span>(thr.name);</span><br><span class="line">            <span class="keyword">this</span>-&gt;name = <span class="keyword">new</span> <span class="keyword">char</span>[len+<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, thr.name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重载=号，防止 s2 = s1的时候内部的name直接指向堆中的同一个内容，析构时发生错误</span></span><br><span class="line">        Student&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Student&amp; thr)&#123; </span><br><span class="line">            <span class="comment">//1. 防止自身赋值</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;thr) <span class="comment">//&amp;是取地址 </span></span><br><span class="line">                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">            <span class="comment">//2. 将自身的空间回收</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;name != <span class="literal">NULL</span>)&#123; </span><br><span class="line">                <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;name;</span><br><span class="line">                <span class="keyword">this</span>-&gt;name = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">this</span>-&gt;id = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3. 执行深拷贝</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;id = thr.id;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="built_in">strlen</span>(thr.name);</span><br><span class="line">            <span class="keyword">this</span>-&gt;name = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, thr.name);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4. 返回本身的对象</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">Student</span>()&#123; </span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;name != <span class="literal">NULL</span>)&#123; </span><br><span class="line">                <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;name;</span><br><span class="line">                <span class="keyword">this</span>-&gt;name = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">this</span>-&gt;id = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">printS</span><span class="params">()</span></span>&#123; </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, name);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">char</span> *name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">s1</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;zhangsan&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Student <span class="title">s2</span><span class="params">(s1)</span></span>; <span class="comment">//拷贝构造</span></span><br><span class="line">    Student s3 = s1; <span class="comment">//这个调用的还是拷贝构造函数，不是=操作符，初始化的都是拷贝构造函数</span></span><br><span class="line">    s1.<span class="built_in">printS</span>();</span><br><span class="line">    s2.<span class="built_in">printS</span>();</span><br><span class="line">    s3.<span class="built_in">printS</span>();</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//但是这样就是调用的等号操作符</span></span><br><span class="line">    Student s4;</span><br><span class="line">    s4 = s1; <span class="comment">//不是初始化的时候</span></span><br><span class="line">    s4.<span class="built_in">printS</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="重载流插入运算符和流提取运算符"><a href="#重载流插入运算符和流提取运算符" class="headerlink" title="重载流插入运算符和流提取运算符"></a>重载流插入运算符和流提取运算符</h5><ul>
<li>重载流插入运算符的基本格式: <code>istream&amp; operator&gt;&gt; (istream&amp;, 自定义类&amp;);</code> ，也就是返回值和第一个参数必须是<code>istream&amp;</code>类型；</li>
<li>重载流提取运算符的基本格式: <code>ostream&amp; operator&lt;&lt; (istream&amp;, 自定义类&amp;);</code>，也就是返回值和第一个参数必须是<code>ostream&amp;</code>类型；</li>
<li><font color = red>注意: 重载这两个运算符的时候，只能将他们作为友元函数，不能作为成员函数。避免修改 <code>c++</code>的标准库。</font></li>
</ul>
<p>案例: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp;, Complex&amp;);</span><br><span class="line">        <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt; (istream&amp;, Complex&amp;);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp; os, Complex&amp; c)</span><br><span class="line">&#123; </span><br><span class="line">    os&lt;&lt;<span class="string">&quot;(&quot;</span>&lt;&lt;c.a&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;c.b&lt;&lt;<span class="string">&quot;i)&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> os;<span class="comment">//返回stream对象就可以连续向输出流插入信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt; (istream&amp; is, Complex&amp; c)</span><br><span class="line">&#123; </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a:&quot;</span>;</span><br><span class="line">    is&gt;&gt;c.a;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;b:&quot;</span>;</span><br><span class="line">    is&gt;&gt;c.b;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Complex c;</span><br><span class="line">    cin&gt;&gt;c;</span><br><span class="line">    cout&lt;&lt;c;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="综合案例-矩阵加法以及输入输出"><a href="#综合案例-矩阵加法以及输入输出" class="headerlink" title="综合案例-矩阵加法以及输入输出"></a>综合案例-矩阵加法以及输入输出</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span>&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Matrix</span>();</span><br><span class="line">        <span class="keyword">friend</span> Matrix <span class="keyword">operator</span>+(Matrix&amp;, Matrix&amp;);</span><br><span class="line">        <span class="comment">//千万注意: 只能将&quot;&lt;&lt;&quot;和&quot;&gt;&gt;&quot;定义为友元函数，不能作为成员函数</span></span><br><span class="line">        <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp;, Matrix&amp;);</span><br><span class="line">        <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp;, Matrix&amp;); </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> mat[N][M];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Matrix::<span class="built_in">Matrix</span>()&#123; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++)&#123; </span><br><span class="line">            mat[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意返回局部变量对象，不能返回引用</span></span><br><span class="line">Matrix <span class="keyword">operator</span>+ (Matrix&amp; a, Matrix&amp; b)&#123; </span><br><span class="line">    Matrix c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++)&#123; </span><br><span class="line">            c.mat[i][j] = a.mat[i][j] + b.mat[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, Matrix&amp; m)&#123; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++)&#123; </span><br><span class="line">            os&lt;&lt;m.mat[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        os&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; is, Matrix&amp; m)&#123; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++)&#123; </span><br><span class="line">            is&gt;&gt;m.mat[i][j];</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Matrix matrix1,matrix2;</span><br><span class="line">    cin&gt;&gt;matrix1;</span><br><span class="line">    cin&gt;&gt;matrix2;</span><br><span class="line">    Matrix matrix3 = matrix1 + matrix2;</span><br><span class="line">    cout&lt;&lt;matrix3&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:<br><img src="images/cpp1.png" alt="在这里插入图片描述"></p>
<hr>
<h3 id="函数模板、类模板"><a href="#函数模板、类模板" class="headerlink" title="函数模板、类模板"></a><font color = red id = "4">函数模板、类模板</h3><ul>
<li>函数模板基本语法: <code>template &lt;typename T&gt;</code>；</li>
<li>类模板基本语法: <code>template &lt;class T&gt;</code>，注意函数声明在外面的时候也要在函数的上面写上这个语句；</li>
<li>函数模板实际上是建立一个通用函数， 其函数类型和形参类型不具体制定， 用 一个虚拟的类型来代表。 这 个通用函数就成为函数模板；</li>
<li>注意:  ①函数模板不允许自动类型转化；②普通函数能够自动进行类型转化；</li>
<li>&lt;函数模板和普通函数在一起调用规则：① 函数模板可以想普通函数那样可以被重载；②<code>C++</code>编 译器优先考虑普通函数；</li>
<li>类模板中的 <code>static</code>关 键字: ①从 类模板实例化的每一个模板类有自己的类模板数据成员， 该 模板的所有对象共享一 个 <code>statci</code>数 据成员②每 个模板类有自己类模板的<code>static</code>数据成员的副本；</li>
</ul>
<p>测试程序: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap1</span><span class="params">(T&amp; a, T&amp; b)</span></span>&#123;</span><br><span class="line">    T t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">R</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Complex</span>(T a, R b):<span class="built_in">a</span>(a),<span class="built_in">b</span>(b)&#123; &#125;</span><br><span class="line">        <span class="comment">//方法一: 下面的printC函数是在类内实现</span></span><br><span class="line">        <span class="comment">//void printC()</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">        <span class="comment">//    cout&lt;&lt;&quot;(&quot;&lt;&lt;a&lt;&lt;&quot;,&quot;&lt;&lt;b&lt;&lt;&quot;i)&quot;&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方法二: 在类外实现要声明</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法三: 重载+友元函数 最好作为内部，外部有点麻烦</span></span><br><span class="line">        <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp; os, Complex&lt;T,R&gt;&amp; c)&#123; </span><br><span class="line">            os&lt;&lt;<span class="string">&quot;(&quot;</span>&lt;&lt;c.a&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;c.b&lt;&lt;<span class="string">&quot;i)&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> os;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T a;</span><br><span class="line">        R b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在类外实现,必须要加上函数模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">R</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Complex&lt;T,R&gt;::<span class="built_in">printC</span>()</span><br><span class="line">&#123; </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;(&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;b&lt;&lt;<span class="string">&quot;i)&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    swap1&lt;<span class="keyword">int</span>&gt;(a,b);<span class="comment">//显示的调用</span></span><br><span class="line">    <span class="comment">//自动类型推导</span></span><br><span class="line">    <span class="comment">//swap1(a, b);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d,b = %d\n&quot;</span>, a, b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-------类模板-------\n&quot;</span>);</span><br><span class="line">    Complex&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt;<span class="built_in">c1</span>(<span class="number">2.2</span>, <span class="number">3.3</span>);</span><br><span class="line">    c1.<span class="built_in">printC</span>();</span><br><span class="line"></span><br><span class="line">    Complex&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt;<span class="built_in">c2</span>(<span class="number">4</span>, <span class="number">5.5</span>);</span><br><span class="line">    cout&lt;&lt;c2&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a = <span class="number">20</span>,b = <span class="number">10</span></span><br><span class="line">-------类模板-------</span><br><span class="line">(<span class="number">2.2</span>,<span class="number">3.3</span>i)</span><br><span class="line">(<span class="number">4</span>,<span class="number">5.5</span>i)</span><br></pre></td></tr></table></figure>
<h5 id="案例-简单实现的Vector类模板中的push-back"><a href="#案例-简单实现的Vector类模板中的push-back" class="headerlink" title="案例-简单实现的Vector类模板中的push_back"></a>案例-简单实现的Vector类模板中的<code>push_back</code></h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span>&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">MyArray</span>(<span class="keyword">int</span> capacity)&#123; <span class="comment">//构造函数</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">            <span class="keyword">this</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">this</span>-&gt;p = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;capacity];</span><br><span class="line">        &#125;</span><br><span class="line">        MyArray&lt;T&gt;(<span class="keyword">const</span> MyArray&lt;T&gt;&amp; thr)&#123; <span class="comment">//拷贝构造</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;size = thr.size;</span><br><span class="line">            <span class="keyword">this</span>-&gt;capacity = thr.capacity;</span><br><span class="line">            <span class="keyword">this</span>-&gt;p = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;capacity];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;size; i++)&#123;  </span><br><span class="line">                <span class="keyword">this</span>-&gt;p[i] = thr.p[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重载=号</span></span><br><span class="line">        MyArray&lt;T&gt;&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> MyArray&lt;T&gt;&amp; thr)&#123; </span><br><span class="line">             <span class="comment">//1. 防止自身赋值</span></span><br><span class="line">             <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;thr)&#123; </span><br><span class="line">                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//2. 删除原来的</span></span><br><span class="line">            <span class="keyword">if</span>(p != <span class="literal">NULL</span>)&#123; </span><br><span class="line">                <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;p;</span><br><span class="line">                <span class="keyword">this</span>-&gt;p = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>-&gt;size = thr.size;</span><br><span class="line">            <span class="keyword">this</span>-&gt;capacity = thr.capacity;</span><br><span class="line">            <span class="keyword">this</span>-&gt;p = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;capacity];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;size; i++)&#123; </span><br><span class="line">                <span class="keyword">this</span>-&gt;p[i] = thr.p[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//重载[]运算符: 提取元素</span></span><br><span class="line">        T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;p[index];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">pushBack</span><span class="params">(T&amp; ele)</span></span>&#123; </span><br><span class="line">            <span class="keyword">if</span>(size == capacity)&#123; </span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 调用的是 = 号运算符，如果成员是指针，要注意深拷贝问题</span></span><br><span class="line">            p[size++] = ele;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//搞定插入常量(右值)的引用问题(C++11特性)</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">pushBack</span><span class="params">(T&amp;&amp; ele)</span></span>&#123; </span><br><span class="line">            <span class="keyword">if</span>(size == capacity)&#123; </span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 调用的是 = 号运算符，如果成员是指针，要注意深拷贝问题</span></span><br><span class="line">            p[size++] = ele;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~<span class="built_in">MyArray</span>()&#123; </span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;p != <span class="literal">NULL</span>)&#123; </span><br><span class="line">                <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;size;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> capacity;<span class="comment">//容量</span></span><br><span class="line">        <span class="keyword">int</span> size; <span class="comment">//当前数组元素</span></span><br><span class="line">        T *p; <span class="comment">//数组首地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    MyArray&lt;<span class="keyword">int</span>&gt;<span class="built_in">array</span>(<span class="number">20</span>); </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    array.<span class="built_in">pushBack</span>(a);</span><br><span class="line">    array.<span class="built_in">pushBack</span>(b);</span><br><span class="line"></span><br><span class="line">    array.<span class="built_in">pushBack</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.<span class="built_in">getSize</span>(); i++)&#123; </span><br><span class="line">        cout&lt;&lt;array[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a><font color = red id = "5">文件操作</h3><h4 id="输入输出流"><a href="#输入输出流" class="headerlink" title="输入输出流"></a>输入输出流</h4><p><code>C++</code>输入输出包含以下三个方面的内容：</p>
<ul>
<li>对 系统指定的标准设备的输入和输出。 即从键盘输入数据，输出到显示器屏幕。这种输入输出称为标准的输入输出，简称<font color  = blue>标准 I /O。</li>
<li>以外存磁盘文件为对象进行输入和输出， 即从磁盘文件输入数据， 数据输出到磁盘文件。 以外存文件为对象的输入输出称为文件的输入输出，简称<font color  = blue>文件 I /O。</li>
<li>对 内存中指定的空间进行输入和输出。通常指定一个字符数组作为存储空间( 实际上可以利用该空间存储任何信息) 。 这种输入和输出称为字符串输入输出，简称<font color  = blue>串 I /O。 </li>
</ul>
<p>缓冲区的概念: </p>
<ul>
<li>要注意；</li>
<li>读和写是站在应用程序的角度来看的；<br><img src="images/cpp2.png" alt="在这里插入图片描述"></li>
</ul>
<p>标准输入流对象 <code>cin</code>， 重点函数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cin.<span class="built_in">get</span>() <span class="comment">// 一次只能读取一个字符</span></span><br><span class="line">cin.<span class="built_in">get</span>(一个参数) <span class="comment">// 读 一个字符</span></span><br><span class="line">cin.<span class="built_in">get</span>(两个参数) <span class="comment">// 可以读字符串</span></span><br><span class="line">cin.<span class="built_in">getline</span>()</span><br><span class="line">cin.<span class="built_in">ignore</span>()</span><br><span class="line">cin.<span class="built_in">peek</span>()</span><br><span class="line">cin.<span class="built_in">putback</span>()</span><br></pre></td></tr></table></figure>

<p>测试<code>cin.get()</code>、<code>cin.getline()</code>的简单使用: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="comment">//while( (ch = cin.get()) != EOF)</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; ch &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//char ch;  cin.get(ch); //same as above</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    cin.<span class="built_in">get</span>(buf, <span class="number">256</span>); <span class="comment">//　两个参数,从缓冲区读取一个字符串指定长度</span></span><br><span class="line">    cout &lt;&lt; buf;</span><br><span class="line">    cin.<span class="built_in">get</span>(buf, <span class="number">256</span>, <span class="string">&#x27;\n&#x27;</span>); <span class="comment">//三个参数,指定终止的字符</span></span><br><span class="line">    cout &lt;&lt; buf;</span><br><span class="line">    cin.<span class="built_in">getline</span>(buf, <span class="number">256</span>);  <span class="comment">//读取一行数据，不读换行符</span></span><br><span class="line">    cout &lt;&lt; buf;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试<code>cin.ignore()</code>使用: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    cin.<span class="built_in">get</span>(ch);    <span class="comment">//从缓冲区要数据 阻塞</span></span><br><span class="line">    cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">    cin.<span class="built_in">ignore</span>(<span class="number">1</span>); <span class="comment">//忽略当前字符 从缓冲区取走了</span></span><br><span class="line">    cin.<span class="built_in">get</span>(ch);</span><br><span class="line">    cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果:<br><img src="images/cpp3.png" alt="在这里插入图片描述"></p>
<p>测试<code>cin.peek()</code>函数的使用: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入数组或者字符串:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    ch = cin.<span class="built_in">peek</span>(); <span class="comment">//偷窥一下缓冲区，并不会取走, 返回第一个字符</span></span><br><span class="line">    <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> number;</span><br><span class="line">        cin &gt;&gt; number; <span class="comment">// 从缓冲区读取这个数字</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;您输入的是数字:&quot;</span> &lt;&lt; number &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        cin &gt;&gt; buf; <span class="comment">// 从缓冲区读取这个字符串</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;您输入的是字符串:&quot;</span> &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：　<br><img src="images/cpp4.png" alt="在这里插入图片描述"></p>
<p>测试<code>cin.putback()</code>函数的使用: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入字符串或者数字:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    cin.<span class="built_in">get</span>(ch); <span class="comment">//从缓冲区取走一个字符</span></span><br><span class="line">    <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        cin.<span class="built_in">putback</span>(ch); <span class="comment">//ch放回到缓冲区</span></span><br><span class="line">        <span class="keyword">int</span> number;</span><br><span class="line">        cin &gt;&gt; number;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;您输入的是数字:&quot;</span> &lt;&lt; number &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cin.<span class="built_in">putback</span>(ch);<span class="comment">// 将字符放回缓冲区</span></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        cin &gt;&gt; buf;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;您输入的是字符串: &quot;</span> &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果和测试<code>cin.peek()</code>函数的一样。</p>
<p>标准输出流对象 <code>cout</code>，重点函数: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout.<span class="built_in">flush</span>() <span class="comment">// 刷新缓冲区</span></span><br><span class="line">cout.<span class="built_in">put</span>() <span class="comment">// 向缓冲区写字符</span></span><br><span class="line">cout.<span class="built_in">write</span>() <span class="comment">// 二进制流的输出</span></span><br><span class="line">cout.<span class="built_in">width</span>() <span class="comment">// 输出格式控制</span></span><br><span class="line">cout.<span class="built_in">fill</span>()</span><br><span class="line">cout.<span class="built_in">setf</span>(标记)</span><br></pre></td></tr></table></figure>
<p><code>cout</code>比较简单不做案例演示。</p>
<h4 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h4><p>输入输出是以系统指定的标准设备（输入设备为键盘，输出设备为显示器）为对象的。 在实际应用中，常以磁盘文件作为对象。即从磁盘文件读取数据，将数据输出到磁盘文件。 和 文件有关系的输入输出类主要在 <code>fstream.h</code> 这 个头文件中被定义，在这个头文件中主要被定义了三个类， 由这三个类控制对文件的各种输入输出操作 ， 他们分别是 <code>ifstream</code>、 <code>ofstream</code>。</p>
<p><img src="images/cpp5.png" alt="在这里插入图片描述"><br>由于文件设备并不像显示器屏幕与键盘那样是标准默认设备，所以它在 <code>fstream.h</code> 头 文件中<br>是没有像 <code>cout</code> 那 样预先定义的全局对象，所以我们必须自己定义一个该类的对象。 <code>ifstream</code> 类 ，它是从 <code>istream</code> 类 派生的，用来支持从磁盘文件的输入。<code>ofstream</code> 类 ，它是从<code>ostream</code>类 派生的，用来支持向磁盘文件的输出。<br><code>fstream</code> 类 ，它是从<code>iostream</code>类 派生的，用来支持对磁盘文件的输入输出。</p>
<p>所谓打开( <code>open</code>)文 件是一种形象的说法，如同打开房门就可以进入房间活动一样。 打<br>开 文件是指在文件读写之前做必要的准备工作，包括：</p>
<ul>
<li>为文件流对象和指定的磁盘文件建立关联，以便使文件流 向指定的磁盘文件。</li>
<li> 指定文件的工作方式，如，该文件是作为输入文件还是输出文件，是 <code>ASCII</code> 文件还是二进制文件等。</li>
</ul>
<p>以上工作可以通过两种不同的方法实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span> <span class="comment">//文件读写的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* srcName = <span class="string">&quot;src.txt&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* destName = <span class="string">&quot;dest.txt&quot;</span>;</span><br><span class="line">    <span class="function">ifstream <span class="title">is</span><span class="params">(srcName, ios::in)</span></span>; <span class="comment">//只读方式打开</span></span><br><span class="line">    <span class="function">ofstream <span class="title">os</span><span class="params">(destName, ios::out | ios::app)</span></span>; <span class="comment">// app表示是追加</span></span><br><span class="line">    <span class="keyword">if</span>(!is)&#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;打开文件失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>(is.<span class="built_in">get</span>(ch))&#123; </span><br><span class="line">        cout &lt;&lt; ch;</span><br><span class="line">        os.<span class="built_in">put</span>(ch); <span class="comment">// 输出到os指向的文件</span></span><br><span class="line">    &#125;</span><br><span class="line">    is.<span class="built_in">close</span>();</span><br><span class="line">    os.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>演示结果:<br><img src="images/cpp6.png" alt="在这里插入图片描述"></p>
<p>测试按照二进制方式写入和读取: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="built_in">Person</span>()&#123; &#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">int</span> age, <span class="keyword">int</span> id):<span class="built_in">age</span>(age), <span class="built_in">id</span>(id)&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age: &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;, id: &quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Person p1(10, 20), p2(30, 40);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *destFile = <span class="string">&quot;dest.txt&quot;</span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">os</span><span class="params">(destFile, ios::out | ios::binary)</span></span>; <span class="comment">// 二进制方式写入</span></span><br><span class="line">    os.<span class="built_in">write</span>((<span class="keyword">char</span>*)&amp;p1, <span class="built_in"><span class="keyword">sizeof</span></span>(Person));</span><br><span class="line">    os.<span class="built_in">write</span>((<span class="keyword">char</span>*)&amp;p2, <span class="built_in"><span class="keyword">sizeof</span></span>(Person));</span><br><span class="line">    os.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *destFile = <span class="string">&quot;dest.txt&quot;</span>;</span><br><span class="line">    <span class="function">ifstream <span class="title">is</span><span class="params">(destFile, ios::in | ios::binary)</span></span>;</span><br><span class="line">    Person p1, p2;</span><br><span class="line">    is.<span class="built_in">read</span>((<span class="keyword">char</span>*)&amp;p1, <span class="built_in"><span class="keyword">sizeof</span></span>(Person));</span><br><span class="line">    is.<span class="built_in">read</span>((<span class="keyword">char</span>*)&amp;p2, <span class="built_in"><span class="keyword">sizeof</span></span>(Person));</span><br><span class="line">    p1.<span class="built_in">show</span>();</span><br><span class="line">    p2.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C Language</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Instrction Arrangement以及关键路径详解</title>
    <url>/2022/02/25/Ordering%20Tasks%20_%20LeetCode%20-%20207.%20Course%20Schedule%20(%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F)/</url>
    <content><![CDATA[<h2 id="Ordering-Tasks-LeetCode-207-Course-Schedule-拓扑排序"><a href="#Ordering-Tasks-LeetCode-207-Course-Schedule-拓扑排序" class="headerlink" title="Ordering Tasks | LeetCode - 207. Course Schedule (拓扑排序)"></a>Ordering Tasks | LeetCode - 207. Course Schedule (拓扑排序)</h2><ul>
<li><a href="#1">Uva - 10305. Ordering Tasks</a></li>
<li><a href="#2">LeetCode - 207. Course Schedule</a></li>
</ul>
<hr>
<h3 id="Uva-10305-Ordering-Tasks"><a href="#Uva-10305-Ordering-Tasks" class="headerlink" title="Uva - 10305. Ordering Tasks"></a><font color = red id = "1">Uva - 10305. Ordering Tasks</h3><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1246">题目链接</a></h4><blockquote>
<p><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1246">https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1246</a></p>
</blockquote>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p><img src="images/to1.png"></p>
<p>给你<code>n、m</code>，<code>n</code>代表点的个数，<code>m</code>代表边的条数，然后下面给出<code>m</code>条边，都是有向的(有向图)，要你建出一个图，并且找出一种序列，这种序列即拓扑序列 。</p>
<blockquote>
<p>拓扑排序  是对有向无环图（<code>DAG</code>)进行的一种操作，这种操作是将<code>DAG</code>中的所有顶点排成一个线性序列，使得图中的任意一对顶点<code>u,v</code>满足如下条件：若边<code>(u,v) ∈ E(G)</code>，则<code>u</code>在最终的线性序列中出现在<code>v</code>的前面;<br>拓扑排序的应用常常和<code>AOV</code>网相联系，在一个大型的工程中，某些项目不是独立于其他项目的，这意味着这种非独立的项目的完成必须依赖与其它项目的完成而完成，不妨记为<code>u,v</code>，则若边<code>(u,v)∈E(G)</code>，代表着必须在项目<code>u</code>完成后，<code>v</code>才能完成。</p>
</blockquote>
<p> <strong>所以如果存在有向环，则不存在拓扑排序</strong>，反之则存在。</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>拓扑排序可以使用<code>BFS</code>或者<code>DFS</code>来求解。</p>
<p><font color = purple><strong>①<code>BFS</code></strong></font></p>
<p>拓扑排序使用<code>BFS</code>解题的过程: </p>
<ul>
<li>找出入度为<code>0</code>的结点并加入队列；</li>
<li>在队列中弹出一个结点，并访问，<strong>并把它的相邻结点的入度<code>-1</code>，如果减一之后入度为<code>0</code>，则也进队列；</strong></li>
<li>直到队列为空，访问完毕 ；</li>
</ul>
<p>通过上述过程即可以得到图的拓扑序列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;Integer&gt; G[];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] in;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n , m;</span><br><span class="line">    <span class="keyword">static</span> PrintStream out;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortedTopology</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt;queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[i] == <span class="number">0</span>)</span><br><span class="line">                queue.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>; <span class="comment">// for output</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                out.print(cur);</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                out.print(<span class="string">&quot; &quot;</span> + cur);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[cur].size(); i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> to = G[cur].get(i);</span><br><span class="line">                <span class="keyword">if</span>(--in[to] == <span class="number">0</span>)</span><br><span class="line">                    queue.add(to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line">        out = System.out;</span><br><span class="line">        <span class="keyword">while</span>(cin.hasNext())&#123;</span><br><span class="line">            n = cin.nextInt();</span><br><span class="line">            m = cin.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            in = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">            G = <span class="keyword">new</span> ArrayList[n + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">                G[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> from = cin.nextInt();</span><br><span class="line">                <span class="keyword">int</span> to = cin.nextInt();</span><br><span class="line">                G[from].add(to);</span><br><span class="line">                in[to]++;</span><br><span class="line">            &#125;</span><br><span class="line">            sortedTopology();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color = purple><strong>②<code>DFS</code></strong></font><br>使用<code>DFS</code>求解拓扑排序的过程:</p>
<ul>
<li>这里的<code>vis</code>需要表示三个状态，即: <code>vis[i] = 0</code>表示还从未访问过、<code>vis[i] = 1</code>表示已经访问过、<code>vis[i] = 2</code>表示正在访问；</li>
<li>只需要通过上述的设置，即可以判断是否能得到拓扑排序(或者说是否有环)；</li>
<li>然后我们还需要记录拓扑序列，因为递归不断进行到深层，所以我们需要用栈来记录拓扑序列，这里用一个数组<font color = red>从后往前</font>存即可；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;Integer&gt; G[];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] vis;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n , m;</span><br><span class="line">    <span class="keyword">static</span> PrintStream out;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] res;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> p;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123; </span><br><span class="line">        vis[cur] = <span class="number">2</span>; <span class="comment">// now is visiting </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> to : G[cur])&#123;  </span><br><span class="line">            <span class="keyword">if</span>(vis[to] == <span class="number">2</span> || (vis[to] == <span class="number">0</span> &amp;&amp; !dfs(to))) <span class="comment">// exist directed cycle </span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[cur] = <span class="number">1</span>; <span class="comment">// now is visited</span></span><br><span class="line">        res[p--] = cur;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line">        out = System.out;</span><br><span class="line">        <span class="keyword">while</span>(cin.hasNext())&#123;</span><br><span class="line">            n = cin.nextInt();</span><br><span class="line">            m = cin.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            G = <span class="keyword">new</span> ArrayList[n + <span class="number">1</span>];</span><br><span class="line">            vis = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">                G[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> from = cin.nextInt();</span><br><span class="line">                <span class="keyword">int</span> to = cin.nextInt();</span><br><span class="line">                G[from].add(to);</span><br><span class="line">            &#125; </span><br><span class="line">            p = n - <span class="number">1</span>;  <span class="comment">// back to front</span></span><br><span class="line">            res = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">boolean</span> ok = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; </span><br><span class="line">                <span class="keyword">if</span>(vis[i] == <span class="number">0</span>)</span><br><span class="line">                    dfs(i);</span><br><span class="line">            &#125;       </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n-<span class="number">1</span>; i++)</span><br><span class="line">                out.print(res[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            out.println(res[n-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="LeetCode-207-Course-Schedule"><a href="#LeetCode-207-Course-Schedule" class="headerlink" title="LeetCode - 207. Course Schedule"></a><font color = red id = "2">LeetCode - 207. Course Schedule</h3><h4 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a><a href="https://leetcode.com/problems/course-schedule/">题目链接</a></h4><blockquote>
<p><a href="https://leetcode.com/problems/course-schedule/">https://leetcode.com/problems/course-schedule/</a></p>
</blockquote>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><img src="images/to2.png" alt="在这里插入图片描述"></p>
<h4 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h4><p>和上一个题目差不多，这个题目更加简单，只需要你判断能不能得到拓扑序列。</p>
<p><font color = purple><strong>①<code>BFS</code></strong></font></p>
<ul>
<li>总体过程和上一题差不多；</li>
<li>这里增加一个<code>vis</code>数组，当我们进行完<code>BFS</code>过程之后，如果还有点没有被访问到<code>vis[i] = false</code>，则说明不能得到拓扑序列(有环)；</li>
</ul>
<p><img src="images/to3.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// topological sorting should be used on directed acyclic graph </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = numCourses;</span><br><span class="line">        ArrayList&lt;Integer&gt; G[] = <span class="keyword">new</span> ArrayList[n];</span><br><span class="line">        <span class="keyword">int</span>[] in = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">boolean</span>[] vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            G[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; i++)&#123; </span><br><span class="line">            <span class="keyword">int</span> to = prerequisites[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> from = prerequisites[i][<span class="number">1</span>];</span><br><span class="line">            G[from].add(to);</span><br><span class="line">            in[to]++;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt;queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span>(in[i] == <span class="number">0</span>)</span><br><span class="line">                queue.add(i);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123; </span><br><span class="line">            Integer cur = queue.poll();</span><br><span class="line">            vis[cur] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[cur].size(); i++)&#123; </span><br><span class="line">                <span class="keyword">int</span> to = G[cur].get(i);</span><br><span class="line">                <span class="keyword">if</span>(--in[to] == <span class="number">0</span>)</span><br><span class="line">                    queue.add(to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span>(!vis[i]) <span class="comment">// 有些点没有访问到</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        PrintStream out = System.out;</span><br><span class="line">        <span class="keyword">int</span> numCourses = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] prerequisites = &#123; </span><br><span class="line">             &#123;<span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">             &#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        out.println(<span class="keyword">new</span> Solution().</span><br><span class="line">            canFinish(numCourses, prerequisites)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color = purple><strong>②<code>DFS</code></strong></font></p>
<p>这个和上面的<code>DFS</code>也是一样的，区别就是这里不需要记录拓扑序列了。</p>
<p><img src="images/to4.png" alt="在这里插入图片描述"></p>
<p><code>DFS</code>访问顺序以及记录的拓扑序列(<code>res</code>)如下: </p>
<p>可以看到访问的顺序和结果的顺序正好相反: </p>
<table>
<thead>
<tr>
<th><font color = red><strong>vertex</strong></th>
<th><font color = red><strong>visiting</strong>( <code>vis = 2</code>)</th>
<th><font color = red><strong>visited</strong>(<code>vis = 1</code>)</th>
<th><code>res</code></th>
</tr>
</thead>
<tbody><tr>
<td><font color = purple><strong>0</strong></td>
<td><strong>{0}</strong></td>
<td><strong>{}</strong></td>
<td><strong>{}</strong></td>
</tr>
<tr>
<td><font color = purple><strong>1</strong></td>
<td><strong>{0, 1}</strong></td>
<td><strong>{}</strong></td>
<td><strong>{}</strong></td>
</tr>
<tr>
<td><font color = purple><strong>0</strong></td>
<td><strong>{0</strong>}</td>
<td><strong>{1}</strong></td>
<td><strong>{1}</strong></td>
</tr>
<tr>
<td><font color = purple><strong>7</strong></td>
<td><strong>{0, 7}</strong></td>
<td><strong>{1}</strong></td>
<td><strong>{1}</strong></td>
</tr>
<tr>
<td><font color = purple><strong>0</strong></td>
<td><strong>{0}</strong></td>
<td><strong>{1, 7}</strong></td>
<td>{<strong>7, 1}</strong></td>
</tr>
<tr>
<td><font color = purple><strong>-</strong></td>
<td><strong>{}</strong></td>
<td><strong>{1, 7, 0}</strong></td>
<td><strong>{0, 7, 1}</strong></td>
</tr>
<tr>
<td><font color = purple><strong>2</strong></td>
<td><strong>{2}</strong></td>
<td><strong>{1, 7, 0}</strong></td>
<td><strong>{0, 7, 1}</strong></td>
</tr>
<tr>
<td><font color = purple><strong>-</strong></td>
<td><strong>{}</strong></td>
<td><strong>{1, 7, 0, 2}</strong></td>
<td><strong>{2, 0, 7, 1}</strong></td>
</tr>
<tr>
<td><font color = purple><strong>3</strong></td>
<td><strong>{3}</strong></td>
<td><strong>{1, 7, 0, 2}</strong></td>
<td><strong>{2, 0, 7, 1}</strong></td>
</tr>
<tr>
<td><font color = purple><strong>-</strong></td>
<td><strong>{}</strong></td>
<td><strong>{1, 7, 0, 2, 3}</strong></td>
<td><strong>{3, 2, 0, 7, 1}</strong></td>
</tr>
<tr>
<td><font color = purple><strong>4</strong></td>
<td><strong>{4}</strong></td>
<td><strong>{1, 7, 0, 2, 3}</strong></td>
<td><strong>{3, 2, 0, 7, 1}</strong></td>
</tr>
<tr>
<td><font color = purple><strong>6</strong></td>
<td><strong>{4, 6}</strong></td>
<td><strong>{1, 7, 0, 2, 3}</strong></td>
<td><strong>{3, 2, 0, 7, 1}</strong></td>
</tr>
<tr>
<td><font color = purple><strong>4</strong></td>
<td><strong>{4}</strong></td>
<td><strong>{1, 7, 0, 2, 3, 6}</strong></td>
<td><strong>{6, 3, 2, 0, 7, 1}</strong></td>
</tr>
<tr>
<td><font color = purple><strong>-</strong></td>
<td><strong>{}</strong></td>
<td><strong>{1, 7, 0, 2, 3, 6, 4}</strong></td>
<td><strong>{4, 6, 3, 2, 0, 7, 1}</strong></td>
</tr>
<tr>
<td><font color = purple><strong>5</strong></td>
<td><strong>{5}</strong></td>
<td><strong>{1, 7, 0, 2, 3, 6, 4}</strong></td>
<td><strong>{4, 6, 3, 2, 0, 7, 1}</strong></td>
</tr>
<tr>
<td><font color = purple><strong>-</strong></td>
<td><strong>{}</strong></td>
<td><strong>{1, 7, 0, 2, 3, 6, 4, 5}</strong></td>
<td><strong>{5, 4, 6, 3, 2, 0, 7, 1}</strong></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; G[];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] vis; <span class="comment">// 0: not visited, 1 : visited, 2 : visiting</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// topological sorting should be used on directed acyclic graph </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = numCourses;</span><br><span class="line">        G = <span class="keyword">new</span> ArrayList[n];</span><br><span class="line">        vis = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            G[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; i++)&#123; </span><br><span class="line">            <span class="keyword">int</span> to = prerequisites[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> from = prerequisites[i][<span class="number">1</span>];</span><br><span class="line">            G[from].add(to);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span>(!dfs(i))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123; </span><br><span class="line">        vis[cur] = <span class="number">2</span>; <span class="comment">// visiting </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> to : G[cur])&#123; </span><br><span class="line">            <span class="keyword">if</span>((vis[to] == <span class="number">2</span>) || (vis[to] == <span class="number">0</span> &amp;&amp; !dfs(to)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[cur] = <span class="number">1</span>; <span class="comment">// visited</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        PrintStream out = System.out;</span><br><span class="line">        <span class="keyword">int</span> numCourses = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] prerequisites = &#123; </span><br><span class="line">             &#123;<span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">             &#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        out.println(<span class="keyword">new</span> Solution().</span><br><span class="line">            canFinish(numCourses, prerequisites)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>另外<code>DFS</code>函数也可以这样写:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(vis[cur] == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(vis[cur] == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    vis[cur] = <span class="number">2</span>; <span class="comment">// visiting </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> to : G[cur])&#123; </span><br><span class="line">        <span class="keyword">if</span>(!dfs(to))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[cur] = <span class="number">1</span>; <span class="comment">// visited</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Graph</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>乘法快速幂相关总结  &amp; LeetCode - 50. Pow(x, n)</title>
    <url>/2022/04/26/%E4%B9%98%E6%B3%95%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93%20%20&amp;%20LeetCode%20-%2050.%20Pow(x,%20n)/</url>
    <content><![CDATA[<h2 id="乘法快速幂相关总结-amp-LeetCode-50-Pow-x-n"><a href="#乘法快速幂相关总结-amp-LeetCode-50-Pow-x-n" class="headerlink" title="乘法快速幂相关总结  &amp; LeetCode - 50. Pow(x, n)"></a>乘法快速幂相关总结  &amp; LeetCode - 50. Pow(x, n)</h2><ul>
<li>递归计算<font color = red> (a <sup>n</sup>) % mod</li>
<li>非递归计算  <font color = red>(a <sup>n</sup>) % mod</li>
<li>计算<font color = red> ( a * b ) % mod</li>
<li>配合<font color = red> ( a * b ) % mod</font>和乘法快速幂</li>
<li>XYNUOJ - 1872. 次方求模题解</li>
<li>LeetCode - 50. Pow(x, n)题解</li>
</ul>
<hr>
<h3 id="递归计算-a-n-mod"><a href="#递归计算-a-n-mod" class="headerlink" title="递归计算 (a n) % mod"></a>递归计算 (a <sup>n</sup>) % mod</h3><p>递归计算其实是更容易理解的: </p>
<ul>
<li>为了求<font color = red>a<sup>n</sup></font>，我们先递归去求出<font color = red>a<sup>n/2</sup></font>，得到结果记录为<code>halfRes</code>；</li>
<li>然后如果<code>n</code>为偶数，很好办，再乘以一个<code>halfRes</code>就可以了(再取模一下)，也就是可以返回<code>halfRes*halfRes</code>；</li>
<li>但是如果<code>n</code>为奇数的话，就需要再乘以一个<code>a</code>，然后再返回；</li>
</ul>
<p><img src="images/m14.png" alt="幂分解"><br><img src="images/m26.png" alt="在这里插入图片描述"></p>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">pow_mod</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> n, <span class="keyword">long</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)      <span class="comment">// a^0 = 1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 先求一半的 --&gt; 你先给我求出 a ^ (n/2) 的结果给我</span></span><br><span class="line">    <span class="keyword">long</span> halfRes = pow_mod(a, n &gt;&gt; <span class="number">1</span>, mod); <span class="comment">// n &gt;&gt; 1 --&gt; n/2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> res = halfRes * halfRes % mod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) != <span class="number">0</span>)       <span class="comment">// odd num</span></span><br><span class="line">        res = res * a % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="非递归计算-a-n-mod"><a href="#非递归计算-a-n-mod" class="headerlink" title="非递归计算  (a n) % mod"></a>非递归计算 <font color = red> (a <sup>n</sup>) % mod</h3><p><img src="https://img-blog.csdn.net/201809222010339?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br><img src="images/m13.png" alt="在这里插入图片描述"><img src="images/m18.png" alt="在这里插入图片描述"><br>假设一个整数是<code>10</code>，如何最快的求解<code>10</code>的<code>75</code>次方。</p>
<ul>
<li>① <code>75</code>的二进制形式为<code>1001011</code>；</li>
<li>②<code>10</code>的<code>75</code>次方  = **10<sup>64</sup> × 10<sup>8</sup> × 10<sup>2</sup> × 10<sup>1</sup>**；</li>
<li>在这个过程中，我们先求出<strong>10<sup>1</sup><strong>，然后根据</strong>10<sup>1</sup><strong>求出</strong>10<sup>2</sup><strong>，再根据</strong>10<sup>2</sup><strong>求出</strong>10<sup>4</sup><strong>。。。。，最后根据</strong>10<sup>32</sup><strong>求出</strong>10<sup>64</sup><strong>，</strong>即<code>75</code>的二进制数形式总共有多少位，我们就使用了多少次乘法；</strong></li>
<li>③ 在步骤②进行的过程中，把应该累乘的值相乘即可，比如**10<sup>64</sup><strong>、</strong>10<sup>8</sup><strong>、</strong>10<sup>2</sup><strong>、</strong>10<sup>1</sup><strong>应该累乘，因为<code>64、8、2、1</code>对应到<code>75</code>的二进制数中，相应位上是<code>1</code>；而</strong>10<sup>32</sup><strong>、</strong>10<sup>16</sup>**、10<sup>4</sup>不应该累乘，因为<code>32、16、 4</code>对应到<code>75</code>的二进制数中，相应位是<code>0</code>；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">pow_mod2</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> n, <span class="keyword">long</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) != <span class="number">0</span>) <span class="comment">// 二进制最低位 是 1 --&gt; (n&amp;1) != 0  --&gt;  乘上 x ^ (2^i)   (i从0开始)</span></span><br><span class="line">            res = res * a % mod;</span><br><span class="line">        a = a * a % mod;  <span class="comment">// a = a^2</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;          <span class="comment">// n -&gt; n/2      往右边移一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>a ^ 11</code>来模拟一下计算过程: </p>
<p><img src="images/m17.png" alt="在这里插入图片描述"></p>
<h3 id="计算-a-b-mod"><a href="#计算-a-b-mod" class="headerlink" title="计算 ( a * b ) % mod"></a>计算 <font color = red>( a * b ) % mod</h3><p><img src="images/m16.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算 (a * b) % mod</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">mul_mod</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> b, <span class="keyword">long</span> mod)</span></span>&#123;</span><br><span class="line">       <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(b &gt; <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>( (b&amp;<span class="number">1</span>) != <span class="number">0</span>)  <span class="comment">// 二进制最低位是1 --&gt; 加上 a的 2^i 倍, 快速幂是乘上a的2^i ）</span></span><br><span class="line">               res  = ( res + a) % mod;</span><br><span class="line">           a = (a &lt;&lt; <span class="number">1</span>) % mod;    <span class="comment">// a = a * 2    a随着b中二进制位数而扩大 每次 扩大两倍。</span></span><br><span class="line">           b &gt;&gt;= <span class="number">1</span>;               <span class="comment">// b -&gt; b/2     右移  去掉最后一位 因为当前最后一位我们用完了，</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="配合-a-b-mod和乘法快速幂"><a href="#配合-a-b-mod和乘法快速幂" class="headerlink" title="配合 ( a * b ) % mod和乘法快速幂"></a>配合<font color = red> ( a * b ) % mod</font>和乘法快速幂</h3><p>可以使用非递归的乘法快速幂和上面的<code> (a*b) % mod</code> 来计算快速幂，差别不大: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算 (a * b) % mod</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">mul_mod</span><span class="params">(<span class="keyword">long</span> a,<span class="keyword">long</span> b,<span class="keyword">long</span> mod)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>( (b&amp;<span class="number">1</span>) != <span class="number">0</span>)  <span class="comment">// 二进制最低位是1 --&gt; 加上 a的 2^i 倍, 快速幂是乘上a的2^i ）</span></span><br><span class="line">            res  = ( res + a) % mod;</span><br><span class="line">        a = (a &lt;&lt; <span class="number">1</span>) % mod;    <span class="comment">// a = a * 2    a随着b中二进制位数而扩大 每次 扩大两倍。</span></span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;               <span class="comment">// b -&gt; b/2     右移  去掉最后一位 因为当前最后一位我们用完了，</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归 计算 (a^n) % mod   配合 mul</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">pow_mod3</span><span class="params">(<span class="keyword">long</span> a,<span class="keyword">long</span> n,<span class="keyword">long</span> mod)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>( (n&amp;<span class="number">1</span>) != <span class="number">0</span> ) <span class="comment">// 二进制最低位 是 1 --&gt; (n&amp;1) != 0  --&gt;  乘上 x ^ (2^i)   (i从0开始)</span></span><br><span class="line">            res = mul_mod(res,a,mod) % mod;</span><br><span class="line">        a = mul_mod(a,a,mod) % mod;  <span class="comment">// a = a^2</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;          <span class="comment">// n -&gt; n/2      往右边移一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="XYNUOJ-1872-次方求模题解"><a href="#XYNUOJ-1872-次方求模题解" class="headerlink" title="XYNUOJ - 1872. 次方求模题解"></a>XYNUOJ - 1872. 次方求模题解</h3><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="http://xyoj.xynu.edu.cn/problem.php?id=1872">题目链接</a></h4><blockquote>
<p><a href="http://xyoj.xynu.edu.cn/problem.php?id=1872">http://xyoj.xynu.edu.cn/problem.php?id=1872</a></p>
</blockquote>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><img src="images/m12.png" alt="在这里插入图片描述"></p>
<p>完全的模板题，三种方法都可以通过: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目链接:  http://xyoj.xynu.edu.cn/problem.php?id=1872&amp;csrf=mmofuzhUWGip3c6WlmhiFY6bLxeVHZta</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;  <span class="comment">//提交时改成Main</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归 计算 (a^n) % mod</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">pow_mod</span><span class="params">(<span class="keyword">long</span> a,<span class="keyword">long</span> n,<span class="keyword">long</span> mod)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)      <span class="comment">// a^0 = 1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 先求一半的 --&gt; 你先给我求出 a ^ (n/2) 的结果给我</span></span><br><span class="line">        <span class="keyword">long</span> halfRes = pow_mod(a, n &gt;&gt; <span class="number">1</span>, mod); <span class="comment">// n &gt;&gt; 1 --&gt; n/2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> res = halfRes * halfRes % mod;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( (n&amp;<span class="number">1</span>) != <span class="number">0</span>)       <span class="comment">// odd num</span></span><br><span class="line">            res = res * a % mod;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非递归 计算 (a^n) % mod</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">pow_mod2</span><span class="params">(<span class="keyword">long</span> a,<span class="keyword">long</span> n,<span class="keyword">long</span> mod)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>( (n&amp;<span class="number">1</span>) != <span class="number">0</span> ) <span class="comment">// 二进制最低位 是 1 --&gt; (n&amp;1) != 0  --&gt;  乘上 x ^ (2^i)   (i从0开始)</span></span><br><span class="line">                res = res * a % mod;</span><br><span class="line">            a = a * a % mod;  <span class="comment">// a = a^2</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;          <span class="comment">// n -&gt; n/2      往右边移一位</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 (a * b) % mod</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">mul_mod</span><span class="params">(<span class="keyword">long</span> a,<span class="keyword">long</span> b,<span class="keyword">long</span> mod)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(b &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (b&amp;<span class="number">1</span>) != <span class="number">0</span>)  <span class="comment">// 二进制最低位是1 --&gt; 加上 a的 2^i 倍, 快速幂是乘上a的2^i ）</span></span><br><span class="line">                res  = ( res + a) % mod;</span><br><span class="line">            a = (a &lt;&lt; <span class="number">1</span>) % mod;    <span class="comment">// a = a * 2    a随着b中二进制位数而扩大 每次 扩大两倍。</span></span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;               <span class="comment">// b -&gt; b/2     右移  去掉最后一位 因为当前最后一位我们用完了，</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非递归 计算 (a^n) % mod   配合 mul</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">pow_mod3</span><span class="params">(<span class="keyword">long</span> a,<span class="keyword">long</span> n,<span class="keyword">long</span> mod)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>( (n&amp;<span class="number">1</span>) != <span class="number">0</span> ) <span class="comment">// 二进制最低位 是 1 --&gt; (n&amp;1) != 0  --&gt;  乘上 x ^ (2^i)   (i从0开始)</span></span><br><span class="line">                res = mul_mod(res,a,mod) % mod;</span><br><span class="line">            a = mul_mod(a,a,mod) % mod;  <span class="comment">// a = a^2</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;          <span class="comment">// n -&gt; n/2      往右边移一位</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line">        <span class="keyword">int</span> T = cin.nextInt();</span><br><span class="line">        <span class="keyword">while</span>(T-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> n = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> mod = cin.nextInt();</span><br><span class="line"><span class="comment">//            System.out.println(pow_mod(a,n,mod));</span></span><br><span class="line"><span class="comment">//            System.out.println(pow_mod2(a,n,mod));</span></span><br><span class="line">            System.out.println(pow_mod3(a,n,mod));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="LeetCode-50-Pow-x-n-题解"><a href="#LeetCode-50-Pow-x-n-题解" class="headerlink" title="LeetCode - 50. Pow(x, n)题解"></a>LeetCode - 50. Pow(x, n)题解</h3><h4 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a><a href="https://leetcode.com/problems/powx-n/description/">题目链接</a></h4><blockquote>
<p><a href="https://leetcode.com/problems/powx-n/description/">https://leetcode.com/problems/powx-n/description/</a></p>
</blockquote>
<h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p><img src="images/m15.png"></p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>这个题目和普通的求幂不同的是: </p>
<ul>
<li><strong>其中<code>x</code>(底数)是<code>double</code>类型的，且<code>n</code>是范围是<code>Integer</code>范围的(可正可负) :</strong> </li>
<li><strong>要注意的就是当<code>n</code>为负数的时候，我们可以转换成求<code> 1.0 / pow(x,-n)</code>；</strong></li>
<li><font color = red>还一个很重要的地方就是当<code>n = Integer.MIN_VALUE</code>的时候要特殊处理，因为整形范围是-2<sup>31</sup>到2<sup>31</sup>-1，所以或者我们使用<code>long</code>来存转换的数，或者特殊判断一下；</font><h5 id="递归求解"><a href="#递归求解" class="headerlink" title="递归求解:"></a>递归求解:</h5>两种写法意思一样，第二种写法更加简洁: <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> pow(x, n);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == Integer.MIN_VALUE) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1.0</span> / (pow(x, -(Integer.MIN_VALUE + <span class="number">1</span>)) * x); <span class="comment">// MAX_VALUE = -(Integer.MIN_VALUE + 1)</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span> / pow(x, -n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> half = pow(x, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> half * half;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> x * half * half;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == Integer.MIN_VALUE) &#123;</span><br><span class="line">                <span class="comment">// return 1.0 / (myPow(x,-(Integer.MIN_VALUE+1)) * x);</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1.0</span> / (myPow(x, Integer.MAX_VALUE) * x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span> / myPow(x, -n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> half = myPow(x, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> half * half;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> x * half * half;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="非递归求解"><a href="#非递归求解" class="headerlink" title="非递归求解:"></a>非递归求解:</h5><p><font color = red>三种写法的意思都是一样，只不过处理<code>Integer.MIN_VALUE</code>的方式不同而已。</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == Integer.MIN_VALUE) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1.0</span> / (myPow(x, Integer.MAX_VALUE) * x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1.0</span> / myPow(x, -n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">                res *= x;</span><br><span class="line">            x = x * x;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            n = -(<span class="number">1</span> + n);  <span class="comment">// for Integer.MIN_VALUE   </span></span><br><span class="line">            res *= x;  <span class="comment">// x is 1/x   because n is -(n+1) so should do this </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">                res *= x;</span><br><span class="line">            x = x * x;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> abs = Math.abs((<span class="keyword">long</span>) n); <span class="comment">// also for Integer.MIN_VALUE</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span> (abs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((abs &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">                res *= x;</span><br><span class="line">            x = x * x;</span><br><span class="line">            abs &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span> / res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找的总结(6种变形)</title>
    <url>/2021/12/15/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E6%80%BB%E7%BB%93(6%E7%A7%8D%E5%8F%98%E5%BD%A2)/</url>
    <content><![CDATA[<h2 id="二分查找的总结"><a href="#二分查找的总结" class="headerlink" title="二分查找的总结"></a>二分查找的总结</h2><ul>
<li><p><a href="#%E6%99%AE%E9%80%9A%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">普通的二分查找</a></p>
</li>
<li><p><a href="#%E6%99%AE%E9%80%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%86%99%E6%B3%95">普通二分查找的另一种写法</a></p>
</li>
<li><p><a href="#%E7%AC%AC%E4%B8%80%E4%B8%AAkey%E7%9A%84%E4%B8%8D%E5%AD%98%E5%9C%A8%E8%BF%94%E5%9B%9E-1">第一个<code>=key</code>的，不存在返回<code>-1</code></a></p>
</li>
<li><p><a href="#%E7%AC%AC%E4%B8%80%E4%B8%AAkey%E7%9A%84">第一个<code>&gt;=key</code>的</a></p>
</li>
<li><p><a href="#%E7%AC%AC%E4%B8%80%E4%B8%AAkey%E7%9A%84">第一个<code>&gt;key</code>的</a></p>
</li>
<li><p><a href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%9A%84%E6%80%BB%E7%BB%93">第一个<code>...</code>的总结</a></p>
</li>
<li><p><a href="#%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AAkey%E7%9A%84%E4%B8%8D%E5%AD%98%E5%9C%A8%E8%BF%94%E5%9B%9E-1">最后一个<code>=</code>key的，不存在返回<code>-1</code></a></p>
</li>
<li><p><a href="#%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AAkey%E7%9A%84">最后一个<code>&lt;=key</code>的</a> </p>
</li>
<li><p><a href="#%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AAkey%E7%9A%84">最后一个<code>&lt;key</code> 的</a></p>
</li>
<li><p><a href="#%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E7%9A%84%E6%80%BB%E7%BB%93">最后一个<code>...</code>的总结</a></p>
</li>
<li><p><a href="#%E5%AE%8C%E6%95%B4%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">完整测试代码</a></p>
</li>
</ul>
<hr>
<h3 id="普通的二分查找"><a href="#普通的二分查找" class="headerlink" title="普通的二分查找"></a>普通的二分查找</h3><p>最普通的写法: </p>
<ul>
<li>范围在<code>[L,R]</code>闭区间中，<code>L = 0</code>、<code>R = arr.length - 1</code>；</li>
<li>注意循环条件为 <code>L &lt;= R</code> ，而不是<code>L &lt; R</code>；</li>
</ul>
<p><img src="images/bs1.png" alt="这里写图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bs1</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>,R = arr.length - <span class="number">1</span>; <span class="comment">//在[L,R]范围内寻找key</span></span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>( L &lt;= R)&#123;</span><br><span class="line">        mid = L + (R - L) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] == key)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &gt; key)</span><br><span class="line">            R = mid - <span class="number">1</span>;<span class="comment">// key 在 [L,mid-1]内</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="普通二分查找的另一种写法"><a href="#普通二分查找的另一种写法" class="headerlink" title="普通二分查找的另一种写法"></a>普通二分查找的另一种写法</h3><p>首先说明，这个和上面的二分查找是完全一样的，只不过我们定义的区间不同而已: </p>
<ul>
<li><p>上面的二分查找是在<code>[L,R]</code>的闭区间中查找，而这个二分查找是在<code>[L,R</code><font color =red>)</font>的左闭右开区间查找；</p>
</li>
<li><p>所以<font color =red>此时的循环条件是<code>L &lt; R</code> ，因为<code>R</code>本来是一个不可到达的地方，我们定义为了开区间，所以<code>R</code>是一个不会考虑的数，所以我们循环条件是<code>L  &lt; R</code>；</p>
</li>
<li><p>同理，当<code>arr[mid] &gt; key</code>的时候，不是<code>R = mid -  1</code>，因为我们定义的是开区间，所以<code>R = mid</code> ，因为不会考虑<code>arr[mid]</code>这个数；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//和上面的完全一样，只是一开始R不是arr.length-1 而是arr.length</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bs2</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>, R = arr.length; <span class="comment">//注意这里R = arr.length 所以在[L,R)开区间中找</span></span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>( L &lt; R)&#123; <span class="comment">//注意这里 不是 L &lt;= R</span></span><br><span class="line">        mid = L + (R - L)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] == key)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &gt; key)</span><br><span class="line">            R = mid; <span class="comment">// 在[L,mid)中找</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color =red>上面的两种方式一般还是第一种方式用的多一点。</font></p>
<hr>
<h3 id="第一个-key的，不存在返回-1"><a href="#第一个-key的，不存在返回-1" class="headerlink" title="第一个=key的，不存在返回-1"></a>第一个<code>=key</code>的，不存在返回<code>-1</code></h3><p>这个和之前的不同是: </p>
<ul>
<li><p><strong>数组中可能有重复的<code>key</code>，我们要找的是第一个<code>key</code>的位置；</strong></p>
</li>
<li><p>和普通二分查找法不同的是在我们要<code>R = mid - 1</code>前的判断条件不是<code>arr[mid] &gt; key</code>，而是<code>arr[mid] &gt;= key</code>；</p>
</li>
<li><p>为什么是上面那样，<strong>其实直观上理解，我们要找的是第一个，那我们去左边找的时候不仅仅<code>arr[mid] &gt; key</code>就去左边找，等于我也要去找，因为我要最左边的等于的；</strong></p>
</li>
<li><p>最后我们要判断<code>L</code>是否越界(<code>L</code> 有可能等于<code>arr.length</code>)，而且最后<code>arr[L]</code>是否等于要找的<code>key</code>；</p>
</li>
<li><p>如果<code>arr[L]</code>不等于<code>key</code>，说明没有这个元素，返回<code>-1</code>；</p>
</li>
</ul>
<p><strong>举个例子:</strong> </p>
<p><img src="images/bs2.png" alt="这里写图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**查找第一个与key相等的元素的下标，　如果不存在返回-1　*/</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">firstEqual</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> L = <span class="number">0</span>, R = arr.length - <span class="number">1</span>; <span class="comment">//在[L,R]查找第一个&gt;=key的</span></span><br><span class="line">       <span class="keyword">int</span> mid;</span><br><span class="line">       <span class="keyword">while</span>( L &lt;= R)&#123;</span><br><span class="line">           mid = L + (R - L)/<span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span>(arr[mid] &gt;= key)</span><br><span class="line">               R = mid - <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               L = mid + <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(L &lt; arr.length &amp;&amp; arr[L] == key)</span><br><span class="line">           <span class="keyword">return</span> L;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="第一个-gt-key的"><a href="#第一个-gt-key的" class="headerlink" title="第一个&gt;=key的"></a>第一个<code>&gt;=key</code>的</h3><p>这个和上面那个寻找第一个等于<code>key</code>的唯一的区别就是: </p>
<ul>
<li><p>最后我们不需要判断(<code> L &lt; arr.length &amp;&amp; arr[L] == key</code>)，因为如果不存在<code>key</code>的话，我们返回第一个<code>&gt; key</code>的元素即可；</p>
</li>
<li><p><strong>注意这里没有判断越界(<code>L  &lt; arr.length </code>)，因为如果整个数组都比<code>key</code>要小，就会返回<code>arr.length</code>的大小；</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**查找第一个大于等于key的元素的下标*/</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">firstLargeEqual</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> L = <span class="number">0</span>, R = arr.length - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> mid;</span><br><span class="line">       <span class="keyword">while</span>( L &lt;= R)&#123;</span><br><span class="line">           mid = L + (R - L) / <span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span>(arr[mid] &gt;= key)</span><br><span class="line">               R = mid - <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               L = mid + <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> L;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="第一个-gt-key的-1"><a href="#第一个-gt-key的-1" class="headerlink" title="第一个&gt;key的"></a>第一个<code>&gt;key</code>的</h3><p>这个和上两个的不同在于: </p>
<ul>
<li><p><font color = red><code>if(arr[mid] &gt;= key) </code>改成了<code> if(arr[mid]  &gt; key)</code></font>，因为我们不是要寻找 <code>= key</code>的；</p>
</li>
<li><p><strong>看似和普通二分法很像，但是我们在循环中没有判断<code>if(arr[mid] == key)</code>就返回<code>mid</code>(因为要寻找的不是等于<code>key</code>的)，而是在最后返回了<code>L</code> ；</strong></p>
</li>
</ul>
<p>举个例子: </p>
<p><img src="images/bs3.png" alt="这里写图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**查找第一个大于key的元素的下标 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">firstLarge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>,R = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(L &lt;= R)&#123;</span><br><span class="line">        mid = L + (R - L) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &gt; key)</span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="第一个-的总结"><a href="#第一个-的总结" class="headerlink" title="第一个...的总结"></a><font color  =red>第一个<code>...</code>的总结</h3><p>上面写了三个第一个<code>.....</code>的程序，可以发现一些共同点 ，也可以总结一下它们微妙的区别: </p>
<ul>
<li><p><strong>最后返回的都是<code>L</code>；</strong></p>
</li>
<li><p>如果是寻找第一个等于<code>key</code>的，是<code>if( arr[mid]  &gt;= key) R = mid -  1</code>，且最后要判断<code>L </code>的合法以及是否存在<code>key</code>；</p>
</li>
<li><p>如果是寻找第一个大于等于<code>key</code>的，也是<code>if(arr[mid] &gt;= key) R = mid - 1</code>，但是最后直接返回<code>L</code>；</p>
</li>
<li><p>如果是寻找第一个大于<code>key</code>的，则判断条件是<code>if(arr[mid]  &gt; key) R = mid - 1</code>，最后返回<code>L</code> ；</p>
</li>
</ul>
<hr>
<h3 id="最后一个-key的，不存在返回-1"><a href="#最后一个-key的，不存在返回-1" class="headerlink" title="最后一个=key的，不存在返回-1"></a>最后一个<code>=</code>key的，不存在返回<code>-1</code></h3><p>和寻找第一个 <code>= key</code>的很类似，不过是方向的不同而已: </p>
<ul>
<li><p>数组中有可能有重复的<code>key</code>，我们要查找的是最后一个 <code>= key</code>的位置，不存在返回<code>-1</code>；</p>
</li>
<li><p>为了更加的直观的理解，和寻找第一个…的形成对比，这里是当<code>arr[mid] &lt;= key</code>的时候，我们要去右边查找(<code>L = mid + 1</code>)，<strong>同样是直观的理解，因为我们是要去找到最后一个 <code>=  key</code>的，所以不仅仅是<code>arr[mid]  &lt; key</code>要去左边寻找，等于<code>key</code>的时候也要去左边寻找；</strong></p>
</li>
<li><p><font color  = red>和第一个….不同的是，我们返回的都是<code>R</code>；</p>
</li>
<li><p>同时我们也要判断<code>R</code>的下标的合法性，以及最后的<code>arr[R]</code>是否等于<code>key</code>，如果不等于就返回<code>-1</code>；</p>
</li>
</ul>
<p>举个例子: </p>
<p><img src="images/bs4.png" alt="这里写图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**查找最后一个与key相等的元素的下标，　如果没有返回-1*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lastEqual</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>, R = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>( L &lt;= R)&#123;</span><br><span class="line">        mid = L + (R - L)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &lt;= key)</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(R &gt;= <span class="number">0</span> &amp;&amp; arr[R] == key)</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="最后一个-lt-key的"><a href="#最后一个-lt-key的" class="headerlink" title="最后一个&lt;=key的"></a>最后一个<code>&lt;=key</code>的</h3><p>这个和上面那个寻找最后一个等于<code>key</code>的唯一的区别就是: </p>
<ul>
<li><p>最后我们不需要判断 (<code>R &gt;= 0 &amp;&amp; arr[R] == key</code>)，<strong>因为如果不存在<code>key</code>的话，我们返回最后一个  <code>&lt; key</code>的元素即可；</strong></p>
</li>
<li><p><strong>注意这里没有判断越界(<code>R &gt;=  0 </code>)，因为如果整个数组都比<code>key</code>要大，数组最左边的更左边一个(也就是<code>-1</code>)；</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**查找最后一个小于等于key的元素的下标 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lastSmallEqual</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>, R = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>( L &lt;= R)&#123;</span><br><span class="line">        mid = L + (R - L) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &lt;= key)</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="最后一个-lt-key-的"><a href="#最后一个-lt-key-的" class="headerlink" title="最后一个&lt;key 的"></a>最后一个<code>&lt;key</code> 的</h3><p>这个和上面两个不同的是: </p>
<ul>
<li><p><font color = red>和上面的程序唯一不同的就是<code>arr[mid] &lt;= key</code>改成了 <code>arr[mid]  &lt; key</code>，因为我们要寻找的不是<code> = key</code>的；</font></p>
</li>
<li><p>注意这三个最后一个的都是先对<code>L</code>的操作<code>L = mid + 1</code>，然后在<code>else</code> 中进行对<code>R</code>的操作；</p>
</li>
</ul>
<p><img src="images/bs5.png" alt="这里写图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**查找最后一个小于key的元素的下标*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lastSmall</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>, R = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(L &lt;= R)&#123;</span><br><span class="line">        mid = L + (R - L) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &lt; key)</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="最后一个-的总结"><a href="#最后一个-的总结" class="headerlink" title="最后一个...的总结"></a><font color  =red>最后一个<code>...</code>的总结</h3><p>上面三个都是求最后一个<code>.....</code>的，也进行一下总结: </p>
<ul>
<li><p><strong>最后返回的都是<code>R</code>；</strong></p>
</li>
<li><p><strong>第一个<code>if</code>判断条件(不管是<code>arr[mid] &lt;= key</code>还是<code>arr[mid] &lt; key</code>) ，都是<code>L</code>的操作，也就是去右边寻找；</strong></p>
</li>
<li><p>如果是寻找最后一个 等于<code> key</code>的， <code> if(arr[mid] &lt;= key) L = mid + 1;</code> 不过最后要判断<code>R</code>的合法性以及是否存在<code>key</code>；</p>
</li>
<li><p>如果是寻找最后一个 小于等于 <code>key</code>的，也是<code>if(arr[mid] &lt;= key) L = mid + 1</code>；不过最后直接返回<code>R</code>；</p>
</li>
<li><p>如果是寻找最后一个 小于 <code>key</code>的，则判断条件是  <code> if(arr[mid] &lt; key) L = mid + 1</code> ，最后返回<code>R</code>；</p>
</li>
</ul>
<hr>
<h3 id="完整测试代码"><a href="#完整测试代码" class="headerlink" title="完整测试代码"></a>完整测试代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最普通的二分搜索法</span></span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bs1</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>,R = arr.length - <span class="number">1</span>; <span class="comment">//在[L,R]范围内寻找key</span></span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>( L &lt;= R)&#123;</span><br><span class="line">            mid = L + (R - L) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid] == key)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &gt; key)</span><br><span class="line">                R = mid - <span class="number">1</span>;<span class="comment">// key 在 [L,mid-1]内</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//和上面的完全一样，只是一开始R不是arr.length-1 而是arr.length</span></span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bs2</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>, R = arr.length; <span class="comment">//注意这里R = arr.length 所以在[L,R)开区间中找</span></span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>( L &lt; R)&#123; <span class="comment">//注意这里 不是 L &lt;= R</span></span><br><span class="line">            mid = L + (R - L)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid] == key)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &gt; key)</span><br><span class="line">                R = mid; <span class="comment">// 在[L,mid)中找</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**查找第一个与key相等的元素的下标，　如果不存在返回-1　*/</span></span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">firstEqual</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>, R = arr.length - <span class="number">1</span>; <span class="comment">//在[L,R]查找第一个&gt;=key的</span></span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>( L &lt;= R)&#123;</span><br><span class="line">            mid = L + (R - L)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &gt;= key)</span><br><span class="line">                R = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(L &lt; arr.length &amp;&amp; arr[L] == key)</span><br><span class="line">            <span class="keyword">return</span> L;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**查找第一个大于等于key的元素的下标*/</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">firstLargeEqual</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>, R = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>( L &lt;= R)&#123;</span><br><span class="line">            mid = L + (R - L) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &gt;= key)</span><br><span class="line">                R = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**查找第一个大于key的元素的下标 */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">firstLarge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>,R = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(L &lt;= R)&#123;</span><br><span class="line">            mid = L + (R - L) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &gt; key)</span><br><span class="line">                R = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**查找最后一个与key相等的元素的下标，　如果没有返回-1*/</span></span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lastEqual</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>, R = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>( L &lt;= R)&#123;</span><br><span class="line">            mid = L + (R - L)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &lt;= key)</span><br><span class="line">                L = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(R &gt;= <span class="number">0</span> &amp;&amp; arr[R] == key)</span><br><span class="line">            <span class="keyword">return</span> R;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**查找最后一个小于等于key的元素的下标 */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lastSmallEqual</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>, R = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>( L &lt;= R)&#123;</span><br><span class="line">            mid = L + (R - L) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &lt;= key)</span><br><span class="line">                L = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**查找最后一个小于key的元素的下标*/</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lastSmall</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>, R = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(L &lt;= R)&#123;</span><br><span class="line">            mid = L + (R - L) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &lt; key)</span><br><span class="line">                L = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------general-----------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(bs1(arr,<span class="number">3</span>));<span class="comment">//1</span></span><br><span class="line">        System.out.println(bs2(arr,<span class="number">3</span>));<span class="comment">//1</span></span><br><span class="line">        System.out.println(bs2(arr,<span class="number">6</span>));<span class="comment">//5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------first------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个 =  的</span></span><br><span class="line">        System.out.println(firstEqual(arr,<span class="number">6</span>));<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个　&gt;= 的</span></span><br><span class="line">        System.out.println(firstLargeEqual(arr,<span class="number">5</span>));<span class="comment">//3</span></span><br><span class="line">        System.out.println(firstLargeEqual(arr,<span class="number">6</span>));<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个 &gt; 的</span></span><br><span class="line">        System.out.println(firstLarge(arr,<span class="number">6</span>));<span class="comment">//9</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------last------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后一个 =  的</span></span><br><span class="line">        System.out.println(lastEqual(arr,<span class="number">6</span>));<span class="comment">//8</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后一个 &lt;= 的</span></span><br><span class="line">        System.out.println(lastSmallEqual(arr,<span class="number">7</span>));<span class="comment">//8</span></span><br><span class="line">        System.out.println(lastSmallEqual(arr,<span class="number">6</span>));<span class="comment">//8</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后一个 &lt; 的</span></span><br><span class="line">        System.out.println(lastSmall(arr,<span class="number">6</span>));<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>效果:<br><img src="images/bs6.png" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>BinarySearch</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路dijkstra模板</title>
    <url>/2022/03/09/%E6%9C%80%E7%9F%AD%E8%B7%AFdijkstra%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>﻿## 最短路dijkstra模板</p>
<ul>
<li><code>dijkstra</code>算法总结</li>
<li>常用模板解决</li>
<li>其他写法</li>
</ul>
<hr>
<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1874">题目链接</a></h4><blockquote>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1874">http://acm.hdu.edu.cn/showproblem.php?pid=1874</a></p>
</blockquote>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><img src="images/path1.png"></p>
<h3 id="dijkstra算法总结"><a href="#dijkstra算法总结" class="headerlink" title="dijkstra算法总结"></a><code>dijkstra</code>算法总结</h3><p>总结一下<code>dijkstra</code>算法大致的流程: </p>
<ul>
<li>一开始有一个<code>dist[]</code>数组(也可以是<code>map</code>)来保存从<code>start</code>(起点)到每个点的最短路径(一开始的话，如果<code>start</code>和某个点没有边，就为<code>INF</code>(或者为<code>null</code>)，如果有连线的话就是边的权值)；</li>
<li>然后每次从<code>dist</code>数组中取出一个<code>dist[i]</code>最小的<code>i</code>(不能取已经用过的顶点(<code>vis</code>数组标记))，也就是<strong>start距离某个结点</strong>最近的一个；</li>
<li>取出这个结点之后，用这个结点更新和<strong>它相连的边的<code>dist</code>数组</strong>；</li>
<li>直到把所有的<code>dist</code>数组都更新一遍；</li>
</ul>
<p><img src="images/path2.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>注意: <font color = red><code>dijkstra</code>为什么不能有负权边? 因为如果有的话，我们找最小的那个结构的时候，没准它还能通过松弛变得更短，例如上面我们一开始选出<code>0~2</code>这条边的时候，试想如果<code>2~1</code>的那条边权值为<code>-4</code>，那一开始我们找的<code>0~2</code>这条边就是错的，所以不能有负权边。</font></p>
</blockquote>
<hr>
<h3 id="常用模板解决"><a href="#常用模板解决" class="headerlink" title="常用模板解决"></a>常用模板解决</h3><p><strong>推荐的写法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span>[] vis;</span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;Edge&gt; G[];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Edge</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> to;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> w;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.to = to;</span><br><span class="line">            <span class="keyword">this</span>.w = w;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Edge o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> w - o.w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] dijkstra(<span class="keyword">int</span> start) &#123;</span><br><span class="line">        PriorityQueue&lt;Edge&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] dis = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) dis[i] = Integer.MAX_VALUE; <span class="comment">//初始标记（不是-1(因为是求最小的)）</span></span><br><span class="line">        dis[start] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//        G.vis[start] = true;  //第一个访问 start, 不能将start标记为true</span></span><br><span class="line">        pq.add(<span class="keyword">new</span> Edge(start, <span class="number">0</span>)); <span class="comment">//将第一条边加入 pq, 自环边</span></span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            Edge curEdge = pq.poll();</span><br><span class="line">            <span class="keyword">int</span> to = curEdge.to;</span><br><span class="line">            <span class="keyword">if</span> (vis[to])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            vis[to] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[to].size(); i++) &#123; <span class="comment">//更新相邻的边</span></span><br><span class="line">                <span class="keyword">int</span> nxtNode = G[to].get(i).to;</span><br><span class="line">                <span class="keyword">int</span> nxtW = G[to].get(i).w;</span><br><span class="line">                <span class="keyword">if</span> (!vis[nxtNode] &amp;&amp; dis[nxtNode] &gt; dis[to] + nxtW) &#123;</span><br><span class="line">                    dis[nxtNode] = dis[to] + nxtW;</span><br><span class="line">                    pq.add(<span class="keyword">new</span> Edge(nxtNode, dis[nxtNode])); <span class="comment">//将这个新的dis[nxtNode]加入优先队列，没准它是下一个(很小)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line">        <span class="keyword">while</span> (cin.hasNext()) &#123;</span><br><span class="line">            n = cin.nextInt();</span><br><span class="line">            m = cin.nextInt();</span><br><span class="line">            G = <span class="keyword">new</span> ArrayList[n]; <span class="comment">// 0~n-1</span></span><br><span class="line">            vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                G[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                vis[i] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> from = cin.nextInt();</span><br><span class="line">                <span class="keyword">int</span> to = cin.nextInt();</span><br><span class="line">                <span class="keyword">int</span> w = cin.nextInt();</span><br><span class="line">                G[from].add(<span class="keyword">new</span> Edge(to, w));</span><br><span class="line">                G[to].add(<span class="keyword">new</span> Edge(from, w));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> s = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> e = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span>[] dis = dijkstra(s);</span><br><span class="line">            System.out.println(dis[e] == Integer.MAX_VALUE ? -<span class="number">1</span> : dis[e]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他写法"><a href="#其他写法" class="headerlink" title="其他写法"></a>其他写法</h3><p>没有使用堆优化，也就是说找出当前最小的<code>dist</code>所在的结构的时候，遍历了一遍当前的<code>dist</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> ArrayList&lt;Edge&gt;edges;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            edges = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> weight;</span><br><span class="line">        <span class="keyword">public</span> Node from;</span><br><span class="line">        <span class="keyword">public</span> Node to;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">( Node from, Node to,<span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.from = from;</span><br><span class="line">            <span class="keyword">this</span>.to = to;</span><br><span class="line">            <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> HashMap&lt;Integer,Node&gt;nodes;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            nodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有使用堆优化的 O(n^2)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Node,Integer&gt; <span class="title">dijkstra</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        HashMap&lt;Node,Integer&gt;dist = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        dist.put(head,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(Edge edge : head.edges)&#123;</span><br><span class="line">            dist.put(edge.to,edge.weight);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashSet&lt;Node&gt;set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Node minNode = getMinAndUnSelect(dist,set); minNode != <span class="keyword">null</span> ; minNode = getMinAndUnSelect(dist,set))&#123;</span><br><span class="line">            <span class="keyword">int</span> distance = dist.get(minNode);</span><br><span class="line">            <span class="keyword">for</span>(Edge edge : minNode.edges)&#123;</span><br><span class="line">                Node toNode = edge.to;</span><br><span class="line">                <span class="keyword">if</span>(set.contains(toNode))<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(!dist.containsKey(toNode))&#123;</span><br><span class="line">                    dist.put(toNode,distance + edge.weight);</span><br><span class="line">                &#125;</span><br><span class="line">                dist.put(toNode,Math.min(dist.get(toNode),distance + edge.weight));</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(minNode); <span class="comment">//使用过这个之后就标记</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找出dist中最小且没有选择的结点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">getMinAndUnSelect</span><span class="params">(HashMap&lt;Node, Integer&gt; dist, HashSet&lt;Node&gt; set)</span> </span>&#123;</span><br><span class="line">        Node minNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> minDistance = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(Entry&lt;Node,Integer&gt; entry : dist.entrySet())&#123; <span class="comment">// map遍历方式 https://www.cnblogs.com/fqfanqi/p/6187085.html</span></span><br><span class="line">            Node node = entry.getKey();</span><br><span class="line">            <span class="keyword">int</span> distance = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(node) &amp;&amp; distance &lt; minDistance)&#123;</span><br><span class="line">                minDistance = distance;</span><br><span class="line">                minNode = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line">        <span class="keyword">while</span>(cin.hasNext())&#123;</span><br><span class="line">            <span class="keyword">int</span> n = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> m = cin.nextInt();</span><br><span class="line">            Graph G = <span class="keyword">new</span> Graph();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)G.nodes.put(i,<span class="keyword">new</span> Node(i));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> a = cin.nextInt();</span><br><span class="line">                <span class="keyword">int</span> b = cin.nextInt();</span><br><span class="line">                <span class="keyword">int</span> w = cin.nextInt();</span><br><span class="line">                Node from = G.nodes.get(a);</span><br><span class="line">                Node to = G.nodes.get(b);</span><br><span class="line">                from.edges.add(<span class="keyword">new</span> Edge(from,to,w));</span><br><span class="line">                to.edges.add(<span class="keyword">new</span> Edge(to,from,w));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> start = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> end = cin.nextInt();</span><br><span class="line">            HashMap&lt;Node, Integer&gt; dist = dijkstra(G.nodes.get(start));<span class="comment">//从start开始</span></span><br><span class="line">            Integer res = dist.get(G.nodes.get(end));</span><br><span class="line">            System.out.println((res == <span class="keyword">null</span>) ? -<span class="number">1</span> : res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>堆优化，其他写法(建图稍有不同): </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> ArrayList&lt;Edge&gt;edges;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            edges = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> weight;</span><br><span class="line">        <span class="keyword">public</span> Node from;</span><br><span class="line">        <span class="keyword">public</span> Node to;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">( Node from, Node to,<span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.from = from;</span><br><span class="line">            <span class="keyword">this</span>.to = to;</span><br><span class="line">            <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> HashMap&lt;Integer,Node&gt;nodes;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            nodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeRecord</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Node node;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> distance;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">NodeRecord</span><span class="params">(Node node, <span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.node = node;</span><br><span class="line">            <span class="keyword">this</span>.distance = distance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">NodeRecord</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(NodeRecord o1, NodeRecord o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1.distance - o2.distance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> HashMap&lt;Node, Integer&gt; <span class="title">dijkstra</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        HashMap&lt;Node,Integer&gt;dist = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        dist.put(head,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(Edge edge : head.edges)&#123;<span class="comment">//这个不能少</span></span><br><span class="line">            dist.put(edge.to,edge.weight);</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;NodeRecord&gt;priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> EdgeComparator());</span><br><span class="line">        priorityQueue.add(<span class="keyword">new</span> NodeRecord(head,<span class="number">0</span>));</span><br><span class="line">        HashSet&lt;Node&gt;set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!priorityQueue.isEmpty())&#123;</span><br><span class="line">            NodeRecord poll = priorityQueue.poll();</span><br><span class="line">            Node cur = poll.node;</span><br><span class="line">            <span class="keyword">int</span> distance = poll.distance;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(cur))<span class="keyword">continue</span>;</span><br><span class="line">            set.add(cur);</span><br><span class="line">            <span class="keyword">for</span>(Edge edge : cur.edges)&#123;</span><br><span class="line">                <span class="keyword">int</span> w = edge.weight;</span><br><span class="line">                Node toNode = edge.to;</span><br><span class="line">                <span class="keyword">if</span>(set.contains(toNode))<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(!dist.containsKey(toNode))dist.put(toNode,distance + w);</span><br><span class="line">                dist.put(toNode,Math.min(dist.get(toNode),distance + w));</span><br><span class="line">                priorityQueue.add(<span class="keyword">new</span> NodeRecord(toNode,dist.get(toNode)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line">        <span class="keyword">while</span>(cin.hasNext())&#123;</span><br><span class="line">            <span class="keyword">int</span> n = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> m = cin.nextInt();</span><br><span class="line">            Graph G = <span class="keyword">new</span> Graph();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)G.nodes.put(i,<span class="keyword">new</span> Node(i));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> a = cin.nextInt();</span><br><span class="line">                <span class="keyword">int</span> b = cin.nextInt();</span><br><span class="line">                <span class="keyword">int</span> w = cin.nextInt();</span><br><span class="line">                Node from = G.nodes.get(a);</span><br><span class="line">                Node to = G.nodes.get(b);</span><br><span class="line">                from.edges.add(<span class="keyword">new</span> Edge(from,to,w));</span><br><span class="line">                to.edges.add(<span class="keyword">new</span> Edge(to,from,w)); <span class="comment">//注意无向图</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> start = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> end = cin.nextInt();</span><br><span class="line">            HashMap&lt;Node, Integer&gt; dist = dijkstra(G.nodes.get(start));<span class="comment">//从start开始</span></span><br><span class="line">            Integer res = dist.get(G.nodes.get(end));</span><br><span class="line">            System.out.println((res == <span class="keyword">null</span>) ? -<span class="number">1</span> : res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>手写堆解决写法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> ArrayList&lt;Edge&gt; edges;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            edges = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> weight;</span><br><span class="line">        <span class="keyword">public</span> Node from;</span><br><span class="line">        <span class="keyword">public</span> Node to;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">( Node from, Node to,<span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.from = from;</span><br><span class="line">            <span class="keyword">this</span>.to = to;</span><br><span class="line">            <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> HashMap&lt;Integer,Node&gt; nodes;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            nodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeRecord</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Node node;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> distance;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">NodeRecord</span><span class="params">(Node node, <span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.node = node;</span><br><span class="line">            <span class="keyword">this</span>.distance = distance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeHeap</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node[] nodes;</span><br><span class="line">        <span class="keyword">private</span> HashMap&lt;Node, Integer&gt; indexMap;<span class="comment">//堆的下标</span></span><br><span class="line">        <span class="keyword">private</span> HashMap&lt;Node, Integer&gt; distMap; <span class="comment">//堆里面Node对应的distance</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">NodeHeap</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">            nodes = <span class="keyword">new</span> Node[size];</span><br><span class="line">            indexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            distMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;<span class="comment">//堆是否为空</span></span><br><span class="line">            <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOrUpdateOrIgnore</span><span class="params">(Node node, <span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//如果在堆中已经有了这个结点，就要更新   -1表示的是被访问过了</span></span><br><span class="line">            <span class="keyword">if</span> (indexMap.containsKey(node) &amp;&amp; indexMap.get(node) != -<span class="number">1</span>) &#123; <span class="comment">//update contain and index != -1</span></span><br><span class="line">                distMap.put(node, Math.min(distMap.get(node), distance));</span><br><span class="line">                insertHeapify(node, indexMap.get(node));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果 堆中没有这个结点 就创建一个</span></span><br><span class="line">            <span class="keyword">if</span> (!indexMap.containsKey(node)) &#123;<span class="comment">//if isEntered --&gt; ignore</span></span><br><span class="line">                nodes[size] = node;</span><br><span class="line">                indexMap.put(node, size);</span><br><span class="line">                distMap.put(node, distance);</span><br><span class="line">                insertHeapify(node, size++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从堆中取一个</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> NodeRecord <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            NodeRecord top = <span class="keyword">new</span> NodeRecord(nodes[<span class="number">0</span>], distMap.get(nodes[<span class="number">0</span>]));<span class="comment">//取出堆顶</span></span><br><span class="line">            swap(<span class="number">0</span>, size - <span class="number">1</span>); <span class="comment">//和最后一个交换</span></span><br><span class="line">            indexMap.put(nodes[size - <span class="number">1</span>], -<span class="number">1</span>); <span class="comment">//标记已经用过，相当于　Hashset作用</span></span><br><span class="line">            distMap.remove(nodes[size - <span class="number">1</span>]);  <span class="comment">//距离数组中李处</span></span><br><span class="line">            nodes[size - <span class="number">1</span>] = <span class="keyword">null</span>;  <span class="comment">//结点数组中设置为null</span></span><br><span class="line">            heapify(<span class="number">0</span>, --size);</span><br><span class="line">            <span class="keyword">return</span> top;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertHeapify</span><span class="params">(Node node, <span class="keyword">int</span> index)</span> </span>&#123; <span class="comment">//插入并调整</span></span><br><span class="line">            <span class="keyword">while</span> (distMap.get(nodes[index]) &lt; distMap.get(nodes[(index - <span class="number">1</span>) / <span class="number">2</span>])) &#123;</span><br><span class="line">                swap(index, (index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">                index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; size) &#123;</span><br><span class="line">                <span class="keyword">int</span> minIndex = left + <span class="number">1</span> &lt; size &amp;&amp; distMap.get(nodes[left + <span class="number">1</span>]) &lt; distMap.get(nodes[left])</span><br><span class="line">                        ? left + <span class="number">1</span> : left;</span><br><span class="line">                minIndex = distMap.get(nodes[minIndex]) &lt; distMap.get(nodes[index]) ? minIndex : index;</span><br><span class="line">                <span class="keyword">if</span> (minIndex == index) <span class="keyword">break</span>;</span><br><span class="line">                swap(minIndex, index);</span><br><span class="line">                index = minIndex;</span><br><span class="line">                left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">            indexMap.put(nodes[a], b);<span class="comment">//交换各自的下标</span></span><br><span class="line">            indexMap.put(nodes[b], a);</span><br><span class="line">            Node tmp = nodes[a];</span><br><span class="line">            nodes[a] = nodes[b];</span><br><span class="line">            nodes[b] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> HashMap&lt;Node,Integer&gt; <span class="title">dijkstra</span><span class="params">(Graph G,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        NodeHeap heap = <span class="keyword">new</span> NodeHeap(G.nodes.size());</span><br><span class="line">        heap.addOrUpdateOrIgnore(G.nodes.get(start),<span class="number">0</span>);</span><br><span class="line">        HashMap&lt;Node,Integer&gt;dist = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!heap.isEmpty())&#123;</span><br><span class="line">            NodeRecord poll = heap.poll();</span><br><span class="line">            Node cur = poll.node;</span><br><span class="line">            <span class="keyword">int</span> distance = poll.distance;</span><br><span class="line">            <span class="keyword">for</span>(Edge edge : cur.edges)&#123;</span><br><span class="line">                heap.addOrUpdateOrIgnore(edge.to, distance + edge.weight);</span><br><span class="line">            &#125;</span><br><span class="line">            dist.put(cur,distance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Graph <span class="title">createGraph</span><span class="params">(Scanner cin,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        Graph G = <span class="keyword">new</span> Graph();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)G.nodes.put(i,<span class="keyword">new</span> Node(i));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> b = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> w = cin.nextInt();</span><br><span class="line">            Node from = G.nodes.get(a);</span><br><span class="line">            Node to = G.nodes.get(b);</span><br><span class="line">            from.edges.add(<span class="keyword">new</span> Edge(from,to,w));</span><br><span class="line">            to.edges.add(<span class="keyword">new</span> Edge(to,from,w));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> G;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line">        <span class="keyword">while</span>(cin.hasNext())&#123;</span><br><span class="line">            <span class="keyword">int</span> n = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> m = cin.nextInt();</span><br><span class="line">            Graph G = createGraph(cin,n,m);</span><br><span class="line">            <span class="keyword">int</span> start = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> end = cin.nextInt();</span><br><span class="line">            HashMap&lt;Node, Integer&gt; dist = dijkstra(G,start);<span class="comment">//从start开始</span></span><br><span class="line">            Integer res = dist.get(G.nodes.get(end));</span><br><span class="line">            System.out.println((res == <span class="keyword">null</span>) ? -<span class="number">1</span> : res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Graph</tag>
        <tag>dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title>各种排序算法总结(全面)</title>
    <url>/2021/12/29/%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93(%E5%85%A8%E9%9D%A2)/</url>
    <content><![CDATA[<h1 id="各种排序算法总结-全面"><a href="#各种排序算法总结-全面" class="headerlink" title="各种排序算法总结(全面)"></a>各种排序算法总结(全面)</h1><ul>
<li><a href="#%E6%A6%82%E6%8B%AC">概括</a></li>
<li><a href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序</a></li>
<li><a href="#%E6%94%B9%E8%BF%9B%E7%9A%84%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-%E9%B8%A1%E5%B0%BE%E9%85%92%E6%8E%92%E5%BA%8F">改进的冒泡排序-鸡尾酒排序</a></li>
<li><a href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">选择排序</a></li>
<li><a href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">插入排序</a></li>
<li><a href="#%E4%BA%8C%E5%88%86%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">二分插入排序</a></li>
<li><a href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序</a></li>
<li><a href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a></li>
<li><a href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">归并排序</a></li>
<li><a href="#%E5%A0%86%E6%8E%92%E5%BA%8F">堆排序</a></li>
<li><a href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F">计数排序</a></li>
<li><a href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F">基数排序</a></li>
<li><a href="#%E6%A1%B6%E6%8E%92%E5%BA%8F">桶排序</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">测试代码</a></li>
<li><a href="#%E9%99%84c%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81">附C++部分代码</a></li>
</ul>
<hr>
<h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><p>排序算法大体可分为两种：</p>
<ul>
<li>一种是比较排序，时间复杂度<code>O(nlogn) ~ O(n^2)</code>，主要有：冒泡排序，选择排序，插入排序，归并排序，堆排序，快速排序等。</li>
<li>另一种是非比较排序，时间复杂度可以达到<code>O(n)</code>，主要有：计数排序，基数排序，桶排序等。</li>
</ul>
<p>下面给出常见比较算法的排序性能</p>
<table>
<thead>
<tr>
<th>排序方法</th>
<th>平均情况</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>简单选择排序</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>直接插入排序</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(nlogn) ~ O(n<sup>2</sup>)</td>
<td>O(n<sup>1.3</sup>)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(n)</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(logn)~O(n)</td>
<td>不稳定</td>
</tr>
</tbody></table>
<ul>
<li><strong>另外在说一下关于排序算法的<font color = crimson>稳定性问题 :</font>　排序算法稳定性的简单形式化定义为：如果<code>arr[i] = arr[j]</code>，排序前<code>arr[i]</code>在<code>arr[j]</code>之前，排序后<code>arr[i]</code>还在<code>arr[j]</code>之前，则称这种排序算法是稳定的。通俗地讲就是保证排序前后两个相等的数的相对顺序不变。</strong>（<font color = blue>可以通过自定义比较函数来去除稳定性问题</font>）</li>
</ul>
<p>举例：对于冒泡排序，原本是稳定的排序算法，如果将记录交换的条件改成<code>arr[i] &gt;= arr[i + 1]</code>，则两个相等的记录就会交换位置，从而变成不稳定的排序算法。 </p>
<p><strong>为了使下面的代码方便，这里贴出Swap函数，交换数组中某两个位置的值</strong>；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j]; </span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者这样:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    arr[i] = arr[i] ^ arr[j];</span><br><span class="line">    arr[j] = arr[i] ^ arr[j];</span><br><span class="line">    arr[i] = arr[i] ^ arr[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><font color = red id = "1">冒泡排序</h2><p>冒泡排序是比较简单的排序算法，它的运作过程如下：</p>
<ul>
<li>进行<code>n-1</code>次排序。</li>
<li>每次排序从<code>0~n-1-i</code>(<code>i</code>是次数编号)，检查这个序列中的数，两两相邻的数，如果前面的大于后面的就将它们交换，这样使得大的数往后面走，每次冒泡就会将一个大的数往后面冒，从而达到目的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**冒泡排序(加入了判断是否已经排序了的boolean变量) */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> end = arr.length-<span class="number">1</span>; end &gt; <span class="number">0</span>; end--)&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isSort = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; end; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[i+<span class="number">1</span>])&#123;</span><br><span class="line">                swap(arr,i,i+<span class="number">1</span>);</span><br><span class="line">                isSort = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isSort)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以还可以做一个优化 :</p>
<ul>
<li>记录上一次最后交换的那个位置<code>border</code>；</li>
<li>下一轮交换只需要进行到这个位置即可；<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> end = arr.length-<span class="number">1</span>; end &gt; <span class="number">0</span>; end--)&#123;</span><br><span class="line">        <span class="keyword">int</span> border = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; end; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[i+<span class="number">1</span>])&#123;</span><br><span class="line">                swap(arr, i, i+<span class="number">1</span>);</span><br><span class="line">                border = i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        end = border;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="鸡尾酒排序-改进的冒泡排序"><a href="#鸡尾酒排序-改进的冒泡排序" class="headerlink" title="鸡尾酒排序-改进的冒泡排序"></a><font color = red id = "2">鸡尾酒排序-改进的冒泡排序</h2><p>也叫做<font color = crimson>定向</font>冒泡排序:</p>
<ul>
<li>它的改进在于同时的冒泡两边，<font color = crimson>从低到高，然后从高到低；</li>
<li>相当于顺便把最小的数也冒泡到最前面</font>这个方法比冒泡更加高效一点；</li>
</ul>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**改进的冒泡排序(鸡尾酒排序)  就是把最大的数往后面冒泡的同时，　最小的数也往前面冒泡*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cocktailSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>,R = arr.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(L &lt; R) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = L; i &lt; R; i++) <span class="keyword">if</span>(arr[i] &gt; arr[i+<span class="number">1</span>]) swap(arr,i,i+<span class="number">1</span>);</span><br><span class="line">        R--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = R; i &gt; L; i--) <span class="keyword">if</span>(arr[i] &lt; arr[i-<span class="number">1</span>]) swap(arr,i,i-<span class="number">1</span>);</span><br><span class="line">        L++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a><font color = red id = "3">选择排序</h2><p>选择排序的思想是：</p>
<ul>
<li>在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列；</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，放到<font color = crimson><strong>已排序序列的末尾</strong></font>。</li>
</ul>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;<span class="comment">/**记录后面的最小值的下标*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) <span class="comment">//注意从i+1开始</span></span><br><span class="line">            minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;</span><br><span class="line">        swap(arr,i,minIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a><font color = red id = "4">插入排序</h2><p>插入排序的思想有点类似抓扑克牌 ， 过程如下:</p>
<ul>
<li><p>从第一个元素开始，该元素可以看作已经排好序；</p>
</li>
<li><p>取出下一个元素，从这个元素从后往前开始扫描，如果该元素大于新元素，将该元素移到下一位置；</p>
</li>
<li><p>重复上述步骤，直到找到已排序的元素小于或者等于新元素的位置，将新元素插入到该位置后；</p>
</li>
<li><p><strong>注意插入排序和数据状况有关系，涉及到最好情况，最差情况和平均情况。</strong></p>
</li>
<li><p>插入排序在工程上，当数组元素个数少的时候用的多，因为如果数组比较有序的话，会很快；</p>
</li>
</ul>
<p><img src="images/1_%E6%8F%92%E5%85%A5.png" alt="这里写图片描述"></p>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> key = arr[i], j;</span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; key &lt; arr[j]; j--) arr[j + <span class="number">1</span>] = arr[j]; <span class="comment">//中间的元素往后面移动</span></span><br><span class="line">        arr[j + <span class="number">1</span>] = key;   <span class="comment">//将key插入到合适的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更加简单的做法，配上swap函数:(有点类似冒泡了):<font color = red>这里要注意第二层循环的下标j &gt; 0。</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j-<span class="number">1</span>]; j--)swap(arr,j,j-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="二分插入排序"><a href="#二分插入排序" class="headerlink" title="二分插入排序"></a><font color = red id = "5">二分插入排序</h2><p>二分插入排序是对插入排序的一个小小的改进：</p>
<ul>
<li>改进的地方在于<font color = crimson>在前面已经排好序的序列中找当前要插入的元素的时候采用二分查找的方式去找那个插入的位置(大于key的那个位置) ，关于二分查找可以看<a href="https://blog.csdn.net/zxzxzx0119/article/details/82670761#t4">这篇博客</a></font>；</li>
<li>找到那个位置之后，再进行元素的移动，已及把那个元素插入到找到的那个位置；</li>
</ul>
<p><img src="images/2_.png" alt="这里写图片描述"></p>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二分插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort3</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> key = arr[i];</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>, R = i-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(L &lt;= R) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = L + (R-L)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &gt; key)R = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//二分结束之后　L = 刚好大于key(不是等于)的那个位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i-<span class="number">1</span>; j &gt;= L; j--)arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">        arr[L] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a><font color = red id = "6">希尔排序</h2><p>希尔排序使更高效的插入排序，它的思想在于，</p>
<ul>
<li>把数组分成几块，每一块进行一个插入排序；</li>
<li>而分块的依据在于<font color = crimson >增量的选择</font>分好块之后，<font color = crimson >从gap开始到n，每一组和它前面的元素（自己组内的）进行插入排序</font>；</li>
</ul>
<p><strong>每次和组内的元素比较完之后，最后的元素基本就是有序的了，希尔排序相对于插入排序的优势在于插入排序每次只能将数据移动一位，不过希尔排序时间复杂度的大小还是要取决于步长的合适度，另外希尔排序不是一种稳定的排序算法。</strong></p>
<p><img src="images/3_%E5%B8%8C%E5%B0%94.png" alt="在这里插入图片描述"></p>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//步长为n/2....</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> gap = arr.length; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;     <span class="comment">//增量序列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;        <span class="comment">//从数组第gap个元素开始</span></span><br><span class="line">            <span class="keyword">int</span> key = arr[i],j;                        <span class="comment">//每个元素与自己组内的数据进行直接插入排序</span></span><br><span class="line">            <span class="keyword">for</span>(j = i-gap; j &gt;= <span class="number">0</span> &amp;&amp; key &lt; arr[j]; j -= gap) arr[j+gap] = arr[j];</span><br><span class="line">            arr[j+gap] = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//步长为 n*3+1</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(; gap &lt;= arr.length; gap = gap*<span class="number">3</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(; gap &gt; <span class="number">0</span>; gap = (gap-<span class="number">1</span>)/<span class="number">3</span>) &#123; <span class="comment">//增量序列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;  <span class="comment">//从数组第gap个元素开始</span></span><br><span class="line">            <span class="keyword">int</span> key = arr[i],j;  <span class="comment">//每个元素与自己组内的数据进行直接插入排序</span></span><br><span class="line">            <span class="keyword">for</span>(j = i-gap; j &gt;= <span class="number">0</span> &amp;&amp; key &lt; arr[j]; j -= gap) arr[j+gap] = arr[j];</span><br><span class="line">            arr[j+gap] = key; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<hr>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a><font color = red id = "7">快速排序</h2><p>快速排序有几种不同的实现方式，先看最简单的，快排的宏观过程就是每次递归左右两边划分，关键是划分的过程，即<code>partition</code>过程的写法，先看最原始的<code>partition</code>:</p>
<ul>
<li>在<code>[L, R]</code>之间，选取<code>arr[L]</code>为划分点<code>key</code>；</li>
<li>然后从<code>[L, R]</code>，如果当前<code>arr[i] &lt; key</code>，就放到左边部分<code>swap(arr, i, ++pivot);</code>，否则就不动；</li>
<li>最后将数组划分成了<code>arr[L...p-1] &lt; arr[p]</code> ， <code>arr[p+1...R] &gt; arr[p]</code>，并返回<code>p</code>；<br><img src="images/4_%E5%BF%AB1.png" alt="在这里插入图片描述"></li>
</ul>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    quickProcess(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickProcess</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= R)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> p = partition(arr, L, R);</span><br><span class="line">    quickProcess(arr, L, p - <span class="number">1</span>);</span><br><span class="line">    quickProcess(arr, p + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 对arr[l...r]部分进行partition操作</span></span><br><span class="line"><span class="comment">* 返回p, 使得arr[L...p-1] &lt; arr[p] ; arr[p+1...R] &gt; arr[p]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//直接选取 arr[L]作为pivot(中心点)</span></span><br><span class="line">    <span class="keyword">int</span> key = arr[L];</span><br><span class="line">    <span class="keyword">int</span> pivot = L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L + <span class="number">1</span>; i &lt;= R; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; key)</span><br><span class="line">            swap(arr, i, ++pivot);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, pivot, L); <span class="comment">// 将arr[L]放到pivot位置(中间) --&gt; 完全了按照arr[L]划分数组的目的</span></span><br><span class="line">    <span class="keyword">return</span> pivot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color = green><strong>第一个优化(随机快排) (解决划分数选取不好的问题)</strong></font><br>上面的快速排序当选取的划分的元素(<code>pivot = arr[L]</code>)很小(或者很大)，使得后面划分的数组极度的不平衡的时候，会将快速排序降到<font color = red>O(N<sup>2</sup>)</font>，于是我们使用<font color = red>随机快排</font>，即不是将<code>arr[L]</code>作为划分点，而是随机选取一个元素作为(<code>pivot</code>)：</p>
<p><img src="images/5_%E5%BF%AB2.png" alt="在这里插入图片描述"></p>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    quickProcess(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickProcess</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= R)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    swap(arr, L, L + (<span class="keyword">int</span>) (Math.random() * (R - L + <span class="number">1</span>))); <span class="comment">//随机选取一个pivot</span></span><br><span class="line">    <span class="keyword">int</span> p = partition(arr, L, R);</span><br><span class="line">    quickProcess(arr, L, p - <span class="number">1</span>);</span><br><span class="line">    quickProcess(arr, p + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//直接选取 arr[L]作为pivot(中心点)</span></span><br><span class="line">    <span class="keyword">int</span> key = arr[L];</span><br><span class="line">    <span class="keyword">int</span> pivot = L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L + <span class="number">1</span>; i &lt;= R; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; key)</span><br><span class="line">            swap(arr, i, ++pivot);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, pivot, L); <span class="comment">// 将arr[L]放到pivot位置(中间) --&gt; 完全了按照arr[L]划分数组的目的</span></span><br><span class="line">    <span class="keyword">return</span> pivot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color = green><strong>第二个优化(双路快速排序)(解决重复元素多的问题)</strong></font></p>
<p>当我们要排序的数组<font color = red>重复元素很多</font>的情况下，还是会使得划分极其的不均匀: </p>
<p><img src="images/6_%E5%BF%AB3.png" alt="在这里插入图片描述"></p>
<p>第一个解决的方法: <font color = blue>换一种划分的方式: </p>
<ul>
<li>将 <code>&lt;key</code>和<code>&gt;key</code>的元素放在数组的两边，更准确的说是: <font color =red>左端放的是 <code>&lt;=key</code>的元素，右端放的是<code>&gt;=key</code>的元素；</li>
<li>然后设置两个指针(一个从<code>L</code>开始，一个从<code>R</code>开始)，然后向中间靠拢，分别找到第一个<code>&gt;=key</code>(左边)、<code>&lt;=key</code>(右边)的元素，就停止扫描，然后交换这两个位置，终止条件是两个指针相碰；</li>
<li>为什么这样就可以解决重复元素多的问题呢? 因为两个指针的元素相等且都等于<code>key</code>的时候，还是要交换两个位置，这样就不会将重复的元素集中在同一侧。</li>
</ul>
<p>解决方式: </p>
<p><img src="images/7_%E5%BF%AB4.png" alt="在这里插入图片描述"></p>
<p>改进代码: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    quickProcess(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickProcess</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= R)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    swap(arr, L, L + (<span class="keyword">int</span>) (Math.random() * (R - L + <span class="number">1</span>))); <span class="comment">//随机选取一个pivot</span></span><br><span class="line">    <span class="keyword">int</span> p = partition(arr, L, R);</span><br><span class="line">    quickProcess(arr, L, p - <span class="number">1</span>);</span><br><span class="line">    quickProcess(arr, p + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key = arr[L];</span><br><span class="line">    <span class="keyword">int</span> less = L + <span class="number">1</span>, more = R;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (less &lt; R &amp;&amp; arr[less] &lt; key) less++;</span><br><span class="line">        <span class="keyword">while</span> (more &gt; L &amp;&amp; arr[more] &gt; key) more--;</span><br><span class="line">        <span class="keyword">if</span> (less &gt;= more)<span class="comment">// not less &gt; more  </span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        swap(arr, less++, more--);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, L, more); <span class="comment">// finally let L to the middle </span></span><br><span class="line">    <span class="keyword">return</span> more;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color = green><strong>第三个优化(三路快速排序)(更好的解决重复元素多的问题)</strong></font><br>三路快排关键在于<code>partion</code>的过程(荷兰国旗问题)，也就是将一个数组按照某个数划分成三部分:</p>
<ul>
<li>先从序列中选取一个数作为基数(<code>key</code>)；</li>
<li>分区过程，将<code>&lt;key</code>放到左边，<code>&gt;key</code>的放在右边，<code>=key</code>放到中间；</li>
<li>再对左右区间重复第二步，直到各区间只有一个数；</li>
<li>返回的<code>p</code>数组中<code>p[0]</code>代表的是等于区域的左边界，<code>p[1]</code>代表的是等于区域的右边界；</li>
</ul>
<p> 过程:<br> <img src="images/8_%E5%BF%AB5.png"></p>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> num) &#123;</span><br><span class="line">    <span class="keyword">int</span> less = L - <span class="number">1</span>; <span class="comment">//小于部分的最后一个数</span></span><br><span class="line">    <span class="keyword">int</span> more = R + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cur = L;</span><br><span class="line">    <span class="keyword">while</span> (cur &lt; more) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[cur] &lt; num) &#123;</span><br><span class="line">            swap(arr, ++less, cur++); <span class="comment">//把这个比num小的数放到小于区域的下一个，并且把小于区域扩大一个单位</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[cur] &gt; num) &#123;</span><br><span class="line">            swap(arr, --more, cur); <span class="comment">//把这个比num大的数放到大于去余的下一个，并且把大于区域扩大一个单位</span></span><br><span class="line">            <span class="comment">//同时，因为从大于区域拿过来的数是未知的，所以不能cur++ 还要再次判断一下arr[cur]</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 否则的话就直接移动</span></span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;less + <span class="number">1</span>, more - <span class="number">1</span>&#125;;  <span class="comment">//返回的是等于区域的两个下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color = red>荷兰国旗问题的一个<a href="https://blog.csdn.net/zxzxzx0119/article/details/82715141">经典应用题LeetCode75-Sort Colors</a>。</font><br>注意这里的快速排序就是<code>partition</code>更改的，默认将<code>R</code>中的最后一个作为划分(也可以用<code>arr[L]</code>)．<br><font color =  red>这里总结一下优化 (<strong>所有的优化都是为了划分的均匀</strong>):  </font></p>
<ul>
<li><p>这里实际上使用的是<font color = red>三路快排</font>，这个是为了<font color = blue>防止数组中有很多重复的元素</font>    ；</p>
</li>
<li><p>使用的是<font color = red>随机快排</fon>，时间复杂度是概率级别的<code>Ologn</code>(<font color = blue>防止数组近乎有序</font>)；</p>
</li>
<li><p>注意下面我写了<font color= red>四种</font><code>partition</code>的过程，达到的效果是一样的，分别使用<code>arr[L]</code>和<code>arr[R]</code>来作划分，一些细节和边界的不同导致程序不同；</p>
</li>
</ul>
<p>最终三路快排代码如下: (<strong>下面的四个partition都是三路快排，只不过写的稍微有点不同</strong>)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    quickProcess(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用随机快排 (也就是 时间复杂度是概率的，防止我们选取的划分的数使得左右两边划分的很不均匀)</span></span><br><span class="line"><span class="comment"> * 随机快排的额外空间复杂度为Ologn</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickProcess</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= R)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/**随机化的排序 期望为Ologn从前面的数中随机选出一个数和最后一个数交换 不至于极端的情况使得两边划分很不对称*/</span></span><br><span class="line">    swap(arr, R, L + (<span class="keyword">int</span>) (Math.random() * (R - L + <span class="number">1</span>))); <span class="comment">//例子3~6 --&gt; [0~1)*3 --&gt; 0~2</span></span><br><span class="line">    <span class="keyword">int</span>[] p = partition4(arr, L, R); <span class="comment">// 分别用partition、partition2、partition3测试都可以</span></span><br><span class="line">    quickProcess(arr, L, p[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">    quickProcess(arr, p[<span class="number">1</span>] + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 划分函数,这里使用的是arr[R]来划分, 左边的都比arr[R]小，右边都比arr[R]大</span></span><br><span class="line"><span class="comment"> * 返回的数组是中间相等的两个下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R) &#123;</span><br><span class="line">    <span class="keyword">int</span> cur = L, less = L - <span class="number">1</span>, more = R;</span><br><span class="line">    <span class="keyword">int</span> key = arr[R];</span><br><span class="line">    <span class="keyword">while</span> (cur &lt; more) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[cur] &lt; key)</span><br><span class="line">            swap(arr, ++less, cur++);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[cur] &gt; key)</span><br><span class="line">            swap(arr, --more, cur);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, more, R);  <span class="comment">//把最后那个数放到中间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;less + <span class="number">1</span>, more&#125;;  <span class="comment">//当然如果没有相等的部分  那less+1 = more</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上面的简写方式</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] partition2(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R) &#123;</span><br><span class="line">    <span class="keyword">int</span> less = L - <span class="number">1</span>, more = R;  <span class="comment">//把最后这个数当作标准 也可以使用第一个</span></span><br><span class="line">    <span class="keyword">while</span> (L &lt; more) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[L] &lt; arr[R])</span><br><span class="line">            swap(arr, ++less, L++);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[L] &gt; arr[R])</span><br><span class="line">            swap(arr, --more, L);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            L++;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, more, R);  <span class="comment">//把最后那个数放到中间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;less + <span class="number">1</span>, more&#125;;  <span class="comment">//为什么不是 more-1,因为上面又交换了一个, 当然如果没有相等的部分  那less+1 = more</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正方向：按照 arr[L]来划分</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] partition3(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R) &#123;</span><br><span class="line">    <span class="keyword">int</span> key = arr[L], cur = L + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> less = L, more = R + <span class="number">1</span>; <span class="comment">// more在外面(R+1)，等下循环cur &lt; more</span></span><br><span class="line">    <span class="keyword">while</span> (cur &lt; more) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[cur] &lt; key)</span><br><span class="line">            swap(arr, ++less, cur++);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[cur] &gt; key)</span><br><span class="line">            swap(arr, --more, cur);</span><br><span class="line">        <span class="keyword">else</span> cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, L, less);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;less, more - <span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对比partition3的不同</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] partition4(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R) &#123;</span><br><span class="line">    <span class="keyword">int</span> key = arr[L], cur = L + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> less = L, more = R; <span class="comment">// more = R，等下循环cur &lt;= more</span></span><br><span class="line">    <span class="keyword">while</span> (cur &lt;= more) &#123; <span class="comment">// not cur &lt; more</span></span><br><span class="line">        <span class="keyword">if</span> (arr[cur] &lt; key)</span><br><span class="line">            swap(arr, ++less, cur++);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[cur] &gt; key)</span><br><span class="line">            swap(arr, more--, cur); <span class="comment">// 对比上面,不是--more,这些就是边界问题</span></span><br><span class="line">        <span class="keyword">else</span> cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, L, less);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;less, more&#125;; <span class="comment">//同样返回的也不同</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[a];</span><br><span class="line">    arr[a] = arr[b];</span><br><span class="line">    arr[b] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意这里和荷兰国旗<code>partitiion</code>过程的不同:</strong></p>
<p><img src="images/9_%E5%BF%AB6.png" alt="这里写图片描述"></p>
<p><strong>注意最后的<code>arr[more]</code>和<code>arr[R]</code>的交换(注意最后的交换和返回的下标位置):</strong></p>
<p><img src="images/10_%E5%BF%AB7.png" alt="这里写图片描述"> </p>
<hr>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a><font color = red id = "8">归并排序</h2><p><strong>归并排序也是分治法一个很好的应用，先递归到最底层，然后从下往上每次两个序列进行归并合起来，是一个由上往下分开，再由下往上合并的过程。</strong></p>
<p><strong>而对于每一次合并操作，对于每一次<code>merge</code>的操作过程如下：</strong></p>
<ul>
<li> 准备一个额外的数组(<code>help</code>)，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>重复步骤3直到某一指针达到序列尾；</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾；</li>
</ul>
<p>看下面的例子合并过程如下：</p>
<p><img src="images/12_%E5%A0%861.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    mergeProcess(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeProcess</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= R)</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">//递归条件判断</span></span><br><span class="line">    <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>); <span class="comment">//这个相当于 (R+L)/2;</span></span><br><span class="line">    mergeProcess(arr, L, mid);  <span class="comment">//T(n/2)</span></span><br><span class="line">    mergeProcess(arr, mid + <span class="number">1</span>, R); <span class="comment">//T(n/2)</span></span><br><span class="line">    <span class="comment">/**这个是一个优化，因为arr[L,mid]和arr[mid+1,R]已经有序，所以如果满足这个条件，就不要排序了,防止一开始数组有序*/</span></span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &gt; arr[mid + <span class="number">1</span>])</span><br><span class="line">        merge(arr, L, mid, R);  <span class="comment">// O(n)</span></span><br><span class="line">    <span class="comment">//整个的表达式  T(n) = 2*T(n/2) + O(n) 使用master公式求出  N*logN</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> mid, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = L, p2 = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//while(p1 &lt;= mid &amp;&amp; p2 &lt;= R)</span></span><br><span class="line">    <span class="comment">//   help[k++] = arr[p1] &lt; arr[p2]  ? arr[p1++] : arr[p2++];</span></span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= R)</span><br><span class="line">        help[k++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];  <span class="comment">//左右两边相等的话，就先拷贝左边的(实现稳定性)</span></span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid)  <span class="comment">//左边剩余的部分</span></span><br><span class="line">        help[k++] = arr[p1++];</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= R)   <span class="comment">//右边剩余的部分</span></span><br><span class="line">        help[k++] = arr[p2++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) <span class="comment">//拷贝回原来的数组</span></span><br><span class="line">        arr[i + L] = help[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意几点: </p>
<ul>
<li><strong>注意上面的代码中<code>if(arr[mid] &gt; arr[mid+1])</code>防止一开始数组很有序的情况；</strong></li>
<li><strong>注意在外排比较的时候，为了保证稳定性，左右相等的时候，先拷贝左边的；</strong></li>
</ul>
<p><strong>另外再补充一个<a href="https://www.lintcode.com/problem/reverse-pairs/description">LintCode532Reverse Pairs归并排序求解逆序数</a>的问题</strong>:  </p>
<p><img src="images/11_%E5%BF%AB8.png" alt="在这里插入图片描述"></p>
<p>这个的关键在于，在合并<code>l ~ mid</code>和<code>mid+1~r</code>的过程中，只要<code>arr[p1] &gt; arr[p2]</code>，则<code>arr[p2]</code>和<code>arr[p1 ~ mid]</code>都能组成逆序对，所以我们每次都可以加上<code>mid - p1 + 1</code>个数，故可以方便求出逆序数对数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A: an array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: total of reverse pairs</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">1</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> mergeProcess(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">mergeProcess</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( L == R)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = L + ((R-L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> mergeProcess(arr,L,mid)</span><br><span class="line">                + mergeProcess(arr,mid+<span class="number">1</span>,R)</span><br><span class="line">                + merge(arr,L,mid,R);<span class="comment">//注意merge放在后面</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> L,<span class="keyword">int</span> mid,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[R-L+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p1 = L,p2 = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(p1 &lt;= mid &amp;&amp; p2 &lt;= R)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[p1] &lt;= arr[p2])&#123;</span><br><span class="line">                help[k++] = arr[p1++];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;   <span class="comment">//arr[p1] &gt; arr[p2] 此时p2都小于arr[p1,mid]之间的元素</span></span><br><span class="line">                sum += (mid-p1+<span class="number">1</span>);  <span class="comment">//加上逆序数的个数</span></span><br><span class="line">                help[k++] = arr[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p1 &lt;= mid)</span><br><span class="line">            help[k++] = arr[p1++];</span><br><span class="line">        <span class="keyword">while</span>(p2 &lt;= R) </span><br><span class="line">            help[k++] = arr[p2++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            arr[i+L] = help[i];</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>还有一个题目就是小和问题:  具体的问题和上面的逆序数差不多。</strong></p>
<p>题目:</p>
<blockquote>
<p>小和问题 </p>
<p>在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组<br>的小和。</p>
<p>例子;</p>
<p><code>[1,3,4 2,5]</code></p>
<p>1左边比1小的数，没有；</p>
<p>3左边比3小的数，1；</p>
<p>4左边比4小的数，1、3；</p>
<p>2左边比2小的数，1；</p>
<p>5左边比5小的数，1、3、4、2；<br>所以小和为1+1+3+1+1+3+4+2=16</p>
</blockquote>
<p>代码类似:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mergeSortSum</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> mergeProcess(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mergeProcess</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>); </span><br><span class="line">    <span class="keyword">return</span> mergeProcess(arr, L, mid) +</span><br><span class="line">            mergeProcess(arr, mid + <span class="number">1</span>, R) +</span><br><span class="line">            merge(arr, L, mid, R); <span class="comment">//左边的小和和右边的小和</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> mid, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = L, p2 = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[p1] &lt; arr[p2]) &#123;<span class="comment">//如果arr[p1] &lt; arr[p2] 则arr[p1] &lt; arr[p2 ~ R]</span></span><br><span class="line">            sum += arr[p1] * (R - p2 + <span class="number">1</span>);</span><br><span class="line">            help[i++] = arr[p1++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            help[i++] = arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid) help[i++] = arr[p1++];</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= R) help[i++] = arr[p2++];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= R - L; i++) arr[i + L] = help[i];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>另外，归并排序也可以<font color = red>自底向上</font>的进行: </p>
<p><img src="images/13_%E5%BD%92%E5%B9%B62.png" alt="在这里插入图片描述"></p>
<p>代码实现注意两个细节: </p>
<ul>
<li>第二层循环: <code>sz + i -1 = mid</code> ，注意不要越界，所以在第二层循环中<code>i+sz &lt; arr.length</code>；</li>
<li>同理，<code>i+2*sz - 1</code>也要保证不能越界，所以和<code>arr.length - 1</code>取最小值；<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSortBU</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt;= arr.length; sz += sz)&#123; <span class="comment">// 区间的个数，1..2..4..8</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; sz + i &lt; arr.length; i += sz+sz)&#123;  <span class="comment">// 对[i...i+sz-1]和[i+sz...i+2*sz-1]内归并</span></span><br><span class="line">            merge(arr, i, i+sz-<span class="number">1</span>, Math.min(arr.length-<span class="number">1</span>, i+<span class="number">2</span>*sz-<span class="number">1</span>)); <span class="comment">// min防止越界</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a><font color = red id = "9">堆排序</h2><p><font color =red>堆的相关介绍看<a href="https://blog.csdn.net/zxzxzx0119/article/details/79890060">这篇博客</a>。</p>
<p>堆排序的过程是一个反复调整堆的过程：</p>
<ul>
<li>利用数组建立一个大根堆（父亲比孩子的值大）；</li>
<li>把堆顶元素和堆尾元素互换；</li>
<li> 把堆（无序区）的尺寸缩小<code>1</code>，并调用<code>siftDown(arr, 0,len-1)</code>从新的堆顶元素开始进行堆调整；</li>
<li>重复步骤，直到堆的大小为<code>1</code>；</li>
</ul>
<p>基本的堆排序 : </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        siftUp(arr, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size = arr.length;</span><br><span class="line">    swap(arr, <span class="number">0</span>, --size);</span><br><span class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        siftDown(arr, <span class="number">0</span>, size);</span><br><span class="line">        swap(arr, <span class="number">0</span>, --size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上浮的过程  --&gt;  把新插入的数调整为大根堆的过程</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (arr[i] &gt; arr[(i - <span class="number">1</span>) / <span class="number">2</span>]) &#123;</span><br><span class="line">        swap(arr, i, (i - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        i = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下沉的过程  --&gt;  这个函数就是一个数变小了，往下沉的函数,改变的数为index  目前的自己指定的堆的大小为heapSize</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; heapSize) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxIndex = L + <span class="number">1</span> &lt; heapSize &amp;&amp; arr[L + <span class="number">1</span>] &gt; arr[L] ? L + <span class="number">1</span> : L;</span><br><span class="line">        maxIndex = arr[i] &gt; arr[maxIndex] ? i : maxIndex;</span><br><span class="line">        <span class="keyword">if</span> (maxIndex == i) <span class="keyword">break</span>; <span class="comment">//自己就是最大的， 不用忘下沉</span></span><br><span class="line">        <span class="comment">//否则就要一直往下沉</span></span><br><span class="line">        swap(arr, i, maxIndex);</span><br><span class="line">        i = maxIndex;</span><br><span class="line">        L = <span class="number">2</span> * i + <span class="number">1</span>; <span class="comment">//继续往下</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color = red> 下面是将一个数组建成堆的时候的优化过程: </font></p>
<p>下面的写法就是一个下沉的操作(这里建堆的时候没有使用上浮，而是从第一个非叶子结点开始使用下沉的方式建堆):<br><img src="images/14_%E5%A0%861.png" alt="在这里插入图片描述"></p>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> size = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (size - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        siftDown(arr, i, size);</span><br><span class="line">    swap(arr, <span class="number">0</span>, size);</span><br><span class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        siftDown(arr, <span class="number">0</span>, size);</span><br><span class="line">        swap(arr, <span class="number">0</span>, --size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 往下沉的函数,改变的数为index  目前的自己指定的堆的大小为heapSize</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; heapSize) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxIdx = L + <span class="number">1</span> &lt; heapSize &amp;&amp; arr[L + <span class="number">1</span>] &gt; arr[L] ? L + <span class="number">1</span> : L;</span><br><span class="line">        maxIdx = arr[i] &gt; arr[maxIdx] ? i : maxIdx;</span><br><span class="line">        <span class="keyword">if</span> (maxIdx == i) <span class="keyword">break</span>; <span class="comment">//自己就是最大的， 不用忘下沉</span></span><br><span class="line"></span><br><span class="line">        swap(arr, i, maxIdx);</span><br><span class="line">        i = maxIdx;</span><br><span class="line">        L = <span class="number">2</span> * i + <span class="number">1</span>; <span class="comment">//继续往下</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>shiftDown的过程也可以递归的换:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归的调整A[i]以下的堆</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> size)</span> </span>&#123; <span class="comment">//从A[i] 开始往下调整</span></span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">2</span> * i + <span class="number">1</span>; <span class="comment">//左孩子的下标</span></span><br><span class="line">    <span class="keyword">int</span> R = <span class="number">2</span> * i + <span class="number">2</span>;<span class="comment">//右孩子的下标</span></span><br><span class="line">    <span class="keyword">int</span> maxIdx = i;</span><br><span class="line">    <span class="keyword">if</span> (L &lt; size &amp;&amp; arr[L] &gt; arr[maxIdx]) maxIdx = L;</span><br><span class="line">    <span class="keyword">if</span> (R &lt; size &amp;&amp; arr[R] &gt; arr[maxIdx]) maxIdx = R;</span><br><span class="line">    <span class="keyword">if</span> (maxIdx != i) &#123;</span><br><span class="line">        swap(arr, i, maxIdx);  <span class="comment">//把当前结点和它的最大(直接)子节点进行交换</span></span><br><span class="line">        siftDown(arr, maxIdx, size);  <span class="comment">//继续调整它的孩子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (size - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        siftDown(arr, i, size);</span><br><span class="line">    swap(arr, <span class="number">0</span>, size);<span class="comment">//和最后一个数交换</span></span><br><span class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        siftDown(arr, <span class="number">0</span>, size);</span><br><span class="line">        swap(arr, <span class="number">0</span>, --size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a><font color = red id = "10">计数排序</h2><p>计数排序是一种非比较排序： </p>
<ul>
<li><strong>利用一个<code>count</code>数组，统计每个元素<code>arr[i]</code>出现的次数<code>count[arr[i]]</code>，<code>count</code>数组的大小代表的是能排序的元素的最大的值；</strong></li>
<li><strong>然后让<code>count</code>数组中每一个元素<code>count[i]</code>等于其与他前面一项<code>count[i-1]</code>相加，这时候<code>count[arr[i]]</code>表示的值就是小于等于<code>arr[i]</code>的元素的个数，这时就找到了<code>arr[i]</code>在输出数组中的位置；</strong></li>
<li><strong>最后通过<font color =red>反向填充</font>目标数组<code>tmp</code>，将数组元素<code>arr[i]</code> 放在数组<code>tmp</code>的第<code>count[arr[i]]</code>个位置(下标为<code>count[arr[i]]-1</code>)，每放一个元素就将<code>count[arr[i]]</code>递减，可以确保计数排序的稳定性；</strong></li>
</ul>
<p>看一个例子<br><img src="https://img-blog.csdn.net/20180405170000881?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>填充过程：</p>
<p><img src="images/15_%E8%AE%A1%E6%95%B01.png" alt="这里写图片描述"></p>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 计数排序   count 统计数组， tmp 目标填充数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> RANGE)</span> </span>&#123; <span class="comment">/**数组中最大的元素不能超过 RANGE*/</span></span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[RANGE + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">        count[arr[i]]++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**现在的count[i]表示小于i的数有count[i]个，排序后元素i就放在第C[i]个输出位置上*/</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= RANGE; i++)</span><br><span class="line">        count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 从后向前扫描保证计数排序的稳定性(重复元素相对次序不变)</span></span><br><span class="line"><span class="comment">         * 当再遇到重复元素时会被放在当前元素的前一个位置上保证计数排序的稳定性</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        tmp[--count[arr[i]]] = arr[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝回原来的数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">        arr[i] = tmp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color = red>可以看一个简单的关于计数排序的一个<a href="https://blog.csdn.net/zxzxzx0119/article/details/82715141">练习题LeetCode75-Sort Colors</a></font>。</p>
<hr>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a><font color = red id = "11">基数排序</h2><p>基数排序是按照不同的位数，或者优先级来排列某个元素，其中利用到了计数排序: </p>
<blockquote>
<p> 基数排序分为两种模式:</p>
<p>Least significant digit (LSD)</p>
<p>短的关键字被认为是小的，排在前面，然后相同长度的关键字再按照词典顺序或者数字大小等进行排序。比如<code>1，2，3，4，5，6，7，8，9，10，11</code>或者<code>&quot;b, c, d, e, f, g, h, i, j, b, a&quot;</code> 。</p>
<p>Most significance digit (MSD)<br>直接按照字典的顺序进行排序，对于字符串、单词或者是长度固定的整数排序比较合适。比如: <code>1, 10, 2, 3, 4, 5, 6, 7, 8, 9</code>和 <code>&quot;b, ba, c, d, e, f, g, h, i, j&quot;</code>。</p>
<p>假设我们有一些二元组<code>(a,b)</code>，要对它们进行以a为首要关键字，b的次要关键字的排序。</p>
<p>我们可以先把它们先按照首要关键字排序，分成首要关键字相同的若干堆。然后，在按照次要关键值分别对每一堆进行单独排序。最后再把这些堆连到一起，使首要关键字较小的-堆排在上面。按这种方式的基数排序称为MSD(Most Significant Dight)排序。</p>
<p>第二种方式是从最低有效关键字开始排序，称为LSD(Least Significant Dight)排序。首先对所有的数据按照次要关键字排序，然后对所有的数据按照首要关键字排序。要注意的是，使用的排序算法必须是稳定的，否则就会取消前一次排序的结果。由于不需要分堆对每堆单独排序，LSD方法往往比MSD简单而开销小。</p>
</blockquote>
<p>下面的方式是基于LSD的。 </p>
<p>LSD模式: </p>
<ul>
<li>基数排序将所有待比较正整数统一为同样的数位长度，<strong>数位较短的数前面补零；</strong></li>
<li>然后，从最低位开始进行基数为<code>10</code>的计数排序，一直到最高位计数排序完后，数列就变成一个有序序列（利用了计数排序的稳定性）；</li>
</ul>
<p>看下图例子，对<code>&#123; 329, 457, 657, 839, 436, 720, 355 &#125;</code>进行基数排序：</p>
<p><img src="images/16_%E5%9F%BA%E6%95%B0.png" alt="这里写图片描述"></p>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将整形数按照每位(从低到高)拆分，然后从低位(个位)到高位依次比较各个位，得到所在的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//dn表示最大的数的位数 3位的话只能表示到999</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> dn = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得元素x的第d位数字</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDigit</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] radix = &#123;<span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>&#125;; <span class="comment">//这里只排序总共有三位数,分别代表 个位，十位，百位</span></span><br><span class="line">    <span class="keyword">return</span> (num / radix[d]) % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据数组arr中每个元素 的第d位数,来对整个arr数组排序</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lsdRadixSortInfo</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];      <span class="comment">//  单独考虑每一个位的时候， 数字都是从[0~9]</span></span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">        count[getDigit(arr[i], d)]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) count[i] += count[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> digit = getDigit(arr[i], d);  <span class="comment">//元素arr[i]当前 的d位的数字为dight</span></span><br><span class="line">        tmp[--count[digit]] = arr[i];    <span class="comment">//根据当前位数字digit来排序，把每个元素A[i]放到它在输出数组B中的正确位置上</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) arr[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lsdRadixSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; dn; d++) <span class="comment">//从低位(个位)到高位 按照每一位排序</span></span><br><span class="line">        lsdRadixSortInfo(arr, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者另一种写法: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++)</span><br><span class="line">        max = arr[i] &gt; max ? arr[i] : max;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lsdRadixProcess</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> exp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">        count[(arr[i] / exp) % <span class="number">10</span>]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) count[i] += count[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        tmp[--count[(arr[i] / exp) % <span class="number">10</span>]] = arr[i];    <span class="comment">//根据当前位数字digit来排序，把每个元素A[i]放到它在输出数组B中的正确位置上</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) arr[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lsdRadixSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = getMax(arr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> exp = <span class="number">1</span>; max / exp &gt; <span class="number">0</span>; exp *= <span class="number">10</span>) <span class="comment">//从低位到高位</span></span><br><span class="line">        lsdRadixProcess(arr, exp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a><font color = red id = "12">桶排序</h2><p>桶排序的原理可以分为一下三个步骤：</p>
<ul>
<li><p>扫描序列，根据每个元素的值所属的区间(可以设置一个映射函数)，放入指定的桶中(顺序放置)；</p>
</li>
<li><p>对每个桶中的元素进行排序，(使用其它排序算法或以递归方式继续使用桶排序）；</p>
</li>
</ul>
<p>看下面对<code>&#123; 29, 25, 3, 49, 9, 37, 21, 43 &#125;</code>进行桶排序；</p>
<p><img src="images/17_%E6%A1%B6.png" alt="这里写图片描述"></p>
<p>因为每个桶各自的容量可能不同，所以也可以使用链表来储存，但是空间复杂度高；</p>
<p>下面的代码: </p>
<ul>
<li>主要是<font color =red>利用计数排序找到每个桶的起始下标和终止下标，然后对每个桶进行系统的排序；</li>
<li><code>mapToBucket()</code>采用的是<code> / bucketNum</code>(桶的个数) 的操作，如果对<code>0 ~ 99</code>排序就设置桶的个数为<code>10</code>个，如果是<code>0~999</code>就设置为<code>100</code>个…..；</li>
</ul>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> bucketNum = <span class="number">100</span>; <span class="comment">//桶的个数 0 ～ 9号桶</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//桶排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mapToBucket</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;   <span class="comment">// 映射函数f(x)</span></span><br><span class="line">    <span class="keyword">return</span> x / bucketNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[bucketNum];  <span class="comment">// 计数数组，存放桶的边界信息</span></span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)  <span class="comment">//count[i]保存着i号桶中元素的个数</span></span><br><span class="line">        count[mapToBucket(arr[i])]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; bucketNum; i++)  <span class="comment">// 定位桶边界初始时，count[i]-1(下标从0开始)为i号桶最后一个元素的位置</span></span><br><span class="line">        count[i] += count[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//count[0]~count[9]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        tmp[--count[mapToBucket(arr[i])]] = arr[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">        arr[i] = tmp[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用计数排序确定各个桶的边界（分桶）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> L = count[i];     <span class="comment">//count[i]为i号桶第一个元素的位置</span></span><br><span class="line">        <span class="keyword">int</span> R = (i == bucketNum - <span class="number">1</span> ? arr.length - <span class="number">1</span> : count[i + <span class="number">1</span>] - <span class="number">1</span>); <span class="comment">//count[i+1]-1为i号桶最后一个元素的位置</span></span><br><span class="line">        <span class="comment">//for(int j = L; j &lt;= R; j++)System.out.print( arr[j] + &quot; &quot;); System.out.println();  //print</span></span><br><span class="line">        <span class="keyword">if</span> (L &lt; R)  <span class="comment">//对每个桶里面进行排序</span></span><br><span class="line">            Arrays.sort(arr, L, R + <span class="number">1</span>);<span class="comment">//注意这里是R+1，系统库的sort的右边界是开区间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a><font color = red id = "13">测试代码</h2><p>上述排序都是用下面的程序测试的: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000</span>];</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">            arr[i] = random.nextInt(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//原数组</span></span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        bubbleSort(arr);</span></span><br><span class="line"><span class="comment">//        cocktailSort(arr);</span></span><br><span class="line"><span class="comment">//        selectSort(arr);</span></span><br><span class="line"><span class="comment">//        insertSort(arr);</span></span><br><span class="line"><span class="comment">//        insertSort2(arr);</span></span><br><span class="line"><span class="comment">//        insertSort3(arr);</span></span><br><span class="line"><span class="comment">//        shellSort(arr);</span></span><br><span class="line"><span class="comment">//        shellSort2(arr);</span></span><br><span class="line"><span class="comment">//        quickSort(arr);</span></span><br><span class="line"><span class="comment">//        heapSort(arr);</span></span><br><span class="line"><span class="comment">//        heapSort2(arr);</span></span><br><span class="line"><span class="comment">//        countSort(arr,1000);</span></span><br><span class="line"><span class="comment">//        lsdRadixSort(arr);</span></span><br><span class="line"><span class="comment">//        lsdRadixSort2(arr);</span></span><br><span class="line">        bucketSort(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//test</span></span><br><span class="line">        <span class="keyword">boolean</span> good = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt; arr[i-<span class="number">1</span>])&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;bad!&quot;</span>);</span><br><span class="line">                System.out.println(arr[i-<span class="number">1</span>] + <span class="string">&quot; &quot;</span> + arr[i]);</span><br><span class="line">                good = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(good)System.out.println(<span class="string">&quot;good!&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="附C-部分代码"><a href="#附C-部分代码" class="headerlink" title="附C++部分代码"></a>附C++部分代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SortTestHelper&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> *<span class="title">generateRandomArray</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> *arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            arr[i] = <span class="built_in">rand</span>() % (R - L + <span class="number">1</span>) + L;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> *<span class="title">generateNearlyOrderedArray</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> swapTimes)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> *arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; swapTimes; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> posx = <span class="built_in">rand</span>() % n;</span><br><span class="line">            <span class="keyword">int</span> posy = <span class="built_in">rand</span>() % n;</span><br><span class="line">            std::<span class="built_in">swap</span>(arr[posx], arr[posy]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> *<span class="title">copyArray</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> *arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            arr[i] = a[i];</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSorted</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testSort</span><span class="params">(<span class="keyword">const</span> std::string &amp;sortName, <span class="keyword">void</span> (*sort)(T[], <span class="keyword">int</span>), T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">clock_t</span> startTime = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="built_in">sort</span>(arr, n);</span><br><span class="line">        <span class="keyword">clock_t</span> endTime = <span class="built_in">clock</span>();</span><br><span class="line">        std::cout &lt;&lt; sortName &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">double</span></span>(endTime - startTime)/CLOCKS_PER_SEC &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="built_in">isSorted</span>(arr, n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> end = n<span class="number">-1</span>; end &gt; <span class="number">0</span>; end--)&#123; <span class="comment">// n-1次</span></span><br><span class="line">        <span class="keyword">int</span> border = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; end; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[i+<span class="number">1</span>])&#123;</span><br><span class="line">                std::<span class="built_in">swap</span>(arr[i], arr[i+<span class="number">1</span>]);</span><br><span class="line">                border = i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        end = border; <span class="comment">// 下一次只交换到这里</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;</span><br><span class="line">        std::<span class="built_in">swap</span>(arr[minIndex], arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[i]; j--) <span class="comment">//find the insert position,  notice init j = i is wrong  </span></span><br><span class="line">            arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort2</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j<span class="number">-1</span>]; j--)</span><br><span class="line">            std::<span class="built_in">swap</span>(arr[j], arr[j<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> __merge(T arr[], <span class="keyword">int</span> L, <span class="keyword">int</span> mid, <span class="keyword">int</span> R)&#123;</span><br><span class="line">    T* help = <span class="keyword">new</span> T[R-L+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> p1 = L, p2 = mid + <span class="number">1</span>, k = <span class="number">0</span>; <span class="comment">// note p1 = 0</span></span><br><span class="line">    <span class="keyword">while</span>(p1 &lt;= mid &amp;&amp; p2 &lt;= R)</span><br><span class="line">        help[k++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    <span class="keyword">while</span>(p1 &lt;= mid)</span><br><span class="line">        help[k++] = arr[p1++];</span><br><span class="line">    <span class="keyword">while</span>(p2 &lt;= R)</span><br><span class="line">        help[k++] = arr[p2++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) </span><br><span class="line">        arr[i+L] = help[i];</span><br><span class="line">    <span class="keyword">delete</span>[] help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> __mergeSort(T arr[], <span class="keyword">int</span> L, <span class="keyword">int</span> R)&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &gt;= R)</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// int mid = L + (R-L)/2;</span></span><br><span class="line">    <span class="keyword">int</span> mid = (L+R)/<span class="number">2</span>;</span><br><span class="line">    __mergeSort(arr, L, mid);</span><br><span class="line">    __mergeSort(arr, mid+<span class="number">1</span>, R);</span><br><span class="line">    <span class="keyword">if</span>(arr[mid] &gt; arr[mid+<span class="number">1</span>])  <span class="comment">// optimize</span></span><br><span class="line">        __merge(arr, L, mid, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    __mergeSort(arr, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSortBU</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt;= n; sz += sz)&#123; <span class="comment">// 区间的个数，1..2..4..8</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i+sz &lt; n; i += sz+sz)&#123;  <span class="comment">// 对[i...i+sz-1]和[i+sz...i+2*sz-1]内归并</span></span><br><span class="line">            __merge(arr, i, i+sz<span class="number">-1</span>, std::<span class="built_in">min</span>(n<span class="number">-1</span>, i+sz+sz<span class="number">-1</span>)); <span class="comment">// min防止越界</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对arr[l...r]部分进行partition操作</span></span><br><span class="line"><span class="comment">// 返回p, 使得arr[l...p-1] &lt; arr[p] ; arr[p+1...r] &gt; arr[p]</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> __partition1(T arr[], <span class="keyword">int</span> L, <span class="keyword">int</span> R)&#123;</span><br><span class="line">    std::<span class="built_in">swap</span>( arr[L] , arr[<span class="built_in">rand</span>()%(R-L+<span class="number">1</span>)+L] );<span class="comment">// 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot</span></span><br><span class="line">    T key = arr[L];</span><br><span class="line">    <span class="keyword">int</span> pivot = L;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = L+<span class="number">1</span> ; i &lt;= R; i++)</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; key)</span><br><span class="line">            std::<span class="built_in">swap</span>(arr[++pivot] , arr[i]);</span><br><span class="line">    std::<span class="built_in">swap</span>( arr[L] , arr[pivot]);</span><br><span class="line">    <span class="keyword">return</span> pivot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> __quickSort1(T arr[], <span class="keyword">int</span> L, <span class="keyword">int</span> R)&#123;</span><br><span class="line">    <span class="keyword">if</span>( L &gt;= R )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> p = __partition1(arr, L, R);</span><br><span class="line">    __quickSort1(arr, L, p<span class="number">-1</span> );</span><br><span class="line">    __quickSort1(arr, p+<span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort1</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>)); <span class="comment">// 设置随机种子</span></span><br><span class="line">    __quickSort1(arr, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> __partition2(T arr[], <span class="keyword">int</span> L, <span class="keyword">int</span> R)&#123;</span><br><span class="line">    std::<span class="built_in">swap</span>( arr[L] , arr[<span class="built_in">rand</span>()%(R-L+<span class="number">1</span>)+L] );<span class="comment">// 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot</span></span><br><span class="line">    T key = arr[L];</span><br><span class="line">    <span class="keyword">int</span> less = L+<span class="number">1</span>, more = R;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(less &lt; R &amp;&amp; arr[less] &lt; key) less++;</span><br><span class="line">        <span class="keyword">while</span>(more &gt; L &amp;&amp; arr[more] &gt; key) more--;</span><br><span class="line">        <span class="keyword">if</span>(less &gt;= more)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        std::<span class="built_in">swap</span>(arr[less++], arr[more--]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">swap</span>(arr[L], arr[more]);</span><br><span class="line">    <span class="keyword">return</span> more;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> __quickSort2(T arr[], <span class="keyword">int</span> L, <span class="keyword">int</span> R)&#123;</span><br><span class="line">    <span class="keyword">if</span>( L &gt;= R )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> p = __partition2(arr, L, R);</span><br><span class="line">    __quickSort2(arr, L, p<span class="number">-1</span> );</span><br><span class="line">    __quickSort2(arr, p+<span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort2</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>)); <span class="comment">// 设置随机种子</span></span><br><span class="line">    __quickSort2(arr, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span>* __partition3(T arr[], <span class="keyword">int</span> L, <span class="keyword">int</span> R)&#123;</span><br><span class="line">    std::<span class="built_in">swap</span>( arr[L] , arr[<span class="built_in">rand</span>()%(R-L+<span class="number">1</span>)+L] );<span class="comment">// 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot</span></span><br><span class="line">    T key = arr[L]; <span class="comment">// 将arr[L]作为划分</span></span><br><span class="line">    <span class="keyword">int</span> cur = L+<span class="number">1</span>, less = L, more = R+<span class="number">1</span>; <span class="comment">// more 也可以写成R, 但是下面的程序要改</span></span><br><span class="line">    <span class="keyword">while</span>(cur &lt; more)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[cur] &lt; key)</span><br><span class="line">            std::<span class="built_in">swap</span>(arr[++less], arr[cur++]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(arr[cur] &gt; key)</span><br><span class="line">            std::<span class="built_in">swap</span>(arr[--more], arr[cur]); <span class="comment">// cur不能--</span></span><br><span class="line">        <span class="keyword">else</span>    </span><br><span class="line">            cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">swap</span>(arr[L], arr[less]);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>]&#123;less, more<span class="number">-1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> __quickSort3(T arr[], <span class="keyword">int</span> L, <span class="keyword">int</span> R)&#123;</span><br><span class="line">    <span class="keyword">if</span>( L &gt;= R )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span>* p = __partition3(arr, L, R);</span><br><span class="line">    __quickSort3(arr, L, p[<span class="number">0</span>]<span class="number">-1</span>);</span><br><span class="line">    __quickSort3(arr, p[<span class="number">1</span>]+<span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort3</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>)); <span class="comment">// 设置随机种子</span></span><br><span class="line">    __quickSort3(arr, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">2000</span>;</span><br><span class="line">    <span class="keyword">int</span> *arr1 = SortTestHelper::<span class="built_in">generateRandomArray</span>(n,<span class="number">0</span>,n);</span><br><span class="line">    <span class="comment">// SortTestHelper::testSort(&quot;BubbleSort&quot;, bubbleSort, arr1, n);</span></span><br><span class="line">    <span class="comment">// SortTestHelper::testSort(&quot;selectionSort&quot;, selectionSort, arr1, n);</span></span><br><span class="line">    <span class="comment">// SortTestHelper::testSort(&quot;insertSort&quot;, insertSort, arr1, n);</span></span><br><span class="line">    <span class="comment">// SortTestHelper::testSort(&quot;insertSort2&quot;, insertSort2, arr1, n);</span></span><br><span class="line">    <span class="comment">// SortTestHelper::testSort(&quot;mergeSort&quot;, mergeSort, arr1, n);</span></span><br><span class="line">    <span class="comment">// SortTestHelper::testSort(&quot;mergeSortBU&quot;, mergeSortBU, arr1, n);</span></span><br><span class="line">    <span class="comment">// SortTestHelper::testSort(&quot;quickSort1&quot;, quickSort1, arr1, n);</span></span><br><span class="line">    <span class="comment">// SortTestHelper::testSort(&quot;quickSort2&quot;, quickSort2, arr1, n);</span></span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;quickSort3&quot;</span>, quickSort3, arr1, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树模板题(Kruskal算法和Prim算法实现)</title>
    <url>/2022/03/26/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E6%A8%A1%E6%9D%BF%E9%A2%98(Kruskal%E7%AE%97%E6%B3%95%E5%92%8CPrim%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0)/</url>
    <content><![CDATA[<h2 id="最小生成树模板题-Kruskal算法和Prim算法实现"><a href="#最小生成树模板题-Kruskal算法和Prim算法实现" class="headerlink" title="最小生成树模板题(Kruskal算法和Prim算法实现)"></a>最小生成树模板题(Kruskal算法和Prim算法实现)</h2><ul>
<li><code>Kruskal</code>算法思想及流程</li>
<li><code>Prim</code>算法思想及流程: </li>
</ul>
<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1863">题目链接</a></h4><blockquote>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1863">http://acm.hdu.edu.cn/showproblem.php?pid=1863</a></p>
</blockquote>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><img src="images/tree1.png"></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p> 就是一个求最小生成树的模板题(<font color = blue>一般是无向图</font>)。</p>
<hr>
<h3 id="Kruskal算法思想及流程"><a href="#Kruskal算法思想及流程" class="headerlink" title="Kruskal算法思想及流程"></a><code>Kruskal</code>算法思想及流程</h3><ul>
<li>首先各个顶点看成一个集合，每个顶点的根就是自己；</li>
<li>从整个图中边的集合中取出<strong>最小</strong>的一条(一开始对边的集合排序)，判断该边的两个定点是不是同一个集合，如果不是，<strong>合并两个集合；</strong></li>
<li>如果是同一个集合，舍弃，继续取下一条边；</li>
<li>直到集合中有<code>n - 1</code>条边为止；</li>
</ul>
<p><strong>时间复杂度为为<font color =red>O(e<sup>2</sup>)</font>, 使用并查集优化后复杂度为 <font color = red>O（eloge）</font>，与网中的边数有关，适用于求边稀疏的网的最小生成树</strong></p>
<p><img src="images/tree2.png" alt="这里写图片描述"></p>
<p><strong>推荐写法</strong> </p>
<ul>
<li>建图和上面稍有不同，<code>kruskal</code>的特性只需要用到<code>Edge</code>这个类即可，对边集排序然后不断合并两个顶点即可；</li>
<li>这里并查集使用的数组，和上面有点不同，但是原理都是一样的；<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;Edge&gt; edges;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Edge</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> from;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> to;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> w;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.from = from;</span><br><span class="line">            <span class="keyword">this</span>.to = to;</span><br><span class="line">            <span class="keyword">this</span>.w = w;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Edge o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> w - o.w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionSet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] rank;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnionSet</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">            rank = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                parent[i] = i;</span><br><span class="line">                rank[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameSet</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (parent[v] != v) &#123;</span><br><span class="line">                parent[v] = parent[parent[v]];  <span class="comment">// 路径压缩优化</span></span><br><span class="line">                v = parent[v];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> aRoot = find(a);</span><br><span class="line">            <span class="keyword">int</span> bRoot = find(b);</span><br><span class="line">            <span class="keyword">if</span> (aRoot == bRoot)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (rank[aRoot] &lt; rank[bRoot]) &#123; <span class="comment">// a更矮,所以挂到b更好</span></span><br><span class="line">                parent[aRoot] = bRoot;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[aRoot] &gt; rank[bRoot]) &#123;</span><br><span class="line">                parent[bRoot] = aRoot;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent[aRoot] = bRoot;</span><br><span class="line">                rank[bRoot]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Collections.sort(edges);  <span class="comment">// 对边集排序</span></span><br><span class="line">        UnionSet uset = <span class="keyword">new</span> UnionSet(n);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> from = edges.get(i).from;</span><br><span class="line">            <span class="keyword">int</span> to = edges.get(i).to;</span><br><span class="line">            <span class="keyword">int</span> w = edges.get(i).w;</span><br><span class="line">            <span class="keyword">if</span> (!uset.isSameSet(from, to)) &#123; <span class="comment">//两个顶点不属于同一个集合</span></span><br><span class="line">                res += w;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span> (count == n - <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                uset.union(from, to);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count == n - <span class="number">1</span> ? res : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line">        <span class="keyword">while</span> (cin.hasNext()) &#123;</span><br><span class="line">            m = cin.nextInt(); <span class="comment">// 先输入道路条数</span></span><br><span class="line">            n = cin.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (m == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            edges = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> from = cin.nextInt();</span><br><span class="line">                <span class="keyword">int</span> to = cin.nextInt();</span><br><span class="line">                <span class="keyword">int</span> w = cin.nextInt();</span><br><span class="line">                edges.add(<span class="keyword">new</span> Edge(from, to, w));</span><br><span class="line">                edges.add(<span class="keyword">new</span> Edge(to, from, w));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> res = kruskal();</span><br><span class="line">            System.out.println(res == -<span class="number">1</span> ? <span class="string">&quot;?&quot;</span> : res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其他写法。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; <span class="comment">//提交时改成Main</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        ArrayList&lt;Node&gt; nexts;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            nexts = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> weight;</span><br><span class="line">        <span class="keyword">public</span> Node from;</span><br><span class="line">        <span class="keyword">public</span> Node to;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(Node from, Node to, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.from = from;</span><br><span class="line">            <span class="keyword">this</span>.to = to;</span><br><span class="line">            <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> HashMap&lt;Integer, Node&gt; nodes;</span><br><span class="line">        <span class="keyword">public</span> HashSet&lt;Edge&gt; edges;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            nodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            edges = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//并查集结构</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionSet</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> HashMap&lt;Node, Node&gt; faMap;</span><br><span class="line">        <span class="keyword">public</span> HashMap&lt;Node, Integer&gt; sizeMap;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnionSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            faMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            sizeMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Collection&lt;Node&gt; nodes)</span> </span>&#123;</span><br><span class="line">            faMap.clear();</span><br><span class="line">            sizeMap.clear();</span><br><span class="line">            <span class="keyword">for</span> (Node node : nodes) &#123;</span><br><span class="line">                faMap.put(node, node);</span><br><span class="line">                sizeMap.put(node, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Node <span class="title">findHead</span><span class="params">(Node v)</span> </span>&#123;</span><br><span class="line">            Node fa = faMap.get(v);</span><br><span class="line">            <span class="keyword">if</span> (fa != v) &#123;</span><br><span class="line">                fa = findHead(fa);</span><br><span class="line">            &#125;</span><br><span class="line">            faMap.put(v, fa); <span class="comment">//v的父改为根(沿途所有的)</span></span><br><span class="line">            <span class="keyword">return</span> fa;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameSet</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> findHead(a) == findHead(b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">            Node aF = findHead(a);</span><br><span class="line">            Node bF = findHead(b);</span><br><span class="line">            <span class="keyword">if</span> (aF == bF) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">int</span> aSize = sizeMap.get(a);</span><br><span class="line">            <span class="keyword">int</span> bSize = sizeMap.get(b);</span><br><span class="line">            <span class="keyword">if</span> (aSize &gt;= bSize) &#123;</span><br><span class="line">                faMap.put(bF, aF); <span class="comment">//把bF挂到aF下面</span></span><br><span class="line">                sizeMap.put(aF, aSize + bSize);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                faMap.put(aF, bF); <span class="comment">//把aF挂到bF下面</span></span><br><span class="line">                sizeMap.put(bF, aSize + bSize);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在优先级队列中按照边的权值升序排列</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Edge</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Edge o1, Edge o2)</span> </span>&#123; <span class="comment">//按照边的权重升序排列</span></span><br><span class="line">            <span class="keyword">return</span> o1.weight - o2.weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Set&lt;Edge&gt; <span class="title">kruskal</span><span class="params">(Graph graph)</span> </span>&#123;</span><br><span class="line">        UnionSet unionSet = <span class="keyword">new</span> UnionSet();</span><br><span class="line">        unionSet.init(graph.nodes.values()); <span class="comment">//初始化</span></span><br><span class="line">        PriorityQueue&lt;Edge&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;Edge&gt;(<span class="keyword">new</span> EdgeComparator());</span><br><span class="line">        <span class="keyword">for</span> (Edge edge : graph.edges) &#123;</span><br><span class="line">            priorityQueue.add(edge);</span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;Edge&gt; set = <span class="keyword">new</span> HashSet&lt;Edge&gt;();  <span class="comment">//保存这n-1条边</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!priorityQueue.isEmpty()) &#123;</span><br><span class="line">            Edge poll = priorityQueue.poll();</span><br><span class="line">            <span class="keyword">if</span> (!unionSet.isSameSet(poll.from, poll.to)) &#123;</span><br><span class="line">                set.add(poll);</span><br><span class="line">                cnt++;</span><br><span class="line">                unionSet.union(poll.from, poll.to);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt == graph.nodes.size() - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> set;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line">        <span class="keyword">while</span> (cin.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> n = cin.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            Graph G = <span class="keyword">new</span> Graph();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) G.nodes.put(i, <span class="keyword">new</span> Node(i));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> from = cin.nextInt();</span><br><span class="line">                <span class="keyword">int</span> to = cin.nextInt();</span><br><span class="line">                <span class="keyword">int</span> w = cin.nextInt();</span><br><span class="line">                G.edges.add(<span class="keyword">new</span> Edge(G.nodes.get(from), G.nodes.get(to), w));</span><br><span class="line">            &#125;</span><br><span class="line">            Set&lt;Edge&gt; set = kruskal(G);</span><br><span class="line">            <span class="keyword">if</span> (set.size() != n - <span class="number">1</span>) &#123; <span class="comment">//没有n-1条边  不足以保持畅通</span></span><br><span class="line">                System.out.println(<span class="string">&quot;?&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (Edge edge : set) &#123;</span><br><span class="line">                    sum += edge.weight;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="Prim算法思想及流程"><a href="#Prim算法思想及流程" class="headerlink" title="Prim算法思想及流程:"></a><code>Prim</code>算法思想及流程:</h3><ul>
<li>一开始也有一个集合，和<code>Kruskal</code>算法不同的是，这个不是慢慢的合并(通过并查集)变大，而是一个一个的添加结点；</li>
<li>一开始选择一个起点，有一个<font color =  red>优先队列</font>存放边的集合，<strong>把这个结点相连的边加入优先队列</strong>；</li>
<li>然后选择一条相连的且<strong>权值最小</strong>的边，<strong>并判断这条边的终点是否已经加入过点的集合(<font color = red>准确的来说是看这两个点相连的边是否已经加入过集合(但是这里是用两个端点都是否进过<code>vis</code>数组替代)</font>)，如果没有，就加入，并且把这条边加入到结果集，并且解锁和它相连的边(解锁就是把边加入到优先队列)</strong></li>
<li>如果出现过，<font color = blue>继续从优先队列中拿出最小的边判断</font>；</li>
<li>直到结果集达到<code>n-1</code>条边，或者图不连通；</li>
</ul>
<p><img src="images/tree3.png" alt="这里写图片描述"></p>
<p><strong>推荐写法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span>[] vis;</span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;Edge&gt;[] G;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Edge</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> to;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> w;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.to = to;</span><br><span class="line">            <span class="keyword">this</span>.w = w;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Edge o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> w - o.w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Edge&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[start].size(); i++)</span><br><span class="line">            pq.add(G[start].get(i));</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        vis[start] = <span class="keyword">true</span>; <span class="comment">// 起始节点已经在集合中</span></span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            Edge curEdge = pq.poll();</span><br><span class="line">            <span class="keyword">int</span> to = curEdge.to;</span><br><span class="line">            <span class="keyword">if</span> (!vis[to]) &#123;</span><br><span class="line">                vis[to] = <span class="keyword">true</span>;</span><br><span class="line">                count++;</span><br><span class="line">                res += curEdge.w;</span><br><span class="line">                <span class="keyword">if</span> (count == n - <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[to].size(); i++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> nxtNode = G[to].get(i).to;</span><br><span class="line">                    <span class="keyword">if</span> (!vis[nxtNode]) <span class="comment">// to -&gt; nxtNode 没有加入过</span></span><br><span class="line">                        pq.add(G[to].get(i)); <span class="comment">// 将to-&gt; nxtNode的边加入优先队列</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count != n - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line">        <span class="keyword">while</span> (cin.hasNext()) &#123;</span><br><span class="line">            m = cin.nextInt(); <span class="comment">// 先输入道路条数</span></span><br><span class="line">            n = cin.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (m == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            G = <span class="keyword">new</span> ArrayList[n + <span class="number">1</span>];  <span class="comment">// 1~n</span></span><br><span class="line">            vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                G[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> from = cin.nextInt();</span><br><span class="line">                <span class="keyword">int</span> to = cin.nextInt();</span><br><span class="line">                <span class="keyword">int</span> w = cin.nextInt();</span><br><span class="line">                G[from].add(<span class="keyword">new</span> Edge(to, w));</span><br><span class="line">                G[to].add(<span class="keyword">new</span> Edge(from, w));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> res = prim(<span class="number">1</span>);</span><br><span class="line">            System.out.println(res == -<span class="number">1</span> ? <span class="string">&quot;?&quot;</span> : res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其他写法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        ArrayList&lt;Edge&gt; edges; <span class="comment">//以这个点作为起点出发的边</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            edges = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> weight;</span><br><span class="line">        <span class="keyword">public</span> Node from;</span><br><span class="line">        <span class="keyword">public</span> Node to;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(Node from, Node to, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.from = from;</span><br><span class="line">            <span class="keyword">this</span>.to = to;</span><br><span class="line">            <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> HashMap&lt;Integer, Node&gt; nodes;</span><br><span class="line">        <span class="keyword">public</span> HashSet&lt;Edge&gt; edges;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            nodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            edges = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Edge</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Edge o1, Edge o2)</span> </span>&#123; <span class="comment">//按照边的权重升序排列</span></span><br><span class="line">            <span class="keyword">return</span> o1.weight - o2.weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Set&lt;Edge&gt; <span class="title">prim</span><span class="params">(Graph graph)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Edge&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> EdgeComparator());</span><br><span class="line">        HashSet&lt;Edge&gt; res = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        HashSet&lt;Node&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Node start = graph.nodes.get(<span class="number">1</span>); <span class="comment">//从第一个点开始</span></span><br><span class="line">        set.add(start);</span><br><span class="line">        <span class="keyword">for</span> (Edge edge : start.edges) &#123;</span><br><span class="line">            priorityQueue.add(edge);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!priorityQueue.isEmpty()) &#123;</span><br><span class="line">            Edge poll = priorityQueue.poll();</span><br><span class="line">            Node toNode = poll.to;   <span class="comment">//这条边的to点</span></span><br><span class="line">            <span class="keyword">if</span> (!set.contains(toNode)) &#123;</span><br><span class="line">                set.add(toNode);</span><br><span class="line">                res.add(poll);    <span class="comment">//注意这个不能放在if的上面</span></span><br><span class="line">                <span class="keyword">if</span> (res.size() == graph.nodes.size() - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">for</span> (Edge nextEdge : toNode.edges) &#123;</span><br><span class="line">                    priorityQueue.add(nextEdge);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Graph <span class="title">createGraph</span><span class="params">(Scanner in, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        Graph G = <span class="keyword">new</span> Graph();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) G.nodes.put(i, <span class="keyword">new</span> Node(i));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = in.nextInt();</span><br><span class="line">            <span class="keyword">int</span> b = in.nextInt();</span><br><span class="line">            <span class="keyword">int</span> w = in.nextInt();</span><br><span class="line">            Node from = G.nodes.get(a);</span><br><span class="line">            Node to = G.nodes.get(b);</span><br><span class="line">            Edge newEdge = <span class="keyword">new</span> Edge(from, to, w);</span><br><span class="line">            G.edges.add(newEdge);</span><br><span class="line">            from.edges.add(newEdge);  <span class="comment">//记得添加这条边</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> G;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line">        <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = in.nextInt();</span><br><span class="line">            <span class="keyword">int</span> n = in.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            Graph G = createGraph(in, n, m);</span><br><span class="line">            Set&lt;Edge&gt; set = prim(G);</span><br><span class="line">            <span class="keyword">if</span> (set.size() != n - <span class="number">1</span>) &#123; <span class="comment">//没有n-1条边  不足以保持畅通</span></span><br><span class="line">                System.out.println(<span class="string">&quot;?&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (Edge edge : set) &#123;</span><br><span class="line">                    sum += edge.weight;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Graph</tag>
        <tag>Kruskal</tag>
        <tag>Prim</tag>
      </tags>
  </entry>
  <entry>
    <title>图的基本结构以及BFS和DFS(递归和非递归)</title>
    <url>/2022/01/29/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8ABFS%E5%92%8CDFS(%E9%80%92%E5%BD%92%E5%92%8C%E9%9D%9E%E9%80%92%E5%BD%92)/</url>
    <content><![CDATA[<h2 id="图的基本结构以及BFS和DFS-递归和非递归"><a href="#图的基本结构以及BFS和DFS-递归和非递归" class="headerlink" title="图的基本结构以及BFS和DFS(递归和非递归)"></a>图的基本结构以及BFS和DFS(递归和非递归)</h2><ul>
<li>完整的图结构</li>
<li>有向图建图以及BFS和DFS</li>
<li>无向图建图以及BFS和DFS</li>
<li>DFS和BFS常见应用</li>
</ul>
<hr>
<h3 id="完整的图结构"><a href="#完整的图结构" class="headerlink" title="完整的图结构"></a>完整的图结构</h3><ul>
<li>图的每个顶点包括顶点的值、入度、出度、和<strong>它相邻的点(或者在有向图中就是下一个可以到达的点)的集合</strong>、以及<strong>以它为起点出发的边的集合；</strong></li>
<li>图的每条边包括边的权值、边的起点、边的终点；</li>
<li>一个图包括点的集合和边的集合；</li>
</ul>
<p>综上可以得到如下的图结构:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//点  (默认我是from的情况下)</span></span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">int</span> in; <span class="comment">//入度</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">int</span> out; <span class="comment">//出度</span></span><br><span class="line">       <span class="keyword">public</span> ArrayList&lt;Node&gt;nexts;<span class="comment">// 从我出发能到达的下一级结点，就是邻居结点  可以有多个(邻居)(跳一步)	</span></span><br><span class="line">       <span class="keyword">public</span> ArrayList&lt;Edge&gt;edges;<span class="comment">//我是from的情况下，从我出发，发散出边的集合</span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.value = value;</span><br><span class="line">           in = <span class="number">0</span>;</span><br><span class="line">           out = <span class="number">0</span>;</span><br><span class="line">           nexts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           edges = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//边</span></span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span></span>&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">int</span> weight;</span><br><span class="line">       <span class="keyword">public</span> Node from;</span><br><span class="line">       <span class="keyword">public</span> Node to;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">( Node from, Node to, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.from = from;</span><br><span class="line">           <span class="keyword">this</span>.to = to;</span><br><span class="line">           <span class="keyword">this</span>.weight = weight;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//图</span></span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span>&#123;</span><br><span class="line">       HashMap&lt;Integer,Node&gt;nodes; <span class="comment">// 点的编号,以及实际对应的node</span></span><br><span class="line">       HashSet&lt;Edge&gt;edges;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           nodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">           edges = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="有向图建图以及BFS和DFS"><a href="#有向图建图以及BFS和DFS" class="headerlink" title="有向图建图以及BFS和DFS"></a>有向图建图以及BFS和DFS</h3><p>这里使用一个二维矩阵来表示图(<strong>每一行都代表输入一条边</strong>)，第一列表示的是边的起点、第二列是边的终点、第三列是边的权值。如下例子: </p>
<p><img src="images/p1.png" alt="这里写图片描述"></p>
<p>使用上面的例子来建图并进行BFS(广度遍历)和DFS(深度遍历)的代码如下: (<strong>在遍历的过程中边的集合几乎用不到</strong>)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完整的图的结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//点</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> in; <span class="comment">//入度</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> out; <span class="comment">//出度</span></span><br><span class="line">        <span class="keyword">public</span> ArrayList&lt;Node&gt; nexts;</span><br><span class="line">        <span class="keyword">public</span> ArrayList&lt;Edge&gt; edges;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            in = <span class="number">0</span>;</span><br><span class="line">            out = <span class="number">0</span>;</span><br><span class="line">            nexts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            edges = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//边</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> weight;</span><br><span class="line">        <span class="keyword">public</span> Node from;</span><br><span class="line">        <span class="keyword">public</span> Node to;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(Node from, Node to, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.from = from;</span><br><span class="line">            <span class="keyword">this</span>.to = to;</span><br><span class="line">            <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//图</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Node&gt; nodes;</span><br><span class="line">        HashSet&lt;Edge&gt; edges;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            nodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            edges = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Graph <span class="title">createGraph</span><span class="params">(Integer[][] matrix)</span> </span>&#123;</span><br><span class="line">        Graph graph = <span class="keyword">new</span> Graph();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            Integer from = matrix[i][<span class="number">0</span>];</span><br><span class="line">            Integer to = matrix[i][<span class="number">1</span>];</span><br><span class="line">            Integer weight = matrix[i][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!graph.nodes.containsKey(from)) graph.nodes.put(from, <span class="keyword">new</span> Node(from));</span><br><span class="line">            <span class="keyword">if</span> (!graph.nodes.containsKey(to)) graph.nodes.put(to, <span class="keyword">new</span> Node(to));</span><br><span class="line"></span><br><span class="line">            Node fromNode = graph.nodes.get(from);</span><br><span class="line">            Node toNode = graph.nodes.get(to);</span><br><span class="line"></span><br><span class="line">            fromNode.nexts.add(toNode);<span class="comment">//有向图</span></span><br><span class="line">            fromNode.out++;</span><br><span class="line">            toNode.in++;</span><br><span class="line"></span><br><span class="line">            Edge newEdge = <span class="keyword">new</span> Edge(fromNode, toNode, weight);</span><br><span class="line">            fromNode.edges.add(newEdge);</span><br><span class="line">            graph.edges.add(newEdge);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> graph;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        Queue&lt;Node&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        HashSet&lt;Node&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">//相当于记录是否访问过</span></span><br><span class="line">        que.add(node);</span><br><span class="line">        set.add(node);</span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            Node cur = que.poll();</span><br><span class="line">            System.out.print(cur.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Node next : cur.nexts) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!set.contains(next)) &#123;</span><br><span class="line">                    set.add(next);</span><br><span class="line">                    que.add(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归的</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(Node node, HashSet&lt;Node&gt; set)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        set.add(node);</span><br><span class="line">        System.out.print(node.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Node next : node.nexts) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(next)) dfs1(next, set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非递归的</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        HashSet&lt;Node&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        stack.push(node);</span><br><span class="line">        System.out.print(node.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        set.add(node);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            Node cur = stack.pop();</span><br><span class="line">            <span class="keyword">for</span> (Node next : cur.nexts) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!set.contains(next)) &#123;</span><br><span class="line">                    stack.push(cur); <span class="comment">//注意这个也要入栈</span></span><br><span class="line">                    stack.push(next);</span><br><span class="line">                    set.add(next);</span><br><span class="line">                    System.out.print(next.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每一列分别代表的是    边的 起点,终点,和权值</span></span><br><span class="line">        Integer[][] martix = &#123;</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;,</span><br><span class="line">                &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>&#125;,</span><br><span class="line">                &#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>&#125;,</span><br><span class="line">                &#123;<span class="number">2</span>, <span class="number">8</span>, <span class="number">2</span>&#125;,</span><br><span class="line">                &#123;<span class="number">3</span>, <span class="number">7</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;,</span><br><span class="line">                &#123;<span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">        Graph G = createGraph(martix);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------BFS-----------&quot;</span>);</span><br><span class="line">        bfs(G.nodes.get(<span class="number">1</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;----------DFS-----------&quot;</span>);</span><br><span class="line">        dfs1(G.nodes.get(<span class="number">1</span>), <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;----------DFS-----------&quot;</span>);</span><br><span class="line">        dfs2(G.nodes.get(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>BFS就是按照到起点的距离(按层次)遍历; </li>
<li>DFS就是只要某个结点可以往下走，就一直走下去(一条路走到黑)，走不了了再回溯回来;</li>
<li>其中非递归的DFS使用栈完成，注意，<strong>访问某个结点的<code>next</code>结点集合的时候，只访问一个，然后结点本身还是要先入栈;</strong> </li>
<li>BFS和DFS都要记录某个结点是否已经被访问过; </li>
</ul>
<p>上面例子的遍历结果: </p>
<p><img src="images/p2.png" alt="这里写图片描述"></p>
<hr>
<h3 id="无向图建图以及BFS和DFS"><a href="#无向图建图以及BFS和DFS" class="headerlink" title="无向图建图以及BFS和DFS"></a>无向图建图以及BFS和DFS</h3><p>无向图和有向图的区别就是<strong>度没有出度和入度之分，结点的<code>nexts</code>域、和结点相邻的边集要相互的添加</strong>；<br>看下图的例子: </p>
<p><img src="images/p3.png" alt="这里写图片描述"></p>
<p>建图以及BFS和DFS遍历如下: (这里省去了边的集合)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无向图BFS和DFS</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BFS_DFS</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> ArrayList&lt;Node&gt; nexts;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            nexts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Node&gt; nodes;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            nodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建一个无向图</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line">        <span class="keyword">while</span> (cin.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> m = cin.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            Graph G = <span class="keyword">new</span> Graph();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> a = cin.nextInt();</span><br><span class="line">                <span class="keyword">int</span> b = cin.nextInt();</span><br><span class="line">                <span class="keyword">if</span> (!G.nodes.containsKey(a)) G.nodes.put(a, <span class="keyword">new</span> Node(a));</span><br><span class="line">                <span class="keyword">if</span> (!G.nodes.containsKey(b)) G.nodes.put(b, <span class="keyword">new</span> Node(b));</span><br><span class="line">                Node from = G.nodes.get(a);</span><br><span class="line">                Node to = G.nodes.get(b);</span><br><span class="line">                from.nexts.add(to);</span><br><span class="line">                to.nexts.add(from); <span class="comment">//无向图</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;---------------BFS----------------&quot;</span>);</span><br><span class="line">            bfs(G.nodes.get(<span class="number">1</span>)); <span class="comment">// 从某个结点开始BFS遍历</span></span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(<span class="string">&quot;---------------DFS----------------&quot;</span>);</span><br><span class="line">            dfs1(G.nodes.get(<span class="number">1</span>), <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(<span class="string">&quot;---------------DFS----------------&quot;</span>);</span><br><span class="line">            dfs2(G.nodes.get(<span class="number">1</span>));</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Queue&lt;Node&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        HashSet&lt;Node&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">//相当于记录是否访问过</span></span><br><span class="line">        que.add(node);</span><br><span class="line">        set.add(node);</span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            Node cur = que.poll();</span><br><span class="line">            System.out.print(cur.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Node next : cur.nexts) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!set.contains(next)) &#123;</span><br><span class="line">                    set.add(next);</span><br><span class="line">                    que.add(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归的</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(Node node, HashSet&lt;Node&gt; set)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        set.add(node);</span><br><span class="line">        System.out.print(node.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Node next : node.nexts) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(next)) dfs1(next, set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非递归的</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        HashSet&lt;Node&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        stack.push(node);</span><br><span class="line">        System.out.print(node.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        set.add(node);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            Node cur = stack.pop();</span><br><span class="line">            <span class="keyword">for</span> (Node next : cur.nexts) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!set.contains(next)) &#123;</span><br><span class="line">                    stack.push(cur); <span class="comment">//注意这个也要入栈</span></span><br><span class="line">                    stack.push(next);</span><br><span class="line">                    set.add(next);</span><br><span class="line">                    System.out.print(next.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历结果</p>
<p><img src="images/p4.png" alt="这里写图片描述"></p>
<hr>
<h3 id="DFS和BFS常见应用"><a href="#DFS和BFS常见应用" class="headerlink" title="DFS和BFS常见应用"></a>DFS和BFS常见应用</h3><p><code>DFS</code> :  求一个图的连通分量以及判断两个点是否可通，以及求出任意一条路径；<br><code>DFS</code>：求最短路径；</p>
<p>代码：（未测试）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无权图</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseGraph</span> </span>&#123; <span class="comment">// 稀疏图</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> n; <span class="comment">// vertex num</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> m; <span class="comment">// edge num</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> directed; <span class="comment">// is a directed graph</span></span><br><span class="line">        <span class="keyword">public</span> ArrayList&lt;Integer&gt;[] g;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">boolean</span> directed)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.n = n;</span><br><span class="line">            <span class="keyword">this</span>.m = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">this</span>.directed = directed;</span><br><span class="line">            g = <span class="keyword">new</span> ArrayList[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                g[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">            g[from].add(to);</span><br><span class="line">            <span class="keyword">if</span> (from != to &amp;&amp; !directed) <span class="comment">// 自环, 无向图</span></span><br><span class="line">                g[to].add(from);</span><br><span class="line">            m++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// from to is connected</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">hasEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[from].size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[from].get(i) == to)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求一个图的连通分量以及　判断两个点是否可通</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Graph G;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span>[] vis;  <span class="comment">// 记录dfs的过程中节点是否被访问</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] id;        <span class="comment">// 每个节点所对应的联通分量标记</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Component</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.G = G;</span><br><span class="line">            vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.n];</span><br><span class="line">            id = <span class="keyword">new</span> <span class="keyword">int</span>[G.n];</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.n; i++) &#123;</span><br><span class="line">                vis[i] = <span class="keyword">false</span>;</span><br><span class="line">                id[i] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回连通分量</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.n; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G.g[i].size(); j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!vis[j])&#123;</span><br><span class="line">                        dfs(j);</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">            vis[v] = <span class="keyword">true</span>;</span><br><span class="line">            id[v] = count; <span class="comment">// 当前节点在第count个连通分量</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.g[v].size(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!vis[i])</span><br><span class="line">                    dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> id[i] == id[j]; <span class="comment">// 判断两个点所属连通分量是不是同一个</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用dfs获取路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Path</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Graph G;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span>[] vis;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] pre; <span class="comment">// 记录路径, pre[i]表示查找的路径上i的上一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Path</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.G = G;</span><br><span class="line">            vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.n];</span><br><span class="line">            pre = <span class="keyword">new</span> <span class="keyword">int</span>[G.n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.n; i++)&#123;</span><br><span class="line">                vis[i] = <span class="keyword">false</span>;</span><br><span class="line">                pre[i] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">            vis[v] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.g[i].size(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">                    pre[i] = v; <span class="comment">// is important</span></span><br><span class="line">                    dfs(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">getPath</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">            dfs(start);</span><br><span class="line">            <span class="keyword">if</span>(!vis[end])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// no path</span></span><br><span class="line">            Stack&lt;Integer&gt;stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> p = end;</span><br><span class="line">            <span class="keyword">while</span>(p != -<span class="number">1</span>)&#123;</span><br><span class="line">                stack.push(p);</span><br><span class="line">                p = pre[p];</span><br><span class="line">            &#125;</span><br><span class="line">            ArrayList&lt;Integer&gt;res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty())</span><br><span class="line">                res.add(stack.pop());</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用BFS求最短路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortestPath</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Graph G;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span>[] vis;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] pre;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ShortestPath</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.G = G;</span><br><span class="line">            vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.n];</span><br><span class="line">            pre = <span class="keyword">new</span> <span class="keyword">int</span>[G.n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.n; i++)&#123;</span><br><span class="line">                vis[i] = <span class="keyword">false</span>;</span><br><span class="line">                pre[i] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取从s到所有顶点的最短路径</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] getShortestPath(<span class="keyword">int</span> start)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[G.n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.n; i++) dist[i] = -<span class="number">1</span>;</span><br><span class="line">            Queue&lt;Integer&gt;queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            queue.add(start);</span><br><span class="line">            vis[start] = <span class="keyword">true</span>;</span><br><span class="line">            dist[start] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">int</span> cur = queue.poll();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.g[cur].size(); i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">                        queue.add(i);</span><br><span class="line">                        vis[i] = <span class="keyword">true</span>;</span><br><span class="line">                        pre[i] = cur;</span><br><span class="line">                        dist[i] = dist[cur]+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">            vis[v] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.g[i].size(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">                    pre[i] = v; <span class="comment">// is important</span></span><br><span class="line">                    dfs(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">getPath</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">            dfs(start);</span><br><span class="line">            <span class="keyword">if</span>(!vis[end])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// no path</span></span><br><span class="line">            Stack&lt;Integer&gt;stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> p = end;</span><br><span class="line">            <span class="keyword">while</span>(p != -<span class="number">1</span>)&#123;</span><br><span class="line">                stack.push(p);</span><br><span class="line">                p = pre[p];</span><br><span class="line">            &#125;</span><br><span class="line">            ArrayList&lt;Integer&gt;res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty())</span><br><span class="line">                res.add(stack.pop());</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Graph</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>最长公共子序列LCS 和 最长公众子串</title>
    <url>/2022/01/15/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97LCS%20%E5%92%8C%20%E6%9C%80%E9%95%BF%E5%85%AC%E4%BC%97%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="最长公共子序列LCS-和-最长公众子串"><a href="#最长公共子序列LCS-和-最长公众子串" class="headerlink" title="最长公共子序列LCS 和 最长公众子串"></a>最长公共子序列LCS 和 最长公众子串</h2><ul>
<li><a href="#51nod-1006-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97lcs">51Nod-1006-最长公共子序列LCS</a></li>
<li><a href="#%E6%9C%80%E9%95%BF%E5%85%AC%E4%BC%97%E5%AD%90%E4%B8%B2">最长公众子串</a></li>
</ul>
<hr>
<h3 id="51Nod-1006-最长公共子序列LCS"><a href="#51Nod-1006-最长公共子序列LCS" class="headerlink" title="51Nod-1006-最长公共子序列LCS"></a><font color =red id = "1">51Nod-1006-最长公共子序列LCS</h3><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="http://www.51nod.com/Challenge/Problem.html#!#problemId=1006">题目链接</a></h4><blockquote>
<p><a href="http://www.51nod.com/Challenge/Problem.html#!#problemId=1006">http://www.51nod.com/Challenge/Problem.html#!#problemId=1006</a></p>
</blockquote>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>就是输入两个字符串<code>str1</code>、<code>str2</code>，输出任意一个最长公共子序列。</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p><code>dp[i][j]</code>代表的是 : 必须以<code>str1[i]</code>、<code>str2[j]</code>结尾的最长公共子序列，<code>dp[i][j]</code>来源: </p>
<ul>
<li>可能是<code>dp[i-1][j]</code>，代表<code>str1[0~i-1]</code>与<code>str2[0~j]</code>的最长公共子序列。</li>
<li>可能是<code>dp[i][j-1]</code>，代表<code>str1[0~i]</code>与<code>str2[0~j-1]</code>的最长公共子序列。</li>
<li>如果<code>str1[i] == str2[j]</code>，还可能是<code>dp[i-1][j-1] + 1</code>。</li>
</ul>
<p>这三种情况中取最大值。</p>
<p><img src="images/dp1.png" alt="在这里插入图片描述"></p>
<p>构造结果的过程(利用<code>dp</code>数组即可)</p>
<ul>
<li>从矩阵的右下角开始，有三种移动方式: <font color = blue>向上、向左、向左上。</font></li>
<li>如果<code>dp[i][j] &gt; dp[i-1][j] &amp;&amp; dp[i][j] &gt; dp[i][j-1]</code>，说明之前在计算<code>dp[i][j]</code>的时候，一定是选择了<code>dp[i-1][j-1]+1</code>，所以可以确定<code>str1[i] = str2[j]</code>，并且这个字符一定输入最长公共子序列，把这个字符放进结果字符串，然后向左上方移动；</li>
<li>如果<code>dp[i][j] == dp[i-1][j]</code>，说明之前计算<code>dp[i][j]</code>的时候，<code>dp[i-1][j-1]+1</code>不是必须的选择，向 <font color = blue>上方</fonT>移动即可；</li>
<li> 如果<code>dp[i][j] == dp[i][j-1]</code>，向 <font color = blue>左方</fonT>移动即可；</li>
<li>如果<code>dp[i][j]</code>同时等于<code>dp[i-1][j]</code>和<code>dp[i][j-1]</code>，向上向左都可以，选择一个即可，不会错过必须选择的字符；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** dp[i][j]代表的是 str[0..i]与str[0...j]的最长公共子序列*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] getDp(<span class="keyword">char</span>[] sa,<span class="keyword">char</span>[] sb)&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[sa.length][sb.length];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = sa[<span class="number">0</span>] == sb[<span class="number">0</span>] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sa.length; i++)  <span class="comment">// 一旦dp[i][0]被设置成1,则dp[i~N-1][0]都为1</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>], sa[i] == sb[<span class="number">0</span>] ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; sb.length; j++)</span><br><span class="line">            dp[<span class="number">0</span>][j] = Math.max(dp[<span class="number">0</span>][j-<span class="number">1</span>], sb[j] == sa[<span class="number">0</span>] ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sa.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; sb.length; j++)&#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(sa[i] == sb[j])&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j],dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** 求出最长公共子序列*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getLCS</span><span class="params">(String sa, String sb, <span class="keyword">int</span>[][] dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sa == <span class="keyword">null</span> || sb == <span class="keyword">null</span> || sa.equals(<span class="string">&quot;&quot;</span>) || sb.equals(<span class="string">&quot;&quot;</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chs1 = sa.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] chs2 = sb.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> i = chs1.length - <span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">int</span> j = chs2.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>[] res = <span class="keyword">new</span> <span class="keyword">char</span>[dp[i][j]]; <span class="comment">//生成答案的数组</span></span><br><span class="line">        <span class="keyword">int</span> index = dp[i][j] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(index &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; dp[i][j] == dp[i-<span class="number">1</span>][j])&#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j &gt; <span class="number">0</span> &amp;&amp; dp[i][j] == dp[i][j-<span class="number">1</span>])&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">// dp[i][j] = dp[i-1][j-1]+1</span></span><br><span class="line">                res[index--] = chs1[i];</span><br><span class="line">                i--;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line">        String sa = cin.next();</span><br><span class="line">        String sb = cin.next();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = getDp(sa.toCharArray(), sb.toCharArray());</span><br><span class="line"><span class="comment">//        System.out.println(dp[sa.length()-1][sb.length()-1]); //length of lcs</span></span><br><span class="line">        System.out.println(getLCS(sa, sb, dp));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="最长公众子串"><a href="#最长公众子串" class="headerlink" title="最长公众子串"></a><font color =red id = "2">最长公众子串</h3><h4 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a><a href="https://www.nowcoder.com/questionTerminal/02e7cc263f8a49e8b1e1dc9c116f7602?toCommentId=1532408">题目链接</a></h4><blockquote>
<p><a href="https://www.nowcoder.com/questionTerminal/02e7cc263f8a49e8b1e1dc9c116f7602?toCommentId=1532408">https://www.nowcoder.com/questionTerminal/02e7cc263f8a49e8b1e1dc9c116f7602?toCommentId=1532408</a></p>
</blockquote>
<h4 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h4><ul>
<li><code>dp</code>矩阵第一列即<code>dp[0~N-1][0]</code>，对某一个位置<code>(i,0)</code>来说，如果<code>str1[i] == str2[0]</code>，令<code>dp[i][0] = 1</code>，否则令<code>dp[i][0] = 0</code>；</li>
<li>矩阵<code>dp</code>第一行，即<code>dp[0][0~M-1]</code>，对某个位置<code>(0,j)</code>来说，如果<code>str1[0] == str2[j]</code>，令<code>dp[0][j] = 1</code>，否则令<code>dp[0][j] = 0</code>；</li>
<li>一般的位置有两种情况，如果<code>str1[i] != str2[j]</code>，说明在必须把<code>str1[i]</code>和<code>str2[j]</code>当做公共子串最后一个字符是不可能的，所以<code>dp[i][j] = 0</code>； 如果<code>str1[i] = str2[j]</code>，说明可以将<code>str1[i]</code>和<code>str2[j]</code>作为公共子串的最后一个字符，其长度就是<code>dp[i-1][j-1] + 1</code>；</li>
</ul>
<p><img src="images/dp2.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestSubstring</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLongest</span><span class="params">(String A, <span class="keyword">int</span> n, String B, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] sa = A.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] sb = B.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[sa.length][sb.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sa.length; i++) <span class="comment">//注意和最长公共子序列有点不同</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = sa[i] == sb[<span class="number">0</span>] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sb.length; j++)</span><br><span class="line">            dp[<span class="number">0</span>][j] = sa[<span class="number">0</span>] == sb[j] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sa.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; sb.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(sa[i] == sb[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    res = Math.max(res, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;  <span class="comment">//dp数组中的最大值，就是最大公共字串的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由<code>dp</code>表生成答案字符串也是不难的，找到最大值，然后往左边的<code>res</code>个字符就是答案。</p>
<p>测试程序: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LCSub</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] getDp(<span class="keyword">char</span>[] sa,<span class="keyword">char</span>[] sb)&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[sa.length][sb.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sa.length; i++) <span class="comment">//注意和最长公共子序列有点不同</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = sa[i] == sb[<span class="number">0</span>] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sb.length; j++)</span><br><span class="line">            dp[<span class="number">0</span>][j] = sa[<span class="number">0</span>] == sb[j] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sa.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; sb.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(sa[i] == sb[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    res = Math.max(res, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);  <span class="comment">//4</span></span><br><span class="line">        <span class="keyword">return</span> dp;  <span class="comment">//dp数组中的最大值，就是最大公共字串的长度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 根据dp表得到答案*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getLongestSubstring</span><span class="params">(String sa, String sb, <span class="keyword">int</span>[][] dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sa == <span class="keyword">null</span> || sb == <span class="keyword">null</span> || sa.length() == <span class="number">0</span> || sb.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dp[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &gt; max)&#123;</span><br><span class="line">                    max = dp[i][j];</span><br><span class="line">                    end = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sa.substring(end - max + <span class="number">1</span>, end+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String sa = <span class="string">&quot;abcdefq&quot;</span>;</span><br><span class="line">        String sb = <span class="string">&quot;cdefab&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = getDp(sa.toCharArray(), sb.toCharArray()); </span><br><span class="line">        System.out.println(getLongestSubstring(sa, sb, dp)); <span class="comment">// cdef</span></span><br><span class="line">        System.out.println(getLongestSubstring(sa, sb, dp).length()); <span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>另外，还有一种可以优化空间的做法:</p>
<ul>
<li>因为<code>dp[i][j]</code>只依赖于左上角位置的<code>dp[i-1][j-1]</code>，所以用一个变量记录左上角的值即可。</li>
<li>遍历方向从右上角的斜线开始，一直遍历到左下角，中间记录最大值<code>max</code>和结束位置<code>end</code>即可。<br><img src="images/dp3.png" alt="在这里插入图片描述"></li>
</ul>
<p>代码如下: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getLongestSubstring2</span><span class="params">(String sa,String sb)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sa == <span class="keyword">null</span> || sb == <span class="keyword">null</span> || sa.length() == <span class="number">0</span> || sb.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span>[] chs1 = sa.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] chs2 = sb.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>, col = chs2.length-<span class="number">1</span>; <span class="comment">//从右上角开始</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>, end = <span class="number">0</span>; <span class="comment">//记录最大长度和结束位置</span></span><br><span class="line">    <span class="keyword">while</span>(row &lt; chs1.length)&#123;</span><br><span class="line">        <span class="keyword">int</span> i = row, j = col;</span><br><span class="line">        <span class="keyword">int</span> ul = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; chs1.length &amp;&amp; j &lt; chs2.length)&#123; <span class="comment">//从(i,j)向右下方开始遍历</span></span><br><span class="line">            <span class="keyword">if</span>(chs1[i] == chs2[j])</span><br><span class="line">                ul++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ul = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(ul &gt; max)&#123; <span class="comment">//记录最大值以及结尾字符的位置</span></span><br><span class="line">                max = ul;</span><br><span class="line">                end = i;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(col &gt; <span class="number">0</span>) <span class="comment">// 斜线还没到最左边 --&gt;　往左移动</span></span><br><span class="line">            col--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            row++;  <span class="comment">//到了最左  --&gt; 往下移动</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(max);</span><br><span class="line">    <span class="keyword">return</span> sa.substring(end-max+<span class="number">1</span>, end+<span class="number">1</span>); <span class="comment">// [end-max+1, end]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵相关操作和矩阵快速幂</title>
    <url>/2022/05/06/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E5%92%8C%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    <content><![CDATA[<h2 id="矩阵相关操作和矩阵快速幂"><a href="#矩阵相关操作和矩阵快速幂" class="headerlink" title="矩阵相关操作和矩阵快速幂"></a>矩阵相关操作和矩阵快速幂</h2><ul>
<li>矩阵基本运算以及快速幂模板</li>
<li>POJ - 3070. Fibonacci</li>
<li>Hdu - 1757A. Simple Math Problem</li>
<li>Codeforces - 185A. Plant</li>
</ul>
<hr>
<h3 id="矩阵基本运算以及快速幂模板"><a href="#矩阵基本运算以及快速幂模板" class="headerlink" title="矩阵基本运算以及快速幂模板"></a>矩阵基本运算以及快速幂模板</h3><p>先看一下矩阵的乘法规则: </p>
<p><img src="images/m1.png" alt="在这里插入图片描述"></p>
<h5 id="直接给出一个模板题，直接包含了基本的乘法和求幂，求幂的详细解释，可以看这篇乘法快速幂。"><a href="#直接给出一个模板题，直接包含了基本的乘法和求幂，求幂的详细解释，可以看这篇乘法快速幂。" class="headerlink" title="直接给出一个模板题，直接包含了基本的乘法和求幂，求幂的详细解释，可以看这篇乘法快速幂。"></a><font color = red>直接给出一个模板题，直接包含了基本的乘法和求幂，求幂的详细解释，可以看这篇<a href="https://blog.csdn.net/zxzxzx0119/article/details/82816131">乘法快速幂</a>。</font></h5><h4 id="题目来源-XYNU-OJ"><a href="#题目来源-XYNU-OJ" class="headerlink" title="题目来源: XYNU OJ"></a>题目来源: XYNU OJ</h4><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><img src="images/m2.png" alt="在这里插入图片描述"></p>
<p>注意: </p>
<ul>
<li>矩阵的乘法必须满足第一个矩阵的列 = 第二个矩阵的行；</li>
<li>矩阵的求幂必须满足矩阵是一个方阵；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> row;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> col;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[][] m;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Matrix</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.row = row;</span><br><span class="line">            <span class="keyword">this</span>.col = col;</span><br><span class="line">            m = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个矩阵相加  --&gt;  a,b必须为 同型矩阵</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Matrix <span class="title">add</span><span class="params">(Matrix a, Matrix b)</span> </span>&#123;</span><br><span class="line">        Matrix c = <span class="keyword">new</span> Matrix(a.row, a.col);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.col; j++) &#123;</span><br><span class="line">                c.m[i][j] = a.m[i][j] + b.m[i][j]; <span class="comment">// sub 减法换成-</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须满足a.col = b.row  才能相乘</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Matrix <span class="title">mul</span><span class="params">(Matrix a, Matrix b)</span> </span>&#123;</span><br><span class="line">        Matrix c = <span class="keyword">new</span> Matrix(a.row, b.col); <span class="comment">//注意这里</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.col; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; a.col; k++)</span><br><span class="line">                    c.m[i][j] = c.m[i][j] + a.m[i][k] * b.m[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须为 方阵才能 求幂</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Matrix <span class="title">pow</span><span class="params">(Matrix a, <span class="keyword">int</span> k)</span> </span>&#123; <span class="comment">// 矩阵 a 的 k次幂</span></span><br><span class="line">        Matrix res = <span class="keyword">new</span> Matrix(a.row, a.col);  <span class="comment">//求幂必须满足 a.row = a.col(也就是方阵)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.row; i++)</span><br><span class="line">            res.m[i][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 真正的快速幂</span></span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((k &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">                res = mul(res, a);</span><br><span class="line">            a = mul(a, a);</span><br><span class="line">            k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = cin.nextInt();</span><br><span class="line">        <span class="keyword">int</span> k = cin.nextInt();</span><br><span class="line"></span><br><span class="line">        Matrix a = <span class="keyword">new</span> Matrix(n, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                a.m[i][j] = cin.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Matrix res = pow(a, k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == n - <span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.println(res.m[i][j]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.print(res.m[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="POJ-3070-Fibonacci"><a href="#POJ-3070-Fibonacci" class="headerlink" title="POJ - 3070. Fibonacci"></a>POJ - 3070. Fibonacci</h3><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="http://poj.org/problem?id=3070">题目链接</a></h4><blockquote>
<p><a href="http://poj.org/problem?id=3070">http://poj.org/problem?id=3070</a></p>
</blockquote>
<h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p><img src="images/m3.png" alt="在这里插入图片描述"></p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>关键在于推导出递推式，也就是左边是一个<code>A</code>矩阵，<code>B</code>一般是一个列向量；<br><img src="images/m4.png" alt="在这里插入图片描述"></p>
<p>类似的规律: </p>
<p><img src="images/m5.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Matrix</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> row;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> col;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[][] m;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Matrix</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.row = row;</span><br><span class="line">            <span class="keyword">this</span>.col = col;</span><br><span class="line">            m = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> mod = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Matrix <span class="title">mul</span><span class="params">(Matrix a,Matrix b)</span></span>&#123;</span><br><span class="line">        Matrix c = <span class="keyword">new</span> Matrix(a.row,b.col); <span class="comment">//注意这里</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.col; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; a.col; k++)</span><br><span class="line">                    c.m[i][j] = (c.m[i][j] + a.m[i][k]*b.m[k][j]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Matrix <span class="title">pow</span><span class="params">(Matrix a,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        Matrix res = <span class="keyword">new</span> Matrix(a.row,a.col); <span class="comment">// 方阵</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.row; i++)</span><br><span class="line">            res.m[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (k&amp;<span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">                res = mul(res,a);</span><br><span class="line">            a = mul(a,a);</span><br><span class="line">            k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cin.hasNext())&#123;</span><br><span class="line">            <span class="keyword">int</span> n = cin.nextInt();</span><br><span class="line">            <span class="keyword">if</span>( n == -<span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Matrix a = <span class="keyword">new</span> Matrix(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">            a.m[<span class="number">0</span>][<span class="number">0</span>] = a.m[<span class="number">0</span>][<span class="number">1</span>] = a.m[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            a.m[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            Matrix res = pow(a,n-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(res.m[<span class="number">0</span>][<span class="number">0</span>] % mod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Hdu-1757A-Simple-Math-Problem"><a href="#Hdu-1757A-Simple-Math-Problem" class="headerlink" title="Hdu - 1757A. Simple Math Problem"></a>Hdu - 1757A. Simple Math Problem</h3><h4 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1757">题目链接</a></h4><blockquote>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1757">http://acm.hdu.edu.cn/showproblem.php?pid=1757</a></p>
</blockquote>
<h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p><img src="images/m6.png" alt="在这里插入图片描述"></p>
<h4 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h4><p><img src="images/m7.png" alt="在这里插入图片描述"><br>继续递推: </p>
<p><img src="images/m8.png" alt="这里写图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Matrix</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> row;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> col;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[][] m;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Matrix</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.row = row;</span><br><span class="line">            <span class="keyword">this</span>.col = col;</span><br><span class="line">            m = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Matrix <span class="title">mul</span><span class="params">(Matrix a,Matrix b,<span class="keyword">int</span> mod)</span></span>&#123;</span><br><span class="line">        Matrix c = <span class="keyword">new</span> Matrix(a.row,b.col); <span class="comment">//注意这里</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.col; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; a.col; k++)</span><br><span class="line">                    c.m[i][j] = (c.m[i][j] + a.m[i][k]*b.m[k][j]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Matrix <span class="title">pow</span><span class="params">(Matrix a,<span class="keyword">int</span> k,<span class="keyword">int</span> mod)</span></span>&#123;</span><br><span class="line">        Matrix res = <span class="keyword">new</span> Matrix(a.row,a.col); <span class="comment">// 方阵</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.row; i++)</span><br><span class="line">            res.m[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (k&amp;<span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">                res = mul(res,a,mod);</span><br><span class="line">            a = mul(a,a,mod);</span><br><span class="line">            k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cin.hasNext())&#123;</span><br><span class="line">            <span class="keyword">int</span> k = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> mod = cin.nextInt();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(k &lt; <span class="number">10</span>)&#123;</span><br><span class="line">                System.out.println(k);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Matrix a = <span class="keyword">new</span> Matrix(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">            <span class="comment">// init</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">                a.m[<span class="number">0</span>][i] = cin.nextInt();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">                a.m[i][i-<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// computer  matrix ^ (k-9)</span></span><br><span class="line">            Matrix res = pow(a,k-<span class="number">9</span>,mod);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">                sum += (res.m[<span class="number">0</span>][i] * (<span class="number">9</span> - i)) % mod;</span><br><span class="line"></span><br><span class="line">            System.out.println(sum % mod); <span class="comment">// also should mod</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Codeforces-185A-Plant"><a href="#Codeforces-185A-Plant" class="headerlink" title="Codeforces - 185A. Plant"></a>Codeforces - 185A. Plant</h3><h4 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a><a href="http://codeforces.com/problemset/problem/185/A">题目链接</a></h4><blockquote>
<p><a href="http://codeforces.com/problemset/problem/185/A">http://codeforces.com/problemset/problem/185/A</a></p>
</blockquote>
<h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p><img src="images/m9.png" alt="在这里插入图片描述"></p>
<p><img src="images/m10.png" alt="在这里插入图片描述"></p>
<h4 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h4><p><img src="images/m11.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> row;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> col;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">long</span>[][] m;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Matrix</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.row = row;</span><br><span class="line">            <span class="keyword">this</span>.col = col;</span><br><span class="line">            m = <span class="keyword">new</span> <span class="keyword">long</span>[row][col];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Matrix <span class="title">mul</span><span class="params">(Matrix a, Matrix b)</span> </span>&#123;</span><br><span class="line">        Matrix c = <span class="keyword">new</span> Matrix(a.row, b.col); <span class="comment">//注意这里</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.col; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; a.col; k++)</span><br><span class="line">                    c.m[i][j] = (c.m[i][j] + a.m[i][k] * b.m[k][j]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Matrix <span class="title">pow</span><span class="params">(Matrix a, <span class="keyword">long</span> k)</span> </span>&#123;</span><br><span class="line">        Matrix res = <span class="keyword">new</span> Matrix(a.row, a.col); <span class="comment">// 方阵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.row; i++)</span><br><span class="line">            res.m[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((k &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">                res = mul(res, a);</span><br><span class="line">            a = mul(a, a);</span><br><span class="line">            k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> n = cin.nextLong();</span><br><span class="line"></span><br><span class="line">        Matrix a = <span class="keyword">new</span> Matrix(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        a.m[<span class="number">0</span>][<span class="number">0</span>] = a.m[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">        a.m[<span class="number">0</span>][<span class="number">1</span>] = a.m[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        Matrix res = pow(a, n);</span><br><span class="line"></span><br><span class="line">        System.out.println(res.m[<span class="number">0</span>][<span class="number">0</span>] % mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>素数回文以及素数相关总结</title>
    <url>/2022/04/08/%E7%B4%A0%E6%95%B0%E5%9B%9E%E6%96%87%E4%BB%A5%E5%8F%8A%E7%B4%A0%E6%95%B0%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="素数回文以及素数相关总结"><a href="#素数回文以及素数相关总结" class="headerlink" title="素数回文以及素数相关总结"></a>素数回文以及素数相关总结</h2><ul>
<li>普通筛素数法</li>
<li>埃式筛法</li>
<li>优化筛法</li>
<li>整数分解(唯一分解定理)</li>
<li>约数枚举</li>
<li>Hdu - 1431. 素数回文</li>
</ul>
<hr>
<h3 id="普通筛素数法"><a href="#普通筛素数法" class="headerlink" title="普通筛素数法"></a>普通筛素数法</h3><p>这个也是普通的素数判定的方法，这个方法判定素数时间复杂度为<code>O (sqrt(n))。</code></p>
<p><img src="images/m19.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">sieve</span><span class="params">(<span class="keyword">boolean</span>[] is_prime, <span class="keyword">int</span> MAX)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; prime = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="keyword">false</span>; <span class="comment">// 01 不是素数</span></span><br><span class="line">    <span class="keyword">boolean</span> flag;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX; i++) &#123;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j * j &lt;= i; j++) &#123;<span class="comment">// 根号i的时间复杂度</span></span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                is_prime[i] = <span class="keyword">false</span>;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            prime.add(i);</span><br><span class="line">            is_prime[i] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="埃式筛法"><a href="#埃式筛法" class="headerlink" title="埃式筛法"></a>埃式筛法</h3><p><img src="images/m20.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//经典的埃式筛法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">sieve</span><span class="params">(<span class="keyword">boolean</span>[] is_prime, <span class="keyword">int</span> MAX)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; prime = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Arrays.fill(is_prime, <span class="keyword">true</span>);</span><br><span class="line">    is_prime[<span class="number">0</span>] = is_prime[<span class="number">0</span>] = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_prime[i]) &#123;</span><br><span class="line">            prime.add(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt;= MAX; j += i)</span><br><span class="line">                is_prime[j] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="优化筛法"><a href="#优化筛法" class="headerlink" title="优化筛法"></a>优化筛法</h3><ul>
<li><p>上面的方法还是有一些重复的计算，比如说在搞定素数<code>2</code>的时候，筛选掉<code>6 (2 + 2 + 2)</code>；而在搞定素数<code>3</code>的时候，也要筛选掉<code>6 (3 + 3)</code> ，所以此时重复筛选；</p>
</li>
<li><p>解决办法是 只筛选<font color = red>小于等于<code>i</code>的素数和<code>i</code>的乘积</font>，这样可以<font color = red>尽量的</font>的减少重复的筛选，也不会遗漏；</p>
<p><img src="images/m21.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//优化筛法</span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">sieve2</span><span class="params">(<span class="keyword">boolean</span>[] is_prime, <span class="keyword">int</span> MAX)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; prime = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Arrays.fill(is_prime, <span class="keyword">true</span>);</span><br><span class="line">    is_prime[<span class="number">0</span>] = is_prime[<span class="number">0</span>] = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_prime[i])</span><br><span class="line">            prime.add(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; prime.size() &amp;&amp; prime.get(j) &lt;= MAX / i; j++) &#123;<span class="comment">// MAX/i防止溢出</span></span><br><span class="line">            is_prime[prime.get(j) * i] = <span class="keyword">false</span>; <span class="comment">//筛掉  (小于等于i的素数 * i)  构成的合数</span></span><br><span class="line">            <span class="keyword">if</span> (i % prime.get(j) == <span class="number">0</span>) <span class="comment">//如果 i是 &lt; i的素数的倍数 就不用筛了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="整数分解-唯一分解定理"><a href="#整数分解-唯一分解定理" class="headerlink" title="整数分解(唯一分解定理)"></a>整数分解(唯一分解定理)</h3><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="https://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/1634.html">题目链接</a></h4><blockquote>
<p><a href="https://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/1634.html">https://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/1634.html</a></p>
</blockquote>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><img src="images/m22.png" alt="在这里插入图片描述"></p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p><img src="images/m23.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> MAX)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; prime = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span>[] is_prime = <span class="keyword">new</span> <span class="keyword">boolean</span>[MAX + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        Arrays.fill(is_prime, <span class="keyword">true</span>);</span><br><span class="line">        is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (is_prime[i]) &#123;</span><br><span class="line">                prime.add(i);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt;= MAX; j += i) &#123;</span><br><span class="line">                    is_prime[j] = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> T = cin.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (T-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = cin.nextInt();</span><br><span class="line"></span><br><span class="line">            ArrayList&lt;Integer&gt; prime = sieve(n);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> isFirst = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prime.size(); i++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> num = prime.get(i);</span><br><span class="line">                <span class="keyword">while</span> (n % num == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isFirst) &#123;</span><br><span class="line">                        System.out.print(num);</span><br><span class="line">                        isFirst = <span class="keyword">false</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span></span><br><span class="line">                        System.out.print(<span class="string">&quot;*&quot;</span> + num);</span><br><span class="line"></span><br><span class="line">                    n /= num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="约数枚举"><a href="#约数枚举" class="headerlink" title="约数枚举"></a>约数枚举</h3><p>就是得到某个数的约数，和普通筛法有点像: </p>
<p><img src="images/m19.png" alt="在这里插入图片描述"></p>
<p>这里把上面的整数分解的保存也贴在这个代码里面: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPrime</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//约数枚举</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">divisor</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n % i == <span class="number">0</span>)</span><br><span class="line">                res.add(i);</span><br><span class="line">            <span class="keyword">if</span>(i != n/i)</span><br><span class="line">                res.add(n/i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//整数分解</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> HashMap&lt;Integer,Integer&gt; <span class="title">prime_factor</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(n % i == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(i)) &#123;</span><br><span class="line">                    map.put(i, map.get(i) + <span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    map.put(i,<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                n /= i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n != <span class="number">1</span>)</span><br><span class="line">            map.put(n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(divisor(<span class="number">12</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----测试分解素因子(唯一分解定理)-----&quot;</span>);</span><br><span class="line">        HashMap&lt;Integer,Integer&gt;map = prime_factor(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Integer num : map.keySet())&#123;</span><br><span class="line">            System.out.println(num  + <span class="string">&quot; &quot;</span> + map.get(num));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果: </p>
<p><img src="images/m24.png" alt="在这里插入图片描述"></p>
<hr>
<h3 id="Hdu-1431-素数回文"><a href="#Hdu-1431-素数回文" class="headerlink" title="Hdu - 1431. 素数回文"></a>Hdu - 1431. 素数回文</h3><h4 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1431">题目链接</a></h4><blockquote>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1431">http://acm.hdu.edu.cn/showproblem.php?pid=1431</a></p>
</blockquote>
<h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p><img src="images/m25.png" alt="在这里插入图片描述"></p>
<h4 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h4><ul>
<li>先用素数筛法筛出<code>0~9989899</code>之间的素数，然后再遍历一遍，判断一下是不是回文，最后判断是不是在那个区间即可；</li>
<li>注意这里使用的三种筛法，第一种会超时，第二种和第三种可以通过；<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目链接:  http://acm.hdu.edu.cn/showproblem.php?pid=1431</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; <span class="comment">//提交时改成main</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 经典筛法，超时</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">primary</span><span class="params">(<span class="keyword">boolean</span>[] is_prime,<span class="keyword">int</span> MAX)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; prime = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="keyword">false</span>; <span class="comment">// 01 不是素数</span></span><br><span class="line">        <span class="keyword">boolean</span> flag;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX; i++)&#123; <span class="comment">//范围是1000 我筛选 0~2000内的素数</span></span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j * j &lt;= i; j++)&#123;<span class="comment">// 根号i的时间复杂度</span></span><br><span class="line">                <span class="keyword">if</span>(i % j == <span class="number">0</span>)&#123;</span><br><span class="line">                    is_prime[i] = <span class="keyword">false</span>;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                prime.add(i);</span><br><span class="line">                is_prime[i] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//经典的埃式筛法</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">sieve</span><span class="params">(<span class="keyword">boolean</span>[] is_prime,<span class="keyword">int</span> MAX)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; prime = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.fill(is_prime,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        is_prime[<span class="number">0</span>] = is_prime[<span class="number">0</span>] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(is_prime[i])&#123;</span><br><span class="line">                prime.add(i);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt;= MAX; j+=i)</span><br><span class="line">                    is_prime[j] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//优化筛法</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">sieve2</span><span class="params">(<span class="keyword">boolean</span>[] is_prime,<span class="keyword">int</span> MAX)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; prime = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.fill(is_prime,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        is_prime[<span class="number">0</span>] = is_prime[<span class="number">0</span>] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(is_prime[i])</span><br><span class="line">                prime.add(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; prime.size() &amp;&amp; prime.get(j) &lt;= MAX / i; j++) &#123;</span><br><span class="line">                is_prime[prime.get(j) * i] = <span class="keyword">false</span>; <span class="comment">//筛掉  (小于等于i的素数 * i)  构成的合数</span></span><br><span class="line">                <span class="keyword">if</span>(i % prime.get(j) == <span class="number">0</span>) <span class="comment">//如果 i是 &lt; i的素数的倍数 就不用筛了</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldNum = num;</span><br><span class="line">        <span class="keyword">int</span> newNum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//反过来计算</span></span><br><span class="line">        <span class="keyword">while</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            newNum = newNum * <span class="number">10</span> + num % <span class="number">10</span>;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newNum == oldNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> maxn = <span class="number">9989899</span>; <span class="comment">//题目中最大的回文素数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] is_prime = <span class="keyword">new</span> <span class="keyword">boolean</span>[maxn + <span class="number">1</span>];</span><br><span class="line"><span class="comment">//        primary(is_prime,maxn); //超时</span></span><br><span class="line"><span class="comment">//        sieve(is_prime,maxn); // ok</span></span><br><span class="line">        sieve2(is_prime,maxn); <span class="comment">// ok  fast</span></span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxn; i++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>(is_prime[i] &amp;&amp; isPalindrome(i))</span><br><span class="line">                res.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cin.hasNext())&#123;</span><br><span class="line">            <span class="keyword">int</span> a = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> b = cin.nextInt();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.size(); i++)&#123;</span><br><span class="line">                num = res.get(i);</span><br><span class="line">                <span class="keyword">if</span>(num &lt; a)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(num &gt; b)</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 直接退出</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    System.out.println(num);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络知识总结一计算机网络和协议(一)</title>
    <url>/2021/11/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%E4%B8%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8D%8F%E8%AE%AE(%E4%B8%80)/</url>
    <content><![CDATA[<h2 id="计算机网络知识总结一计算机网络和协议-一"><a href="#计算机网络知识总结一计算机网络和协议-一" class="headerlink" title="计算机网络知识总结一计算机网络和协议(一)"></a>计算机网络知识总结一计算机网络和协议(一)</h2><ul>
<li><a href="#%E4%BA%92%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0">互联网概述</a></li>
<li><a href="#%E4%BA%92%E8%81%94%E7%BD%91%E7%BB%84%E6%88%90">互联网组成</a></li>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87">计算机网络的性能指标</a></li>
<li><a href="#osi%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B%E4%BB%A5%E5%8F%8Atcpip%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE">OSI参考模型以及TCP/IP四层模型、五层协议</a></li>
<li><a href="#%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87">通信过程、数据传输、网络设备</a></li>
<li><a href="#%E5%B0%8F%E7%BB%93">小结</a></li>
</ul>
<hr>
<h3 id="互联网概述"><a href="#互联网概述" class="headerlink" title="互联网概述"></a>互联网概述</h3><ul>
<li>计算机网络: 由若干节点和连接这些节点的链路组成，网络中的节点可以是计算机、集线器、交换机、或路由器等；</li>
<li>网络之间可以通过路由器相互连接，这就构成了一个更大范围的计算机网路，这样的网路称为<font color = red>互连网</font>，因此互连网是<font color = red>网路的网路</font>；</li>
<li>因特网(互联网):  全球最大的特定互连网；</li>
</ul>
<p>注意以下两个意思相差很大的名词 <code>internet</code> 和 <code>Internet</code> [RFC 1208]:</p>
<ul>
<li><p>以小写字母 i 开始的 <code>internet</code> (互连网) 是一个通用名词，它泛指由多个计算机网络互连而成的计算机网络。在这些网络之间的通信协议〈即通信规则) 可以任意选择，不一定非要使用<code>TCP/IP</code> 协议；</p>
</li>
<li><p>以大写字母 I 开始的 <code>Internet</code> 〈互联网或因特网) 则是一个专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定互连网，它采用 <code>TCP/IP</code> 协议族作为通信的规则，且其前身是美国的 ARPANET；</p>
</li>
<li><p>可见，任意把几个计算机网络互连起来〈不管采用什么协议)，并能够相互通信，这样构成的是一个互连网(<code>internet</code>，而不是互联网(<code>Internet</code>)。</p>
</li>
</ul>
<p><img src="images/1_1.png" alt="在这里插入图片描述"></p>
<ul>
<li>路由器（Router），是连接因特网中各局域网、广域网的设备，它会根据信道的情况自动选择和设定路由，以最佳路径，按前后顺序发送信号。</li>
<li> 路由器是互联网络的枢纽，”交通警察”。**<font color = red>路由和交换机之间的主要区别就是交换机发生在OSI参考模型第二层（数据链路层），而路由发生在第三层，即网络层**。</font>这一区别决定了路由和交换机在移动信息的过程中需使用不同的控制信息，所以说两者实现各自功能的方式是不同的。</li>
<li>路由器（<code>Router</code>）又称网关设备（<code>Gateway</code>）是用于连接多个逻辑上分开的网络，所谓逻辑网络是代表一个单独的网络或者一个子网。当数据从一个子网传输到另一个子网时，可通过路由器的路由功能来完成。因此，路由器具有判断网络地址和选择IP路径的功能。</li>
<li><font color = red><strong>交换机是将不同IP地址的电脑连在一起，共享一根网线；路由器是将同一个IP给不同的电脑使用，就像一条大路分成很多条小路。一句话，路由器是接外网的，路由器是接内网的。(交换机没有开关，路由器有开关)</strong></font></li>
</ul>
<p><img src="images/1_2.png" alt="在这里插入图片描述"></p>
<hr>
<h3 id="互联网组成"><a href="#互联网组成" class="headerlink" title="互联网组成"></a>互联网组成</h3><p>基本组成:</p>
<ul>
<li>①边缘部分: 由所有连接在互联网上的主机组成，这部分是用户直接使用的，用来进行通信（传送数据，音频或视频）和资源共享；</li>
<li>②核心部分: 由大量网络和连接这些网络的<font color = red><strong>路由器</strong></font> 组成，这部分是为边缘部分提供服务的(提供连通性和交换)；</li>
</ul>
<p><img src="images/1_3.png" alt="在这里插入图片描述"></p>
<p>边缘部分的主机间的通信方式: </p>
<p><img src="images/1_4.png" alt="在这里插入图片描述"></p>
<p><strong>(1). 客户程序:</strong></p>
<ul>
<li>被用户调用后运行，在通信时主动向远地服务器发起通信(请求服务)。因此，客</li>
</ul>
<p>户程序必须知道服务器程序的地址。</p>
<ul>
<li>不需要特殊的硬件和很复杂的操作系统。</li>
</ul>
<p><strong>(2). 服务器程序:</strong></p>
<ul>
<li>是一种专门用来提供某种服务的程序，可同时处理多个远地或本地客户的请求。</li>
<li>系统启动后即自动调用并一直不断地运行着，被动地等待并接受来自各地的客户的</li>
</ul>
<p>通信请求。因此，服务器程序不需要知道客户程序的地址。</p>
<p><strong>客户与服务器的通信关系建立后，通信可以是双向的，客户和服务器都可发送和接收</strong></p>
<p><strong>数据。</strong></p>
<p><strong>网络的传输过程(从客户端和服务器的角度来看):</strong></p>
<p><img src="images/1_5.png" alt="在这里插入图片描述"></p>
<p><strong><font color = red>电路交换:</font></strong></p>
<p><img src="images/1_6.png" alt="在这里插入图片描述"></p>
<p> <strong><font color = red>分组交换: </font></strong></p>
<p><img src="images/1_7.png" alt="在这里插入图片描述"></p>
<p><strong>三种交换方式的比较</strong></p>
<p><img src="images/1_8.png" alt="在这里插入图片描述"></p>
<hr>
<h3 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h3><p><img src="images/1_9.png"></p>
<h5 id="速率"><a href="#速率" class="headerlink" title="速率"></a><font color = blue>速率</font></h5><ul>
<li>网络技术中的速率是指每秒钟传输的比特数量，称为数据率或比特率，速率的单位是<code>bit/s</code>，或<code>b/s</code>(比特每秒)；</li>
<li>速率较高时，就可以使用kb/s，Mb/s，Gb/s，Tb/s，人们现在所说的10M网速，其实是10Mb/s；</li>
<li>360等可以显示网速的软件，测试你电脑的那个网速，这里单位是<font color = red>B/秒，大写的B是字节(byte)，8bit = 1byte，也就是说如果测速为3.82MB/s，则下载速率为3.82 * 8Mb/s。</li>
</ul>
<h5 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a><font color = blue>带宽</font></h5><ul>
<li>带宽用来表示网络通信线路传输数据的能力(数字信道所能传送的最高数据率)，即最高速率；</li>
<li>比如说家里使用ADSL拨号，有4M带宽、8M带宽，这里说的带宽就是你访问Internet的最高带宽，你家里的带宽由电信运营商控制；</li>
</ul>
<h5 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a><font color = blue>吞吐量</font></h5><ul>
<li>吞吐量表示在单位时间内通过某个网络或接口的数据量，包括<font color = red>全部上传和下载的流量；</li>
<li>吞吐量受网络带宽或网络额定速率的限制，计算机的网卡如果连接交换机，网卡就可以工作在全双工模式，即能够同时接收和发送数据；如果计算机的网卡连接的是集线器，网卡就只能工作在半双工模式，即不能同时发送和接收数据；</li>
</ul>
<p><img src="images/1_10.png" alt="在这里插入图片描述"></p>
<h5 id="时延"><a href="#时延" class="headerlink" title=" 时延"></a><font color = blue> 时延</font></h5><ul>
<li>时延(delay)是指数据(一个数据包或bit)从网络的一段传送到另一端所需要的时间，是一个很重要的性能指标；</li>
<li>时延包括: 发送时延、传播时延、处理时延、排队时延；（数据在网络中经历的的总时延就是这四种时延的累加和）；</li>
</ul>
<h6 id="发送时延"><a href="#发送时延" class="headerlink" title="发送时延"></a><font color = green>发送时延</h6><p><img src="images/1_11.png" alt="在这里插入图片描述"></p>
<h6 id="传播时延"><a href="#传播时延" class="headerlink" title="传播时延"></a><font color = green>传播时延</h6><ul>
<li>传播时延是<font color = red>是电磁波在信道中传播一定的距离要花费的时间； </li>
</ul>
<p><img src="images/1_12.png" alt="在这里插入图片描述"></p>
<h6 id="排队时延和处理时延"><a href="#排队时延和处理时延" class="headerlink" title="排队时延和处理时延"></a><font color = green>排队时延和处理时延</h6><p><img src="images/1_13.png" alt="在这里插入图片描述"></p>
<h6 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a><font color = green>时延带宽积</h6><p><img src="images/1_14.png" alt="在这里插入图片描述"></p>
<h5 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a><font color = blue>往返时间</font></h5><p><strong>表示从发送端发送数据开始，到发送端接收到来自接收端的确认(发送端收到确认立即发送确认)，总共经历的时间；</strong></p>
<h5 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a><font color = blue>利用率</font></h5><p><img src="images/1_15.png" alt="在这里插入图片描述"></p>
<hr>
<h3 id="OSI参考模型以及TCP-IP四层模型、五层协议"><a href="#OSI参考模型以及TCP-IP四层模型、五层协议" class="headerlink" title="OSI参考模型以及TCP/IP四层模型、五层协议"></a>OSI参考模型以及TCP/IP四层模型、五层协议</h3><p><img src="images/1_16.png" alt="在这里插入图片描述"></p>
<p><img src="images/1_17.png" alt="在这里插入图片描述"></p>
<p><img src="images/1_18.png" alt="在这里插入图片描述"></p>
<p>TCP/IP只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p>
<p>TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p>
<p><img src="images/1_19.png" alt="在这里插入图片描述"></p>
<hr>
<h3 id="通信过程、数据传输、网络设备"><a href="#通信过程、数据传输、网络设备" class="headerlink" title="通信过程、数据传输、网络设备"></a>通信过程、数据传输、网络设备</h3><h4 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程:"></a><font color = blue>通信过程:</h4><p><img src="images/1_20.png" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>注意: MAC地址由48位二进制数组成，在Windows操作系统命令提示符下，    输入”ipconfig / all”能够看到计算机网卡的MAC地址，物理地址…. : C8-60-00-2E-6E-EB，这里显示的是十六进制表示的MAC地址，使用MA和MB代替MAC地址是为了简化说明。</strong></p>
</blockquote>
<p><strong><font color = red>解释:</font></strong> </p>
<p><img src="images/1_21.png"></p>
<p><img src="images/1_22.png"></p>
<p><img src="images/1_23.png"></p>
<blockquote>
<p>为什么计算机通信需要物理地址和IP地址?，物理地址决定了数据帧下一跳给谁，而 IP地址决定了数据包最终给谁。如果全球的计算机都使用集线器或交换机连接，就可以只使用 MAC 地址进行通信了。</p>
</blockquote>
<p><img src="images/1_24.png"></p>
<p><font color = green>通过本图也可以看出:</p>
<ul>
<li><strong>目标MAC地址决定了数据帧下一跳由哪个设备接收；</strong></li>
<li><strong>目标IP地址决定了数据包最终到达那个计算机；</strong></li>
<li><strong>不同的网络数据链路层使用不同的协议，帧格式也不相同，路由器在不同网络转发数据包，需要将数据包重新封装；</strong><h4 id="数据封装和解封-数据传输"><a href="#数据封装和解封-数据传输" class="headerlink" title="数据封装和解封(数据传输)"></a><font color = blue>数据封装和解封(数据传输)</h4><img src="images/1_25.png" alt="在这里插入图片描述"></li>
</ul>
<p><img src="images/1_26.png" alt="在这里插入图片描述"></p>
<p><img src="images/1_27.png" alt="在这里插入图片描述"></p>
<h4 id="网络设备"><a href="#网络设备" class="headerlink" title="网络设备"></a><font color = blue>网络设备</h4><p>现实中各个网络设备的样子: </p>
<p><img src="images/1_28.png" alt="在这里插入图片描述"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li><p>计算机网络〈可简称为网络) 把许多计算机连接在一起，而互连网则把许多网络连接在一起，是网络的网络。</p>
</li>
<li><p>以小写字母<code>i </code>开始的 <code>internet</code> 〈互连网) 是通用名词，它泛指由多个计算机网络互连而成的网络。在这些网络之间的通信协议〈即通信规则) 可以是任意的。</p>
</li>
<li><p> 以大写字母 <code>I </code>开始的 Internet (互联网) 是专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定互连网，并采用 TCP/P 协议族作为通信规则，且其前身是美国的 ARPANET。Internet 的推荐译名是“因特网” 但很少被使用。</p>
</li>
<li><p> 互联网现在采用存储转发的分组交换技术，以及三层 ISP 结构。</p>
</li>
<li><p>互联网按工作方式可划分为<strong>边缘部分与核心部分</strong>。<strong>主机在网络的边缘部分，其作用是进行信息处理。路由器在网络的核心部分，其作用是按存储转发方式进行分组交换。</strong></p>
</li>
<li><p> 计算机通信是计算机中的进程〈即运行着的程序) 之间的通信。<strong>计算机网络采用的通信方式是客户-服务器方式和对等连接方式 (P2P 方式)。</strong></p>
</li>
<li><p> 客户和服务器都是指通信中所涉及的应用进程。客户是服务请求方，服务器是服务 提供方。</p>
</li>
<li><p>按作用范围的不同，计算机网络分为广域网 WAN、城域网 MAN、局域网 LAN 和个人区域网 PAN。</p>
</li>
<li><p>计算机网络最常用的性能指标是: <strong>速率、带宽、吞吐量、时延〈发送时延、传播时延、处理时延、排队时延)、时延带宽积、往返时间和信道〈或网络》利用率。</strong></p>
</li>
<li><p>网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层及其协议的集合，称为网络的体系结构。</p>
</li>
<li><p>五层协议的体系结构由应用层、运输层、网络层〈或网际层)、数据链路层和物理层组成。<strong>运输层最重要的协议是 <code>TCP</code> 和 <code>UDP</code> 协议，而网络层最重要的协议是 <code>IP</code>协议。</strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Computer Network</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>TCP/IP</tag>
        <tag>OSI</tag>
      </tags>
  </entry>
  <entry>
    <title>Implement Trie (Prefix Tree)以及实现字典树(前缀树)</title>
    <url>/2022/11/07/Implement%20Trie%20(Prefix%20Tree)%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%AD%97%E5%85%B8%E6%A0%91(%E5%89%8D%E7%BC%80%E6%A0%91)/</url>
    <content><![CDATA[<h2 id="LeetCode-208-Implement-Trie-Prefix-Tree-以及实现字典树-前缀树"><a href="#LeetCode-208-Implement-Trie-Prefix-Tree-以及实现字典树-前缀树" class="headerlink" title="LeetCode - 208. Implement Trie (Prefix Tree)以及实现字典树(前缀树)"></a>LeetCode - 208. Implement Trie (Prefix Tree)以及实现字典树(前缀树)</h2><ul>
<li>基础知识和结构</li>
<li>字符串的插入</li>
<li> 统计某个字符串的数量 || 查询是否有某个字符串</li>
<li>统计以某个字符串为前缀的字符串数量  ||  是否有某个前缀</li>
<li>字符串的删除</li>
<li>完整测试代码</li>
<li>题目解析　</li>
<li>使用Map来保存next</li>
<li>更多字典树</li>
</ul>
<hr>
<h3 id="基础知识和结构"><a href="#基础知识和结构" class="headerlink" title="基础知识和结构"></a>基础知识和结构</h3><p><code>Map</code>和<code>Trie</code>的差别，关于映射集合等可以看<a href="https://blog.csdn.net/zxzxzx0119/article/details/79891408"><strong>这篇博客</strong></a>。</p>
<p><img src="images/t1.png" alt="在这里插入图片描述"></p>
<ul>
<li> <font color = red> <strong>字典树也叫做前缀树，可以存储一组元素(一般是字符串)，可以快速的查找某个字符串在树中的个数以及寻找以某个字符串为前缀的字符串的个数，先看下图为一些字符串插入到字典树中的情形。</strong></li>
</ul>
<p>字典树的存储结构: </p>
<ul>
<li><strong>首先字母是画在树的边上的；</strong></li>
<li><strong>而结点中的<code>path</code>代表的是经过这个结点的字母的次数；</strong></li>
<li><strong>为了方便前缀的计算，而<code>end</code>表示的是以这个结点结尾的字符串的数量，方便统计树中某个字符串的数量。</strong></li>
<li><strong>而<code>next</code>表示的是多个儿子结点，因为可以有大小写字母，所以我初始化为<code>52</code>(如果是小写字母的就为<code>26</code>)(也可以使用<code>Map</code>来存储)。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> path;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> end;</span><br><span class="line">        <span class="keyword">public</span> Node[] next;<span class="comment">//使用整数表示字符　c - &#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            path = <span class="number">0</span>;</span><br><span class="line">            end = <span class="number">0</span>;</span><br><span class="line">            next = <span class="keyword">new</span> Node[<span class="number">26</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如: 下面的这颗字典树: </p>
<p><img src="images/t2.png" alt="这里写图片描述"></p>
<p>再如:  <strong>树中有<code>&quot;abc&quot;,&quot;ab&quot;,&quot;ab&quot;,&quot;abd&quot;,&quot;bc&quot;,&quot;bd&quot;,&quot;cd&quot;,&quot;cde&quot;,&quot;ce&quot;</code>总共<code>9</code>个字符串。如下的结构:</strong> </p>
<p><img src="images/t3.png" alt="这里写图片描述"></p>
<hr>
<h3 id="字符串的插入"><a href="#字符串的插入" class="headerlink" title="字符串的插入"></a>字符串的插入</h3><ul>
<li>遍历每个字符，算出每个<code>字符-&#39;a&#39;</code>的值，表示的是在结点儿子中的位置；</li>
<li>一开始结点的儿子都是<code>null</code>(<code>nexts</code>数组结构)，如果对应的位置为<code>null</code>，创建即可，然后走向下一个结点，并维护<code>path</code>。</li>
<li>记得遍历完之后，最后一个结点的<code>end++</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入一个字符</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(word == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    Node cur = root;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">        index = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur.next[index] == <span class="keyword">null</span>)&#123; <span class="comment">//没有就新建</span></span><br><span class="line">            cur.next[index] = <span class="keyword">new</span> Node();</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next[index];</span><br><span class="line">        cur.path++; <span class="comment">//经过这里</span></span><br><span class="line">    &#125;</span><br><span class="line">    cur.end++;<span class="comment">//以这个结尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="统计某个字符串的数量-查询是否有某个字符串"><a href="#统计某个字符串的数量-查询是否有某个字符串" class="headerlink" title="统计某个字符串的数量 || 查询是否有某个字符串"></a>统计某个字符串的数量 || 查询是否有某个字符串</h3><ul>
<li>这个很简单，怎么插入的就怎么查找，如果查找到某个结点(数组还没有遍历完)，就找到<code>nexts[index]</code>为空，直接返回<code>0</code>就可以了；</li>
<li>否则遍历完之后，返回结点的<code>end</code>的值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//统计某个字符串的数量</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(word == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       Node cur = root;</span><br><span class="line">       <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">           index = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">           <span class="keyword">if</span>(cur.next[index] == <span class="keyword">null</span>)</span><br><span class="line">               <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">           cur = cur.next[index];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> cur.end;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//查询是否有某个字符串</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> count(word) &gt; <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="统计以某个字符串为前缀的字符串数量-是否有某个前缀"><a href="#统计以某个字符串为前缀的字符串数量-是否有某个前缀" class="headerlink" title="统计以某个字符串为前缀的字符串数量  ||  是否有某个前缀"></a>统计以某个字符串为前缀的字符串数量  ||  是否有某个前缀</h3><ul>
<li>这个和上面都是一个套路，遍历完之后，返回结点的<code>path</code>的值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prefixNum</span><span class="params">(String prefix)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(prefix == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       Node cur = root;</span><br><span class="line">       <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i++)&#123;</span><br><span class="line">           index = prefix.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">           <span class="keyword">if</span>(cur.next[index] == <span class="keyword">null</span>)</span><br><span class="line">               <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">           cur = cur.next[index];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> cur.path; <span class="comment">//返回这个经过的　　也就是以这个为前驱的</span></span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//是否有某个前缀(以某个字符串开头)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> prefixNum(prefix) &gt; <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="字符串的删除"><a href="#字符串的删除" class="headerlink" title="字符串的删除"></a>字符串的删除</h3><p>我们删除某个字符串的时候，不能直接删除，要看某个结点的<code>path</code>的值：</p>
<ul>
<li><strong>如果<code>path</code>是<code>1</code>，以后的所有结点都可以删除了(释放后面所有结点)；</strong></li>
</ul>
<p><img src="https://img-blog.csdn.net/20180908115347286?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<ul>
<li><strong>否则只是将结点的<code>path--</code>就可以了。</strong></li>
</ul>
<p><img src="https://img-blog.csdn.net/20180908115421994?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(word == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">if</span>(!search(word)) <span class="comment">//不包含这个字符串</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      Node cur = root;</span><br><span class="line">      <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">          index = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">          <span class="keyword">if</span>(--cur.next[index].path == <span class="number">0</span>)&#123;</span><br><span class="line">              cur.next[index] = <span class="keyword">null</span>; <span class="comment">//释放掉下面的这棵树</span></span><br><span class="line">              <span class="keyword">return</span> ;</span><br><span class="line">          &#125;</span><br><span class="line">          cur = cur.next[index];</span><br><span class="line">      &#125;</span><br><span class="line">      cur.end--; <span class="comment">//最后这个字符串也要--</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="完整测试代码"><a href="#完整测试代码" class="headerlink" title="完整测试代码"></a>完整测试代码</h3><p>上面图形的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> path;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> end;</span><br><span class="line">        <span class="keyword">public</span> Node[] next;<span class="comment">//使用整数表示字符　c - &#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            path = <span class="number">0</span>;</span><br><span class="line">            end = <span class="number">0</span>;</span><br><span class="line">            next = <span class="keyword">new</span> Node[<span class="number">26</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入一个字符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        Node cur = root;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            index = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur.next[index] == <span class="keyword">null</span>)&#123; <span class="comment">//没有就新建</span></span><br><span class="line">                cur.next[index] = <span class="keyword">new</span> Node();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next[index];</span><br><span class="line">            cur.path++; <span class="comment">//经过这里</span></span><br><span class="line">        &#125;</span><br><span class="line">        cur.end++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//统计某个字符串的数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Node cur = root;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            index = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur.next[index] == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            cur = cur.next[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count(word) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prefixNum</span><span class="params">(String prefix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prefix == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Node cur = root;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i++)&#123;</span><br><span class="line">            index = prefix.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur.next[index] == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            cur = cur.next[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.path; <span class="comment">//返回这个经过的　　也就是以这个为前驱的</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prefixNum(prefix) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(!search(word)) <span class="comment">//不包含这个字符串</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        Node cur = root;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            index = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(--cur.next[index].path == <span class="number">0</span>)&#123;</span><br><span class="line">                cur.next[index] = <span class="keyword">null</span>; <span class="comment">//释放掉下面的这棵树</span></span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next[index];</span><br><span class="line">        &#125;</span><br><span class="line">        cur.end--; <span class="comment">//最后这个字符串也要--</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Trie trie = <span class="keyword">new</span> Trie();</span><br><span class="line"></span><br><span class="line">        trie.insert(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        trie.insert(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">        trie.insert(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">        trie.insert(<span class="string">&quot;abd&quot;</span>);</span><br><span class="line">        trie.insert(<span class="string">&quot;bc&quot;</span>);</span><br><span class="line">        trie.insert(<span class="string">&quot;bd&quot;</span>);</span><br><span class="line">        trie.insert(<span class="string">&quot;cd&quot;</span>);</span><br><span class="line">        trie.insert(<span class="string">&quot;cde&quot;</span>);</span><br><span class="line">        trie.insert(<span class="string">&quot;ce&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(trie.count(<span class="string">&quot;ab&quot;</span>));</span><br><span class="line">        trie.remove(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">        System.out.println(trie.count(<span class="string">&quot;ab&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(trie.count(<span class="string">&quot;abd&quot;</span>));</span><br><span class="line">        trie.remove(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">        System.out.println(trie.count(<span class="string">&quot;ab&quot;</span>));</span><br><span class="line">        System.out.println(trie.count(<span class="string">&quot;abd&quot;</span>));</span><br><span class="line"></span><br><span class="line">        trie.remove(<span class="string">&quot;abd&quot;</span>);</span><br><span class="line">        System.out.println(trie.count(<span class="string">&quot;abd&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试结果输出: </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="https://leetcode.com/problems/implement-trie-prefix-tree/description/">题目链接</a></h4><blockquote>
<p><a href="https://leetcode.com/problems/implement-trie-prefix-tree/description/">https://leetcode.com/problems/implement-trie-prefix-tree/description/</a></p>
</blockquote>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><img src="images/t4.png" alt="在这里插入图片描述"></p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>运用上面的操作完全能解决这个问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> path;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> end;</span><br><span class="line">        <span class="keyword">public</span> Node[] next;<span class="comment">//使用整数表示字符　c - &#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            path = <span class="number">0</span>;</span><br><span class="line">            end = <span class="number">0</span>;</span><br><span class="line">            next = <span class="keyword">new</span> Node[<span class="number">26</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入一个字符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        Node cur = root;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            index = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur.next[index] == <span class="keyword">null</span>)&#123; <span class="comment">//没有就新建</span></span><br><span class="line">                cur.next[index] = <span class="keyword">new</span> Node();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next[index];</span><br><span class="line">            cur.path++; <span class="comment">//经过这里</span></span><br><span class="line">        &#125;</span><br><span class="line">        cur.end++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//统计某个字符串的数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Node cur = root;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            index = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur.next[index] == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            cur = cur.next[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count(word) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prefixNum</span><span class="params">(String prefix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prefix == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Node cur = root;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i++)&#123;</span><br><span class="line">            index = prefix.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur.next[index] == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            cur = cur.next[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.path; <span class="comment">//返回这个经过的　　也就是以这个为前驱的</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prefixNum(prefix) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="使用Map来保存next"><a href="#使用Map来保存next" class="headerlink" title="使用Map来保存next"></a>使用Map来保存next</h3><p>还有一种写法就是 </p>
<ul>
<li>使用<code>Map</code>来保存<code>next</code>数组，这样不只可以存<code>26</code>或者<code>52</code>个孩子: </li>
</ul>
<p>还是上面那个题目代码: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">int</span> path;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">int</span> end;</span><br><span class="line">     <span class="keyword">public</span> HashMap&lt;Character,Node&gt;next;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         path = <span class="number">0</span>;</span><br><span class="line">         end = <span class="number">0</span>;</span><br><span class="line">         next = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     root = <span class="keyword">new</span> Node();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//插入一个字符</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(word == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">return</span> ;</span><br><span class="line">     Node cur = root;</span><br><span class="line">     <span class="keyword">char</span> c;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">         c = word.charAt(i);</span><br><span class="line">         <span class="keyword">if</span>(cur.next.get(c) == <span class="keyword">null</span>)&#123; <span class="comment">//没有就新建</span></span><br><span class="line">             cur.next.put(c,<span class="keyword">new</span> Node());</span><br><span class="line">         &#125;</span><br><span class="line">         cur = cur.next.get(c);</span><br><span class="line">         cur.path++; <span class="comment">//经过这里</span></span><br><span class="line">     &#125;</span><br><span class="line">     cur.end++;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//统计某个字符串的数量</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(word == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     Node cur = root;</span><br><span class="line">     <span class="keyword">char</span> c;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">         c = word.charAt(i);</span><br><span class="line">         <span class="keyword">if</span>(cur.next.get(c) == <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         cur = cur.next.get(c);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> cur.end;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> count(word) &gt; <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prefixNum</span><span class="params">(String prefix)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(prefix == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     Node cur = root;</span><br><span class="line">     <span class="keyword">char</span> c;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i++)&#123;</span><br><span class="line">         c = prefix.charAt(i);</span><br><span class="line">         <span class="keyword">if</span>(cur.next.get(c) == <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         cur = cur.next.get(c);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> cur.path; <span class="comment">//返回这个经过的　　也就是以这个为前驱的</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> prefixNum(prefix) &gt; <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(word == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     <span class="keyword">if</span>(!search(word)) <span class="comment">//不包含这个字符串</span></span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     Node cur = root;</span><br><span class="line">     <span class="keyword">char</span> c;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">         c = word.charAt(i);</span><br><span class="line">         <span class="keyword">if</span>(--cur.next.get(c).path == <span class="number">0</span>)&#123;</span><br><span class="line">             cur.next.remove(c);</span><br><span class="line">             <span class="keyword">return</span> ;</span><br><span class="line">         &#125;</span><br><span class="line">         cur = cur.next.get(c);</span><br><span class="line">     &#125;</span><br><span class="line">     cur.end--; <span class="comment">//最后这个字符串也要--</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="更多字典树"><a href="#更多字典树" class="headerlink" title="更多字典树"></a>更多字典树</h3><ul>
<li><strong>压缩字典树；</strong></li>
</ul>
<p><img src="images/t5.png" alt="这里写图片描述"></p>
<ul>
<li><strong>三分搜索树；</strong></li>
</ul>
<p><img src="images/t6.png" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程基础</title>
    <url>/2023/01/12/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Java多线程基础"><a href="#Java多线程基础" class="headerlink" title="Java多线程基础"></a>Java多线程基础</h1><ul>
<li><a href="#%E4%B8%80%E7%BA%BF%E7%A8%8B%E4%BB%8B%E7%BB%8D">一、线程介绍</a><ul>
<li><a href="#1%E7%AE%80%E5%8D%95%E6%A1%88%E4%BE%8B%E5%BC%95%E5%85%A5">1、简单案例引入</a></li>
<li><a href="#2start%E5%92%8Crun%E6%96%B9%E6%B3%95%E5%8C%BA%E5%88%AB">2、start和run方法区别</a></li>
<li><a href="#3%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">3、线程生命周期</a></li>
<li><a href="#4%E9%93%B6%E8%A1%8C%E6%8E%92%E9%98%9F%E4%B8%9A%E5%8A%A1%E6%A1%88%E4%BE%8B">4、银行排队业务案例</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3thread%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">二、深入理解Thread构造函数</a><pre><code>- [1、线程的默认命名](#1线程的默认命名)
- [2、线程的父子关系](#2线程的父子关系)
- [3、Thread和ThreadGroup](#3thread和threadgroup)
- [4、Thread和JVM虚拟机栈](#4thread和jvm虚拟机栈)
- [5、守护线程](#5守护线程)
</code></pre>
</li>
<li><a href="#%E4%B8%89threadapi%E7%9A%84%E8%AF%A6%E7%BB%86%E5%86%85%E5%AE%B9">三、Thread API的详细内容</a><ul>
<li><a href="#1%E7%BA%BF%E7%A8%8Bsleep">1、线程sleep</a></li>
<li><a href="2%E7%BA%BF%E7%A8%8Byield">2、线程yield</a></li>
<li><a href="#3%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7">3、设置线程的优先级</a></li>
<li><a href="#4%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8Bid">4、获取线程ID</a></li>
<li><a href="5%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B">5、获取当前线程</a></li>
<li><a href="#6%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8">6、设置线程上下文类加载器</a></li>
<li><a href="#7%E7%BA%BF%E7%A8%8Binterrupt">7、线程interrupt</a></li>
<li><a href="#8%E7%BA%BF%E7%A8%8Bjoin">8、线程join</a></li>
<li><a href="9%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B">9、关闭线程</a></li>
</ul>
</li>
<li>四、线程安全与数据同步</li>
<li>五、线程间通信</li>
<li>六、ThreadGroup详细讲解</li>
</ul>
<hr>
<h2 id="一、线程介绍"><a href="#一、线程介绍" class="headerlink" title="一、线程介绍"></a>一、线程介绍</h2><h3 id="1、简单案例引入"><a href="#1、简单案例引入" class="headerlink" title="1、简单案例引入"></a>1、简单案例引入</h3><blockquote>
<p>模拟同时从数据库中读取数据和写入文件；</p>
</blockquote>
<ul>
<li>模拟同时从数据库中读取数据和写入文件，这两个操作作为两个线程同时进行，不需要相互的等待；</li>
<li>这里使用的是匿名类创建的线程，重写了Thread类中的run方法，当然也可以通过继承Thread类或者实现Runnable接口来创建线程；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基本的创建线程</span></span><br><span class="line"><span class="comment"> * 模拟两个线程同时执行 读数据库和写文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_01_TryConcurrency</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一边从数据库读取，一边写入文件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">&quot;Read-Thread&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">                readFromData();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();<span class="comment">//start()方法是立刻返回的，不会阻塞</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">&quot;Write-Thread&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                writeToFile() ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start(); <span class="comment">//只有调用start()方法才是线程,不然只是一个普通的类</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFromData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            println(<span class="string">&quot;Begin read data from db......&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span> * <span class="number">5L</span>);</span><br><span class="line">            println(<span class="string">&quot;After read data !&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;Read data successfully!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeToFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            println(<span class="string">&quot;Begin write data to File.......&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span> * <span class="number">5L</span>);</span><br><span class="line">            println(<span class="string">&quot;After write date !&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;Write data successfully!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>效果:</p>
<p><img src="images/t1.png" alt="这里写图片描述"> </p>
<h3 id="2、start和run方法区别"><a href="#2、start和run方法区别" class="headerlink" title="2、start和run方法区别"></a>2、start和run方法区别</h3><ul>
<li>注意只有当Thread的实例调用<code>start()</code>方法时，才能真正的成为一个线程，否则<code>Thread</code>和其他普通的Java对象没有什么区别；</li>
<li>调用<code>run()</code>方法不是一个线程；</li>
<li><code>start()</code>方法是一个立即返回的方法，不会让程序陷入阻塞；</li>
</ul>
<p>下面的代码，如果是<code>t.start()</code>输出的线程名为<code>&quot;Read-Thread&quot;</code>，而如果调用的是<code>t.run()</code>则会输出<code>main</code>线程名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread(<span class="string">&quot;Read-Thread&quot;</span>)&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        println(Thread.currentThread().getName()); <span class="comment">//如果调用start就是&quot;Read-Thread&quot;，如果调用的是run方法就是main</span></span><br><span class="line">        readFromDataBase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  t.start();  //只有调用start()方法才是真正的线程</span></span><br><span class="line">t.run();</span><br></pre></td></tr></table></figure>

<p>Thread中使用了<a href="https://blog.csdn.net/zxzxzx0119/article/details/81709199">模板方法设计模式</a>，也就是我们继承Thread类，重写的是<code>run()</code>方法(钩子方法)，但是调用的却是<code>start()</code>方法(最终方法)的原因。</p>
<p><img src="https://img-blog.csdn.net/20181007190314719?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p>
<p>关于模板方法，简单说: <strong>就是父类写了一些固定的逻辑，但是给自己留了一个方法可以实现，有些逻辑不能改，有些可以改</strong>，看一个简单的例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_02_TemplateMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能给子类实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;################&quot;</span>);</span><br><span class="line">        wrapPrint(msg);</span><br><span class="line">        System.out.println(<span class="string">&quot;################&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给子类实现(也可以写成抽象方法，子类必须实现)</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">wrapPrint</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Code_02_TemplateMethod t1 = <span class="keyword">new</span> Code_02_TemplateMethod()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">wrapPrint</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;**&quot;</span> + msg + <span class="string">&quot;**&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.print(<span class="string">&quot;Hello Thread&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Code_02_TemplateMethod t2 = <span class="keyword">new</span> Code_02_TemplateMethod()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">wrapPrint</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;++&quot;</span> + msg + <span class="string">&quot;++&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.print(<span class="string">&quot;Hello Thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">################</span><br><span class="line">**Hello Thread**</span><br><span class="line">################</span><br><span class="line">################</span><br><span class="line">++Hello Thread++</span><br><span class="line">################</span><br></pre></td></tr></table></figure>

<ul>
<li><code>print</code> 方法类似于 Thread 的 <code>start</code>方法，而 wrapPrint 则类似于 <code>run</code> 方法；</li>
<li>这样做的好处是，程序结构由父类控制，并且是 <code>final</code> 修饰的，不允许被重写，子类只需要实现想要的罗辑任务即可；</li>
</ul>
<p>也就是说<code>start</code>方法中会调用<code>start0</code>方法(并没有调用<code>run</code>方法)，而重新的<code>run</code>方法何时被调用呢?</p>
<p>在开始执行这个线程时，JVM 将会调用该线程的 <code>run</code> 方法，换言之，**<code>run</code> 方法是被 JNI 方法 <code>start0()</code> 调用的**，仔细阅读 <code>start()</code> 的源码将会总结出如下几个知识要点。</p>
<ul>
<li>Thread 被构造后的NEW 状态，事实上 threadStatus 这个内部属性为 0。</li>
<li>不能两次启动 Thread，否则就会出现 IlegalThreadStateException 异常。</li>
<li>线程启动后将会被加入到一个 ThreadGroup 中；</li>
<li>一个线程生命周期结束，也就是到了 TERMINATED 状态，再次调用 start 方法是不允许的，也就是说 TERMINATED 状态是没有办法回到RUNNABLE/RUNNING 状态的。</li>
</ul>
<p>其他总结:</p>
<ul>
<li>Java应用程序的main函数是一个线程，在JVM启动的时候调用，名字叫<code>main</code>；</li>
<li><strong>当你调用一个线程<code>start()</code>方法的时候，此时至少有两个线程，一个是调用你的线程(例如<code>main</code>)，还有一个是执行<code>run()</code>方法的线程；</strong></li>
<li>如果在构造Thread的时候没有传递Runable或者没有复写<code>Thread</code>的<code>run()</code>方法，就不会调用任何东西。只有传递<code>Runable</code>接口的实例(策略模式的算法族)；或者复写了<code>Thread</code>的<code>run()</code>方法(在<code>start()</code>中有一个<code>start0()</code>方法（会调用子类重写的<code>run()</code>方法）)，才会执行相应的逻辑代码；</li>
<li>JVM启动时，实际上有多个线程，但是至少有一个<strong>非守护线程</strong>；s</li>
</ul>
<p>关于守护线程和非守护线程:</p>
<blockquote>
<p>Java分为两种线程：用户线程和守护线程</p>
<p>所谓守护线程是指在程序运行的时候在后台提供一种通用服务的线程，比如<strong>垃圾回收线程</strong>就是一个很称职的守护者，并且这种线程并不属于程序中不可或缺的部分。因此，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任何非守护线程还在运行，程序就不会终止。</p>
<p>守护线程和用户线程的没啥本质的区别：唯一的不同之处就在于<strong>虚拟机的离开：如果用户线程已经全部退出运行了，只剩下守护线程存在了</strong>，虚拟机也就退出了。 因为没有了被守护者，守护线程也就没有工作可做了，也就没有继续运行程序的必要了。</p>
<p>将线程转换为守护线程可以通过调用Thread对象的<code>setDaemon(true)</code>方法来实现。在使用守护线程时需要注意一下几点：</p>
<ul>
<li><code>thread.setDaemon(true)</code>必须在<code>thread.start()</code>之前设置，否则会抛出一个<code>IllegalThreadStateException</code>异常。你不能把正在运行的常规线程设置为守护线程。</li>
<li>在Daemon线程中产生的新线程也是Daemon的。</li>
<li>守护线程应该永远不去访问固有资源，如文件、数据库，因为它会在任何时候甚至在一个操作的中间发生中断。</li>
</ul>
</blockquote>
<h3 id="3、线程生命周期"><a href="#3、线程生命周期" class="headerlink" title="3、线程生命周期"></a>3、线程生命周期</h3><p><img src="images/t2_%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="这里写图片描述"></p>
<p>每种状态的解释: </p>
<h4 id="1-、New状态"><a href="#1-、New状态" class="headerlink" title="1)、New状态"></a>1)、New状态</h4><ul>
<li>当我们用关键字 new 创建一个 Thread 对象时，<strong>此时它并不处于执行状态</strong>；</li>
<li>因为没有调用 <code>start</code> 方法启动该线程，那么线程的状态为<code>NEW</code> 状态。</li>
<li>准确地说，它只是 Thread 对象的状态，因为在没有 start 之前，该线程根本不存在，与你用关键字 new 创建一个普通的 Java对象没什么区别。</li>
<li>NEW 状态通过 <code>start</code> 方法进入 <code>RUNNABLE</code> 状态。</li>
</ul>
<h4 id="2-、Runnable状态"><a href="#2-、Runnable状态" class="headerlink" title="2)、Runnable状态"></a>2)、Runnable状态</h4><ul>
<li><p>线程对象进入 RUNNABLE 状态必须调用 start 方法，那么此时才是真正地在 JVM 进程中创建了一个线程，线程一经启动就可以立即得到执行吗?</p>
</li>
<li><p>答案是否定的，线程的运行与否和进程一样都要听令于 CPU 的调度，那么我们把这个中间状态称为可执行状态(RUNNABLE)，<strong>也就是说它具备执行的资格，但是并没有真正地执行起来而是在等待 CPU的调度</strong>；</p>
</li>
<li><p>由于存在<code>Running</code> 状态，所以不会直接进入<code>BLOCKED</code> 状态和<code>TERMINATED </code>状态，即使是在线程的执行逻辑中调用 wait、sleep 或者其他 block 的 IO 操作等，也必须先获得 CPU 的调度执行权才可以，严格来讲，RUNNABLE 的线程只能<strong>意外终止或者进入RUNNING 状态</strong>；(即<code>Runnable</code>不能直接到<code>BLOCKED</code>和<code>TERMINATED</code>状态)</p>
</li>
</ul>
<h4 id="3-、Running状态"><a href="#3-、Running状态" class="headerlink" title="3)、Running状态"></a>3)、Running状态</h4><p>一且 CPU 通过轮询或者其他方式从任务可执行队列中选中了线程，那么此时它才能真正地执行自己的逻辑代码(也就是RUNNING)，需要说明的一点是<strong>一个正在 RUNNING 状态的线程事实上也是RUNNABLE 的，但是反过来则不成立</strong>。在该状态中，线程的状态可以发生如下的状态转换。</p>
<ul>
<li>直接进入TERMINATED 状态，比如调用 JDK 已经不推荐使用的 stop 方法或者判断某个逻辑标识；</li>
<li>进入 BLOCKED 状态，比如调用了 <code>sleep</code> ，或者 <code>wait</code> 方法而加入了 <code>waitSet</code> 中；</li>
<li>进行某个阻塞的 IO 操作，比如因网络数据的读写而进入了 BLOCKED 状态；</li>
<li>获取某个锁资源，从而加入到该锁的阻塞队列中而进入了 BLOCKED 状态；</li>
<li>由于 CPU 的调度器轮询使该线程放弃执行，进入RUNNABLE 状态；</li>
<li>线程主动调用 <code>yield</code> 方法，放弃 CPU 执行权，进入RUNNABLE 状态；</li>
</ul>
<h4 id="4-、BLOCKED状态"><a href="#4-、BLOCKED状态" class="headerlink" title="4)、BLOCKED状态"></a>4)、BLOCKED状态</h4><p>在BLOCKED状态可以转换的状态:</p>
<ul>
<li> 直接进入TERMINATED 状态，比如调用 JDK 已经不推荐使用的 stop 方法或者意外死亡 (<code>JVM Crash</code> ) ；</li>
<li>  线程阻塞的操作结束，比如读取了想要的数据字节进入到RUNNABLE 状态；</li>
<li> 线程完成了指定时间的休眠，进入到了 RUNNABLE 状态；</li>
<li> Wait 中的线程被其他线程 <code>notify/notifyall</code> 唤醒，进入RUNNABLE 状态；</li>
<li> 线程获取到了某个锁资源，进入RUNNABLE 状态；</li>
<li> 线程在阻塞过程中被打断，比如其他线程调用了 <code>interrupt</code> 方法，进入RUNNABLE；</li>
</ul>
<h4 id="5-、TERMINATED状态"><a href="#5-、TERMINATED状态" class="headerlink" title="5)、TERMINATED状态"></a>5)、TERMINATED状态</h4><p>TERMINATED 是一个线程的最终状态，在该状态中线程将<strong>不会切换到其他任何状态，线程进入TERMINATED 状态，意味着该线程的整个生命周期都结束了。</strong></p>
<p>下列这些情况将会使线程进入 TERMINATED 状态。</p>
<ul>
<li>线程运行正常结束，结束生命周期；</li>
<li>线程运行出错意外结束；</li>
<li><code>JVM Crash</code>，导致所有的线程都结束；</li>
</ul>
<hr>
<h3 id="4、银行排队业务案例"><a href="#4、银行排队业务案例" class="headerlink" title="4、银行排队业务案例"></a>4、银行排队业务案例</h3><p><img src="https://img-blog.csdn.net/20180908220950149?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h4 id="1-、方案一，各个线程各搞各的"><a href="#1-、方案一，各个线程各搞各的" class="headerlink" title="1)、方案一，各个线程各搞各的"></a>1)、方案一，各个线程各搞各的</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_03_TicketWindowTest01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketWindow</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TicketWindow</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (index &lt;= MAX) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;柜台: &quot;</span> + name + <span class="string">&quot;,当前号码: &quot;</span> + (index++));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        TicketWindow t1 = <span class="keyword">new</span> TicketWindow(<span class="string">&quot;一号&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        TicketWindow t2 = <span class="keyword">new</span> TicketWindow(<span class="string">&quot;二号&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        TicketWindow t3 = <span class="keyword">new</span> TicketWindow(<span class="string">&quot;三号&quot;</span>);</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下，可以看到每个柜台都有<code>5</code>个号，显然不对，银行总共才<code>5</code>个号。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">柜台: 二号,当前号码: <span class="number">1</span></span><br><span class="line">柜台: 一号,当前号码: <span class="number">1</span></span><br><span class="line">柜台: 三号,当前号码: <span class="number">1</span></span><br><span class="line">柜台: 二号,当前号码: <span class="number">2</span></span><br><span class="line">柜台: 一号,当前号码: <span class="number">2</span></span><br><span class="line">柜台: 三号,当前号码: <span class="number">2</span></span><br><span class="line">柜台: 二号,当前号码: <span class="number">3</span></span><br><span class="line">柜台: 一号,当前号码: <span class="number">3</span></span><br><span class="line">柜台: 三号,当前号码: <span class="number">3</span></span><br><span class="line">柜台: 一号,当前号码: <span class="number">4</span></span><br><span class="line">柜台: 三号,当前号码: <span class="number">4</span></span><br><span class="line">柜台: 二号,当前号码: <span class="number">4</span></span><br><span class="line">柜台: 一号,当前号码: <span class="number">5</span></span><br><span class="line">柜台: 三号,当前号码: <span class="number">5</span></span><br><span class="line">柜台: 二号,当前号码: <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h4 id="2-、方案二，使用static关键字"><a href="#2-、方案二，使用static关键字" class="headerlink" title="2)、方案二，使用static关键字"></a>2)、方案二，使用static关键字</h4><p>最简单的解决方案 : 将<code>index</code>设置成<code>static</code>，这样每个对象都是用这个值，总共就只有<code>MAX</code>个了。</p>
<p>但是这种方案也有一些缺点:</p>
<ul>
<li><code>static</code>修饰的变量生命周期很长，浪费资源；</li>
<li>如果将号码<code>MAX</code>调整到<code>500、1000</code>等稍微大一点的数字就会出现线程安全问题； </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketWindow</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TicketWindow</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= MAX) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;柜台: &quot;</span> + name + <span class="string">&quot;,当前号码: &quot;</span> + (index++));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类不变， 输出如下，可以看到总共只会输出<code>5</code>次，但是不是好的方案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">柜台: 一号,当前号码: <span class="number">1</span></span><br><span class="line">柜台: 二号,当前号码: <span class="number">2</span></span><br><span class="line">柜台: 三号,当前号码: <span class="number">3</span></span><br><span class="line">柜台: 一号,当前号码: <span class="number">4</span></span><br><span class="line">柜台: 二号,当前号码: <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h4 id="3-、方法三，使用Runnable接口以及策略"><a href="#3-、方法三，使用Runnable接口以及策略" class="headerlink" title="3)、方法三，使用Runnable接口以及策略"></a>3)、方法三，使用Runnable接口以及策略</h4><p><strong>可以使用实现Runnable接口来传入到Thread的构造方法当中，完成和static关键字同样的效果。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_03_TicketWindowTest02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketWindow</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">1</span>; <span class="comment">// 没有做static修饰</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (index &lt;= MAX) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot; 的号码是: &quot;</span> + (index++));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        TicketWindow ticketWindow = <span class="keyword">new</span> TicketWindow(); <span class="comment">// 只有一个 TicketWindow实例</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(ticketWindow, <span class="string">&quot;一号窗口&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(ticketWindow, <span class="string">&quot;二号窗口&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(ticketWindow, <span class="string">&quot;三号窗口&quot;</span>);</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出: (此时号码就是有序的):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread[一号窗口,<span class="number">5</span>,main] 的号码是: <span class="number">1</span></span><br><span class="line">Thread[二号窗口,<span class="number">5</span>,main] 的号码是: <span class="number">2</span></span><br><span class="line">Thread[三号窗口,<span class="number">5</span>,main] 的号码是: <span class="number">3</span></span><br><span class="line">Thread[一号窗口,<span class="number">5</span>,main] 的号码是: <span class="number">4</span></span><br><span class="line">Thread[二号窗口,<span class="number">5</span>,main] 的号码是: <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>重写Thread类的<code>run</code>方法和实现<code>Runnable</code>接口的<code>run</code>方法有一个很大的不同:</p>
<ul>
<li>Thread类的<code>run</code>方法是不能共享的，也就是说<code>A</code>线程不能把<code>B</code>线程的<code>run</code>方法当做自己的执行单元；</li>
<li>而使用<code>Runnable</code>接口则很任意就能实现这一点，<strong>使用同一个<code>Runnable</code>的实例构造不同的Thread实例</strong>；</li>
</ul>
<p><strong>这里注意Runnable接口使用的是设计模式中的<a href="https://blog.csdn.net/zxzxzx0119/article/details/81327444">策略模式</a></strong>: </p>
<ul>
<li>Runnable接口类类似接口的行为族；</li>
<li>具体的实现由我们自己创建的是实现Runnable接口的类来指定，并且重写方法<code>run()</code>方法，具体指定自己的实现。 </li>
</ul>
<blockquote>
<p>很多书籍经常会提到，创建线程有两种方式，第一种是构造一个Thread，第二种是实现 Runnable 接口，这种说法是错误的，最起码是不严谨的，在 JDK 中代表线程的就只有 Thread 这个类，我们在前面分析过，线程的执行单元就是run方法，你可以通过继承 Thread 然后重写 run 方法实现自己的业务逻辑，也可以实现 Runnable 接口实现自己的业务逻辑，代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果构造Thread时传入了Runnable，则会执行runnable的run方法</span></span><br><span class="line">    <span class="keyword">if</span>(target != <span class="keyword">null</span>)&#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则需要重写Thread类的run()方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>准确地讲，创建线程只有一种方式那就是构造Thread 类。</strong></p>
<p><strong>而实现线程的执行单元则有两种方式，第一种是重写 Thread 的 run 方法，第二种是实现 Runnable 接口的 run 方法，并且将 Runnable 实例用作构造 Thread 的参数。</strong></p>
</blockquote>
<h2 id="二、深入理解Thread构造函数"><a href="#二、深入理解Thread构造函数" class="headerlink" title="二、深入理解Thread构造函数"></a>二、深入理解Thread构造函数</h2><h3 id="1、线程的默认命名"><a href="#1、线程的默认命名" class="headerlink" title="1、线程的默认命名"></a>1、线程的默认命名</h3><p>打开JDK的源码可以看到我们构造Thread的时候，默认的线程的名字是</p>
<ul>
<li>以<code>Thread-</code>开头，从<code>0</code>开始计数；</li>
<li>即<code>Thread-0、Thread-1、Thread-2...</code>；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* For autonumbering anonymous threads. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> threadInitNumber;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">nextThreadNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> threadInitNumber++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改线程的名字，在线程启动之前，还有一个而已修改线程名字的机会，一旦线程启动，名字就不可以修改: </p>
<p>下面是在Thread中修改名字的代码: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;name cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>) &#123;</span><br><span class="line">        setNativeName(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、线程的父子关系"><a href="#2、线程的父子关系" class="headerlink" title="2、线程的父子关系"></a>2、线程的父子关系</h3><p>Thread的所有构造函数，最终都会去调用一个静态方法<code>init</code>，我们截取片段代码对其进行分析，不难发现新创建的任何一个线程都会有一个父线程:</p>
<p>这里截取<code>Thread</code>的<code>init</code>的部分代码: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;name cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    Thread parent = currentThread();<span class="comment">//获取当前运行的线程作为赴现场</span></span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">this</span>.group = g;<span class="comment">// 设置线程组</span></span><br><span class="line">    <span class="keyword">this</span>.daemon = parent.isDaemon();<span class="comment">// 当前线程是否为守护线程，取决于父线程</span></span><br><span class="line">    <span class="keyword">this</span>.priority = parent.getPriority(); <span class="comment">// 设置优先级</span></span><br><span class="line">    setPriority(priority);</span><br><span class="line">    <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line">    <span class="comment">/* Set thread ID */</span></span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中的 <code>currentThread() </code>是获取当前线程，在线程生命周期中，我们说过线程的最初状态为NEW，没有执行 start 方法之前，它只能算是一个 Thread 的实例，并不意味着一个新的线程被创建，因此 <code>currentThread()</code> 代表的将会是<strong>创建它的那个线程</strong>，因此我们可以得出以下结论。</p>
<ul>
<li> 一个线程的创建肯定是由另一个线程完成的。</li>
<li> <strong>被创建线程的父线程是创建它的线程</strong>。</li>
</ul>
<p><strong>我们都知道 main 函数所在的线程是由 JVM 创建的，也就是 main 线程，那就意味着我们前面创建的所有线程，其父线程都是 main 线程。</strong></p>
<h3 id="3、Thread和ThreadGroup"><a href="#3、Thread和ThreadGroup" class="headerlink" title="3、Thread和ThreadGroup"></a>3、Thread和ThreadGroup</h3><p>在Thread的构造函数中，可以显示的指定线程的Group，也就是ThreadGroup，下面看<code>init</code>方法的中间部分: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">/* Determine if it&#x27;s an applet or not */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If there is a security manager, ask the security manager</span></span><br><span class="line"><span class="comment">              what to do. */</span></span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        g = security.getThreadGroup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the security doesn&#x27;t have a strong opinion of the matter</span></span><br><span class="line"><span class="comment">              use the parent thread group. */</span></span><br><span class="line">    <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">        g = parent.getThreadGroup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码的意思: <strong>如果在构造Thread的时候没有显示的指定一个ThreadGroup，那么子线程将会被加入父线程所在的线程组。</strong></p>
<p>简单测试代码: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_04_ThreadGroupTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        PrintStream out = System.out;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="string">&quot;t1&quot;</span>);<span class="comment">// 没有给t1指定group</span></span><br><span class="line">        ThreadGroup group1 = <span class="keyword">new</span> ThreadGroup(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(group1, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        ThreadGroup mainGroup = Thread.currentThread().getThreadGroup();</span><br><span class="line"></span><br><span class="line">        out.println(<span class="string">&quot;Main Thread Group : &quot;</span> + mainGroup.getName());</span><br><span class="line">        out.println(t1.getThreadGroup() == mainGroup); <span class="comment">// true // 默认就是main线程的</span></span><br><span class="line">        out.println(t2.getThreadGroup() == mainGroup); <span class="comment">// false</span></span><br><span class="line">        out.println(group1 == t2.getThreadGroup()); <span class="comment">// true // 指定了就是这个了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Main Thread Group : main</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>得出结论: </p>
<ul>
<li>main线程所在的<code>ThreadGroup</code>称为<code>main</code>；</li>
<li>构造一个线程的时候如果没有显示的指定<code>ThreadGroup</code>，那么它将会和父线程属于同一个<code>ThreadGroup</code>（且拥有同样的优先级）；</li>
</ul>
<h3 id="4、Thread和JVM虚拟机栈"><a href="#4、Thread和JVM虚拟机栈" class="headerlink" title="4、Thread和JVM虚拟机栈"></a>4、Thread和JVM虚拟机栈</h3><h4 id="1-、Thread与Stacksize"><a href="#1-、Thread与Stacksize" class="headerlink" title="1)、Thread与Stacksize"></a>1)、Thread与Stacksize</h4><p>看下列<code>Thread</code>构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread(ThreadGroup group, Runnable target, String name, <span class="keyword">long</span> stackSize) </span><br><span class="line"><span class="comment">//分配新的 Thread 对象，以便将 target 作为其运行对象，将指定的 name 作为其名称，作为 group 所引用的线程组的一员，并具有指定的堆栈大小。</span></span><br></pre></td></tr></table></figure>

<p>构造Thread的时候传入<code>stackSize</code>代表着线程占用的<code>stack</code>大小，如果没有指定<code>stackSize</code>的大小，默认是<code>0</code>，<code>0</code>代表着会忽略该参数，改参数会被JNI函数(<code>Native</code>)去使用。</p>
<h4 id="2-、JVM内存结构"><a href="#2-、JVM内存结构" class="headerlink" title="2)、JVM内存结构"></a>2)、JVM内存结构</h4><p>详见<code>JVM</code>相关知识。可看我的<a href="../../Java%E5%9F%BA%E7%A1%80/JVM/JVM%E6%80%BB%E7%BB%93(%E4%B8%80">另一篇博客</a> - 内存区域与内存管理.md)。</p>
<h4 id="3-、Thread与虚拟机栈"><a href="#3-、Thread与虚拟机栈" class="headerlink" title="3)、Thread与虚拟机栈"></a>3)、Thread与虚拟机栈</h4><p>虚拟机栈的大小大概是可以存放21456个栈桢(栈桢中存放局部变量表、操作数栈、动态链接…)，而自己创建的线程的虚拟机栈只有大概15534个栈桢，但是我们可以在创建线程的时候指定<code>stackSize</code>；</p>
<h3 id="5、守护线程"><a href="#5、守护线程" class="headerlink" title="5、守护线程"></a>5、守护线程</h3><p>基本性质。</p>
<ul>
<li>在正常的情况下，如果JVM没有一个<strong>非守护线程</strong>，JVM的进程才会退出。(当只有<code>Daemon</code>线程运行的时候才会退出)；</li>
<li><code>setDaemon()</code>方法必须在<code>start()</code>方法之前调用(否则会抛出<code>IllegalThreadException</code>)；</li>
</ul>
<p>线程是否为守护线程和它的父线程有很大的关系，如果父线程是正常线程，则子线程也是正常线程，反之亦然，如果你想要修改它的特性则可以借助 <code>setDaemon</code> 方法。<code>isDaemon()</code> 方法可以判断该线程是不是守护线程。</p>
<p>另外需要注意的就是，<code>setDaemon()</code> 方法只在线程启动之前才能生效，如果一个线程已经死亡，那么再设置 <code>setDaemon()</code> 则会抛出 <code>IllegalThreadStateException</code> 异常。</p>
<p>看一个<code>daemonThread</code>的例子: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_05_DaemonThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;t running...&quot;</span>);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   Thread.sleep(<span class="number">1_000</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//        t.setDaemon(true);</span></span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">2_000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Main 线程结束!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面注释了<code>t.setDaemon(true);</code>运行结果如下，发现<code>main</code> 线程结束了，但是里面的线程没有结束。</p>
<p><img src="images/t3_Daemon%E7%BB%93%E6%9E%9C.png"></p>
<p>但是如果不注释<code>t.setDaemon(true);</code>，当<code>main</code>线程结束，里面的线程就会结束。</p>
<p><img src="images/t4_.png"></p>
<p><strong>守护线程的作用</strong></p>
<p><strong>如果一个 JVM 进程中没有一个非守护线程，那么 JVM 会退出，也就是说守护线程具备自动结束生命周期的特性，而非守护线程则不具备这个特点</strong>，试想一下如果 JVM 进程的垃圾回收线程是非守护线程，如果 main 线程完成了工作，则 JVM 无法退出，因为垃圾回收线程还在正常的工作。再比如有一个简单的游戏程序，其中有一个线程正在与服务器不断地交互以获取玩家最新的金币、武器信息，若希望在退出游戏客户端的时候，这些数据同步的工作也能够立即结束，等等。</p>
<p>守护线程经常用作与执行一些后台任务，因此有时它也被称为<strong>后台线程</strong>，<strong>当你希望关闭某些线程的时候，或者退出 JVM 进程的时候，一些线程能够自动关闭</strong>，此时就可以考虑用守护线程(<code>setDaemon()</code>)为你完成这样的工作。</p>
<hr>
<h2 id="三、Thread-API的详细内容"><a href="#三、Thread-API的详细内容" class="headerlink" title="三、Thread API的详细内容"></a>三、Thread API的详细内容</h2><h3 id="1、线程sleep"><a href="#1、线程sleep" class="headerlink" title="1、线程sleep"></a>1、线程sleep</h3><h4 id="1-、简单介绍"><a href="#1-、简单介绍" class="headerlink" title="1)、简单介绍"></a>1)、简单介绍</h4><p>两个构造方法</p>
<ul>
<li><p>public static void sleep(long millis) throws InterruptedException</p>
</li>
<li><p>public static void sleep(long millis, int nanos) throws InterruptedException</p>
</li>
</ul>
<p><code>sleep</code> 方法会<strong>使当前线程进入指定毫秒数的休眠</strong>，和暂停执行，虽然给定了一个休眠的时间，但是最终要以系统的定时器和调度器的精度为准，休眠有一个非常重要的特性，那就是其不会放弃 monitor 锁的所有权。</p>
<p>每个线程的休眠互不影响。</p>
<h4 id="2-、使用TimeUnit代替Thread-sleep"><a href="#2-、使用TimeUnit代替Thread-sleep" class="headerlink" title="2)、使用TimeUnit代替Thread.sleep"></a>2)、使用TimeUnit代替Thread.sleep</h4><p>JDKE 引入了一个枚举 TimeUnit，<strong>其对 sleep 方法提供了很好的封装</strong>，使用它可以省去时间单位的换算步骤，比如线程想休眠 3小时24分17秒 88 毫秒，使用TimeUnit 来实现就非常的简便优雅了:</p>
<p>Thread.sleep(12257088L)；</p>
<p>TimeUnit.HOURS.sleep(3)；</p>
<p>TimeUnit.MINUTES.sleep(24) ；</p>
<p>TimeUnit.SECONDS.sleep(17) ;</p>
<p>TimeUnit .MILLISECONDS.sleep(88)；</p>
<p>同样的时间表达，TimeUnit 显然清晰很多，强烈建议，在使用 Thread.sleep 的地方，完全使用TimeUnit 来代替，因为 sleep 能做的事，TimeUnit 全部都能完成，并且功能更加的强大。</p>
<h3 id="2、线程yield"><a href="#2、线程yield" class="headerlink" title="2、线程yield"></a>2、线程yield</h3><h4 id="1-、简单介绍-1"><a href="#1-、简单介绍-1" class="headerlink" title="1)、简单介绍"></a>1)、简单介绍</h4><ul>
<li>这也是一个静态方法，调用该方法，是告诉操作系统的调度器，<strong>我现在不着急占用CPU，你可以先让其他线程运行</strong>。不过，<strong>这对调度器也仅仅是建议，调度器如何处理是不一定的</strong>，它可能完全忽略该调用；</li>
<li>调用<code>yield()</code>方法会使得当前线程从<code>RUNNING</code>状态切换到<code>RUNNABLE</code>状态，这个方法不太常用；</li>
</ul>
<p>例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_06_YieldTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">            create(i).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Thread <span class="title">create</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="comment">//           if(index == 0)</span></span><br><span class="line"><span class="comment">//               Thread.yield();</span></span><br><span class="line">            System.out.println(index);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的程序运行很多次，你会发现输出的结果不一致，有时候是 0 最先打印出来，有时候是 1 最先打印出来，但是当你打开代码的注释部分，你会发现，顺序始终是0，1。</p>
<p>因为第一个线程如果最先获得了 CPU 资源，它会比较谦虚，主动告诉 CPU 调度器释放了原本属于自己的资源，但是 <code>yield</code> 只是一个提示 (<code>hint</code>)，CPU 调度器并不会担保每次都能满足 <code>yield</code> 提示；</p>
<h4 id="2-、yield和sleep的区别"><a href="#2-、yield和sleep的区别" class="headerlink" title="2)、yield和sleep的区别"></a>2)、yield和sleep的区别</h4><p>看过前面的内容之后，会发现 yield 和 sleep 有一些混淆的地方， 在 JDK1.5 以前的版本中 yield 的方法事实上是调用了 <code>sleep(0)</code>，但是它们之间存在着本质的区别，具体如下。</p>
<ul>
<li><p><code>sleep</code> 会导致当前线程暂停指定的时间，没有 CPU 时间片的消耗。</p>
</li>
<li><p><code>yield</code> 只是对 CPU 调度器的一个提示，如果 CPU 调度器没有忽略这个提示，它会导致线程上下文的切换。</p>
</li>
<li><p><code>sleep</code> 会使线程短暂 block，会在给定的时间内释放 CPU 资源。</p>
</li>
<li><p><code>yield</code> 会使RUNNING 状态的 Thread 进入RUNNABLE 状态 (如果 CPU 调度器没有<br>忽略这个提示的话)。</p>
</li>
<li><p><code>sleep</code> 几乎百分之百地完成了给定时间的休眠，而 yield 的提示并不能一定担保。</p>
</li>
<li><p>一个线程 sleep 另一个线程调用 interrupt 会捕获到<strong>中断信号</strong>，而 yield 则不会。</p>
</li>
</ul>
<h3 id="3、线程优先级"><a href="#3、线程优先级" class="headerlink" title="3、线程优先级"></a>3、线程优先级</h3><p><code>setPriority(int newPriority)</code>、<code>getPriority()</code>方法。</p>
<h4 id="1-、简单介绍-2"><a href="#1-、简单介绍-2" class="headerlink" title="1)、简单介绍"></a>1)、简单介绍</h4><p>进程有进程的优先级，线程同样也有优先级，理论上是优先级比较高的线程会获取优先被 CPU 调度的机会，<strong>但是事实上往往并不会如你所愿</strong>，设置线程的优先级同样也是一个<strong>hint 操作</strong>，有具体如下。</p>
<ul>
<li>对于 root 用户，它会 hint 操作系统你想要设置的优先级别，否则它会被忽略。</li>
<li>如果 CPU 比较忙，设置优先级可能会获得更多的 CPU 时间片，但是闲时优先级的高低几乎不会有任何作用。</li>
</ul>
<p>所以，<strong>不要在程序设计当中企图使用线程优先级绑定某些特定的业务，或者让业务严重依赖于线程优先级</strong>，这可能会让你大失所望。</p>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_07_ThreadPriority</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.setPriority(<span class="number">3</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t2.setPriority(<span class="number">10</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序，会发现t2出现的频率更高一点。</p>
<h4 id="2-、setPriority-int-newPriority-源码"><a href="#2-、setPriority-int-newPriority-源码" class="headerlink" title="2)、setPriority(int newPriority)源码"></a>2)、setPriority(int newPriority)源码</h4><p>源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span> </span>&#123;</span><br><span class="line">    ThreadGroup g;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((g = getThreadGroup()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">            newPriority = g.getMaxPriority();</span><br><span class="line">        &#125;</span><br><span class="line">        setPriority0(priority = newPriority);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出</p>
<ul>
<li>线程的优先级不能小于 1 也不能大于 10；</li>
<li>如果指定的线程优先级大于线程所在 group 的优先级，那么指定的优先级将会失效，取而代之的是 group 的最大优先级；</li>
<li>另外，我们一般不会设置线程优先级，直接使用默认优先级即可，默认优先级一般是5；</li>
</ul>
<h3 id="4、获取线程ID"><a href="#4、获取线程ID" class="headerlink" title="4、获取线程ID"></a>4、获取线程ID</h3><p>简单介绍:</p>
<ul>
<li><code>public long getId()</code>获取线程唯一的ID，线程的ID在整个JVM进程中都是唯一的。并且是从 0 开始逐次递增；</li>
<li>如果你在 main 线程(main 函数) 中创建了一个唯一的线程，并且调用 getId() 后发现其并不等于0，也许你会纳闷，不应该是从 0 开始的吗? 因为在一个JVM 进程启动的时候，实际上是开辟了很多个线程，自增序列已经有了一定的消耗，因此我们自己创建的线程绝非第 0 号线程；</li>
</ul>
<h3 id="5、获取当前线程"><a href="#5、获取当前线程" class="headerlink" title="5、获取当前线程"></a>5、获取当前线程</h3><p>很简单，就是<code>public static Thread currentThread()</code>方法。作用就是返回当前执行线程的引用。</p>
<h3 id="6、设置线程上下文类加载器"><a href="#6、设置线程上下文类加载器" class="headerlink" title="6、设置线程上下文类加载器"></a>6、设置线程上下文类加载器</h3><ul>
<li><code>public ClassLoader getContextClassLoader()</code>获取线程上下文的类加载器，简单来说就是这个线程是由哪个<strong>类加器</strong>加载的，如果是在没有修改线程上下文类加载器的情况下，<strong>则保持与父线程同样的类加载器</strong>。</li>
<li><code>public void setContextClassLoader(ClassLoader cl)</code> 设置该线程的类加载器，这个方法可以打破 JAVA 类加载器的父委托机制，有时候该方法也被称为 JAVA 类加载器的后门。</li>
</ul>
<h3 id="7、线程interrupt"><a href="#7、线程interrupt" class="headerlink" title="7、线程interrupt"></a>7、线程interrupt</h3><p>三个方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="1-、interrupt"><a href="#1-、interrupt" class="headerlink" title="1)、interrupt()"></a>1)、interrupt()</h4><p><strong>调用下面的方法会使得当前线程进入阻塞状态(blocked)，而调用当前线程的<code>interrupt()</code>方法，就可以打断这个阻塞</strong>；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object 的 wait();</span><br><span class="line">Object 的 wait(<span class="keyword">long</span>);</span><br><span class="line">Object 的 wait(<span class="keyword">long</span>, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">Thread 的 sleep(<span class="keyword">long</span>);</span><br><span class="line">Thread 的 sleep(<span class="keyword">long</span>, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">Thread 的 join();</span><br><span class="line">Thread 的 join(<span class="keyword">long</span>);</span><br><span class="line">Thread 的 join(<span class="keyword">long</span>, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">InterruptibleChannel的io方法；</span><br><span class="line">Selector 的 wakeup();</span><br><span class="line">其他</span><br></pre></td></tr></table></figure>

<p>上述若干方法都会使得当前线程进入阻塞状态。</p>
<ul>
<li>若<strong>另外的一个线程调用被阻塞线程的<code>interrupt</code> 方法，则会打断这种阻塞</strong>，因此这种方法有时会被称为可中断方法，记住，<strong>打断一个线程并不等于该线程的生命周期结束</strong>，仅仅是打断了当前线程的阻塞状态。</li>
<li>一旦线程在阻塞的情况下被打断，都会抛出一个称为 <code>InterruptedException </code>的异常，这个异常就像一个 signal (信号) 一样通知当前线程被打断了。</li>
</ul>
<p>简单测试:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_08_ThreadInterrupt</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MINUTES.sleep(<span class="number">1</span>); <span class="comment">// 企图休眠一分钟</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Oh, I am be interrupted...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t.start();</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">2</span>); <span class="comment">// 这里简短的休眠是为了确保线程已经启动了</span></span><br><span class="line">        t.interrupt(); <span class="comment">// 打断线程休眠</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>程序输出:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Oh, I am be interrupted...</span><br></pre></td></tr></table></figure>

<p>解释:</p>
<p>上面的代码创建了一个线程，并且企图休眠 1 分钟的时长，不过很可惜，大约在 2 毫秒秒之后就被主线程调用 <code>interrupt</code> 方法打断。</p>
<p>interrupt 这个方法内部到底做了什么样的事情呢? 在一个线程内部存在着名为 <code>interrupt flag</code>的标识，如果一个线程被 interrupt，那么它的 flag 将被设置。</p>
<p>但是如果当前线程正在执行可中断方法被阻塞时(<code>sleep()</code>)，调用 interrupt 方法将其中断，反而会导致 flag 被清除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        Interruptible b = blocker;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            interrupt0();           <span class="comment">// flag , Just to set the interrupt flag</span></span><br><span class="line">            b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，如果一个线程已经是死亡状态，那么尝试对其的 interrupt 会直接被忽略。</p>
<h4 id="2-、isInterrupted"><a href="#2-、isInterrupted" class="headerlink" title="2)、isInterrupted"></a>2)、isInterrupted</h4><p>作用: 判断当前线程是否被中断。</p>
<p>给个代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_08_ThreadInterrupt2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">//        test1();</span></span><br><span class="line">        test2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">2</span>); <span class="comment">// 这里简短的休眠是为了确保线程已经启动了</span></span><br><span class="line">        System.out.println(t.isInterrupted());</span><br><span class="line">        t.interrupt(); <span class="comment">// 打断线程休眠</span></span><br><span class="line">        System.out.println(t.isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MINUTES.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// 忽略这个异常</span></span><br><span class="line">                    <span class="comment">// 这里 interrupt flag 将会被clear</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;I am be interrupted ?&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">2</span>); <span class="comment">// 这里简短的休眠是为了确保线程已经启动了</span></span><br><span class="line">        System.out.println(t.isInterrupted());</span><br><span class="line">        t.interrupt(); <span class="comment">// 打断线程休眠</span></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">2</span>); <span class="comment">// 这里简短的休眠是为了确保线程已经启动了</span></span><br><span class="line">        System.out.println(t.isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>test1()</code>输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<p><code>test2()</code>输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">false</span><br><span class="line">I am be interrupted ?</span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<p>解释:</p>
<ul>
<li><code>test1()</code>代码代码中定义了一个线程，并且在线程的执行单元中(run 方法) 写了一个空的死循环，为什么不写 sleep 呢? 因为 sleep 是可中断方法，会捕获到中断信号，从而干扰我们程序的结果；</li>
<li><code>test2()</code>对<code>test1()</code>代码做了一些修改。中断方法补货了中断信号<code>signal</code>之后，也就是捕获了<code>InterruptedException</code>异常之后就会擦除<code>interrupt</code>的标识；</li>
</ul>
<h4 id="3-、interrupted"><a href="#3-、interrupted" class="headerlink" title="3)、interrupted"></a>3)、interrupted</h4><p>interrupted 是一个静态方法，虽然其也用于判断当前线程是否被中断，但是它和成员方法 <code>isInterrupted</code> 还是有很大的区别的，<strong>调用该方法会直接控除掉线程的 interrupt 标识</strong>。</p>
<p>需要注意的是，如果当前线程被打断了，那么第一次调用 <code>interrupted </code>方法会返回 true，并且立即清除了 interrupt 标识；第二次包括以后的调用永远都会返回 false，除非在此期间线程又一次地被打断。</p>
<p>写一个程序简单测试:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_08_ThreadInterrupt3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                System.out.println(Thread.interrupted());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.setDaemon(<span class="keyword">true</span>);<span class="comment">//和主程序一起退出</span></span><br><span class="line">        t.start();</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面程序输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">false</span><br><span class="line">false</span><br><span class="line">true  &#x2F;&#x2F; 只会输出一个true</span><br><span class="line">false</span><br><span class="line">false</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="4-、interrupt注意事项"><a href="#4-、interrupt注意事项" class="headerlink" title="4)、interrupt注意事项"></a>4)、interrupt注意事项</h4><p>打开Thread的源码，发现: <code>isInterrupted()</code>和<code>interrupted()</code>方法都调用了同一个本地方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>其中参数<code>ClearInterrupted</code>主要用来控制是否擦除线程<code>interrupted</code>的标识</strong>。</p>
<p><code>isInterrupted()</code>方法的源码中该参数为<code>false</code>，表示不想擦除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);<span class="comment">// 表示不想擦除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>interrupted</code>静态方法中该参数则为<code>true</code>，表示想要擦除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>); <span class="comment">// 表示想要擦除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8、线程join"><a href="#8、线程join" class="headerlink" title="8、线程join"></a>8、线程join</h3>]]></content>
      <categories>
        <category>Java</category>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>Thread</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>MYSQL高级</title>
    <url>/2022/12/31/MYSQL%E9%AB%98%E7%BA%A7/</url>
    <content><![CDATA[<h1 id="MYSQL高级"><a href="#MYSQL高级" class="headerlink" title="MYSQL高级"></a>MYSQL高级</h1><ul>
<li>一、Mysql的架构介绍</li>
<li>二、索引优化分析</li>
<li>三、查询截取分析</li>
<li>四、主从复制</li>
<li>五、Mysql锁机制</li>
</ul>
<h2 id="一、Mysql的架构介绍"><a href="#一、Mysql的架构介绍" class="headerlink" title="一、Mysql的架构介绍"></a>一、Mysql的架构介绍</h2><h3 id="1、Mysql在Linux下的基本安装配置"><a href="#1、Mysql在Linux下的基本安装配置" class="headerlink" title="1、Mysql在Linux下的基本安装配置"></a>1、Mysql在Linux下的基本安装配置</h3><h4 id="1-、查看是否已经安装好"><a href="#1-、查看是否已经安装好" class="headerlink" title="1)、查看是否已经安装好"></a>1)、查看是否已经安装好</h4><p><img src="images/ad1_.png" alt="pic.png"></p>
<h4 id="2-、Mysql的启动和停止"><a href="#2-、Mysql的启动和停止" class="headerlink" title="2)、Mysql的启动和停止"></a>2)、Mysql的启动和停止</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service mysql start # 启动</span><br><span class="line">service mysql stop # 停止</span><br><span class="line"><span class="meta">#</span><span class="bash"> 另外一种启动停止的方式</span></span><br><span class="line">/etc/init.d/mysql start</span><br><span class="line">/etc/init.d/mysql stop</span><br></pre></td></tr></table></figure>

<h4 id="3-、在Linux下配置Mysql的密码"><a href="#3-、在Linux下配置Mysql的密码" class="headerlink" title="3)、在Linux下配置Mysql的密码"></a>3)、在Linux下配置Mysql的密码</h4><p>方式一(在mysql系统之外):<br>在mysql系统外:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqladmin -u root -p password &quot;test123&quot;</span><br><span class="line">Enter password: 【输入原来的密码】</span><br></pre></td></tr></table></figure>

<p>方式二(登录mysql):</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br><span class="line">Enter password: 【输入原来的密码】</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash">use mysql;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> update user <span class="built_in">set</span> password=password(<span class="string">&quot;test&quot;</span>) <span class="built_in">where</span> user=<span class="string">&#x27;root&#x27;</span>;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> flush privileges;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> <span class="built_in">exit</span>;</span>      </span><br></pre></td></tr></table></figure>

<h4 id="4-、Mysql在linux下的安装位置"><a href="#4-、Mysql在linux下的安装位置" class="headerlink" title="4)、Mysql在linux下的安装位置"></a>4)、Mysql在linux下的安装位置</h4><table>
<thead>
<tr>
<th>路径</th>
<th>解释</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>/var/lib/mysql/</td>
<td>mysql数据库文件的存放路径</td>
<td>/var/lib/mysql/</td>
</tr>
<tr>
<td>/usr/share/mysql</td>
<td>配置文件目录</td>
<td>mysql.server命令以及配置文件</td>
</tr>
<tr>
<td>/usr/bin</td>
<td>相关命令目录</td>
<td>mysqladmin mysqldump等命令</td>
</tr>
<tr>
<td>/etc/init.d/mysql</td>
<td>启停相关脚本</td>
<td></td>
</tr>
</tbody></table>
<h4 id="5-、中文乱码问题"><a href="#5-、中文乱码问题" class="headerlink" title="5)、中文乱码问题"></a>5)、中文乱码问题</h4><p>一个很重要的点: <strong>乱码问题解决是你修改完配置之后再建的新的表，之前的表还是会是乱码</strong>。</p>
<p>给一个博客讲解。</p>
<blockquote>
<p><a href="https://www.2cto.com/database/201305/215563.html">https://www.2cto.com/database/201305/215563.html</a></p>
</blockquote>
<h3 id="2、主要配置文件"><a href="#2、主要配置文件" class="headerlink" title="2、主要配置文件"></a>2、主要配置文件</h3><ul>
<li>二进制日志<code>log-bin</code> : 主从复制；</li>
<li>错误日志<code>log-error</code> : <strong>默认是关闭的</strong>，记录严重的警告和错误信息，每次启动和关闭的详细信息等；</li>
<li>查询日志<code>log</code> : 默认关闭，记录查询的<code>sql</code>语句，如果开启会减低<code>mysql</code>的整体性能，因为记录日志也是需要消耗系统资源的；</li>
<li>数据文件</li>
</ul>
<p><img src="images/ad2_%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6.png" alt="images/ad2_数据文件.png"></p>
<ul>
<li>如何配置: ①<code>windows</code>: <code>my.ini</code>文件；②<code>linux</code>: <code>/etc/my.cnf</code>文件；</li>
</ul>
<h3 id="3、Mysql逻辑架构介绍"><a href="#3、Mysql逻辑架构介绍" class="headerlink" title="3、Mysql逻辑架构介绍"></a>3、Mysql逻辑架构介绍</h3><p>Mysql逻辑架构图如下:</p>
<p><img src="images/ad3_mysql%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="images/ad3_mysql服务器逻辑架构图.png"></p>
<p>下面是mysql官网的体系图:</p>
<p><img src="images/ad4_%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84.png" alt="images/ad4_逻辑架构.pngs"></p>
<p>各层的基本概述</p>
<blockquote>
<p>1.连接层</p>
<p>最上层是一些<strong>客户端和连接服务</strong>，包含本地sock通信和大多数基于客户端/服务端工具实现的类似于<code>tcp/ip</code>的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了<strong>线程池</strong>的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p>
<p>2.服务层</p>
<p>第二层架构主要完成大多少的核心服务功能，如SQL接口，并完成<strong>缓存的查询，SQL的分析和优化及部分内置函数的执行</strong>。所有跨存储引擎的功能也在这一层实现，如<strong>过程、函数</strong>等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定查询表的顺序，是否利用索引等，最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</p>
<p>3.引擎层</p>
<p>存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过APl与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。</p>
<p>4.存储层</p>
<p>数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互。</p>
</blockquote>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>InnoDB</tag>
        <tag>MyISAM</tag>
      </tags>
  </entry>
  <entry>
    <title>The Suspects以及并查集总结</title>
    <url>/2022/11/26/The%20Suspects%E4%BB%A5%E5%8F%8A%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="The-Suspects以及并查集总结"><a href="#The-Suspects以及并查集总结" class="headerlink" title="The Suspects以及并查集总结"></a>The Suspects以及并查集总结</h2><ul>
<li>题目</li>
<li>基本并查集</li>
<li>Size优化并查集</li>
<li>Rank优化并查集</li>
<li>路径压缩优化一(最好)</li>
<li>路径压缩优化二(递归)</li>
</ul>
<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="http://poj.org/problem?id=1611">题目链接</a></h4><blockquote>
<p><a href="http://poj.org/problem?id=1611">http://poj.org/problem?id=1611</a></p>
</blockquote>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p> 就是告诉你<code>0</code>号同学被感染了，他还参加了一些社团，给出一些社团以及里面的人，问总共多少人感染。输入给出<code>n</code>表示人数(标号为<code>0~n-1</code>)，<code>m</code>表示社团数目，接下来<code>m</code>行每行第一个数<code>k</code> ，表示该社团有<code>k</code>人，然后是<code>k</code>个人的编号。要你输出有多少个人感染了病毒。</p>
<p><img src="images/uf1.png" alt="在这里插入图片描述"></p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>题目本身并不难: </p>
<ul>
<li>把每个社团加入到各自的集合中，然后不断的合并相同的集合，最后看哪些和<code>0</code>号同学在同一个集合中，使用一个变量记录和<code>0</code>号同学在同一个集合中的人数即可；</li>
<li>这里主要是总结并查集几种优化的方式；</li>
</ul>
<h3 id="基本并查集"><a href="#基本并查集" class="headerlink" title="基本并查集"></a>基本并查集</h3><p>基本并查集，记录一个每个结点p的父亲结点是<code>parent[p]</code>，然后是一个不断从孩子找父亲的过程: </p>
<ul>
<li><code>find()</code>操作，<code> while(p != parent[p])p = parent[p]</code>，一直往上找根的过程；</li>
<li><code>union()</code>操作，就是找到两个结点的根节点，然后将其中一个结点的根节点挂到另一个结点的根节点即可；</li>
</ul>
<p><font color =red>例如: <code>union()</code>操作合并6和3所在的集合:<br><img src="https://img-blog.csdn.net/20180909134516253?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionSet</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnionSet</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">            <span class="comment">/** 初始化, 每一个parent[i]指向自己, 表示每一个元素自己自成一个集合 */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> parent.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找过程, 查找元素p所对应的集合编号</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (p &lt; <span class="number">0</span> || p &gt;= parent.length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;p is out of bound.&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (p != parent[p])</span><br><span class="line">                p = parent[p];</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameSet</span><span class="params">(Integer a, Integer b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> find(b) == find(a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并元素p和元素q所属的集合</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> aRoot = find(a);</span><br><span class="line">            <span class="keyword">int</span> bRoot = find(b);</span><br><span class="line">            <span class="keyword">if</span> (aRoot == bRoot)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            parent[aRoot] = bRoot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line">        <span class="keyword">while</span> (cin.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> m = cin.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            UnionSet unionSet = <span class="keyword">new</span> UnionSet(n);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> k = cin.nextInt();</span><br><span class="line">                <span class="keyword">int</span> root = cin.nextInt();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k - <span class="number">1</span>; j++) &#123; <span class="comment">//k-1个</span></span><br><span class="line">                    <span class="keyword">int</span> x = cin.nextInt();</span><br><span class="line">                    unionSet.union(root, x); <span class="comment">//这个集合的根</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">1</span>; <span class="comment">//0号已经被感染</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (unionSet.isSameSet(<span class="number">0</span>, i)) &#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Size优化并查集"><a href="#Size优化并查集" class="headerlink" title="Size优化并查集"></a><code>Size</code>优化并查集</h3><ul>
<li>在<code>union()</code>操作中，有一种情况会使得我们的集合变得深度很深，这对查询来说是会降低效率的；</li>
<li><strong>例如下面的<code>union</code>，合并<code>3</code>和<code>9</code>所在的集合，如果我们将<code>3</code>的根<code>8</code>挂在<code>9</code>下面，会使得高度变成<code>4</code>：(不好的）</strong>；</li>
</ul>
<p><img src="https://img-blog.csdn.net/20180909134535670?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><font color =red>于是，我们的解决办法是: </font></p>
<ul>
<li><font color =red>每一个集合记录一个<code>size</code>，在<code>union()</code>操作的时候，我们将<code>size</code>小的挂到<code>size</code>大的下面，这样会使得深度稍微小一点； </font></li>
<li><font color =red>操作完之后记得维护被挂的那个集合的<code>size()</code>；</li>
</ul>
<p><img src="https://img-blog.csdn.net/20180909134546891?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionSet</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] sz;     <span class="comment">// sz[i]表示以i为根的集合中元素个数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionSet</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        sz = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="comment">/** 初始化, 每一个parent[i]指向自己, 表示每一个元素自己自成一个集合 */</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size ; i ++ ) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            sz[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p &lt; <span class="number">0</span> || p &gt;= parent.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;p is out of bound.&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(p != parent[p])</span><br><span class="line">            p = parent[p];</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameSet</span><span class="params">(Integer a, Integer b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(b) == find(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> aRoot = find(a);</span><br><span class="line">        <span class="keyword">int</span> bRoot = find(b);</span><br><span class="line">        <span class="keyword">if</span>(aRoot == bRoot)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 根据两个元素所在树的元素个数不同判断合并方向</span></span><br><span class="line"><span class="comment">         * 将元素个数少的集合合并到元素个数多的集合上</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(sz[aRoot] &lt; sz[bRoot])&#123;</span><br><span class="line">            parent[aRoot] = bRoot;</span><br><span class="line">            sz[bRoot] += sz[aRoot];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            parent[bRoot] = aRoot;</span><br><span class="line">            sz[aRoot] += sz[bRoot];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Rank优化并查集"><a href="#Rank优化并查集" class="headerlink" title="Rank优化并查集"></a><code>Rank</code>优化并查集</h3><ul>
<li><font color= red>基于<code>rank</code>的优化，其中<code>rank[i]</code>表示的是根节点为<code>i</code>的树的高度；</li>
</ul>
<p>发现问题: </p>
<ul>
<li><font color =red>虽然上面的<code>size</code>优化已经很不错，但是如果出现下面的情况，例如合并<code>0</code>和<code>3</code>所在的集合，如下，这样会使得高度变成<code>4</code>，而如果反着合并就只需要变成<code>3</code>；</li>
<li>于是我们需要记录的不是<code>size</code>，而是记录一个高度<code>rank</code>即可；</li>
</ul>
<p><img src="https://img-blog.csdn.net/20180909134703162?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><font color =red>下面是改造的做法，我们将高度小的挂在高度大的下面，这样使得深度更低；<br><img src="https://img-blog.csdn.net/20180909134731165?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionSet</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] rank;   <span class="comment">// rank[i]表示以i为根的集合所表示的树的层数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionSet</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size ; i ++ ) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            rank[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p &lt; <span class="number">0</span> || p &gt;= parent.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;p is out of bound.&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(p != parent[p])</span><br><span class="line">            p = parent[p];</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameSet</span><span class="params">(Integer a, Integer b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(b) == find(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> aRoot = find(a);</span><br><span class="line">        <span class="keyword">int</span> bRoot = find(b);</span><br><span class="line">        <span class="keyword">if</span>(aRoot == bRoot)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *根据两个元素所在树的rank不同判断合并方向</span></span><br><span class="line"><span class="comment">         *将rank低的集合合并到rank高的集合上</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(rank[aRoot] &lt; rank[bRoot])</span><br><span class="line">            parent[aRoot] = bRoot; <span class="comment">// a 挂在 b 下</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rank[bRoot] &lt; rank[aRoot])</span><br><span class="line">            parent[bRoot] = aRoot;</span><br><span class="line">        <span class="keyword">else</span> &#123;  <span class="comment">//rank[aRoot] == rank[bRoot]</span></span><br><span class="line">            parent[aRoot] = bRoot; <span class="comment">// a 挂在　b 下</span></span><br><span class="line">            rank[bRoot]++; <span class="comment">//此时维护rank的值</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="路径压缩优化一-最好"><a href="#路径压缩优化一-最好" class="headerlink" title="路径压缩优化一(最好)"></a>路径压缩优化一(最好)</h3><p>并查集另一个优化就是<font color =red>路径压缩: </font></p>
<ul>
<li>例如下面的三个集合是等价的，但是查询的效率确实逐渐的增加的，第一个查询效率最低，第三个查询效率最高；</li>
<li>我们需要做的就是在find()的时候，沿途将查找的孩子结点改变他们的父亲parent达到路径压缩的目的；</li>
</ul>
<p><img src="images/uf2.png" alt="这里写图片描述"></p>
<p><font color =red>首先来看改造成第二个版本: (使用非递归   )</p>
<ul>
<li><font color =red>这个优化就是对于沿途的结点，我们从底到上，依次更改他们的父亲结点为他们的父亲结点的父亲结点<code>(parent[p] = parent[parent[p]] )</code>；</li>
<li>例如我们查询<code>find(4)</code>，第一步，我们先将<code>parent[4] = 2</code>，（<code>2</code>就是<code>4</code>的父亲(<code>3</code>)的父亲）；</li>
</ul>
<p><img src="https://img-blog.csdn.net/20180909134753889?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<ul>
<li>继续往上，把<code>2</code>的父亲结点改为<code>2</code>的父亲结点的父亲结点，也就是<code>0</code>结点，此时我们的树结构变成了下面的样子；</li>
</ul>
<p><img src="https://img-blog.csdn.net/20180909134808127?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><strong>于是我们就完成了从第一种情况到第二种情况的优化:</strong> </p>
<p><img src="images/uf3.png" alt="这里写图片描述"></p>
<ul>
<li>代码如下： 在代码中的更改只有上一个版本中find()函数中增加了一行代码: parent[p] = parent[parent[p]]；<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionSet</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  在后续的代码中, 我们并不会维护rank的语意, 也就是rank的值在路径压缩的过程中, 有可能不在是树的层数值</span></span><br><span class="line"><span class="comment">     *  这也是我们的rank不叫height或者depth的原因, 他只是作为比较的一个标准</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] rank;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionSet</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size ; i ++ ) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            rank[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p &lt; <span class="number">0</span> || p &gt;= parent.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;p is out of bound.&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(p != parent[p]) &#123;</span><br><span class="line">            <span class="comment">/** p这个结点的父亲设置为它父亲的父亲   ,  相对于第三个版本只增加了这一行代码 */</span></span><br><span class="line">            parent[p] = parent[parent[p]];</span><br><span class="line">            p = parent[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameSet</span><span class="params">(Integer a, Integer b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(b) == find(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> aRoot = find(a);</span><br><span class="line">        <span class="keyword">int</span> bRoot = find(b);</span><br><span class="line">        <span class="keyword">if</span>(aRoot == bRoot)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rank[aRoot] &lt; rank[bRoot])</span><br><span class="line">            parent[aRoot] = bRoot;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rank[bRoot] &lt; rank[aRoot])</span><br><span class="line">            parent[bRoot] = aRoot; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[aRoot] = bRoot;</span><br><span class="line">            rank[bRoot]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="路径压缩优化二-递归"><a href="#路径压缩优化二-递归" class="headerlink" title="路径压缩优化二(递归)"></a>路径压缩优化二(递归)</h3><p><font color = red>继续完成从第一种情况到第三种情况的优化，其实核心代码只有几行: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p != parent[p])</span><br><span class="line">        parent[p] = find(parent[p]);</span><br><span class="line">    <span class="keyword">return</span> parent[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>我们宏观的就是将<code>parent[p]</code>执行了最终的那个根节点，并返回了；</strong></li>
</ul>
<p><img src="images/uf4.png" alt="这里写图片描述"><br><img src="images/uf5.png" alt="这里写图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionSet</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] rank;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionSet</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size ; i ++ ) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            rank[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p &lt; <span class="number">0</span> || p &gt;= parent.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;p is out of bound.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**和上一种路径压缩不同的是　这里使用的是递归　会将所有的孩子都直接挂在根下面*/</span></span><br><span class="line">        <span class="keyword">if</span>(p != parent[p])</span><br><span class="line">            parent[p] = find(parent[p]);</span><br><span class="line">        <span class="keyword">return</span> parent[p];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameSet</span><span class="params">(Integer a, Integer b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(b) == find(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> aRoot = find(a);</span><br><span class="line">        <span class="keyword">int</span> bRoot = find(b);</span><br><span class="line">        <span class="keyword">if</span>(aRoot == bRoot)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rank[aRoot] &lt; rank[bRoot])</span><br><span class="line">            parent[aRoot] = bRoot;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rank[bRoot] &lt; rank[aRoot])</span><br><span class="line">            parent[bRoot] = aRoot;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[aRoot] = bRoot;</span><br><span class="line">            rank[bRoot]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>POJ上测试效率对比，从下到上，从版本一到版本五的时间: </p>
<p><img src="images/uf6.png" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>UnionFind</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基础</title>
    <url>/2022/12/15/MySQL%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h1><ul>
<li><a href="#%E4%B8%80%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">一、数据库的基本操作</a><ul>
<li><a href="#1%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4">1、基本命令</a></li>
<li><a href="#2%E6%95%B0%E6%8D%AE%E5%BA%93%E5%82%A8%E5%AD%98%E5%BC%95%E6%93%8E">2、数据库储存引擎</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">二、数据表的基本操作</a><ul>
<li><a href="#1%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E8%A1%A8">1、创建数据表</a></li>
<li><a href="#2%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E8%A1%A8">2、修改数据表</a></li>
<li><a href="#3%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E8%A1%A8">3、删除数据表</a></li>
<li><a href="#4%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%E5%B0%8F%E7%BB%93">4、综合案例小结</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6">三、数据类型和运算符</a><ul>
<li><a href="#1mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D">1、MYSQL数据类型介绍</a></li>
<li><a href="#2%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">2、如何选择数据类型</a></li>
<li><a href="#3%E5%B8%B8%E8%A7%81%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BB%8B%E7%BB%8D">3、常见运算符介绍</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9Bmysql%E5%87%BD%E6%95%B0">四、Mysql函数</a></li>
<li>查询数据</li>
<li>插入、更新与删除数据</li>
<li>索引</li>
</ul>
<hr>
<h2 id="一、数据库的基本操作"><a href="#一、数据库的基本操作" class="headerlink" title="一、数据库的基本操作"></a>一、数据库的基本操作</h2><h3 id="1、基本命令"><a href="#1、基本命令" class="headerlink" title="1、基本命令"></a>1、基本命令</h3><p><strong>登陆数据库命令:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -h localhost -u root -p</span><br></pre></td></tr></table></figure>
<p><strong>创建数据库命令:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database test_db;</span><br></pre></td></tr></table></figure>
<p><strong>查看已经创建的数据库的定义</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show create database test_db;</span><br></pre></td></tr></table></figure>
<p><strong>查看已经存在的所有数据库:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure>
<p><strong>删除数据库</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> database test_db;</span><br></pre></td></tr></table></figure>
<p>注意删除数据库时要小心，不会给出提示，数据和数据表会一同删除。</p>
<h3 id="2、数据库储存引擎"><a href="#2、数据库储存引擎" class="headerlink" title="2、数据库储存引擎"></a>2、数据库储存引擎</h3><h4 id="1-、查看引擎命令"><a href="#1-、查看引擎命令" class="headerlink" title="1)、查看引擎命令"></a>1)、查看引擎命令</h4><p>使用如下命令查看系统所支持的引擎类型: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show engines;</span><br></pre></td></tr></table></figure>

<h4 id="2-、InnoDB引擎"><a href="#2-、InnoDB引擎" class="headerlink" title="2)、InnoDB引擎"></a>2)、InnoDB引擎</h4><p>InnoDB 是事务型数据库的首选引擎，<strong>支持事务安全表 (ACID ) ，支持行锁定和外键。</strong></p>
<p>InnoDB 作为<strong>默认存储引擎</strong>，特性有:</p>
<ul>
<li> InnoDB 给 MySQL 提供了<strong>具有提交、回滚和崩溃恢复能力的事务安全 (ACID 兼容)存储引擎</strong>。InnoDB 锁定在<strong>行级</strong>并且也在 SELECT 语句中提供一个类似 Oracle 的<strong>非锁定读</strong>。这些功能增加了多用户部署和性能。在 SQL 查询中，可以自由地将 <strong>InnoDB 类型的表与其他MySQL 的表的类型混合起来</strong>，甚至在同一个查询中也可以混合。</li>
<li> InnoDB 是<strong>为处理巨大数据量的最大性能设计</strong>。它的 CPU 效率可能是任何其他基于磁盘的关系数据库引擎所不能匹敌的。</li>
<li> InnoDB 存储引擎完全与 MySQL 服务器整合，I<strong>nnoDB 存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池</strong>。InnoDB <strong>将它的表和索引存在一个逻辑表空间中，表空间可以包含数个文件〈或原始磁盘分区) 。</strong>这与 MyISAM 表不同，比如在 <code>MyISAM</code> 表中每个表被存在分离的文件中。InnoDB 表可以是任何尺寸,，即使在文件尺寸被限制为 2GB 的操作系统上。</li>
<li> InnoDB <strong>支持外键完整性约束 (FOREIGN KEY)</strong> 。存储表中的数据时, 每张表的存储都按主键顺序存放, 如果没有显示在表定义时指定主键，InnoDB 会为每一行生成一个 6B 的ROWID，并以此作为主键。</li>
<li> InnoDB 被用在众多需要高性能的大型数据库站点上。</li>
<li> InnoDB 不创建目录，使用 InnoDB 时，MySQL 将在 MySQL 数据目录下创建一个名为<code>ibdata1</code> 的 10MB 大小的自动扩展数据文件，以及两个名为<code> ib_logfile0</code> 和<code>ib_logfilel</code>的 <code>5MB</code>大小的日志文件。</li>
</ul>
<p>InnoDB 不创建目录，使用 InnoDB 时，MySQL 将在 MySQL 数据目录下创建一个名为<br>ibdatal 的 10MB 大小的自动扩展数据文件，以及两个名为 ib_logfile0 和 ib_logfilel 的 SMB<br>大小的日志文件。</p>
<h4 id="3-、MyISAM引擎"><a href="#3-、MyISAM引擎" class="headerlink" title="3)、MyISAM引擎"></a>3)、MyISAM引擎</h4><p>MyISAM 基于 ISAM 的存储引擎，并对其进行扩展。它是在 <strong>Web、数据存储</strong>和其他应用<br>环境下最常使用的存储引擎之一。MyISAM 拥有较高的插入、查询速度，<strong>但不支持事务</strong>。在<br>MyISAM 主要特性有:</p>
<ul>
<li><strong>大文件</strong> (达 63 位文件长度) 在支持大文件的文件系统和操作系统上被支持。</li>
<li>当把删除、更新及插入操作混合使用的时候，动态尺寸的行产生更少碎片。这要通过合并相邻被删除的块，以及若下一个块被删除，就扩展到下一块来自动完成。</li>
<li>每个 MyISAM 表最大索引数是 64，这可以通过重新编译来改变。每个索引最大的列数是 16 个。</li>
<li>最大的键长度是 1000B，这也可以通过编译来改变。对于键长度超过 250B 的情况，一个超过 1024B 的键将被用上。</li>
<li><strong>BLOB 和TEXT 列可以被索引</strong>。</li>
<li><strong>NULL 值被允许在索引的列中。这个值占每个键的 0~1 个字节</strong>。</li>
<li>所有数字键值以高字节优先被存储以允许一个更高的索引压缩。</li>
<li>每表一个<code>AUTO_INCREMENT</code> 列的内部处理。MyISAM 为 <code>INSERT</code> 和 <code>UPDATE</code> 操作自动更新这一列。这使得 <code>AUTO_INCREMENT </code>列更快〈至少 10%) 。在序列顶的值被删除之后就不能再利用。</li>
<li>可以把<strong>数据文件和索引文件</strong>放在不同目录。</li>
<li>每个字符列可以有不同的字符集。</li>
<li>有VARCHAR 的表可以固定或动态记录长度。</li>
<li>VARCHAR 和CHAR 列可以多达 64KB。</li>
</ul>
<blockquote>
<p>使用 MyISAM 引擎创建数据库，将生产 3 个文件。文件的名字以<strong>表的名字</strong>开始，扩展名指出文件类型， <code>frm</code>文件存储表定义，数据文件的扩展名为<code>.MYD (MYData)</code>，索引文件的扩展名是<code>.MYI MYIndex)</code> 。</p>
</blockquote>
<h4 id="4-、MEMORY引擎"><a href="#4-、MEMORY引擎" class="headerlink" title="4)、MEMORY引擎"></a>4)、MEMORY引擎</h4><p>MEMORY 存储引擎<strong>将表中的数据存储到内存中，为查询和引用其他表数据提供快速访问</strong>。MEMORY 主要特性有:</p>
<ul>
<li>MEMORY 表的每个表可以有多达 32 个索引，每个索引 16 列，以及 500B 的最大键长度。     </li>
<li>MEMORY 存储引擎执行 <strong>HASH 和 BTREE</strong> 索引。</li>
<li>可以在一个MEMORY 表中有非唯一键。</li>
<li>MEMORY 表使用一个固定的记录长度格式。</li>
<li>MEMORY 不支持BLOB 或TEXT 列。</li>
<li>MEMORY 支持 <code>AUTO_INCREMENT</code> 列和<strong>对可包含NULL 值的列的索引</strong>。</li>
<li>MEMORY 表在所有客户端之间共享 (就像其他任何非 TEMPORARY 表) 。</li>
<li><strong>MEMORY 表内容被存在内存中，内存是 MEMORY 表和服务器在查询处理时的空闲中创建的内部表共享</strong>。</li>
<li>当不再需要 MEMORY 表的内容时，<strong>要释放被 MEMORY 表使用的内存</strong>，应该执行<code>DELETE FROM</code> 或TRUNCATE TABLE，或者删除整个表 〈使用DROP TABLE) 。</li>
</ul>
<h4 id="5-、存储引擎的选择"><a href="#5-、存储引擎的选择" class="headerlink" title="5)、存储引擎的选择"></a>5)、存储引擎的选择</font></h4><p>不同存储引擎都有各自的特点，以适应不同的需求。下面是各种引擎的不同的功能: </p>
<p><img src="images/1_%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E9%80%89%E6%8B%A9.png"></p>
<ul>
<li><p>如果要提供提交、回滚和崩溃恢复能力的<strong>事务安全</strong> (ACID 兼容) 能力，并要求实现<strong>并发控制</strong>，InnoDB 是个很好的选择；</p>
</li>
<li><p>如果数据表主要用来<strong>插入和查询记录</strong>，则 MyISAM 引擎能提供较<strong>高的处理效率</strong>；</p>
</li>
<li><p>如果只是<strong>临时存放数据</strong>，数据量不大，并且<strong>不需要较高的数据安全性</strong>，可以选择将<strong>数据保存在内存中</strong>的 Memory 引擎，MySQL 中使用该引擎作为临时表，存放查询的中间结果；</p>
</li>
<li><p>如果只有 <strong>INSERT 和 SELECT 操作</strong>，可以选择 Archive 引擎，Archive 存储引擎支持高并发的插入操作，但是本身<strong>并不是事务安全</strong>的。Archive 存储引擎非常适合<strong>存储归档数据</strong>，如记录日志信息可以使用 Archive 引擎。</p>
</li>
</ul>
<p>使用哪一种引擎要根据需要灵活选择, 一个数据库中多个表可以使用不同引擎以满足各种性能和实际需求。使用合适的存储引擎，将会提高整个数据库的性能。</p>
<blockquote>
<p> 顺便说一下<code>Mysql</code>中单行注释是<code>#</code>，而不是<code>--</code>。</p>
</blockquote>
<hr>
<h2 id="二、数据表的基本操作"><a href="#二、数据表的基本操作" class="headerlink" title="二、数据表的基本操作"></a>二、数据表的基本操作</h2><h3 id="1、创建数据表"><a href="#1、创建数据表" class="headerlink" title="1、创建数据表"></a>1、创建数据表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use test_db;</span><br><span class="line">create table tb_emp1</span><br><span class="line">(</span><br><span class="line">	id int(11),</span><br><span class="line">	name varchar(15),</span><br><span class="line">	deptID int(11),</span><br><span class="line">	salary 	float</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>使用下面语句查看此数据库存在的表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure>
<h4 id="1-、主键约束"><a href="#1-、主键约束" class="headerlink" title="1)、主键约束"></a>1)、主键约束</h4><blockquote>
<p> 主键，又称主码，是表中<strong>一列或多列的组合</strong>。主键约束〈Primary Key Constraint) 要求<strong>主键列的数据唯一，并且不允许为空<code>!= null</code><strong>。主键能够唯一地标识表中的一条记录，可以结合外键</strong>来定义不同数据表之间的关系</strong>， 并且可以加快数据库查询的速度。主键和记录之间的关系如同身份证和人之间的关系，它们之间是一一对应的。主键分为两种类型: <strong>单字段主键和多字段联合主键。</strong></p>
</blockquote>
<ul>
<li>单字段主键；</li>
<li>在定义完所有列之后定义主键；</li>
<li>多字段联合主键；</li>
</ul>
<p>单字段约束: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table tb_emp2</span><br><span class="line">(</span><br><span class="line">	id int(11) primary key,</span><br><span class="line">	name varchar(15),</span><br><span class="line">	deptID int(11),</span><br><span class="line">	salary 	float</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>后面约束: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table tb_emp3</span><br><span class="line">(</span><br><span class="line">	id int(11),</span><br><span class="line">	name varchar(15),</span><br><span class="line">	deptID int(11),</span><br><span class="line">	salary 	float,</span><br><span class="line">	primary key(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>联合约束：假设没有主键<code>id</code>，可以通过<code>name</code>和<code>deptID</code>来确定一个唯一的员工。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table tb_emp4</span><br><span class="line">(</span><br><span class="line">	id int(11),</span><br><span class="line">	name varchar(15),</span><br><span class="line">	deptID int(11),</span><br><span class="line">	salary 	float,</span><br><span class="line">	primary key(name,deptID)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="2-、外键约束"><a href="#2-、外键约束" class="headerlink" title="2)、外键约束"></a>2)、外键约束</h4><ul>
<li>外键用来在两个表的数据之间建立链接， 它可以是一列或者多列。一个表可以有一个或多个外键。<strong>外键对应的是参照完整性</strong>，一个表的外键可以为空值，<strong>若不为空值，则每一个外键值必须等于另一个表中主键的某个值。</strong></li>
<li>外键 : 首先它是表中的一个字段，<strong>它可以不是本表的主键，但对应另外一个表的主键。外键主要作用是保证数据引用的完整性， 定义外键后</strong>，不允许删除在另一个表中具有关联关系的行。外键的作用是保持数据的一致性、完整性。例如，部门表 <code>tb_dept </code>的主键是<code>id</code>，在员工表<code>tb_emp5</code>中有一个键 <code>deptId</code> 与这个<code> id</code> 关联。</li>
</ul>
<p>有关主表和从表:</p>
<ul>
<li><p>主表(父表) : 对于两个具有关联关系的表而言，相关联字段中<strong>主键所在的那个表</strong>即是主表。</p>
</li>
<li><p>从表(子表) : 对于两个具有关联关系的表而言，相关联字段中<strong>外键所在的那个表</strong>即是从表。</p>
</li>
</ul>
<p>需要注意: </p>
<ul>
<li><u>子表的外键必须要关联父表的<strong>主键</strong></u>；</li>
<li><strong>相关联的数据类型必须匹配</strong>；</li>
<li><strong>先删子表，再删父表</strong>；</li>
</ul>
<p>下面的例子**tb_emp5(员工表)中的deptID关联部门表中的ID(主键)**：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;父表</span><br><span class="line">create table tb_dept1</span><br><span class="line">(</span><br><span class="line">	id int(11)primary key,</span><br><span class="line">	name varchar(22) not null,</span><br><span class="line">	location varchar(50)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;子表</span><br><span class="line">create table tb_emp5</span><br><span class="line">(</span><br><span class="line">	id int(11) primary key,</span><br><span class="line">	name varchar(25),</span><br><span class="line">	deptID int(11),</span><br><span class="line">	salary float,</span><br><span class="line">	constraint fk_emp5_dept foreign key(deptID) references tb_dept1(id)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="3-、非空约束"><a href="#3-、非空约束" class="headerlink" title="3)、非空约束"></a>3)、非空约束</h4><p>非空约束指定的字段不能为空，如果添加数据的时候没有指定值，会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table tb_emp6</span><br><span class="line">(</span><br><span class="line">	id int(11) primary key,</span><br><span class="line">	name varchar(15) not null,</span><br><span class="line">	deptID int(11),</span><br><span class="line">	salary 	float</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="4-、唯一性约束"><a href="#4-、唯一性约束" class="headerlink" title="4)、唯一性约束"></a>4)、唯一性约束</h4><ul>
<li>唯一性要求该列唯一；</li>
<li><strong>允许为空，但只能出现一个空值；</strong></li>
<li>唯一性可以确保一列或几列不出现重复值；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table tb_dept2</span><br><span class="line">(</span><br><span class="line">	id int(11)primary key,</span><br><span class="line">	name varchar(22) unique,</span><br><span class="line">	location varchar(50)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table tb_dept3</span><br><span class="line">(</span><br><span class="line">	id int(11)primary key,</span><br><span class="line">	name varchar(22),</span><br><span class="line">	location varchar(50),</span><br><span class="line">	constraint N_uq unique(name)  #N_uq是约束名</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>注意<code>UNIQUE</code>和主键约束(<code>PRIMARY KEY </code>)的区别:</strong> </p>
<ul>
<li> <u>一个表中可以有多个字段声明为<code>UNIQUE</code>，但只能有一个<code>PRIMARY KEY</code> 声明；</u></li>
<li> <u>声明为 <code>PRIMAY KEY</code> 的列不允许有空值，但是声明为 <code>UNIQUE</code>的字段允许空值 (NULL) 的存在。</u></li>
</ul>
<h4 id="5-、默认约束"><a href="#5-、默认约束" class="headerlink" title="5)、默认约束"></a>5)、默认约束</h4><p>指定了默认约束之后，如果没有指定值，就用默认的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table tb_emp7</span><br><span class="line">(</span><br><span class="line">	id int(11) primary key,</span><br><span class="line">	name varchar(15) not null,</span><br><span class="line">	deptID int(11) default 111,</span><br><span class="line">	salary 	float</span><br><span class="line">); </span><br></pre></td></tr></table></figure>
<h4 id="6-、设置表的属性自加"><a href="#6-、设置表的属性自加" class="headerlink" title="6)、设置表的属性自加"></a>6)、设置表的属性自加</h4><ul>
<li>在数据库应用中，经常希望在每次插入新记录时，系统自动生成字段的主键值。可以通过为表主键添加<code>AUTO_INCREMENT</code> 关键字来实现。</li>
<li>默认的，在MySQL 中 <code>AUTO _INCREMENT</code>的初始值是 1，每新增一条记录，字段值自动加 1。</li>
<li><strong>一个表只能有一个字段使用AUTO_INCREMENT 约束，且该字段必须为主键的一部分。</strong></li>
<li><code>AUTO_INCREMENT </code>约束的字段可以是任何整数类型 (TINYINT、SMALLIN、INT、BIGINT 等) 。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table tb_emp8</span><br><span class="line">(</span><br><span class="line">	id int(11) primary key auto_increment,</span><br><span class="line">	name varchar(15) not null,</span><br><span class="line">	deptID int(11),</span><br><span class="line">	salary 	float</span><br><span class="line">); </span><br></pre></td></tr></table></figure>
<h4 id="7-、查看表的结构"><a href="#7-、查看表的结构" class="headerlink" title="7)、查看表的结构"></a>7)、查看表的结构</h4><p><code>desc</code>可以查看表的字段名，数据类型，是否为主键，是否默认值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">desc tb_emp8;</span><br></pre></td></tr></table></figure>
<p>效果如图</p>
<p><img src="images/2_desc%E6%9F%A5%E7%9C%8B%E7%BB%93%E6%9E%9C.png" alt="这里写图片描述"></p>
<p>查看表的详细结构，可以看储存引擎，和字符编码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show create table tb_emp8;</span><br></pre></td></tr></table></figure>
<h3 id="2、修改数据表"><a href="#2、修改数据表" class="headerlink" title="2、修改数据表"></a>2、修改数据表</h3><h4 id="1-、修改表名"><a href="#1-、修改表名" class="headerlink" title="1)、修改表名"></a>1)、修改表名</h4><p>将表<code>tb_dept3</code>改为<code>tb_deptment3</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table tb_dept3 rename tb_deptment3;</span><br></pre></td></tr></table></figure>
<p>查看数据库中的表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure>
<p>修改表名不会改变结构，<code>desc</code>前后结果一样。</p>
<h4 id="2-、修改字段的数据类型"><a href="#2-、修改字段的数据类型" class="headerlink" title="2)、修改字段的数据类型"></a>2)、修改字段的数据类型</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 修改表字段的数据类型,把name列的数据类型改为varchar(33)</span><br><span class="line">alter table tb_dept1 modify name varchar(33);</span><br></pre></td></tr></table></figure>
<h4 id="3-、修改字段名"><a href="#3-、修改字段名" class="headerlink" title="3)、修改字段名"></a>3)、修改字段名</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 修改表的字段名,不改数据类型 将tb_dept1中的location字段改成loc</span><br><span class="line">alter table tb_dept1 change location loc varchar(50);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 修改表的字段名,并且改变数据类型, 同时改变数据类型</span><br><span class="line">alter table tb_dept1 change loc location varchar(60);</span><br></pre></td></tr></table></figure>
<p><code>change</code>也可以只改变数据类型，但是一般不要<strong>轻易改变数据类型</strong>。</p>
<h4 id="4-、添加字段"><a href="#4-、添加字段" class="headerlink" title="4)、添加字段"></a>4)、添加字段</h4><p>有三种添加方式:</p>
<ul>
<li>①默认在最后面添加；</li>
<li>②在第一个位置添加<code>first</code>；</li>
<li>③和指定的位置添加<code>after</code>；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 添加字段(默认在最后面添加)</span><br><span class="line">alter table tb_dept1 add managerID int(10);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 添加字段(默认在最后面添加)(非空约束)</span><br><span class="line">alter table tb_dept1 add column1 int(10) not null;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 添加字段(在第一个位置添加)</span><br><span class="line">alter table tb_dept1 add column2 int(10) first;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 添加字段(在指定位置后面添加)</span><br><span class="line">alter table tb_dept1 add column3 int(10) after name;</span><br></pre></td></tr></table></figure>
<h4 id="5-、删除字段"><a href="#5-、删除字段" class="headerlink" title="5)、删除字段"></a>5)、删除字段</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 删除字段, 删除tb_dept1的column3字段</span><br><span class="line">alter table tb_dept1 drop column3;</span><br></pre></td></tr></table></figure>
<h4 id="6-、修改字段的排列位置"><a href="#6-、修改字段的排列位置" class="headerlink" title="6)、修改字段的排列位置"></a>6)、修改字段的排列位置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 修改字段的排列位置(改到第一个位置)</span><br><span class="line">alter table tb_dept1 modify column1 int(10) first;</span><br><span class="line"># 修改字段的位置为指定的位置</span><br><span class="line">alter table tb_dept1 modify column2 int(10) after name;</span><br></pre></td></tr></table></figure>
<h4 id="7-、更改表的储存引擎"><a href="#7-、更改表的储存引擎" class="headerlink" title="7)、更改表的储存引擎"></a>7)、更改表的储存引擎</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看数据表的定义</span><br><span class="line">show create table tb_deptment3;</span><br><span class="line"># 更改数据表的引擎</span><br><span class="line">alter table tb_deptment3 engine &#x3D; MyISAM;</span><br></pre></td></tr></table></figure>
<h4 id="8-、删除表的外键约束"><a href="#8-、删除表的外键约束" class="headerlink" title="8)、删除表的外键约束"></a>8)、删除表的外键约束</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table tb_emp9</span><br><span class="line">(</span><br><span class="line">	id int(11)primary key,</span><br><span class="line">	deptID int(11),</span><br><span class="line">	name varchar(25),</span><br><span class="line">	salary float,</span><br><span class="line">	constraint fk_emp9_dept foreign key(deptID) references tb_dept1(id)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 删除外键约束</span><br><span class="line">alter table tb_emp9 drop foreign key fk_emp9_dept;</span><br></pre></td></tr></table></figure>
<h3 id="3、删除数据表"><a href="#3、删除数据表" class="headerlink" title="3、删除数据表"></a>3、删除数据表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 删除表</span><br><span class="line">drop table if exists tb_emp9;</span><br></pre></td></tr></table></figure>
<p>注意注意: <strong>删除有关联的数据表的父表的时候，先删除外键再删除父表</strong></p>
<h3 id="4、综合案例小结"><a href="#4、综合案例小结" class="headerlink" title="4、综合案例小结"></a>4、综合案例小结</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database company;</span><br><span class="line">use company;</span><br><span class="line">create table offices</span><br><span class="line">(</span><br><span class="line">	officeCode int(10) primary key not null unique,</span><br><span class="line">	city varchar(50) not null,</span><br><span class="line">	address varchar(50),</span><br><span class="line">	country varchar(50) not null,</span><br><span class="line">	postalCode varchar(15) unique</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">create table employees</span><br><span class="line">(</span><br><span class="line">	employeeNumber int(11) primary key not null unique auto_increment,</span><br><span class="line">	lastName varchar(50) not null,</span><br><span class="line">	firstName varchar(50) not null,</span><br><span class="line">	mobile varchar(25) unique,</span><br><span class="line">	officeCode int(10) not null,</span><br><span class="line">	jobTitle varchar(50) not null,</span><br><span class="line">	birth datetime not null,</span><br><span class="line">	note varchar(255),</span><br><span class="line">	sex varchar(5)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">show tables;</span><br><span class="line">desc employees;</span><br><span class="line"></span><br><span class="line">#将mobile字段修改到officeCode后面</span><br><span class="line">alter table employees modify mobile varchar(25) after officeCode;</span><br><span class="line">#将birth的字段名改为employee_birth</span><br><span class="line">alter table employees change birth employee_birth datetime;</span><br><span class="line">#修改sex字段为char(1)类型，非空约束</span><br><span class="line">alter table employees modify sex char(1) not null;</span><br><span class="line">#删除字段note </span><br><span class="line">alter table employees drop note;</span><br><span class="line">#增加字段名</span><br><span class="line">alter table employees add favoriate_activity varchar(100);</span><br><span class="line"></span><br><span class="line">#为employee增加一个外键</span><br><span class="line">alter table employees add constraint fk_em_off foreign key(officeCode) references offices(officeCode);</span><br><span class="line"></span><br><span class="line">#删除表的外键约束</span><br><span class="line">alter table employees drop foreign key fk_em_off;</span><br><span class="line"></span><br><span class="line">#更改employee的数据引擎</span><br><span class="line">alter table employees engine &#x3D; MyISAM;</span><br><span class="line"></span><br><span class="line">#更改employee的表名</span><br><span class="line">alter table employees rename employees_info;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="三、数据类型和运算符"><a href="#三、数据类型和运算符" class="headerlink" title="三、数据类型和运算符"></a>三、数据类型和运算符</h2><h3 id="1、MYSQL数据类型介绍"><a href="#1、MYSQL数据类型介绍" class="headerlink" title="1、MYSQL数据类型介绍"></a>1、MYSQL数据类型介绍</h3><p>数据类型主要有下面几种</p>
<p>MySQL 支持多种数据类型，主要有<strong>数值类型、日期/时间类型和字符串类型</strong>。</p>
<ul>
<li>数值数据类型: 包括整数类型 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT；浮点小数数据类型 FLOAT 和 DOUBLE；定点小数类型 DECIMAL 。</li>
<li> 日期/时间类型: 包括 YEAR、TIME、DATE、DATETIME 和TIMESTAMP。</li>
<li>字符串类型: 包括 CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM 和 SET 等。字符串类型又分为<strong>文本字符串和二进制字符串</strong>。</li>
</ul>
<h4 id="1-、整数类型"><a href="#1-、整数类型" class="headerlink" title="1)、整数类型"></a>1)、整数类型</h4><p>整数数据类型主要有一下几种：</p>
<p><img src="images/3_%E6%95%B4%E5%BD%A2.png"></p>
<p>不同的数据类型取值范围如下：</p>
<p><img src="images/4_%E6%95%B4%E5%BD%A2%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4.png" alt="在这里插入图片描述"></p>
<p>注意<code>INT</code>(<code>num</code>)中的数和取值范围无关。</p>
<p>举例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table tb_emp1&#123;</span><br><span class="line">	id INT(11),</span><br><span class="line">	name VARCHAR(25),</span><br><span class="line">	deptId INT(11),</span><br><span class="line">	salary FLOAT</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>id </code>字段的数据类型为 INT(11)，注意到后面的数字 11，这表示的是该数据类型指定的显示宽度，指定能够显示的数值中数字的个数。例如，假设声明一个 INT 类型的字段:<code>year INT(4)</code>该声明指明，在 year 字段中的数据一般只显示 4 位数字的宽度。在这里要注意: <strong>显示宽度和数据类型的取值范围是无关的</strong>。显示宽度只是指明 MySQL最大可能显示的数字个数，数值的位数小鱼指定的宽度时会由空格填充。</p>
<h4 id="2-、浮点数类型和定点数类型"><a href="#2-、浮点数类型和定点数类型" class="headerlink" title="2)、浮点数类型和定点数类型"></a>2)、浮点数类型和定点数类型</h4><p>小数类型:</p>
<table>
<thead>
<tr>
<th>类型名称</th>
<th>说明</th>
<th>存储需求</th>
</tr>
</thead>
<tbody><tr>
<td>FLOAT</td>
<td>单精度浮点数</td>
<td>4个字节</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>双精度浮点数</td>
<td>8个字节</td>
</tr>
<tr>
<td>DECIMAL(M, D), DEC</td>
<td>压缩的”严格”<strong>定点数</strong></td>
<td>M+2个字节</td>
</tr>
</tbody></table>
<p>DECIMAL 类型不同于 FLOAT 和 DOUBLE，DECIMAL 实际是以<strong>串</strong>存放的，DECIMAL可能的最大取值范围与 DOUBLE 一样，<strong>但是其有效的取值范围由M 和 D 的值决定</strong>。如果改变 M 而固定D，则其取值范围将随 M 的变大而变大。从表中可以看到，DECIMAL 的存储空间并不是固定的，而由<strong>其精度值 M</strong> 决定，占用 M+2 个字节。</p>
<p>FLOAT 类型的取值范围如下:</p>
<ul>
<li>有符号的取值范围: <code>-3.402823466E+38 ~ -1.175494351E-38</code>。</li>
<li>无符号的取值范围: <code>0</code> 和 <code>1.175494351E-38 ~ 3.402823466E+38</code>。</li>
</ul>
<p>DOUBLE 类型的取值范围如下:</p>
<ul>
<li>有符号的取值范围: <code>-1.7976931348623157E+308 ~ -2.2250738585072014E-308</code>。</li>
<li>无符号的取值范围: <code>0</code> 和 <code>2.2250738585072014E-308 ~ 1.7976931348623157E+308</code>。</li>
</ul>
<p>注意: <strong>不论定点还是浮点类型，如果用户指定的精度超出精度范围，则会四舍五入进行处理。</strong></p>
<p>注意浮点数和定点数的使用场合：</p>
<ul>
<li>在MySQL 中，<strong>定点数以字符串形式存储</strong>，在对精度要求比较高的时候〈如货币，科学数据等) 使用 DECIMAL 的类型比较好；</li>
<li>另外两个浮点数进行减法和比较运算时也容易出问题，<strong>所以在使用浮点型时需要注意，并尽量避免做浮点数比较。</strong></li>
</ul>
<h4 id="3-、时间和日期类型"><a href="#3-、时间和日期类型" class="headerlink" title="3)、时间和日期类型"></a>3)、时间和日期类型</h4><p><img src="images/5_%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F.png" alt="在这里插入图片描述"></p>
<h5 id="a-、Year"><a href="#a-、Year" class="headerlink" title="a)、Year"></a>a)、Year</h5><p><img src="images/6_%E6%97%A5%E6%9C%9FDate.png" alt="在这里插入图片描述"></p>
<p>举几个例子:</p>
<ul>
<li><strong><code>0</code>表示<code>0000</code>，<code>‘0’</code>和<code>‘00’</code>表示<code>2000</code>；</strong></li>
<li>**<code>‘78’</code>和<code>78</code>表示<code>1978</code>，<code>‘68’</code>和<code>68</code>表示<code>2068</code>**；</li>
</ul>
<h5 id="b-、Time"><a href="#b-、Time" class="headerlink" title="b)、Time"></a>b)、Time</h5><p><img src="images/7_%E6%97%B6%E9%97%B4Time.png" alt="在这里插入图片描述"></p>
<p>案例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table tmp4(t Time);</span><br><span class="line">delete from tmp4;</span><br><span class="line">insert into tmp4 values(&#39;10:05:05&#39;),(&#39;23:23&#39;),(&#39;2 10:10&#39;),(&#39;3 02&#39;),(&#39;10&#39;),(now()),(current_time);</span><br></pre></td></tr></table></figure>
<p>效果</p>
<p><img src="images/8_%E6%BC%94%E7%A4%BA%E6%8F%92%E5%85%A5%E7%BB%93%E6%9E%9C.png" alt="这里写图片描述"></p>
<h5 id="c-、Date"><a href="#c-、Date" class="headerlink" title="c)、Date"></a>c)、Date</h5><p><img src="images/9_Date%E6%97%A5%E6%9C%9F.png" alt="在这里插入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table tmp5(d Date);</span><br><span class="line">insert into tmp5 values(&#39;1998-09-01&#39;),(&#39;19980902&#39;),(&#39;980903&#39;),(19980904),(980905),(100906),(000907),(current_date);</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="images/10_%E6%BC%94%E7%A4%BA%E7%BB%93%E6%9E%9C.png" alt="这里写图片描述"></p>
<h5 id="d-、DateTime"><a href="#d-、DateTime" class="headerlink" title="d)、DateTime"></a>d)、DateTime</h5><p><img src="images/11_DateTime.png" alt="在这里插入图片描述"></p>
<p>举例:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tmp6(dt DateTime);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp6 <span class="keyword">values</span>(<span class="string">&#x27;1998-08-08 08:08:08&#x27;</span>),(<span class="string">&#x27;19980809080808&#x27;</span>),(<span class="string">&#x27;98-08-08 08:08:08&#x27;</span>),(<span class="string">&#x27;980808080808&#x27;</span>),(<span class="number">19980808080808</span>),(<span class="number">980808080808</span>);</span><br></pre></td></tr></table></figure>
<p>效果</p>
<p><img src="images/12_%E6%BC%94%E7%A4%BA%E6%95%88%E6%9E%9C.png" alt="这里写图片描述"></p>
<h5 id="e-、TimeStamp"><a href="#e-、TimeStamp" class="headerlink" title="e)、TimeStamp"></a>e)、TimeStamp</h5><p><img src="images/13_TimeStamp.png"></p>
<p><code>TimeStamp</code>把时区修改之后查询结果就会不同，但是<code>DateTime</code>不会。</p>
<h4 id="4-、文本字符串类型"><a href="#4-、文本字符串类型" class="headerlink" title="4)、文本字符串类型"></a>4)、文本字符串类型</h4><p><img src="images/14_%E6%96%87%E6%9C%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B.png" alt="在这里插入图片描述"></p>
<h5 id="a-、char和varchar类型"><a href="#a-、char和varchar类型" class="headerlink" title="a)、char和varchar类型"></a>a)、<code>char</code>和<code>varchar</code>类型</h5><p><code>char</code>数据类型长度不可变，<code>varchar</code>长度可变</p>
<p><img src="images/15_char%E5%92%8Cvarchar.png" alt="在这里插入图片描述"></p>
<p>举例:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tmp8(ch <span class="type">char</span>(<span class="number">4</span>),vch <span class="type">varchar</span>(<span class="number">4</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp8 <span class="keyword">values</span>(<span class="string">&#x27;ab  &#x27;</span>,<span class="string">&#x27;ab  &#x27;</span>);<span class="comment">-- 注意这里有空格</span></span><br><span class="line"><span class="keyword">select</span> concat(<span class="string">&#x27;(&#x27;</span>,ch,<span class="string">&#x27;)&#x27;</span>),concat(<span class="string">&#x27;(&#x27;</span>,vch,<span class="string">&#x27;)&#x27;</span>) <span class="keyword">from</span> tmp8;</span><br></pre></td></tr></table></figure>
<p>看效果<code>vch</code>中的空格没有被截取(即<code>ch</code>末尾的两个空格被删除了，而<code>vch</code>的没有删除)<br><img src="images/16_char%E5%92%8Cvarchar2.png" alt="这里写图片描述"></p>
<h5 id="b-、Text类型"><a href="#b-、Text类型" class="headerlink" title="b)、Text类型"></a>b)、Text类型</h5><p>TEXT 列保存<strong>非二进制字符串</strong>，如文章内容、评论等。当保存或查询 TEXT 列的值时，不删除尾部空格。Text 类型分为 4 种: TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。不同的 TEXT 类型的存储空间和数据长度不同。</p>
<ul>
<li><p>TINYTEXT 最大长度为 255(2<sup>8</sup> - 1)字符的 TEXT 列；</p>
</li>
<li><p>TEXT 最大长度为 65535(2<sup>16</sup> - 1)字符的TEXT 列；</p>
</li>
<li><p>MEDIUMTEXT 最大长度为 16777215(2<sup>24</sup> - 1)字符的TEXT列；</p>
</li>
<li><p>LONGTEXT 最大长度为 4294967295 或 4GB(2<sup>32</sup> - 1)字符的TEXT 列；</p>
</li>
</ul>
<h5 id="c-、Enum类型"><a href="#c-、Enum类型" class="headerlink" title="c)、Enum类型"></a>c)、<code>Enum</code>类型</h5><p>ENUM 是一个字符串对象，其值为表创建时在列规定中枚举的一列值。语法格式如下:’’</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字段名 ENUM(&#39;值1&#39;, &#39;值2&#39;, ..., &#39;值n&#39;)</span><br></pre></td></tr></table></figure>

<p>字段名指将<strong>要定义的字段</strong>，值n指枚举列表中的第 n 个值。 ENUM 类型的字段在取值时，只能在指定的枚举列表中取，而且一次只能取一个。如果创建的成员中有空格时，其尾部的空格将自动被删除。ENUM 值在内部用整数表示，每个枚举值均有一个索引值: <strong>列表值所允许的成员值从 1 开始编号</strong>，MySQL 存储的就是这个索引编号。枚举最多可以有 65 535 个元素。</p>
<p>例如定义 ENUM 类型的列(first，’second’，’third)，该列可以取的值和每个值的索引如表所示:</p>
<p><img src="images/17_emum.png"></p>
<p>举例:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tmp9(enm Enum(<span class="string">&#x27;first&#x27;</span>,<span class="string">&#x27;second&#x27;</span>,<span class="string">&#x27;third&#x27;</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp9 <span class="keyword">values</span>(<span class="string">&#x27;first&#x27;</span>),(<span class="string">&#x27;second&#x27;</span>),(<span class="string">&#x27;third&#x27;</span>),(<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">select</span> enm,enm<span class="operator">+</span><span class="number">0</span> <span class="keyword">from</span> tmp9;</span><br></pre></td></tr></table></figure>
<p><img src="images/18_%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png" alt="这里写图片描述"><br>再看一个实例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tmp10(soc <span class="type">int</span> ,level enum(<span class="string">&#x27;excellent&#x27;</span>,<span class="string">&#x27;good&#x27;</span>,<span class="string">&#x27;bad&#x27;</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp10 <span class="keyword">values</span>(<span class="number">70</span>,<span class="string">&#x27;good&#x27;</span>),(<span class="number">90</span>,<span class="number">1</span>),(<span class="number">75</span>,<span class="number">2</span>),(<span class="number">50</span>,<span class="number">3</span>); #<span class="string">&#x27;excellent&#x27;</span>,<span class="string">&#x27;good&#x27;</span>,<span class="string">&#x27;bad&#x27;</span><span class="comment">--&gt;对应 1，2，3</span></span><br><span class="line"><span class="keyword">select</span> soc,level,level<span class="operator">+</span><span class="number">0</span> <span class="keyword">from</span> tmp10;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp10 <span class="keyword">values</span>(<span class="number">100</span>,<span class="number">4</span>); #没有<span class="number">4</span>这个选项</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="images/19_%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C2.png" alt="这里写图片描述"></p>
<h5 id="d-、Set类型"><a href="#d-、Set类型" class="headerlink" title="d)、Set类型"></a>d)、Set类型</h5><p>SET 是一个字符串对象，可以有零或多个值，SET 列最多可以有 64 个成员，其值为表创建时规定的一列值。指定包括多个 SET 成员的 SET 列值时，各成员之间用逗号<code>(, )</code>间隔开。语法格式如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET(&#39;值1&#39;, &#39;值2&#39;, ... &#39;值n&#39;)</span><br></pre></td></tr></table></figure>

<p>与 ENUM 类型相同，SET 值在内部用整数表示，<strong>列表中每一个值都有一个索引编号</strong>。当创建表时，SET 成员值的尾部空格将自动被删除。但与 ENUM 类型不同的是，ENUM 类型的字段只能从定义的列值中选择一个值插入，而 SET 类型的列可从定义的列值中选择多个字符的联合。</p>
<p>如果插入 SET 字段中列值有重复，则 <strong>MySQL 自动删除重复的值</strong>，<strong>插入 SET 字段的值的顺序并不重要</strong>，MySQL 会在存入数据库时，按照定义的顺序显示；如果插入了不正确的值，默认情况下，MySQL 将忽视这些值，并给出警告。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 自动排序去重</span><br><span class="line">create table tmp11(s set(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;));  # 只能插入a,b,c,d这四个值</span><br><span class="line">insert into tmp11 values(&#39;a&#39;),(&#39;a,b,a&#39;),(&#39;c,a,d&#39;);</span><br><span class="line">select *from tmp11;</span><br></pre></td></tr></table></figure>
<p>效果</p>
<p><img src="images/20_SET%E6%B5%8B%E8%AF%95.png" alt="这里写图片描述"></p>
<hr>
<h4 id="5-、二进制字符串类型"><a href="#5-、二进制字符串类型" class="headerlink" title="5)、二进制字符串类型"></a>5)、二进制字符串类型</h4><p><img src="images/21_%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B.png" alt="这里写图片描述"></p>
<h5 id="a-、Bit类型"><a href="#a-、Bit类型" class="headerlink" title="a)、Bit类型"></a>a)、Bit类型</h5><p>保存的是数的二进制表示:</p>
<p>BIT 类型是位字段类型。M 表示每个值的位数，范围为 1-64。如果 M 被省略，默认为 1。如果为 BIT(M)列分配的值的长度小于 M 位，在值的左边用 0填充。例如，为 BIT(6)列分配一个值<code>b&#39;101&#39;</code>，其效果与分配 <code>b&#39;000101&#39;</code>相同。<strong>BIT 数据类型用来保存位字段值</strong>，例如: 以二进制的形式保存数据 13，13 的二进制形式为 1101，在这里需要位数至少为<code>4</code>位的 BIT 类型，即可以定义列类型为 BIT(4)。大于二进制 1111 的数据是不能插入 BIT(4)类型的字段中的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#bit</span><br><span class="line">create table tmp12(b bit(4));</span><br><span class="line">insert into tmp12 values(2),(9),(15);</span><br><span class="line">insert into tmp12 values(16);#报错，只能存到0-15</span><br><span class="line">select b,b+0 from tmp12;</span><br></pre></td></tr></table></figure>
<p>效果</p>
<p><img src="images/22_Bit%E7%B1%BB%E5%9E%8B.png" alt="这里写图片描述"></p>
<h5 id="b-、Binary和varBinary"><a href="#b-、Binary和varBinary" class="headerlink" title="b)、Binary和varBinary"></a>b)、Binary和varBinary</h5><p>BINARY 类型的长度是固定的 指定长度之后 不足最大长度的 将在它们右边填充 <code>&quot;\0&quot;</code>补齐以达到指定长度。例如: 指定列数据类型为 BINARY(3)，当插入“a”时，存储的内容实际为<code>“a\0\0”</code>，当插入<code>“ab”</code>时，实际存储的内容为<code>“ab\0”</code>，不管存储的内容是否达到指定的长度，其存储空间均为指定的值 M。</p>
<p>VARBINARY 类型的长度是可变的，指定好长度之后，其长度可以在 0 到最大值之间。例如: 指定列数据类型为 VARBINARY(20)，如果插入的值的长度只有 10，则实际存储空间为 10 加 1，即其实际占用的空间为字符串的实际长度加 1。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#binary和varbinary</span><br><span class="line">create table tmp13(b binary(3),vb varbinary(30));</span><br><span class="line">insert into tmp13 values(5,5);</span><br><span class="line">select length(b),length(vb) from tmp13;</span><br></pre></td></tr></table></figure>
<p>效果如图:</p>
<p><img src="images/23_%E6%95%88%E6%9E%9C.png" alt="这里写图片描述"></p>
<h5 id="c-、Blob类型"><a href="#c-、Blob类型" class="headerlink" title="c)、Blob类型"></a>c)、Blob类型</h5><p>BLOB是一个二进制大对象，用来存储可变数量的数据。有四种类型: TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB。</p>
<p>**BLOB列存储的是二进制字符串(字节字符串)，TEXT存储的是非二进制字符串(字符字符串)**。</p>
<hr>
<h3 id="2、如何选择数据类型"><a href="#2、如何选择数据类型" class="headerlink" title="2、如何选择数据类型"></a>2、如何选择数据类型</h3><h4 id="1-、整数和浮点数"><a href="#1-、整数和浮点数" class="headerlink" title="1)、整数和浮点数"></a>1)、整数和浮点数</h4><p>如果不需要小数部分，则使用整数来保存数据；</p>
<p>如果需要表示小数部分，则使用浮点数类型。对于浮点数据列，存入的数值会对该列定义的小数位<strong>进行四舍五入</strong>。 例如，如果列的值的范围为 1-99999, 若使用整数，则MEDIUMINT UNSIGNED 是最好的类型，若需要存储小数，则使用 FLOAT 类型。</p>
<p>浮点类型包括 FLOAT 和 DOUBLE 类型。DOUBLE 类型精度比 FLOAT 类型高，因此，如要求存储精度较高时，应选择 DOUBLE 类型。</p>
<h4 id="2-、浮点数和定点数"><a href="#2-、浮点数和定点数" class="headerlink" title="2)、浮点数和定点数"></a>2)、浮点数和定点数</h4><p>浮点数FLOAT、DOUBLE 相对于定点数 DECIMAL 的优势是: <strong>在长度一定的情况下, 浮点数能表示更大的数据范围</strong>，但是由于浮点数容易产生误差。</p>
<p><strong>因此对精确度要求比较高时，建议使用DECIMAL 来存储</strong>。DECIMAL 在 MySQL 中是以<strong>字符串存储</strong>的，用于定义货币等对精确度要求较高的数据。另外<strong>两个浮点数进行减法和比较运算时也容易出问</strong>题，因此在进行计算的时候，一定要小心。如果进行<strong>数值比较，最好使用 DECIMAL 类型</strong>。</p>
<h4 id="3-、日期和时间类型"><a href="#3-、日期和时间类型" class="headerlink" title="3)、日期和时间类型"></a>3)、日期和时间类型</h4><p>MySQL 对于不同种类的日期和时间有很多的数据类型，比如 YEAR 和 TIME。如果只需要记录年份，则使用YEAR 类型即可； 如果只记录时间，只需使用TIME 类型。</p>
<p><strong>如果同时需要记录日期和时间，则可以使用 TIMESTAMP 或者 DATETIME 类型</strong>。由于TIMESTAMP 列的取值范围小于 DATETIME 的取值范围，<strong>因此存储范围较大的日期最好使用DATETIME</strong>。</p>
<p>TIMESTAMP 也有一个DATETIME 不具备的属性。默认的情况下，当插入一条记录但并没有指定 TIMESTAMP 这个列值时，MySQL 会把 TIMESTAMP 列设为当前的时间。<strong>因此当需要插入记录同时插入当前时间</strong>时，使用TIMESTAMP 是方便的，另外 TIMESTAMP 在空间上比 DATETIME 更有效。</p>
<h4 id="4-、char和varchar"><a href="#4-、char和varchar" class="headerlink" title="4)、char和varchar"></a>4)、char和varchar</h4><p>char和varchar的区别:</p>
<ul>
<li><p>char是固定长度字符，varchar是可变长度字符；</p>
</li>
<li><p>CHAR 会自动删除插入数据的尾部空格，VARCHAR 不会删除尾部空格。</p>
</li>
</ul>
<p>CHAR 是固定长度，<strong>所以它的处理速度比 VARCHAR 的速度要快</strong>，但是它的缺点就是浪费存储空间。所以对存储不大，但在速度上有要求的可以使用 CHAR 类型，反之可以使用VARCHAR 类型来实现。</p>
<p>存储引擎对于选择 CHAR 和 VARCHAR 的影响:</p>
<ul>
<li>对于MYyISAM 存储引擎: 最好使用固定长度(<code>char</code>)的数据列代替可变长度的数据列。这样可以使整个表静态化，从而使数据检索更快，用空间换时间。</li>
<li>对于 InnoDB 存储引擎: 使用可变长度(<code>varchar</code>)的数据列，因为 InnoDB 数据表的存储格式不分固定长度和可变长度，因此使用 CHAR 不一定比使用 VARCHAR 更好，但由于VARCHAR 是按照实际的长度存储，比较节省空间，所以对磁盘 IO 和数据存储总量比较好。</li>
</ul>
<h4 id="5-、ENUM和SET"><a href="#5-、ENUM和SET" class="headerlink" title="5)、ENUM和SET"></a>5)、ENUM和SET</h4><p><strong>ENUM 只能取单值</strong>, 它的数据列表是一个<strong>枚举集合</strong>。它的合法取值列表最多允许有 65 535个成员。因此，在需要从<strong>多个值中选取一个</strong>时，可以使用 ENUM。比如: 性别字段适合定义为 ENUM 类型，每次只能从“男”或“女”中取一个值。</p>
<p><strong>SET 可取多值</strong>。它的合法取值列表最多允许有 64 个成员。空字符串也是一个合法的 SET值。在需要<strong>取多个值的时候</strong>，适合使用 SET 类型，比如: 要存储一个人兴趣爱好，最好使用SET 类型 。</p>
<p><strong>ENUM 和 SET 的值是以字符串形式出现的，但在内部，MySQL 以数值的形式存储它们</strong>。</p>
<h4 id="6-、BLOB和TEXT"><a href="#6-、BLOB和TEXT" class="headerlink" title="6)、BLOB和TEXT"></a>6)、BLOB和TEXT</h4><p><strong>BLOB 是二进制字符串，TEXT 是非二进制字符串</strong>，两者均可存放大容量的信息。BLOB主要存储图片、音频信息等，而 TEXT 只能存储纯文本文件。</p>
<hr>
<h3 id="3、常见运算符介绍"><a href="#3、常见运算符介绍" class="headerlink" title="3、常见运算符介绍"></a>3、常见运算符介绍</h3><h4 id="1-、运算符概述"><a href="#1-、运算符概述" class="headerlink" title="1)、运算符概述"></a>1)、运算符概述</h4><p>总共有四大类: </p>
<ol>
<li>算术运算符</li>
</ol>
<p>算术运算符用于各类数值运算，包括加 (+) 、减 (-) 、乘 (+) 、除 (/) 、求余(或称模运算，%) 。</p>
<ol start="2">
<li>比较运算符</li>
</ol>
<p>比较运算符用于比较运算。包括大于 (&gt;) 、小于 (&lt;) 、等于 (=) 、大于等于 (&gt;=) 、小于等于 (&lt;=) 、不等于 (!=) ，以及<code>IN、BETWEEN AND、IS NULL、GREATEST、LEAST、LIKE、REGEXP </code>等。</p>
<ol start="3">
<li>逻辑运算符</li>
</ol>
<p>逻辑运算符的求值所得结果均为1 (TRUE) 、0 (FALSE) ，这类运算符有逻辑非 (NOT或者!) 、逻辑与 (AND 或者&amp;&amp;) 、逻辑或 (OR 或者|) 、逻辑异或 C(XOR) 。</p>
<ol start="4">
<li>位操作运算符</li>
</ol>
<p>位操作运算符参与运算的操作数按二进制位进行运算。包括位与(&amp;) 、位或 (|) 、位非(~) 、位异或 (^) 、左移 (&lt;&lt;) 、右移 (&gt;&gt;) 6种。</p>
<h4 id="2-、算数运算符"><a href="#2-、算数运算符" class="headerlink" title="2)、算数运算符"></a>2)、算数运算符</h4><p>没啥好说的就是<code>+、－、*、/、%</code>。</p>
<h4 id="3-、比较运算符"><a href="#3-、比较运算符" class="headerlink" title="3)、比较运算符"></a>3)、比较运算符</h4><p>注意一下比较运算符</p>
<p><img src="images/24_%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6.png" alt="这里写图片描述"></p>
<p>数值比较有如下规则:</p>
<ul>
<li>若有一个或两个参数为NULL，则比较运算的结果为NULL；</li>
<li>若同一个比较运算中的两个参数都是字符串，则按照字符串进行比较；</li>
<li>若两个参数均为整数，则按照整数进行比较；</li>
<li><strong>若一个字符串和数字进行相等判断，则 MySQL 可以自动将字符串转换为数字</strong>；</li>
</ul>
<p><strong>安全等于运算符</strong></p>
<p>这个操作符和=操作符执行相同的比较操作，不过<code>&lt;=&gt;</code>可以用来判断 NULL 值。在两个操作数均为NULL 时，其返回值为 1 而不为NULL；而当一个操作数为 NULL 时，其返回值为0而不为NULL。</p>
<p><code>&lt;=&gt;</code>在执行比较操作时和<code>&quot;=&quot;</code>的作用是相似的，唯一的区别是<code>&lt;=&gt;</code>可以来对NULL进行判断，两者都为NULL时返回<code>1</code>。</p>
<p><strong>不等于运算符<code>&lt;&gt;</code>或者<code>!=</code></strong>:</p>
<p><code>&quot;&lt;&gt;&quot;</code>或者<code>&quot;!=&quot;</code>用于判断数字、字符串、表达式不相等的判断。如果不相等，返回值为 1； 否则返回值为 0。这两个运算符不能用于判断空值 NULL。</p>
<p><strong>LEAST运算符</strong></p>
<p>语法格式为: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LEAST(值 1,值 2…,值m)</span><br></pre></td></tr></table></figure>

<p>其中值 <code>n</code> 表示参数列表中有<code>n</code>个值。在有两个或多个参数的情况下, 返回最小值。假如任意一个自变量为NULL,则<code>LEAST()</code>的返回值为<code>NULL</code>。</p>
<p><strong>GREATEST</strong></p>
<p>语法格式：<code>GREATEST(值1, 值2, 值3)</code> ，其中<code>n</code>表示参数列表中有<code>n</code>个值。当有<code>2</code>个或多个参数时，返回为最大值，假如任意一个自变量为NULL，则<code>GREATEST()</code>的返回值为NULL。\</p>
<p><strong>LIKE</strong></p>
<p><img src="images/26_LIKE.png" alt="这里写图片描述"></p>
<p><strong>正则表达式REGEXP</strong></p>
<p><img src="images/27_REGEXP.png" alt="这里写图片描述"></p>
<p>看一个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select &#39;ssky&#39; regexp &#39;^s&#39;,&#39;ssky&#39; regexp &#39;y$&#39;, &#39;ssky&#39; regexp &#39;.sky&#39;, &#39;ssky&#39; regexp &#39;[ab]&#39;;</span><br></pre></td></tr></table></figure>
<p>效果</p>
<p><img src="images/25_%E6%AD%A3%E5%88%99%E7%BB%93%E6%9E%9C.png" alt="这里写图片描述">s</p>
<h4 id="4-、逻辑运算符"><a href="#4-、逻辑运算符" class="headerlink" title="4)、逻辑运算符"></a>4)、逻辑运算符</h4><p>和高级语言差不多，不赘述。</p>
<h4 id="5-、位运算"><a href="#5-、位运算" class="headerlink" title="5)、位运算"></a>5)、位运算</h4><p>和高级语言差不多，不赘述。</p>
<h4 id="6-、运算符优先级"><a href="#6-、运算符优先级" class="headerlink" title="6)、运算符优先级"></a>6)、运算符优先级</h4><p><img src="images/28_%E4%BC%98%E5%85%88%E7%BA%A7.png"></p>
<h3 id="4、综合案例-运算符的使用"><a href="#4、综合案例-运算符的使用" class="headerlink" title="4、综合案例-运算符的使用"></a>4、综合案例-运算符的使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table tmp15(note varchar(100),price int);</span><br><span class="line">insert into tmp15 values(&quot;Thisisgood&quot;,50);</span><br><span class="line">#算术运算符</span><br><span class="line">select price,price+10,price-10,price*2,price&#x2F;2,price%3 from tmp15;</span><br><span class="line">#比较运算符</span><br><span class="line">select price,price&gt;10,price&lt;10,price !&#x3D; 10,price &#x3D; 10,price &lt;&#x3D;&gt;10,price &lt;&gt;10 from tmp15;</span><br><span class="line"># in, greatest等</span><br><span class="line">select price,price between 30 and 80,greatest(price,70,30),price in(10,20,50,35) from tmp15;</span><br><span class="line"># 正则等</span><br><span class="line">select note,note is null,note like &#39;t%&#39;,note regexp &#39;$y&#39;,note regexp &#39;[gm]&#39; from tmp15;</span><br><span class="line"># 逻辑运算</span><br><span class="line">select price,price&amp;2,price|4, ~price from tmp15;</span><br><span class="line"># 位运算</span><br><span class="line">select price,price&lt;&lt;2,price&gt;&gt;2 from tmp15;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="四、Mysql函数"><a href="#四、Mysql函数" class="headerlink" title="四、Mysql函数"></a>四、Mysql函数</h2><p>###数学函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#绝对值，π，平方根，去余函数(适用小数)</span><br><span class="line">select abs(-1),pi(),sqrt(9),Mod(31,8),Mod(45.5,6);</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414100041110?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#获取整数的函数</span><br><span class="line">select ceil(-3.5),ceiling(3.5),floor(-3.5),floor(3.5);</span><br></pre></td></tr></table></figure>
<p>效果<img src="https://img-blog.csdn.net/20180414100448562?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#获取随机数的函数</span><br><span class="line">select rand(),rand(),rand(10),rand(10);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdn.net/20180414100756428?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#Round函数(四舍五入函数)，truncate()函数</span><br><span class="line">select round(3.4),(3.6),round(3.16,1),round(3.16,0),round(232.28,-1),truncate(1.31,1),truncate(1.99,1),truncate(19.99,-1);</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414101532820?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#符号函数，幂运算函数pow,power,exp()&#x2F;&#x2F;e的x乘方</span><br><span class="line">select sign(-21),sign(0),sign(21),pow(2,2),power(2,-2),exp(2);</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414101833603?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#自然对数运算和以10为底的对数运算,弧度，角度 radians角度转弧度，弧度转角度</span><br><span class="line">select log(3),log(-3),log10(100),log10(-100),radians(180),degrees(pi()&#x2F;2);</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414102846475?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#正弦函数余弦函数</span><br><span class="line">select sin(pi()&#x2F;2),degrees(asin(1)),cos(pi()),degrees(acos(-1)),round(tan(pi()&#x2F;4)),degrees(atan(1)),cot(pi()&#x2F;4);</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414103636239?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>###字符串函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#字符串函数,concat_ws忽略空值null</span><br><span class="line">select char_length(&#39;aab&#39;),length(&#39;aabb&#39;),concat(&#39;My sql &#39;,&#39;5.7&#39;),concat(&#39;My&#39;,null,&#39;sql&#39;),concat_ws(&#39;-&#39;,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;),concat_ws(&#39;*&#39;,&#39;aa&#39;,null,&#39;bb&#39;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/2018041410443992?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#替换字符串的函数</span><br><span class="line">select insert(&#39;Quest&#39;,2,4,&#39;What&#39;) as Coll,insert(&#39;Quest&#39;,-1,4,&#39;What&#39;) as Coll2,insert(&#39;Quest&#39;,3,100,&#39;Wh&#39;) as Coll3;</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414110146458?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#大小写转换,获取指定长度字符串的函数left,right;</span><br><span class="line">select lower(&#39;ZHENGXIN&#39;),lcase(&#39;ZHENGXIN&#39;),upper(&#39;zhengxin&#39;),ucase(&#39;zhengxin&#39;),left(&#39;football&#39;,5),right(&#39;football&#39;,5);</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414110548833?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#填充字符串的函数,删除空格的函数</span><br><span class="line">select lpad(&#39;hello&#39;,4,&#39;*&#39;),lpad(&#39;hello&#39;,10,&#39;*&#39;),</span><br><span class="line">rpad(&#39;hello&#39;,10,&#39;*&#39;),concat(&#39;(&#39;,ltrim(&#39;   book   &#39;),&#39;)&#39;),</span><br><span class="line">concat(&#39;(&#39;,rtrim(&#39;   book   &#39;),&#39;)&#39;),</span><br><span class="line">concat(&#39;(&#39;,trim(&#39;   book   &#39;),&#39;)&#39;),</span><br><span class="line">trim(&#39;xy&#39; from &#39;xyxyabababxyxy&#39;);</span><br></pre></td></tr></table></figure>
<hr>
<p>效果<br><img src="https://img-blog.csdn.net/20180414112006326?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#重复生成,空格函数，替换函数，比较大小的函数</span><br><span class="line">select repeat(&#39;mysql&#39;,3),concat(&#39;(&#39;,space(6),&#39;)&#39;),</span><br><span class="line">replace(&#39;xxx.baidu.com&#39;,&#39;x&#39;,&#39;w&#39;),strcmp(&#39;abc&#39;,&#39;abd&#39;);</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414133734950?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#获取字串的函数</span><br><span class="line">select substring(&#39;breakfast&#39;,5) as coll,</span><br><span class="line">substring(&#39;breakfast&#39;,3,5) as coll2,</span><br><span class="line">substring(&#39;breakfast&#39;,-3) as coll3, #从后面开始截取3个</span><br><span class="line">substring(&#39;breakfast&#39;,-1,4) as coll4; #从结尾开始第一个位置截取四个</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414134457483?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><font color = crimson>注意还有一个MID函数和substring作用是一样的</font></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#匹配字串开始的位置,字符串逆序</span><br><span class="line">select locate(&#39;ball&#39;,&#39;football&#39;),position(&#39;ball&#39;in&#39;football&#39;),</span><br><span class="line">instr(&#39;football&#39;,&#39;ball&#39;),reverse(&#39;abc&#39;);</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414140015303?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#返回指定位置的值,返回指定字符串的位置的函数</span><br><span class="line">select elt(3,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;),elt(2,&#39;a&#39;),</span><br><span class="line">field(&#39;Hi&#39;,&#39;hihi&#39;,&#39;Hey&#39;,&#39;Hi&#39;,&#39;bas&#39;) as coll,</span><br><span class="line">field(&#39;Hi&#39;,&#39;hihi&#39;,&#39;a&#39;,&#39;b&#39;) as coll2,</span><br><span class="line">find_in_set(&#39;Hi&#39;,&#39;hihi,Hey,Hi,bas&#39;); #返回字串位置的函数</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414141233663?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#make_set()函数的使用</span><br><span class="line">select make_set(1,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;) as coll,#0001选第一个</span><br><span class="line">make_set(1|4, &#39;hello&#39;,&#39;nice&#39;,&#39;word&#39;) as coll2, #0001 0100--&gt;0101 --&gt;选第一和第三</span><br><span class="line">make_set(1|4,&#39;hello&#39;,&#39;nice&#39;,null,&#39;word&#39;) as coll3,#0001 0100--&gt;0101 --&gt;选第一和第三</span><br><span class="line">make_set(0,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;) as coll4; </span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414142118936?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<p>###日期和时间函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#获取日期时间函数</span><br><span class="line">select current_date(),curdate(),curdate()+0,</span><br><span class="line">current_time(),curtime(),curtime()+0,</span><br><span class="line">current_timestamp(),localtime(),now(),sysdate();</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414142607410?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#获取时间的数字,根据时间获取日期(互为反函数)</span><br><span class="line">select unix_timestamp(),unix_timestamp(now()),now(),</span><br><span class="line">from_unixtime(1523689758);</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414151053533?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#返回当前时区日期和时间的函数,日期月份时间函数</span><br><span class="line">select utc_time(),utc_time()+0,</span><br><span class="line">utc_date(),utc_date()+0,</span><br><span class="line">month(&#39;2016-03-04&#39;),monthname(&#39;2016-03-04&#39;),</span><br><span class="line">dayname(&#39;2018-04-14&#39;),dayofweek(&#39;2018-04-14&#39;),</span><br><span class="line">weekday(&#39;2018-04-14&#39;);</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414152120121?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>注意dayofweek和weekday的差别<br><img src="https://img-blog.csdn.net/20180414152202919?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180414152209424?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#返回是这一年的第几周</span><br><span class="line">select week(&#39;2018-4-16&#39;),#默认0表示第一天从周末开始</span><br><span class="line">week(&#39;2018-04-16&#39;,1), #周一#返回是这一年的第几周</span><br><span class="line">dayofyear(&#39;2018-4-16&#39;),dayofmonth(&#39;2018-4-14&#39;), #返回一年中的第几天</span><br><span class="line">year(&#39;2018-4-14&#39;),quarter(&#39;2018-4-14&#39;),</span><br><span class="line">minute(&#39;10:10:02&#39;),second(&quot;10:10:02&quot;);</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414161034181?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#获取指定日期的指定值的函数</span><br><span class="line">select extract(year from &#39;2018-07-06&#39;) as coll,</span><br><span class="line">extract(year_month from &#39;2018-08-06&#39;) as coll2,</span><br><span class="line">extract(day_minute from &#39;2018-07-06 10:11:05&#39;) as coll3;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414161511106?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#时间和秒钟转换的函数</span><br><span class="line">select time_to_sec(&#39;01:00:40&#39;),</span><br><span class="line">sec_to_time(3600);</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414174423286?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#计算日期和时间的函数</span><br><span class="line">select date_add(&#39;2010-12-31 23:59:59&#39;,interval 1 second) as coll,</span><br><span class="line">adddate(&#39;2010-12-31 23:59:59&#39;,interval 1 second) as coll2,</span><br><span class="line">date_add(&#39;2010-12-31 23:59:59&#39;,interval &#39;0:0:1&#39; hour_second) as coll3, #后面的hour_second要看表决定</span><br><span class="line">date_sub(&#39;2011-01-02&#39;,interval 31 day) as coll4,</span><br><span class="line">subdate(&#39;2011-01-02&#39;,interval 31 day) as coll5,</span><br><span class="line">date_sub(&#39;2011-01-02 00:01:00&#39;,interval &#39;0 0:1:1&#39; day_second) as coll6; #对应位置的相减</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414174708360?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#直接输入两个时间，计算</span><br><span class="line">select addtime(&#39;2000-12-31 23:59:59&#39;,&#39;1:1:1&#39;) as coll,</span><br><span class="line">subtime(&#39;2000-12-31 23:59:59&#39;,&#39;1:1:1&#39;)as coll2,</span><br><span class="line">datediff(&#39;2000-12-28&#39;,&#39;2001-01-03&#39;) as coll3; #前面的减后面的</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdn.net/20180414175044280?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>注意看表<br><img src="https://img-blog.csdn.net/20180414174815850?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<p>#####日期和时间格式化的函数<br><img src="https://img-blog.csdn.net/2018041417493265?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180414174940784?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180414174950614?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#时间日期格式化函数</span><br><span class="line">select date_format(&#39;1997-10-04 22:23:00&#39;,&#39;%W %M %Y&#39;) as coll,</span><br><span class="line">date_format(&#39;1997-10-04 22:23:00&#39;,&#39;%D %y %a %d %m %b %j&#39;),</span><br><span class="line">time_format(&#39;16:00:00&#39;,&#39;%H %k %h %I %l&#39;),</span><br><span class="line">date_format(&#39;2000-10-05 22:23:00&#39;,get_format(date,&#39;USA&#39;));</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdn.net/20180414175142523?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>###条件约束函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#条件约束函数</span><br><span class="line">select if(1&gt;2,2,3),</span><br><span class="line">ifNull(null,10),ifNull(1&#x2F;0,100),</span><br><span class="line">case 2 when 1 then &#39;one&#39; when 2 then &#39;two&#39; when 3 then &#39;three&#39; else &#39;more&#39; end, #2等于后面的2返回后面的then</span><br><span class="line">case when 1&gt;2 then &#39;a&#39; else &#39;b&#39; end;</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414190109796?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>###系统信息函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#系统信息函数</span><br><span class="line">select version(),connection_id(),#版本号，连接次数</span><br><span class="line">database(),schema(), #查看当前的数据库名</span><br><span class="line">user(),current_user(),system_user(),session_user();</span><br><span class="line">show processlist;#输出当前用户的连接信息</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414190945328?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#获取字符串的字符集和排列方式的函数</span><br><span class="line">select charset(&#39;abc&#39;),charset(convert(&#39;abc&#39; using latin1)),</span><br><span class="line">charset(version()), #获取字符集</span><br><span class="line">collation(&#39;abc&#39;),collation(convert(&#39;abc&#39; using utf8));#获取排列方式</span><br></pre></td></tr></table></figure>
<p>效果<br>还要注意Last_insert_id最后自动生成的ID值<br><img src="https://img-blog.csdn.net/20180414194735908?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>###加/解密函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#加密解密函数</span><br><span class="line">select password(&#39;newpwd&#39;),MD5(&#39;mypwd&#39;), </span><br><span class="line">encode(&#39;secret&#39;,&#39;cry&#39;),length(encode(&#39;secret&#39;,&#39;cry&#39;)),</span><br><span class="line">decode(encode(&#39;secret&#39;,&#39;cry&#39;),&#39;cry&#39;);#加密后解密</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414195439560?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>###其他函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#其他函数</span><br><span class="line">select format(123.1234,2),format(123.1,3),format(123.123,0),#格式化函数</span><br><span class="line">#不同进制数之间的转换</span><br><span class="line">conv(&#39;a&#39;,16,2),conv(15,10,2),conv(15,10,8),conv(15,10,16);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdn.net/20180414200512674?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#IP地址与数字相互转换的函数</span><br><span class="line">select inet_aton(&#39;209.207.224.40&#39;),inet_ntoa(3520061480),</span><br><span class="line">#枷锁函数和解锁函数</span><br><span class="line">get_lock(&#39;lock1&#39;,10),#这个锁持续10秒</span><br><span class="line">is_used_lock(&#39;lock1&#39;),  #返回当前连接ID</span><br><span class="line">is_free_lock(&#39;lock1&#39;), #是否是可用的</span><br><span class="line">release_lock(&#39;lock1&#39;);</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414201609394?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#重复执行指定操作的函数</span><br><span class="line">select benchmark(5000,password(&#39;newpad&#39;)),</span><br><span class="line">charset(&#39;abc&#39;),charset(convert(&#39;abc&#39; using latin1)),#改变字符集的函数</span><br><span class="line">cast(100 as char(2)),convert(&#39;2010-10-11 12:12:12&#39;,time);#改变数据类型的函数</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414202751518?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>###综合案列-Mysql函数的使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select round(rand() * 10),round(rand() * 10),round(rand() * 10);#产生三个1-10之间的随机数</span><br><span class="line">select pi(),sin(pi()),cos(0),round(tan(pi()&#x2F;4)),floor(cot(pi()&#x2F;4));</span><br><span class="line"></span><br><span class="line">create database test_db3;</span><br><span class="line">use test_db3;</span><br><span class="line">show tables;</span><br><span class="line">create table member</span><br><span class="line">(</span><br><span class="line">	m_id int(11) primary key auto_increment,</span><br><span class="line">	m_FN varchar(15),</span><br><span class="line">	m_LN varchar(15),</span><br><span class="line">	m_brith datetime,</span><br><span class="line">	m_info varchar(15) null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into member values(null,&#39;Halen&#39;,&#39;Park&#39;,&#39;1970-06-29&#39;,&#39;GoodMan&#39;);</span><br><span class="line"></span><br><span class="line">select length(m_FN),#返回m_FN的长度</span><br><span class="line">concat(m_FN,m_LN),#返回第一条记录中的全名</span><br><span class="line">lower(m_info),#将m_info转换成小写</span><br><span class="line">reverse(m_info) from member;</span><br><span class="line"></span><br><span class="line">select year(curdate())-year(m_brith) as age,#计算年龄</span><br><span class="line">dayofyear(m_brith) as days,</span><br><span class="line">date_format(m_brith,&#39;%W %D %M %Y&#39;) as birthDate from member;</span><br><span class="line"></span><br><span class="line">insert into member values(null,&#39;Samuel&#39;,&#39;Green&#39;,now(),null);</span><br><span class="line"></span><br><span class="line">select last_insert_id(); #输出最后插入的自增的编号</span><br><span class="line"></span><br><span class="line">select m_brith,case when year(m_brith) &lt; 2000 then &#39;old&#39; </span><br><span class="line">when year(m_brith) &gt; 2000 then &#39;young&#39; </span><br><span class="line">else &#39;not born&#39; end as status from member;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>InnoDB</tag>
        <tag>MyISAM</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树之Morris遍历</title>
    <url>/2022/07/05/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8BMorris%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="二叉树之Morris遍历"><a href="#二叉树之Morris遍历" class="headerlink" title="二叉树之Morris遍历"></a>二叉树之Morris遍历</h2><ul>
<li>递归理解以及<code>morris</code>遍历</li>
<li>由<code>morris</code>遍历改成前序遍历</li>
<li>由<code>morris</code>遍历改成中序遍历</li>
<li>由<code>morris</code>遍历改成后续遍历</li>
<li>完整测试代码</li>
</ul>
<hr>
<h3 id="递归理解以及morris遍历"><a href="#递归理解以及morris遍历" class="headerlink" title="递归理解以及morris遍历"></a>递归理解以及<code>morris</code>遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rec</span><span class="params">(Node head)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    System.out.print(head.value + <span class="string">&quot; &quot;</span>); <span class="comment">//这里打印就是前序遍历</span></span><br><span class="line">    rec(head.left);</span><br><span class="line">    System.out.print(head.value + <span class="string">&quot; &quot;</span>); <span class="comment">//这里打印就是中序遍历</span></span><br><span class="line">    rec(head.right);</span><br><span class="line">    System.out.print(head.value + <span class="string">&quot; &quot;</span>); <span class="comment">//这里打印就是后续遍历</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是我们用递归写的三种遍历方法，如果是下面的例子，上面程序输出如下：</p>
<p><img src="images/morris1.png" alt="这里写图片描述"></p>
<p>程序输出:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">4</span> <span class="number">4</span> <span class="number">2</span> <span class="number">5</span> <span class="number">5</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">5</span> <span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">6</span> <span class="number">10</span> <span class="number">10</span> <span class="number">10</span> <span class="number">6</span> <span class="number">6</span> <span class="number">3</span> <span class="number">7</span> <span class="number">11</span> <span class="number">11</span> <span class="number">11</span> <span class="number">7</span> <span class="number">7</span> <span class="number">3</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>可以看到，每一个结点都会被访问三次，也就是说，访问的过程中，每一个结点都会经过三次；</strong></li>
<li><strong>一个结点如果没有<code>parent</code>指针或者我们在非递归遍历中使用栈，是不能回到它的父节点的；</strong></li>
<li><strong>而<code>morris</code>就是借助叶子结点的空闲指针帮助我们想办法回到父亲结点，省去了递归的空间，或者栈的空间，达到<code>O(1)</code>空间；</strong></li>
</ul>
<p>每个结点来到三次: </p>
<p><img src="images/morris2.png" alt="在这里插入图片描述"></p>
<p>下面介绍<code>morris</code>遍历规则(现在和前、中、后序无关，就是<code>morris</code>序):</p>
<p><img src="images/morris3.png" alt="这里写图片描述"></p>
<p>流程看下图的举例:</p>
<p><img src="images/morris4.png" alt="这里写图片描述"> </p>
<p><img src="images/morris5.png" alt="这里写图片描述"></p>
<p>按照上面的解释可以完全写出下面的<code>morris</code>遍历过程(没有打印)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morris</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node mostRight = <span class="keyword">null</span>;<span class="comment">//左子树上最右的结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        mostRight = cur.left;   <span class="comment">//cur的第一个左结点</span></span><br><span class="line">        <span class="keyword">if</span>(mostRight != <span class="keyword">null</span>)&#123;  <span class="comment">//如果左子树不为空</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != cur)&#123; <span class="comment">//找到最右边的结点 有两种情况</span></span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(mostRight.right == <span class="keyword">null</span>)&#123; <span class="comment">//第一次来到这个结点  满足第二大条中的第一条</span></span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">//  cur = cur.left 直接结束所有的</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">//第二次来到这个结点         满足第二大条中的第二条</span></span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.right;  <span class="comment">//包括两种情况的 左子树为空和第二次来到这个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="由morris遍历改成前序遍历"><a href="#由morris遍历改成前序遍历" class="headerlink" title="由morris遍历改成前序遍历"></a>由<code>morris</code>遍历改成前序遍历</h3><p>需要注意几点: </p>
<ul>
<li>首先可以肯定是第一次来到这个结点的时候打印，所以是当<code>mostRight.right == null</code>(第一次来的时候，打印当前的<code>cur</code>)；</li>
<li><strong>其次，如果一个结点没有左子树，相当于只会来到结点一次，就直接打印一遍就可以了；</strong></li>
<li><strong>其实这样的做法等同于在递归的时候把打印的行为放在第一次来到这个结点的时候；</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morrisPre</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node mostRight = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        mostRight = cur.left;</span><br><span class="line">        <span class="keyword">if</span>(mostRight != <span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != cur)&#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(mostRight.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                System.out.print(cur.value + <span class="string">&quot; &quot;</span>);   <span class="comment">//先序是第一次来到这个结点的时候打印</span></span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;    <span class="comment">//如果一个结点没有左子树  相当于只会来到这个结点一次  直接打印，然后往右走</span></span><br><span class="line">            System.out.print(cur.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="由morris遍历改成中序遍历"><a href="#由morris遍历改成中序遍历" class="headerlink" title="由morris遍历改成中序遍历"></a>由<code>morris</code>遍历改成中序遍历</h3><p>中序更加简单: </p>
<ul>
<li>如果一个结点有左子树，那么我打印的时机是我遍历完左子树之后的打印，也就是第二次来到这个结点时候打印，也就是<code>mostRight.right = cur</code>的时候打印；</li>
<li>如果一个结点没有左子树，那么本来也要打印一下，打印完就往右边窜了；</li>
<li>本质就是不论怎么样要处理玩左子树才打印根结点；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morrisIn</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node mostRight = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        mostRight = cur.left;</span><br><span class="line">        <span class="keyword">if</span>(mostRight != <span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != cur)&#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(mostRight.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(cur.value + <span class="string">&quot; &quot;</span>);<span class="comment">//这里包括两种情况 没有左子树和有左子树的第二次来到这里打印</span></span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="由morris遍历改成后续遍历"><a href="#由morris遍历改成后续遍历" class="headerlink" title="由morris遍历改成后续遍历"></a>由<code>morris</code>遍历改成后续遍历</h3><p>后续遍历比较麻烦:  因为<code>morris</code>只会来到一个结点两次，但是递归会来到一个结点三次: </p>
<p>主要看以下几点: </p>
<ul>
<li>我们只关心那些有左子树，也就是会到一个结点两次的结点；</li>
<li>逆序打印有左子树结点的左子树的右边界；</li>
<li>最后打印整棵树的右边界的逆序；</li>
</ul>
<p><img src="images/morris6.png" alt="这里写图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//morris后续</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morrisPos</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node mostRight = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        mostRight = cur.left;</span><br><span class="line">        <span class="keyword">if</span>(mostRight != <span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != cur)&#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(mostRight.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">//第二次来的时候</span></span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">                printEdge(cur.left); <span class="comment">//打印左子树的右边界</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    printEdge(head); <span class="comment">//最后打印整棵树的右边界</span></span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印边界</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printEdge</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先逆序边界</span></span><br><span class="line">    Node tail = reverseEdge(head);</span><br><span class="line">    <span class="comment">//打印</span></span><br><span class="line">    Node cur = tail;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.print(cur.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再逆序回来</span></span><br><span class="line">    reverseEdge(tail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有点类似链表的逆序</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Node <span class="title">reverseEdge</span><span class="params">(Node cur)</span> </span>&#123;</span><br><span class="line">    Node pre = <span class="keyword">null</span>;</span><br><span class="line">    Node next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        next = cur.right;<span class="comment">//先保存下一个</span></span><br><span class="line">        cur.right = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>完整测试代码(例子就是上面的例子): </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Morris</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">createTree</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= arr.length || arr[i] == -<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Node head = <span class="keyword">new</span> Node(arr[i]);</span><br><span class="line">        head.left = createTree(arr, <span class="number">2</span> * i + <span class="number">1</span>);</span><br><span class="line">        head.right = createTree(arr, <span class="number">2</span> * i + <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        System.out.print(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        process(head.left);</span><br><span class="line">        System.out.print(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        process(head.right);</span><br><span class="line">        System.out.print(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        System.out.print(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        pre(head.left);</span><br><span class="line">        pre(head.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        in(head.left);</span><br><span class="line">        System.out.print(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        in(head.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pos</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        pos(head.left);</span><br><span class="line">        pos(head.right);</span><br><span class="line">        System.out.print(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morris</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        Node mostRight = <span class="keyword">null</span>;<span class="comment">//左子树上最右的结点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mostRight = cur.left;   <span class="comment">//cur的第一个左结点</span></span><br><span class="line">            <span class="keyword">if</span> (mostRight != <span class="keyword">null</span>) &#123;  <span class="comment">//如果左子树不为空</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != cur) &#123; <span class="comment">//找到最右边的结点 有两种情况</span></span><br><span class="line">                    mostRight = mostRight.right;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mostRight.right == <span class="keyword">null</span>) &#123; <span class="comment">//第一次来到这个结点  满足第二大条中的第一条</span></span><br><span class="line">                    mostRight.right = cur;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">//  cur = cur.left 直接结束所有的</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">//第二次来到这个结点         满足第二大条中的第二条</span></span><br><span class="line">                    mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.right;  <span class="comment">//包括两种情况的 左子树为空和第二次来到这个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//先序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morrisPre</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        Node mostRight = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mostRight = cur.left;</span><br><span class="line">            <span class="keyword">if</span> (mostRight != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;</span><br><span class="line">                    mostRight = mostRight.right;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mostRight.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mostRight.right = cur;</span><br><span class="line">                    System.out.print(cur.value + <span class="string">&quot; &quot;</span>);   <span class="comment">//先序是第一次来到这个结点的时候打印</span></span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    <span class="comment">//如果一个结点没有左子树  相当于只会来到这个结点一次  直接打印，然后往右走</span></span><br><span class="line">                System.out.print(cur.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morrisIn</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        Node mostRight = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mostRight = cur.left;</span><br><span class="line">            <span class="keyword">if</span> (mostRight != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;</span><br><span class="line">                    mostRight = mostRight.right;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mostRight.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mostRight.right = cur;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(cur.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//morris后续</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morrisPos</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        Node mostRight = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mostRight = cur.left;</span><br><span class="line">            <span class="keyword">if</span> (mostRight != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;</span><br><span class="line">                    mostRight = mostRight.right;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mostRight.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mostRight.right = cur;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">//第二次来的时候</span></span><br><span class="line">                    mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">                    printEdge(cur.left); <span class="comment">//打印左子树的右边界</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        printEdge(head); <span class="comment">//最后打印整棵树的右边界</span></span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印边界</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printEdge</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先逆序边界</span></span><br><span class="line">        Node tail = reverseEdge(head);</span><br><span class="line">        <span class="comment">//打印</span></span><br><span class="line">        Node cur = tail;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(cur.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再逆序回来</span></span><br><span class="line">        reverseEdge(tail);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有点类似链表的逆序</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">reverseEdge</span><span class="params">(Node cur)</span> </span>&#123;</span><br><span class="line">        Node pre = <span class="keyword">null</span>;</span><br><span class="line">        Node next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = cur.right;<span class="comment">//先保存下一个</span></span><br><span class="line">            cur.right = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">9</span>, <span class="number">10</span>, -<span class="number">1</span>, <span class="number">11</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        Node head = createTree(arr, <span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;------------递归树每个结点回到三次-----------&quot;</span>);</span><br><span class="line">        process(head);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------前序----------------&quot;</span>);</span><br><span class="line">        pre(head);</span><br><span class="line">        System.out.println();</span><br><span class="line">        morrisPre(head);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------中序----------------&quot;</span>);</span><br><span class="line">        in(head);</span><br><span class="line">        System.out.println();</span><br><span class="line">        morrisIn(head);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------后序----------------&quot;</span>);</span><br><span class="line">        pos(head);</span><br><span class="line">        System.out.println();</span><br><span class="line">        morrisPos(head);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果:<br><img src="https://img-blog.csdn.net/20180814163945869?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的各种操作(递归和非递归遍历,树深度,结点个数等等)</title>
    <url>/2022/06/06/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%84%E7%A7%8D%E6%93%8D%E4%BD%9C(%E9%80%92%E5%BD%92%E5%92%8C%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86,%E6%A0%91%E6%B7%B1%E5%BA%A6,%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0%E7%AD%89%E7%AD%89)/</url>
    <content><![CDATA[<h1 id="二叉树的各种操作-递归和非递归遍历-树深度-结点个数等等"><a href="#二叉树的各种操作-递归和非递归遍历-树深度-结点个数等等" class="headerlink" title="二叉树的各种操作(递归和非递归遍历,树深度,结点个数等等)"></a>二叉树的各种操作(递归和非递归遍历,树深度,结点个数等等)</h1><ul>
<li><a href="#%E5%BB%BA%E7%AB%8B%E4%BA%8C%E5%8F%89%E6%A0%91">建立二叉树</a><ul>
<li><a href="#1%E6%A0%B9%E6%8D%AE%E4%B8%8B%E6%A0%87%E5%85%B3%E7%B3%BB">1、根据下标关系</a></li>
<li><a href="#2%E5%89%8D%E5%BA%8F%E8%BE%93%E5%85%A5cin%E5%BB%BA%E7%AB%8B">2、前序输入(cin)建立</a></li>
</ul>
</li>
<li><a href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86">前序遍历</a><ul>
<li><a href="#1%E9%80%92%E5%BD%92%E5%89%8D%E5%BA%8F">1、递归前序</a></li>
<li><a href="#2%E9%9D%9E%E9%80%92%E5%BD%92%E5%89%8D%E5%BA%8F">2、非递归前序</a></li>
</ul>
</li>
<li><a href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86">中序遍历</a><ul>
<li><a href="#1%E9%80%92%E5%BD%92%E4%B8%AD%E5%BA%8F">1、递归中序</a></li>
<li><a href="#2%E3%80%81%E9%9D%9E%E9%80%92%E5%BD%92%E4%B8%AD%E5%BA%8F">2、非递归中序</a></li>
</ul>
</li>
<li><a href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86">后序遍历</a><ul>
<li><a href="#1%E9%80%92%E5%BD%92%E5%90%8E%E5%BA%8F">1、递归后序</a></li>
<li><a href="#2%E9%9D%9E%E9%80%92%E5%BD%92%E5%90%8E%E5%BA%8F">2、非递归后序</a></li>
</ul>
</li>
<li><a href="#%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86">层次遍历</a></li>
<li><a href="#%E5%AF%BB%E6%89%BE%E6%A0%91%E4%B8%AD%E6%9C%89%E6%B2%A1%E6%9C%89%E5%80%BC%E4%B8%BAx%E7%9A%84%E7%BB%93%E7%82%B9">寻找树中有没有值为x的结点</a></li>
<li><a href="#%E7%BB%9F%E8%AE%A1%E6%A0%91%E4%B8%AD%E7%BB%93%E7%82%B9%E7%9A%84%E4%B8%AA%E6%95%B0">统计树中结点的个数</a></li>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6">计算树的高度</a></li>
<li><a href="#%E5%88%A4%E6%96%AD%E4%B8%A4%E9%A2%97%E6%A0%91%E6%98%AF%E4%B8%8D%E6%98%AF%E7%9B%B8%E7%AD%89">判断两颗树是不是相等</a></li>
<li><a href="#%E5%AE%8C%E6%95%B4%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">完整测试代码</a></li>
</ul>
<hr>
<h2 id="二叉树建立"><a href="#二叉树建立" class="headerlink" title="二叉树建立"></a>二叉树建立</h2><p>先给出结点结构: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种建立方式:</p>
<ul>
<li>可以根据二叉树根节点和左右子结点的下标关系递归建立二叉树，层次输入二叉树结点；</li>
<li><font color = red>也可以使用输入流前序建立二叉树(注意空树要输入-1)；</li>
</ul>
<h3 id="1、根据下标关系"><a href="#1、根据下标关系" class="headerlink" title="1、根据下标关系"></a>1、根据下标关系</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// given a arr to build</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Node <span class="title">createTree</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= arr.length || arr[i] == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Node root = <span class="keyword">new</span> Node(arr[i]);</span><br><span class="line">    root.left = createTree(arr, <span class="number">2</span> * i + <span class="number">1</span>);</span><br><span class="line">    root.right = createTree(arr, <span class="number">2</span> * i + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大致过程如下:<br><img src="images/all1.png" alt="这里写图片描述"></p>
<h3 id="2、前序输入-cin-建立"><a href="#2、前序输入-cin-建立" class="headerlink" title="2、前序输入(cin)建立"></a>2、前序输入(cin)建立</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cin method	</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Node <span class="title">buildTree</span><span class="params">(Scanner cin)</span> </span>&#123;</span><br><span class="line">    Node root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> data = cin.nextInt();</span><br><span class="line">    <span class="keyword">if</span> (data != -<span class="number">1</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node(data);</span><br><span class="line">        root.left = buildTree(cin);</span><br><span class="line">        root.right = buildTree(cin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>过程如下:<br><img src="images/all2.png" alt="这里写图片描述"></p>
<h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><h3 id="1、递归前序"><a href="#1、递归前序" class="headerlink" title="1、递归前序"></a>1、递归前序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    System.out.print(T.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    preOrder(T.left);</span><br><span class="line">    preOrder(T.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、非递归前序"><a href="#2、非递归前序" class="headerlink" title="2、非递归前序"></a>2、非递归前序</h3><p>前序遍历顺序为: <strong>根结点-&gt;左子树-&gt;右子树</strong>，所以对于正在访问的根结点，可以直接访问，访问完之后，按照相同的方式访问左子树，再访问右子树，过程如下 : </p>
<ul>
<li>如果当前节点<code>p</code>不为空，访问结点<code>p</code>，并将结点<code>p</code>入栈，并继续访问左子树(直到左子树为空)；</li>
<li>否则将栈顶元素出栈，并访问栈顶的元素的右子树；</li>
<li>直到栈为空且<code>p</code>为空，循环结束。</li>
</ul>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativePre</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Node p = root;</span><br><span class="line">    <span class="keyword">while</span> (!s.empty() || p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;<span class="comment">//也可以写一个while循环，直到左子树为空</span></span><br><span class="line">            s.push(p);</span><br><span class="line">            System.out.print(p.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = s.pop();</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以将上面的一直访问到左子树为空写成一个<code>while</code>循环:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativePre2</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Node p = root;</span><br><span class="line">    <span class="keyword">while</span> (!s.empty() || p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123; <span class="comment">// while循环，直到左子树为空</span></span><br><span class="line">            s.push(p);</span><br><span class="line">            System.out.print(p.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">        p = s.pop();</span><br><span class="line">        p = p.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 还有另外一种写法是:　</p>
<ul>
<li>先把根节点入栈，然后每次出栈一个元素，先访问这个元素，然后如果它的右子树存在，就入栈，如果它的左子树存在也入栈；</li>
<li><strong>为什么要先入右子树呢，因为，前序遍历是中-&gt;左-&gt;右，而栈可以逆序，所以先右再左；</strong></li>
</ul>
<blockquote>
<p>这个方法在后续遍历的双栈法中有体现，那个只是这个稍微的修改。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativePre3</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Node p = root;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.add(p);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        p = stack.pop();</span><br><span class="line">        System.out.print(p.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (p.right != <span class="keyword">null</span>)<span class="comment">// 先右再左即可</span></span><br><span class="line">            stack.push(p.right);</span><br><span class="line">        <span class="keyword">if</span> (p.left != <span class="keyword">null</span>)</span><br><span class="line">            stack.push(p.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><h3 id="1、递归中序"><a href="#1、递归中序" class="headerlink" title="1、递归中序"></a>1、递归中序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    inOrder(T.left);</span><br><span class="line">    System.out.print(T.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    inOrder(T.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、非递归中序"><a href="#2、非递归中序" class="headerlink" title="2、非递归中序"></a>2、非递归中序</h3><p>中序遍历 : <strong>左子树-&gt;根-&gt;右子树</strong>，过程如下：</p>
<ul>
<li>当前节点不空<code>!= null</code>，压入栈中(和前序遍历不同的是，不需要打印)，当前节点向左；</li>
<li>当前节点为空<code>== null</code>，从栈中拿出一个并且打印(在这里打印) ，当前节点向右；</li>
</ul>
<p>直到栈为空且p为空，循环结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1)、当前节点不空(!=null)，压入栈中(和前序遍历不同的是，不需要打印)，当前节点向左；</span></span><br><span class="line"><span class="comment">* 2)、当前节点为空(==null)，从栈中拿出一个并且打印(在这里打印) ，当前节点向右；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativeIn</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Node p = root;</span><br><span class="line">    <span class="keyword">while</span> (!s.empty() || p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            s.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = s.pop();</span><br><span class="line">            System.out.print(p.val + <span class="string">&quot; &quot;</span>); <span class="comment">//在这里打印</span></span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同理，那个一直访问左孩子那里也可以改成<code>whlie</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativeIn2</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Node p = root;</span><br><span class="line">    <span class="keyword">while</span> (!s.empty() || p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123; <span class="comment">//这里改成while</span></span><br><span class="line">            s.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">        p = s.pop();</span><br><span class="line">        System.out.print(p.val + <span class="string">&quot; &quot;</span>); <span class="comment">//在这里打印</span></span><br><span class="line">        p = p.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><h3 id="1、递归后序"><a href="#1、递归后序" class="headerlink" title="1、递归后序"></a>1、递归后序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    postOrder(T.left);</span><br><span class="line">    postOrder(T.right);</span><br><span class="line">    System.out.print(T.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、非递归后序"><a href="#2、非递归后序" class="headerlink" title="2、非递归后序"></a>2、非递归后序</h3><h4 id="1-、双栈法"><a href="#1-、双栈法" class="headerlink" title="1)、双栈法"></a>1)、双栈法</h4><p>这个其实就是非递归前序(<code>iterativePre3</code>)的稍微一点改进。</p>
<ul>
<li>首先，前序遍历入栈(<code>iterativePre3</code>)的顺序是<strong>先 右　再左</strong>；</li>
<li>这时，我们可以做到<strong>反过来先　左　再右</strong>，这样遍历的顺序可以做到 **”中右左”**，而后续遍历是 <strong>“左右中”<strong>，正好是前面那个的相反，所以我们</strong>再使用一个栈反转保存即可</strong>；</li>
</ul>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 非递归后续1(双栈法解决非递归后续)</span></span><br><span class="line"><span class="comment">* 后续遍历是要实现　　　左-&gt;右-&gt;中</span></span><br><span class="line"><span class="comment">* 这个方法和前序遍历的第二种方法　只是多了一个栈而已</span></span><br><span class="line"><span class="comment">* 因为　前序遍历是  中-&gt;左-&gt;右　　压栈顺序是 右-&gt;左</span></span><br><span class="line"><span class="comment">* 这样，我们就很容易实现　中-&gt;右-&gt;左遍历　　压栈顺序是　左-&gt;右</span></span><br><span class="line"><span class="comment">* 而后续遍历是要实现  左-&gt;右-&gt;中，</span></span><br><span class="line"><span class="comment">* 我们把上面的　　中右左　压入到另一个栈中　就实现了　左右中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativePos</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;&gt;(), s2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Node p;</span><br><span class="line">    s.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">        p = s.pop();</span><br><span class="line">        s2.push(p);</span><br><span class="line">        <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) s.push(p.left); <span class="comment">//这里是先左再右  (非递归前序是先右再左)</span></span><br><span class="line">        <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) s.push(p.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!s2.empty())</span><br><span class="line">        System.out.print(s2.pop().val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-、设置pre结点"><a href="#2-、设置pre结点" class="headerlink" title="2)、设置pre结点"></a>2)、设置<code>pre</code>结点</h4><p>过程如下:</p>
<ul>
<li>对于任一结点<code>p</code>，先将其入栈；</li>
<li>可以访问的情况:  ①若<code>p</code>不存在左孩子和右孩子，则可以直接访问它。②或者<code>p</code>存在左孩子或者右孩子，但是左孩子和右孩子都已经被访问过了，则也可以直接访问该结点；</li>
<li>若非上述两种情况，<strong>则将右孩子和左孩子依次入栈</strong>。这样可以保证每次取栈顶元素时，左孩子在右孩子前面被访问，根结点在左孩子和右孩子访问<strong>之后</strong>被访问；</li>
</ul>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*** 非递归后续2(设置pre结点) */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativePos2</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    Node cur, pre = <span class="keyword">null</span>;</span><br><span class="line">    Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    s.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!s.empty()) &#123; </span><br><span class="line">        cur = s.peek();</span><br><span class="line">        <span class="comment">// 两种可以访问的情况</span></span><br><span class="line">        <span class="keyword">if</span> ((cur.left == <span class="keyword">null</span> &amp;&amp; cur.right == <span class="keyword">null</span>) ||</span><br><span class="line">            ((pre != <span class="keyword">null</span>) &amp;&amp; (pre == cur.left || pre == cur.right))) &#123;</span><br><span class="line">            System.out.print(cur.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            s.pop();</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) s.push(cur.right);</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) s.push(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h2><p>很简单。利用队列BFS即可，每次访问完<code>p</code>，若左右孩子存在，则入队，直至队空；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        Node now = queue.poll();</span><br><span class="line">        System.out.print(now.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (now.left != <span class="keyword">null</span>) queue.add(now.left);</span><br><span class="line">        <span class="keyword">if</span> (now.right != <span class="keyword">null</span>) queue.add(now.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="寻找树中有没有值为x的结点"><a href="#寻找树中有没有值为x的结点" class="headerlink" title="寻找树中有没有值为x的结点"></a>寻找树中有没有值为x的结点</h2><p>递归条件有两个，一个是为空代表没找到，找到了的话直接返回，否则递归查找左右子树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找某个值为x的结点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Node <span class="title">search</span><span class="params">(Node T, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (T.val == x)</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (search(T.left, x) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> search(T.right, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> search(T.left, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="统计树中结点的个数"><a href="#统计树中结点的个数" class="headerlink" title="统计树中结点的个数"></a>统计树中结点的个数</h2><p>树中结点的个数等于根节点(1) + 左子树结点个数 + 右子树的个数，递归求解即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//统计结点个数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(Node T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> count(T.left) + count(T.right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="计算树的高度"><a href="#计算树的高度" class="headerlink" title="计算树的高度"></a>计算树的高度</h2><p>也是递归求解，左右子树的高度中的比较高的加上根节点就是树的高度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算二叉树的深度</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(Node T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.max(depth(T.left), depth(T.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断两棵树是不是相等"><a href="#判断两棵树是不是相等" class="headerlink" title="判断两棵树是不是相等"></a>判断两棵树是不是相等</h2><p>也是递归求解，两棵树相等，既要根节点的值相等，而且左右子树也要相等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断两棵树是不是相等</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">is_SameTree</span><span class="params">(Node T1, Node T2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T1 == <span class="keyword">null</span> &amp;&amp; T2 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> T1 != <span class="keyword">null</span> &amp;&amp; T2 != <span class="keyword">null</span> &amp;&amp; T1.val == T2.val</span><br><span class="line">            &amp;&amp; is_SameTree(T1.left, T2.left) &amp;&amp; is_SameTree(T1.right, T2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="完整测试代码"><a href="#完整测试代码" class="headerlink" title="完整测试代码"></a>完整测试代码</h2><p>完整的测试代码，这里输入的样例树(就是建树的时候那个例子)如下:</p>
<p><img src="images/all3.png" alt="这里写图片描述"></p>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// given a arr to build</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">createTree</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= arr.length || arr[i] == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Node root = <span class="keyword">new</span> Node(arr[i]);</span><br><span class="line">        root.left = createTree(arr, <span class="number">2</span> * i + <span class="number">1</span>);</span><br><span class="line">        root.right = createTree(arr, <span class="number">2</span> * i + <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cin method	</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">buildTree</span><span class="params">(Scanner cin)</span> </span>&#123;</span><br><span class="line">        Node root = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> data = cin.nextInt();</span><br><span class="line">        <span class="keyword">if</span> (data != -<span class="number">1</span>) &#123;</span><br><span class="line">            root = <span class="keyword">new</span> Node(data);</span><br><span class="line">            root.left = buildTree(cin);</span><br><span class="line">            root.right = buildTree(cin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (T == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        System.out.print(T.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        preOrder(T.left);</span><br><span class="line">        preOrder(T.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativePre</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Node p = root;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty() || p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                s.push(p);</span><br><span class="line">                System.out.print(p.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                p = p.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p = s.pop();</span><br><span class="line">                p = p.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativePre2</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Node p = root;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty() || p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123; <span class="comment">// while循环，直到左子树为空</span></span><br><span class="line">                s.push(p);</span><br><span class="line">                System.out.print(p.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                p = p.left;</span><br><span class="line">            &#125;</span><br><span class="line">            p = s.pop();</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 理解 :  push右子树，再push左子树，这样的话弹栈的时候就是先访问左子树，再右子树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativePre3</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        Node p = root;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.add(p);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            p = stack.pop();</span><br><span class="line">            System.out.print(p.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (p.right != <span class="keyword">null</span>)</span><br><span class="line">                stack.push(p.right);</span><br><span class="line">            <span class="keyword">if</span> (p.left != <span class="keyword">null</span>)</span><br><span class="line">                stack.push(p.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (T == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        inOrder(T.left);</span><br><span class="line">        System.out.print(T.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        inOrder(T.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1)、当前节点不空(!=null)，压入栈中(和前序遍历不同的是，不需要打印)，当前节点向左；</span></span><br><span class="line"><span class="comment">     * 2)、当前节点为空(==null)，从栈中拿出一个并且打印(在这里打印) ，当前节点向右；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativeIn</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Node p = root;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty() || p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                s.push(p);</span><br><span class="line">                p = p.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p = s.pop();</span><br><span class="line">                System.out.print(p.val + <span class="string">&quot; &quot;</span>); <span class="comment">//在这里打印</span></span><br><span class="line">                p = p.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativeIn2</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Node p = root;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty() || p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123; <span class="comment">//这里改成while</span></span><br><span class="line">                s.push(p);</span><br><span class="line">                p = p.left;</span><br><span class="line">            &#125;</span><br><span class="line">            p = s.pop();</span><br><span class="line">            System.out.print(p.val + <span class="string">&quot; &quot;</span>); <span class="comment">//在这里打印</span></span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (T == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        postOrder(T.left);</span><br><span class="line">        postOrder(T.right);</span><br><span class="line">        System.out.print(T.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非递归后续1(双栈法解决非递归后续)</span></span><br><span class="line"><span class="comment">     * 后续遍历是要实现　　　左-&gt;右-&gt;中</span></span><br><span class="line"><span class="comment">     * 这个方法和前序遍历的第二种方法　只是多了一个栈而已</span></span><br><span class="line"><span class="comment">     * 因为　前序遍历是  中-&gt;左-&gt;右　　压栈顺序是 右-&gt;左</span></span><br><span class="line"><span class="comment">     * 这样，我们就很容易实现　中-&gt;右-&gt;左遍历　　压栈顺序是　左-&gt;右</span></span><br><span class="line"><span class="comment">     * 而后续遍历是要实现  左-&gt;右-&gt;中，</span></span><br><span class="line"><span class="comment">     * 我们把上面的　　中右左　压入到另一个栈中　就实现了　左右中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativePos</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;&gt;(), s2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Node p;</span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">            p = s.pop();</span><br><span class="line">            s2.push(p);</span><br><span class="line">            <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) s.push(p.left); <span class="comment">//这里是先左再右  (非递归前序是先右再左)</span></span><br><span class="line">            <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) s.push(p.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!s2.empty())</span><br><span class="line">            System.out.print(s2.pop().val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** 非递归后续2(设置pre结点) */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativePos2</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        Node cur, pre = <span class="keyword">null</span>;</span><br><span class="line">        Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">            cur = s.peek();</span><br><span class="line">            <span class="comment">// 两种可以访问的情况</span></span><br><span class="line">            <span class="keyword">if</span> ((cur.left == <span class="keyword">null</span> &amp;&amp; cur.right == <span class="keyword">null</span>) ||</span><br><span class="line">                    ((pre != <span class="keyword">null</span>) &amp;&amp; (pre == cur.left || pre == cur.right))) &#123;</span><br><span class="line">                System.out.print(cur.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                s.pop();</span><br><span class="line">                pre = cur;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) s.push(cur.right);</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) s.push(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Node now = queue.poll();</span><br><span class="line">            System.out.print(now.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (now.left != <span class="keyword">null</span>) queue.add(now.left);</span><br><span class="line">            <span class="keyword">if</span> (now.right != <span class="keyword">null</span>) queue.add(now.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找某个值为x的结点</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">search</span><span class="params">(Node T, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (T == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (T.val == x)</span><br><span class="line">            <span class="keyword">return</span> T;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (search(T.left, x) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> search(T.right, x);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> search(T.left, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//统计结点个数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(Node T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (T == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> count(T.left) + count(T.right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算二叉树的深度</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(Node T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (T == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(depth(T.left), depth(T.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断两棵树是不是相等</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">is_SameTree</span><span class="params">(Node T1, Node T2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (T1 == <span class="keyword">null</span> &amp;&amp; T2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> T1 != <span class="keyword">null</span> &amp;&amp; T2 != <span class="keyword">null</span> &amp;&amp; T1.val == T2.val</span><br><span class="line">                    &amp;&amp; is_SameTree(T1.left, T2.left) &amp;&amp; is_SameTree(T1.right, T2.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line">        <span class="comment">//		int[] arr = &#123;1,2,3,4,5,6,7,8,-1,9,-1,10,-1,11,-1, -1,-1,-1,-1,-1,-1,-1,-1&#125;;</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, -<span class="number">1</span>, <span class="number">9</span>, -<span class="number">1</span>, <span class="number">10</span>, -<span class="number">1</span>, <span class="number">11</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        Node root = createTree(arr, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//		树结构和上面相同,输入: 1 2 4 8 -1 -1 -1 5 9 -1 -1 -1 3 6 10 -1 -1 -1 7 11 -1 -1 -1</span></span><br><span class="line">        Node root2 = buildTree(cin);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-------前序遍历-------&quot;</span>);</span><br><span class="line">        preOrder(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">        iterativePre(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">        iterativePre2(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">        iterativePre3(root);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;-------中序遍历-------&quot;</span>);</span><br><span class="line">        inOrder(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">        iterativeIn(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">        iterativeIn2(root);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;-------后序遍历-------&quot;</span>);</span><br><span class="line">        postOrder(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">        iterativePos(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">        iterativePos2(root);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;-------层次遍历-------&quot;</span>);</span><br><span class="line">        levelOrder(root);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;------结点个数-------&quot;</span>);</span><br><span class="line">        System.out.println(count(root));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;------二叉树深度-------&quot;</span>);</span><br><span class="line">        System.out.println(depth(root));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;-----判断两棵树是不是相同-----&quot;</span>);</span><br><span class="line">        System.out.println(is_SameTree(root, root2));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;-----寻找树中有没有值为3的结点-----&quot;</span>);</span><br><span class="line">        Node Find = search(root, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == Find)</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到结点&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">&quot;这个结点的左右子结点的值是&quot;</span> + Find.left.val + <span class="string">&quot; &quot;</span> + Find.right.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果如下图:</p>
<p><img src="images/all4.png"></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树结点间的最大距离问题</title>
    <url>/2022/06/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%93%E7%82%B9%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%9D%E7%A6%BB%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="二叉树结点间的最大距离问题"><a href="#二叉树结点间的最大距离问题" class="headerlink" title="二叉树结点间的最大距离问题"></a>二叉树结点间的最大距离问题</h2><ul>
<li>递归</li>
<li>改进的写法</li>
<li>完整测试代码<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4></li>
</ul>
<p><img src="images/tree1.png" alt="在这里插入图片描述"></p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>解析<br>这个也是一个二叉树的问题，分为三步:</p>
<ul>
<li>列出所有可能性；</li>
<li>列出结点需要的信息，并整合信息(成一个结构体)；</li>
<li>改递归 ，先假设左和右都给我信息(黑盒)，然后怎么利用左边和右边的信息组出来我该返回的信息，最后<code>basecase</code>(边界)填什么；</li>
</ul>
<p>具体到这个题目:<br><strong>第一步，列出可能性：</strong> 一个以<code>node</code>为头的树上，最大距离只可能来自下面三种情况: </p>
<ul>
<li>不需要经过<code>node</code>这个点，node的左子树上自己的最大距离；</li>
<li>不需要经过<code>node</code>这个点，node的右子树上自己的最大距离；</li>
<li>要经过<code>node</code>这个点，此时就是左子树的高度 <code>+ </code>右子树的高度<code> +</code> <code>1 </code>；</li>
</ul>
<p><strong>第二步，确定结点需要的信息，并整合:</strong></p>
<ul>
<li>信息一: 返回的以<code>node</code>为头的树的最大距离；</li>
<li>信息二: 返回的以<code>node</code>为头的高度；</li>
</ul>
<p><strong>第三步，封装信息，写出递归</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> max;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> h;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> max, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.max = max;</span><br><span class="line">            <span class="keyword">this</span>.h = h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rec(head).max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Pair <span class="title">rec</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Pair(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        Pair L = rec(head.left);</span><br><span class="line">        Pair R = rec(head.right);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair(Math.max((L.h + R.h + <span class="number">1</span>), Math.max(L.max, R.max)),</span><br><span class="line">                Math.max(L.h, R.h) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="改进的写法"><a href="#改进的写法" class="headerlink" title="改进的写法"></a>改进的写法</h3><p>可以使用一个全局变量记录高度，然后<code>max</code>正常返回: <font color = red>注意在<code>java</code>中要使用数组，<strong>是引用</strong>，这样的话就可以一直传递，不能使用一个变量</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxDistance2</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] rec = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> rec2(head, rec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rec2</span><span class="params">(Node head, <span class="keyword">int</span>[] rec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        rec[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> L = rec2(head.left, rec);</span><br><span class="line">    <span class="keyword">int</span> lH = rec[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> R = rec2(head.right, rec);</span><br><span class="line">    <span class="keyword">int</span> rH = rec[<span class="number">0</span>];</span><br><span class="line">    rec[<span class="number">0</span>] = Math.max(lH, rH) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.max(lH + rH + <span class="number">1</span>, Math.max(L, R));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="完整测试代码"><a href="#完整测试代码" class="headerlink" title="完整测试代码"></a>完整测试代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxDistance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> max;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> h;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> max, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.max = max;</span><br><span class="line">            <span class="keyword">this</span>.h = h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rec(head).max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Pair <span class="title">rec</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Pair(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Pair L = rec(head.left);</span><br><span class="line">        Pair R = rec(head.right);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair(Math.max((L.h + R.h + <span class="number">1</span>), Math.max(L.max, R.max)), Math.max(L.h, R.h) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxDistance2</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] rec = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> rec2(head, rec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rec2</span><span class="params">(Node head, <span class="keyword">int</span>[] rec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            rec[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> L = rec2(head.left, rec);</span><br><span class="line">        <span class="keyword">int</span> lH = rec[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> R = rec2(head.right, rec);</span><br><span class="line">        <span class="keyword">int</span> rH = rec[<span class="number">0</span>];</span><br><span class="line">        rec[<span class="number">0</span>] = Math.max(lH, rH) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(lH + rH + <span class="number">1</span>, Math.max(L, R));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">build</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= arr.length || arr[index] == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Node root = <span class="keyword">new</span> Node(arr[index]);</span><br><span class="line">        root.left = build(arr, index * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        root.right = build(arr, index * <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTree</span><span class="params">(Node head, <span class="keyword">int</span> height, String to, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        printTree(head.right, height + <span class="number">1</span>, <span class="string">&quot;v&quot;</span>, len);</span><br><span class="line">        String val = to + head.value + to;  <span class="comment">//两边指示的字符</span></span><br><span class="line">        <span class="keyword">int</span> lenV = val.length();</span><br><span class="line">        <span class="keyword">int</span> lenL = (len - lenV) / <span class="number">2</span>;  <span class="comment">//左边的空格(分一半)</span></span><br><span class="line">        <span class="keyword">int</span> lenR = len - lenV - lenL; <span class="comment">// 右边的空格</span></span><br><span class="line">        System.out.println(getSpace(len * height) + getSpace(lenL) + val + getSpace(lenR));</span><br><span class="line"></span><br><span class="line">        printTree(head.left, height + <span class="number">1</span>, <span class="string">&quot;^&quot;</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取指定的空格</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">getSpace</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        StringBuffer str = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) str.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        Node head = build(arr, <span class="number">0</span>);</span><br><span class="line">        printTree(head, <span class="number">0</span>, <span class="string">&quot;H&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        System.out.println(maxDistance(head));</span><br><span class="line">        System.out.println(maxDistance2(head));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:(打印二叉树见<a href="https://blog.csdn.net/zxzxzx0119/article/details/81096554"><strong>这个博客</strong></a>)<br><img src="images/tree2.png" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>单调栈介绍以及构造数组的MaxTree问题</title>
    <url>/2022/09/29/%E5%8D%95%E8%B0%83%E6%A0%88%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E6%9E%84%E9%80%A0%E6%95%B0%E7%BB%84%E7%9A%84MaxTree%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="单调栈介绍以及构造数组的MaxTree问题"><a href="#单调栈介绍以及构造数组的MaxTree问题" class="headerlink" title="单调栈介绍以及构造数组的MaxTree问题"></a>单调栈介绍以及构造数组的MaxTree问题</h2><ul>
<li>单调栈介绍</li>
<li>单调栈解决构造数组的MaxTree问题</li>
<li>堆解决构造数组的MaxTree问题</li>
<li>完整测试代码</li>
</ul>
<hr>
<h4 id="题目-构造数组的MaxTree问题"><a href="#题目-构造数组的MaxTree问题" class="headerlink" title="题目(构造数组的MaxTree问题)"></a>题目(构造数组的MaxTree问题)</h4><p><img src="images/ms3.png" alt="在这里插入图片描述"></p>
<h3 id="单调栈介绍"><a href="#单调栈介绍" class="headerlink" title="单调栈介绍"></a>单调栈介绍</h3><p>单调栈最初解决的问题就是<strong>寻找一个数组中 ，每一个数的左右两边离它最近的数</strong>。</p>
<ul>
<li>遍历一个数组，如果<strong>栈为空或者栈顶比当前数大(或者相等，相等的话就多个下标对应一个值)，就把当前数入栈</strong>；</li>
<li>如果栈顶比当前数小，那么就<strong>处理这个栈顶，即这个栈顶右边第一个比它大的数就是当前数，左边第一个比它大的数就是在栈里面它的下面的那个数，也就是它出栈之后的栈顶</strong>；</li>
<li> 当遍历完所有的数之后，栈中还有数，这时，逐个判断栈中的数，每一个数，<strong>它的右边不存在比它大的</strong>，如果这个数在栈里面它的下面还有数，它左边离他最近的大的数就是它下面的数；</li>
</ul>
<p><img src="images/ms2.png" alt="这里写图片描述"></p>
<h3 id="单调栈解决构造数组的MaxTree问题"><a href="#单调栈解决构造数组的MaxTree问题" class="headerlink" title="单调栈解决构造数组的MaxTree问题"></a>单调栈解决构造数组的MaxTree问题</h3><p>按照下面的方法来建树</p>
<ul>
<li>每一个树的<strong>父节点是它左边第一个比它大的数和它右边第一个比它大的数中，比较<font color = red>小</font>的那个</strong>；</li>
<li>如果左边没有没有比它大的数，右边也没有。也就是说，这个数是整个数组的最大值，那么这个数是<code>MaxTree</code>的头结点；</li>
</ul>
<p>按照大根堆和上面的方案放置如下：<br><img src="images/ms4.png" alt="这里写图片描述"></p>
<p>相关证明:</p>
<p><img src="images/ms5.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回构造的树的头结点</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> Node <span class="title">getMaxTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">       Node[] nArr = <span class="keyword">new</span> Node[arr.length];  <span class="comment">//生成树的结构,数组中的每一个值都代表一个结点</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">           nArr[i] = <span class="keyword">new</span> Node(arr[i]);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       HashMap&lt;Node, Node&gt; lMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       HashMap&lt;Node, Node&gt; rMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//找每一个数左边离它最近的大的</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nArr.length; i++) &#123;</span><br><span class="line">           Node cur = nArr[i];</span><br><span class="line">           <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().value &lt; cur.value) &#123;</span><br><span class="line">               popStackSetValue(stack, lMap);</span><br><span class="line">           &#125;</span><br><span class="line">           stack.push(cur);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">           popStackSetValue(stack, lMap);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//找每一个数右边比它最近的大的</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = nArr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">           Node cur = nArr[i];</span><br><span class="line">           <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().value &lt; cur.value) &#123;</span><br><span class="line">               popStackSetValue(stack, rMap);</span><br><span class="line">           &#125;</span><br><span class="line">           stack.push(cur);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">           popStackSetValue(stack, rMap);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//开始构造这棵树</span></span><br><span class="line">       Node head = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nArr.length; i++) &#123;</span><br><span class="line">           Node cur = nArr[i];</span><br><span class="line">           Node L = lMap.get(cur); <span class="comment">//左边离cur最近的</span></span><br><span class="line">           Node R = rMap.get(cur); <span class="comment">//右边离cur最近的</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (L == <span class="keyword">null</span> &amp;&amp; R == <span class="keyword">null</span>) &#123;</span><br><span class="line">               head = cur;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (L == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (R.left == <span class="keyword">null</span>)R.left = cur;</span><br><span class="line">               <span class="keyword">else</span> R.right = cur;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (R == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (L.left == <span class="keyword">null</span>)L.left = cur;</span><br><span class="line">               <span class="keyword">else</span> L.right = cur;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               Node minNode = L.value &lt; R.value ? L : R;</span><br><span class="line">               <span class="keyword">if</span> (minNode.left == <span class="keyword">null</span>) minNode.left = cur;</span><br><span class="line">               <span class="keyword">else</span> minNode.right = cur;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//弹出来一个数，并且得到它左/右边边最近的比他大的数</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">popStackSetValue</span><span class="params">(Stack&lt;Node&gt; stack, HashMap&lt;Node, Node&gt; map)</span> </span>&#123;</span><br><span class="line">       Node top = stack.pop();</span><br><span class="line">       <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">           map.put(top, <span class="keyword">null</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           map.put(top, stack.peek());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆解决构造数组的MaxTree问题"><a href="#堆解决构造数组的MaxTree问题" class="headerlink" title="堆解决构造数组的MaxTree问题"></a>堆解决构造数组的MaxTree问题</h3><p>由于从上到下减小，所以正好是一个堆，可以使用堆来写: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Node <span class="title">getMaxTree2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    Node[] nArr = <span class="keyword">new</span> Node[arr.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) nArr[i] = <span class="keyword">new</span> Node(arr[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nArr.length; i++) &#123;</span><br><span class="line">        heapfiyInsert(nArr,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nArr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span> * i + <span class="number">1</span> &lt; nArr.length)&#123;</span><br><span class="line">            nArr[i].left = nArr[<span class="number">2</span>*i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span> * i + <span class="number">2</span> &lt; nArr.length)&#123;</span><br><span class="line">            nArr[i].right = nArr[<span class="number">2</span>*i + <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nArr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapfiyInsert</span><span class="params">(Node[] nArr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (nArr[index].value &gt; nArr[(index - <span class="number">1</span>) / <span class="number">2</span>].value) &#123;</span><br><span class="line">        swap(nArr,index,(index-<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">        index = (index-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Node[] nArr,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    Node temp = nArr[a];</span><br><span class="line">    nArr[a] = nArr[b];</span><br><span class="line">    nArr[b] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完整测试代码"><a href="#完整测试代码" class="headerlink" title="完整测试代码"></a>完整测试代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 利用单调栈解决构造数组的 maxTree问题 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回构造的树的头结点</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">getMaxTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        Node[] nArr = <span class="keyword">new</span> Node[arr.length];  <span class="comment">//生成树的结构,数组中的每一个值都代表一个结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            nArr[i] = <span class="keyword">new</span> Node(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        HashMap&lt;Node, Node&gt; lMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        HashMap&lt;Node, Node&gt; rMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找每一个数左边离它最近的大的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nArr.length; i++) &#123;</span><br><span class="line">            Node cur = nArr[i];</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().value &lt; cur.value) &#123;</span><br><span class="line">                popStackSetValue(stack, lMap);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            popStackSetValue(stack, lMap);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找每一个数右边比它最近的大的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nArr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            Node cur = nArr[i];</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().value &lt; cur.value) &#123;</span><br><span class="line">                popStackSetValue(stack, rMap);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            popStackSetValue(stack, rMap);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始构造这棵树</span></span><br><span class="line">        Node head = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nArr.length; i++) &#123;</span><br><span class="line">            Node cur = nArr[i];</span><br><span class="line">            Node L = lMap.get(cur); <span class="comment">//左边离cur最近的</span></span><br><span class="line">            Node R = rMap.get(cur); <span class="comment">//右边离cur最近的</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (L == <span class="keyword">null</span> &amp;&amp; R == <span class="keyword">null</span>) &#123;</span><br><span class="line">                head = cur;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (L == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (R.left == <span class="keyword">null</span>) R.left = cur;</span><br><span class="line">                <span class="keyword">else</span> R.right = cur;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (R == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (L.left == <span class="keyword">null</span>) L.left = cur;</span><br><span class="line">                <span class="keyword">else</span> L.right = cur;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Node minNode = L.value &lt; R.value ? L : R;</span><br><span class="line">                <span class="keyword">if</span> (minNode.left == <span class="keyword">null</span>) minNode.left = cur;</span><br><span class="line">                <span class="keyword">else</span> minNode.right = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//弹出来一个数，并且得到它左/右边边最近的比他大的数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">popStackSetValue</span><span class="params">(Stack&lt;Node&gt; stack, HashMap&lt;Node, Node&gt; map)</span> </span>&#123;</span><br><span class="line">        Node top = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">            map.put(top, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(top, stack.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">getMaxTree2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        Node[] nArr = <span class="keyword">new</span> Node[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) nArr[i] = <span class="keyword">new</span> Node(arr[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nArr.length; i++) &#123;</span><br><span class="line">            heapfiyInsert(nArr, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nArr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * i + <span class="number">1</span> &lt; nArr.length) &#123;</span><br><span class="line">                nArr[i].left = nArr[<span class="number">2</span> * i + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * i + <span class="number">2</span> &lt; nArr.length) &#123;</span><br><span class="line">                nArr[i].right = nArr[<span class="number">2</span> * i + <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nArr[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapfiyInsert</span><span class="params">(Node[] nArr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (nArr[index].value &gt; nArr[(index - <span class="number">1</span>) / <span class="number">2</span>].value) &#123;</span><br><span class="line">            swap(nArr, index, (index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">            index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Node[] nArr, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        Node temp = nArr[a];</span><br><span class="line">        nArr[a] = nArr[b];</span><br><span class="line">        nArr[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTree</span><span class="params">(Node head, <span class="keyword">int</span> height, String to, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        printTree(head.right, height + <span class="number">1</span>, <span class="string">&quot;v&quot;</span>, len);</span><br><span class="line"></span><br><span class="line">        String val = to + head.value + to;  <span class="comment">//两边指示的字符</span></span><br><span class="line">        <span class="keyword">int</span> lenV = val.length();</span><br><span class="line">        <span class="keyword">int</span> lenL = (len - lenV) / <span class="number">2</span>;   <span class="comment">//左边的空格(分一半)</span></span><br><span class="line">        <span class="keyword">int</span> lenR = len - lenV - lenL;  <span class="comment">// 右边的空格</span></span><br><span class="line">        System.out.println(getSpace(len * height) + getSpace(lenL) + val + getSpace(lenR));</span><br><span class="line"></span><br><span class="line">        printTree(head.left, height + <span class="number">1</span>, <span class="string">&quot;^&quot;</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取指定的空格</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">getSpace</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        StringBuffer str = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) str.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] uniqueArr = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        Node head = getMaxTree(uniqueArr);</span><br><span class="line">        printTree(head, <span class="number">0</span>, <span class="string">&quot;H&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">        head = getMaxTree2(uniqueArr);</span><br><span class="line">        printTree(head, <span class="number">0</span>, <span class="string">&quot;H&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果</p>
<p><img src="images/ms1.png" alt="这里写图片描述"></p>
<p>这里没有用二叉树遍历来验证，直接用的直观打印二叉树的方法，上面打印二叉树的程序可以看<a href="https://blog.csdn.net/zxzxzx0119/article/details/81096554"><strong>这篇博客</strong></a>。</p>
]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>MonotoneStack</tag>
      </tags>
  </entry>
  <entry>
    <title>在一颗二叉树中寻找一个结点的后继结点(前驱结点)</title>
    <url>/2022/08/02/%E5%9C%A8%E4%B8%80%E9%A2%97%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%AF%BB%E6%89%BE%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9%E7%9A%84%E5%90%8E%E7%BB%A7%E7%BB%93%E7%82%B9(%E5%89%8D%E9%A9%B1%E7%BB%93%E7%82%B9)/</url>
    <content><![CDATA[<h2 id="在一颗二叉树中寻找一个结点的后继结点-前驱结点"><a href="#在一颗二叉树中寻找一个结点的后继结点-前驱结点" class="headerlink" title="在一颗二叉树中寻找一个结点的后继结点(前驱结点)"></a>在一颗二叉树中寻找一个结点的后继结点(前驱结点)</h2><ul>
<li>找后继结点</li>
<li>找前驱结点</li>
</ul>
<hr>
<h3 id="找后继结点"><a href="#找后继结点" class="headerlink" title="找后继结点"></a>找后继结点</h3><p> 首先知道什么是后继结点，就是二叉树中序遍历的序列中，某个结点紧随的那个结点比如下面的二叉树以及对应的中序遍历顺序。</p>
<p><img src="images/houji1.png" alt="这里写图片描述"></p>
<p>则<code>4</code>的后继是<code>2</code> ，<code>2</code>的后继是<code>5</code>，<code>7</code>的后继是<code>null</code>。</p>
<p>在树的结构中，每个结点有一个指向父亲的域<code>parent</code>，看如下结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line">    <span class="keyword">public</span> Node parent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>那么如何快速的寻找当前结点<code>node</code>后继结点呢? 其实只需要分为两种情况</p>
<ul>
<li>第一，如果<code>node</code>结点有右子树，那么就是右子树上<strong>最左</strong>的结点，例如上图的<code>２</code>的右子树上的最左结点是<code>5</code>，<code>5</code>的右子树上最左的结点是<code>8</code>，<code>1</code>的右子树上最左的结点是<code>9</code>，<code>3</code>的右子树上最左的结点是<code>7</code>。</li>
<li>第二，如果<code>node</code>结点没有右子树，那么要分两种情况 : <font color = blue><strong>a</strong>. 看当前结点<code>node</code> 是不是它父亲(node.parent)的左孩子，如果是，那么它父亲(<code>node.parent</code>)就是它的后继；</font><font color = #ff00ff><strong>b</strong>.如果当前结点是它父亲的右孩子(<code>node.parent.right == node</code>)，那么就向上不停的寻找它的后继结点，即当前结点为<code>node</code>，它的父亲为parent，如果<code>node</code>还是<code>parent</code>的右孩子，就令<code>node= parent，parent = parent.parent</code>，一直向上，直到<code>parent.left = node</code>，就停止，此时<code>parent</code>就是当初要找的结点的后继。</li>
</ul>
<p>(1) 对于上面的第二种情况看上面的例子，首先<code>a</code>情况</p>
<p><img src="images/houji2.png" alt="这里写图片描述"></p>
<p>(2) 然后再看第二种情况的<code>b</code> ，也就是往上找后继的过程</p>
<p><img src="images/houji3.png" alt="这里写图片描述"></p>
<h3 id="找前驱结点"><a href="#找前驱结点" class="headerlink" title="找前驱结点"></a>找前驱结点</h3><p> 这个和找后继是同理的:  </p>
<ul>
<li>当一个结点有左子树的时候，就是最左子树的最右结点；</li>
<li>没有左子树的时候，<font color = blue><strong>a.</strong> 看当前结点<code>node </code>是不是它父亲(<code>node.parent</code>)的<strong>右</strong>孩子，如果是，那么它父亲(<code>node.parent</code>)就是它的前驱；</font><font color = #ff00ff><strong>b</strong>. 如果当前结点是它父亲的左孩子(<code>node.parent.left == node</code>)，那么就向上不停的寻找它的前驱结点，即当前结点为<code>node</code>，它的父亲为<code>parent</code>，如果<code>node</code>还是<code>parent</code>的左孩子，就令<code>node= parent，parent = parent.parent</code>，一直向上，直到<code>parent.right = node</code>，就停止，此时<code>parent</code>就是当初要找的结点的前驱。</li>
</ul>
<h3 id="完整的测试代码如下"><a href="#完整的测试代码如下" class="headerlink" title="完整的测试代码如下"></a>完整的测试代码如下</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 寻找结点的后继和前驱结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuccessorNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line">        <span class="keyword">public</span> Node parent;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//寻找某个结点的后继结点</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">getSuccessorNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">return</span> getMostLeft(node.right);<span class="comment">//第一种情况　　结点的右子树为null</span></span><br><span class="line">        <span class="keyword">else</span> &#123;  <span class="comment">//第二种情况</span></span><br><span class="line">            Node parent = node.parent;</span><br><span class="line">            <span class="keyword">while</span> (parent != <span class="keyword">null</span> &amp;&amp; parent.left != node) &#123;</span><br><span class="line">                node = parent;</span><br><span class="line">                parent = node.parent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找到某个结点的最左边的结点</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">getMostLeft</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (node.left != <span class="keyword">null</span>)</span><br><span class="line">            node = node.left;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//寻找某个结点的前驱结点</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">getPrecursorNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.left!= <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> getMostRight(node.left);<span class="comment">//第一种情况　　结点的右子树为null</span></span><br><span class="line">        <span class="keyword">else</span> &#123;  <span class="comment">//第二种情况</span></span><br><span class="line">            Node parent = node.parent;</span><br><span class="line">            <span class="keyword">while</span> (parent != <span class="keyword">null</span> &amp;&amp; parent.right != node) &#123;</span><br><span class="line">                node = parent;</span><br><span class="line">                parent = node.parent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找到某个结点的最右边的结点</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">getMostRight</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (node.right != <span class="keyword">null</span>)</span><br><span class="line">            node = node.right;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先创建上图的树</span></span><br><span class="line">        Node head = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        head.left = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">        head.left.parent = head;</span><br><span class="line">        head.left.left = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">        head.left.left.parent = head.left;</span><br><span class="line">        head.left.right = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">        head.left.right.parent = head.left;</span><br><span class="line">        head.left.right.right = <span class="keyword">new</span> Node(<span class="number">8</span>);</span><br><span class="line">        head.left.right.right.parent = head.left.right;</span><br><span class="line">        head.right = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">        head.right.parent = head;</span><br><span class="line">        head.right.left = <span class="keyword">new</span> Node(<span class="number">6</span>);</span><br><span class="line">        head.right.left.parent = head.right;</span><br><span class="line">        head.right.left.left = <span class="keyword">new</span> Node(<span class="number">9</span>);</span><br><span class="line">        head.right.left.left.parent = head.right.left;</span><br><span class="line">        head.right.right = <span class="keyword">new</span> Node(<span class="number">7</span>);</span><br><span class="line">        head.right.right.parent = head.right;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------test Successor----------&quot;</span>);</span><br><span class="line">        Node node = head; <span class="comment">//测试1</span></span><br><span class="line">        System.out.println(node.value + <span class="string">&quot;&#x27;s next : &quot;</span> + getSuccessorNode(node).value);</span><br><span class="line"></span><br><span class="line">        node = head.left.left; <span class="comment">//测试4</span></span><br><span class="line">        System.out.println(node.value + <span class="string">&quot;&#x27;s next : &quot;</span> + getSuccessorNode(node).value);</span><br><span class="line"></span><br><span class="line">        node = head.left.right.right; <span class="comment">// 测试8</span></span><br><span class="line">        System.out.println(node.value + <span class="string">&quot;&#x27;s next : &quot;</span> + getSuccessorNode(node).value);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------test Precursor----------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        node = head; <span class="comment">//测试1</span></span><br><span class="line">        System.out.println(node.value + <span class="string">&quot;&#x27;s next : &quot;</span> + getPrecursorNode(node).value);</span><br><span class="line"></span><br><span class="line">        node = head.right.left.left; <span class="comment">// 测试9</span></span><br><span class="line">        System.out.println(node.value + <span class="string">&quot;&#x27;s next : &quot;</span> + getPrecursorNode(node).value);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="images/houji4.png" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>子数组累加和为aim(小于等于aim)的三个问题</title>
    <url>/2022/05/26/%E5%AD%90%E6%95%B0%E7%BB%84%E7%B4%AF%E5%8A%A0%E5%92%8C%E4%B8%BAaim(%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8Eaim)%E7%9A%84%E4%B8%89%E4%B8%AA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="子数组累加和为aim-小于等于aim-的三个问题"><a href="#子数组累加和为aim-小于等于aim-的三个问题" class="headerlink" title="子数组累加和为aim(小于等于aim)的三个问题"></a>子数组累加和为aim(小于等于aim)的三个问题</h3><ul>
<li>累加和<code> = aim</code>的最长子数组的长度(<strong>数组可<code>+</code>,<code>-</code>,<code>0</code></strong>)；</li>
<li>累加和<code> = aim</code>的最长子数组的长度(<strong>数组<code>+</code></strong>)(只有正数)；</li>
<li>累加和<code> &lt;= aim</code>的最长子数组的长度(<strong>数组可<code>+</code>,<code>-</code>,<code>0</code></strong>)；</li>
</ul>
<hr>
<h3 id="累加和-aim的最长子数组的长度-数组可-0-；"><a href="#累加和-aim的最长子数组的长度-数组可-0-；" class="headerlink" title="累加和 = aim的最长子数组的长度(数组可+,-,0)；"></a>累加和<code> = aim</code>的最长子数组的长度(<strong>数组可<code>+</code>,<code>-</code>,<code>0</code></strong>)；</h3><p>这个题目使用<code>HashMap</code>来存储前面出现过的累加和的下标，具体过程如下: </p>
<ul>
<li>使用变量<code>sum</code>表示从<code>0</code>位置开始一直加到i位置所有元素的累加和；</li>
<li><code>HashMap</code>中<code>key</code>表示从<code>arr</code>最左边开始累加过程中出现过的<code>sum</code>值，<code>value</code>表示的是<code>sum</code>值出现最早的位置；、</li>
<li>假设当前元素为<code>arr[i]</code>，则<code>sum += arr[i]</code>，之前所有累加和为<code>sum</code> ，查看<code>map</code>中是否有<code>sum - aim</code>这个值，如果有，且对应<code>value</code>为<code>j</code>，那么就找到一个子数组累加和为<code>aim</code>的，且长度为 <code>i -  j  + 1</code>；</li>
<li>检查现在的<code>sum </code>是否在<code>map</code>中出现，如果不存在，说明此时是第一次出现的，把<code>(sum,i)</code>加入到<code>map</code>中；</li>
<li>继续遍历数组；</li>
</ul>
<p><font color = red> 很重要的一个地方就是一开始<code>map</code>中要存<code>(0,-1)</code>这个值，直观理解是一个数也没有的时候也可以累加出<code>0</code></font><br>看下面例子:<br><code>[1,2,3,3] ， aim = 6</code>；<br>如果没有存<code>(0,-1)</code>，累加到下标为<code>2</code>的时候，<code>sum = 6</code> 此时，<code>sum - aim = 6 - 6 =  0</code>，但是没有<code>0</code>这个累加和，就会忽略； </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**　O(n)时间 O(n)空间 */</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxLength</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> aim)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length== <span class="number">0</span> )<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       HashMap&lt;Integer,Integer&gt;map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;(); <span class="comment">//表示key这个累加和最早出现在value位置</span></span><br><span class="line">       map.put(<span class="number">0</span>,-<span class="number">1</span>);     <span class="comment">//这个很重要</span></span><br><span class="line">       <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">           sum += arr[i];</span><br><span class="line">           <span class="keyword">if</span>(map.containsKey(sum - aim))&#123; <span class="comment">//如果之前出现了</span></span><br><span class="line">               res = Math.max(res,i - map.get(sum - aim));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(!map.containsKey(sum))&#123;</span><br><span class="line">               map.put(sum,i);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>问题变式: 给定一个数组，求正数和负数个数相等最长子数组长度。<br>解: 把正数变成<code>1</code>，负数变成<code>-1</code>即可。</p>
<p>还有一个扩展问题: </p>
<p>题目: </p>
<blockquote>
<p>定义数组的异或和的概念:<br>数组中所有的数异或起来，得到的结果叫做数组的异或和，比如数组<code>&#123;3, 2, 1&#125;</code>的异或和是: <code>3 ^ 2 ^ 1 = 0 </code>。<br>给定一个数组<code>arr</code>，你可以任意把<code>arr</code>分成很多不相容的子数组，你的目的是: <font color = red>分出来的子数组中，异或和为<code>0</code>的子数组最多。<br>请返回: 分出来的子数组中，异或和为<code>0</code>的子数组最多是多少?  </p>
</blockquote>
<p>解析: 可以利用这个思想找到<strong>最晚出现和<code>0~i</code>内异或和(假设为<code>xor</code>)同样异或和的更小的范围内最晚出现的位置，因为最后一个部分是异或和为<code>0</code>，且<code>xor^0 = xor</code>。</strong><br><img src="images/tp1.png" alt="这里写图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * dp[i] = max(dp[i-1],dp[k] + 1) k表示的是i 如果是最优划分中的最后一个部分的最后一个数的话，k是那个部分的开始的地方的前一个</span></span><br><span class="line"><span class="comment">   * 从 0~i-1中异或还是  xor的最晚的位置  :</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxEor</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">      HashMap&lt;Integer,Integer&gt;map = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//存放某个异或和最晚出现的位置</span></span><br><span class="line">      <span class="keyword">int</span> res = <span class="number">0</span>,xor = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">      map.put(<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">          xor ^= arr[i];</span><br><span class="line">          <span class="keyword">if</span>(map.containsKey(xor))&#123;<span class="comment">// 找到上一个异或和为xor的最晚出现的位置　　　因为xor^0 = xor</span></span><br><span class="line">              <span class="keyword">int</span> k = map.get(xor); <span class="comment">//k</span></span><br><span class="line">              dp[i] = k == -<span class="number">1</span> ? <span class="number">1</span> : dp[k] + <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">              dp[i] = Math.max(dp[i],dp[i-<span class="number">1</span>]);</span><br><span class="line">          &#125;</span><br><span class="line">          map.put(xor,i); <span class="comment">//每次都要put进去</span></span><br><span class="line">          res = Math.max(dp[i],res);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="累加和-aim的最长子数组的长度-数组-只有正数-；"><a href="#累加和-aim的最长子数组的长度-数组-只有正数-；" class="headerlink" title="累加和 = aim的最长子数组的长度(数组+)(只有正数)；"></a>累加和<code> = aim</code>的最长子数组的长度(<strong>数组<code>+</code></strong>)(只有正数)；</h3><p>这个和上面唯一的不同就是数组中只有正数，这里使用类似窗口移动的做法，给出两个指针，<code>L、R</code>表示窗口的左右边界 ，<code>sum</code>表示的是<code>arr[L,R]</code>之间的累加和，<code>L</code>，<code>R</code>一直往右动。</p>
<ul>
<li>如果窗口内<code>sum &lt; aim</code>，<code>R</code>就往右扩，并且<code>sum += arr[R]</code>；</li>
<li>如果窗口内<code>sum &gt; aim</code>，<code>L</code> 就往右扩，并且<code>sum -= arr[L]</code>；</li>
<li>如果窗口内<code>sum = aim</code>， 就说明这个窗口内累加和为<code>sum</code> ，此时记录最大值即可；</li>
</ul>
<p><img src="images/tp2.png" alt="这里写图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> aim)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>,R = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, sum = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span>(R &lt; arr.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == aim)&#123;</span><br><span class="line">            res = Math.max(res,R - L + <span class="number">1</span>);</span><br><span class="line">            sum -= arr[L++];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; aim)&#123;<span class="comment">//小于等于就往右边扩</span></span><br><span class="line">            <span class="keyword">if</span>(++R == arr.length) <span class="keyword">break</span>;</span><br><span class="line">            sum += arr[R];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;           <span class="comment">// 大于就往左边扩  sum &gt; aim</span></span><br><span class="line">            sum -= arr[L++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="累加和-lt-aim的最长子数组的长度-数组可-0-；"><a href="#累加和-lt-aim的最长子数组的长度-数组可-0-；" class="headerlink" title="累加和 &lt;= aim的最长子数组的长度(数组可+,-,0)；"></a>累加和<code> &lt;= aim</code>的最长子数组的长度(<strong>数组可<code>+</code>,<code>-</code>,<code>0</code></strong>)；</h3><p>两个数组<code>sum</code>和<code>ends</code>，<code>sum[i]</code>表示的是以<code>arr[i]</code>开头(必须包含<code>arr[i]</code>)的所有子数组的最小累加和，对应的<code>ends[i]</code>表示的是取得这个最小累加和的右边界。 一开始先求出<code>sums</code>数组和<code>ends[]</code>数组。<br><img src="images/tp3.png" alt="这里写图片描述"></p>
<p>这个题目最精华的是左右边界不回退，就是说，如果从<code>0</code>位置扩到<code>T</code>区间，<code>T+1</code>区间不能扩了，此时不是回到<code>1</code>位置开始扩，而是舍弃<code>0</code>位置，看能不能由于舍弃<code>0</code>位置把<code>T+1</code>位置加进来：</p>
<p><img src="images/tp4.png" alt="这里写图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxLength2</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> aim)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span>[] sums = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length]; <span class="comment">//以arr[i]开头所有子数组的最小累加和</span></span><br><span class="line">     <span class="keyword">int</span>[] ends = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length]; <span class="comment">//取得最小累加和的最右边界</span></span><br><span class="line">     sums[arr.length-<span class="number">1</span>] = arr[arr.length-<span class="number">1</span>];</span><br><span class="line">     ends[arr.length-<span class="number">1</span>] = arr.length-<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = arr.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123; <span class="comment">//求出sums数组和ends数组</span></span><br><span class="line">         <span class="keyword">if</span>(sums[i+<span class="number">1</span>] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">             sums[i] = arr[i] + sums[i+<span class="number">1</span>];</span><br><span class="line">             ends[i] = ends[i+<span class="number">1</span>];</span><br><span class="line">         &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">             sums[i] = arr[i];</span><br><span class="line">             ends[i] = i;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">//目前的累加和  sum -&gt; R</span></span><br><span class="line">     <span class="keyword">int</span> R = <span class="number">0</span>;<span class="comment">//每一次扩到的右边界</span></span><br><span class="line">     <span class="keyword">int</span> res = <span class="number">0</span>; <span class="comment">//答案</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; arr.length; start++)&#123;<span class="comment">//每一次开头</span></span><br><span class="line">         <span class="keyword">while</span>(R &lt; arr.length &amp;&amp; sum + sums[R] &lt;= aim)&#123;<span class="comment">//一整块一整块的扩</span></span><br><span class="line">             sum += sums[R];</span><br><span class="line">             R = ends[R] + <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         sum -= R &gt; start ? arr[start] : <span class="number">0</span>;<span class="comment">//如果R&gt;start，下面start要++了，窗口内减去arr[start]</span></span><br><span class="line">         res = Math.max(res,R - start);<span class="comment">//窗口是start ~ R-1  ,所以是长度为R-start</span></span><br><span class="line">         R = Math.max(R,start + <span class="number">1</span>);  <span class="comment">//有没有可能扩不出去</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>TwoPointer</tag>
      </tags>
  </entry>
  <entry>
    <title>如何直观的打印一颗二叉树</title>
    <url>/2022/07/27/%E5%A6%82%E4%BD%95%E7%9B%B4%E8%A7%82%E7%9A%84%E6%89%93%E5%8D%B0%E4%B8%80%E9%A2%97%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="如何直观的打印一颗二叉树"><a href="#如何直观的打印一颗二叉树" class="headerlink" title="如何直观的打印一颗二叉树"></a>如何直观的打印一颗二叉树</h2><p> 打印的结果是需要<font color = red>顺时针旋转<code>90</code>度</font>的，如下面的结果打印出来是这样的。</p>
<p><img src="images/print1.png" alt="在这里插入图片描述"></p>
<p><img src="images/print2.png" alt="这里写图片描述"></p>
<p>如何打印呢?  需要处理以下四个问题： </p>
<ul>
<li>遍历树的顺序是　<font color= red>右子树-&gt;根-&gt;左子树；</li>
<li>因为要避免数字长度影响对齐的因素，所以两边补上空格(有一个总长度可以自己确定)；</li>
<li><font color  = blue>在结点的两边加上特定的字符串标记区分孩子和父亲以及位置</font>，使用 <code>H</code>、 <code>^</code>、 <code>v</code>  这个几个标记</li>
<li>和高度有关系的  <code>height * len</code>， 打印相应前面的空格长度；</li>
</ul>
<hr>
<h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintBinaryTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head      传入的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> height　　层数(根节点为0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> to       表示的特定节点  H表示根节点   ^表示父亲节点在左上方　v表示父亲节点在左下方</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len　　　 指定每一个节点打印的宽度(总宽度)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTree</span><span class="params">(Node head,<span class="keyword">int</span> height,String to,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        printTree(head.right,height + <span class="number">1</span>,<span class="string">&quot;v&quot;</span>,len);  <span class="comment">// 递归右子树</span></span><br><span class="line"></span><br><span class="line">        String val = to + head.value + to;   <span class="comment">// 加上两边指示的字符</span></span><br><span class="line">        <span class="keyword">int</span> lenV = val.length();</span><br><span class="line">        <span class="keyword">int</span> lenL = (len - lenV)/<span class="number">2</span>;    <span class="comment">//  左边的空格  ((总长度-值所占长度)，然后分一半)</span></span><br><span class="line">        <span class="keyword">int</span> lenR = len - lenV - lenL; <span class="comment">//  右边的空格  (总-值-左边空格长度)</span></span><br><span class="line">        System.out.println( getSpace(len * height) + getSpace(lenL) + val + getSpace(lenR)); <span class="comment">// len*length是对应的层数对应的空格</span></span><br><span class="line"></span><br><span class="line">        printTree(head.left,height + <span class="number">1</span>,<span class="string">&quot;^&quot;</span>,len);  <span class="comment">// 递归左子树</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取指定的空格</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">getSpace</span><span class="params">(<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        StringBuffer str = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            str.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *              1</span></span><br><span class="line"><span class="comment">         *            2   3</span></span><br><span class="line"><span class="comment">         *          4    5 6</span></span><br><span class="line"><span class="comment">         *            7</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node head = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        head.left = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">        head.right = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">        head.left.left = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">        head.right.left = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">        head.right.right = <span class="keyword">new</span> Node(<span class="number">6</span>);</span><br><span class="line">        head.left.left.right = <span class="keyword">new</span> Node(<span class="number">7</span>);</span><br><span class="line">        printTree(head,<span class="number">0</span>,<span class="string">&quot;H&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>将单链表按某值划分成左边小，中间相等，右边大的形式</title>
    <url>/2022/09/16/%E5%B0%86%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8C%89%E6%9F%90%E5%80%BC%E5%88%92%E5%88%86%E6%88%90%E5%B7%A6%E8%BE%B9%E5%B0%8F%EF%BC%8C%E4%B8%AD%E9%97%B4%E7%9B%B8%E7%AD%89%EF%BC%8C%E5%8F%B3%E8%BE%B9%E5%A4%A7%E7%9A%84%E5%BD%A2%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="将单链表按某值划分成左边小，中间相等，右边大的形式"><a href="#将单链表按某值划分成左边小，中间相等，右边大的形式" class="headerlink" title="将单链表按某值划分成左边小，中间相等，右边大的形式"></a>将单链表按某值划分成左边小，中间相等，右边大的形式</h2><ul>
<li>普通方法，将链表节点放到数组然后partition</li>
<li>进阶方法，将链表划分成三个子链表，然后合并</li>
</ul>
<hr>
<h3 id="普通方法，将链表节点放到数组然后partition"><a href="#普通方法，将链表节点放到数组然后partition" class="headerlink" title="普通方法，将链表节点放到数组然后partition"></a>普通方法，将链表节点放到数组然后partition</h3><ul>
<li><p> 这个方法比较简单，直接将链表中的值保存到一个数组中，然后按照荷兰国旗的划分方式，将数组划分成左边小于那个数，中间等于那个数，右边大于那个数的形式，(荷兰国旗问题用于<a href="https://blog.csdn.net/zxzxzx0119/article/details/79826380#t8"><strong>快速排序</strong></a>中的<code>partition</code>过程)；</p>
</li>
<li><p>划分完之后，再把数组中的值用链表的形式连接起来。　但是这个方法需要额外的<code>O(n)</code>的空间复杂度，而且<code>partition</code>不能达到稳定性(就是会改变原来的相对顺序)；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通的需要额外空间O(n)且不能达到稳定性的　方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Node <span class="title">partitionList_1</span><span class="params">(Node head, <span class="keyword">int</span> pivot)</span> </span>&#123; <span class="comment">//pivot表示　枢轴；中心点；旋转运动</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        len++;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    Node[] nodeArr = <span class="keyword">new</span> Node[len];</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodeArr.length; i++) &#123;</span><br><span class="line">        nodeArr[i] = cur;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    arrPartition(nodeArr, pivot);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nodeArr.length; i++) &#123;</span><br><span class="line">        nodeArr[i - <span class="number">1</span>].next = nodeArr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    nodeArr[nodeArr.length - <span class="number">1</span>].next = <span class="keyword">null</span>;  <span class="comment">//一定要记得把最后一个指针指向null</span></span><br><span class="line">    <span class="keyword">return</span> nodeArr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组划分的paration</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arrPartition</span><span class="params">(Node[] nodeArr, <span class="keyword">int</span> pivot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> less = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> more = nodeArr.length;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur &lt; more) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodeArr[cur].value &lt; pivot) &#123;</span><br><span class="line">            swap(nodeArr, ++less, cur++);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeArr[cur].value &gt; pivot) &#123;</span><br><span class="line">            swap(nodeArr, --more, cur); <span class="comment">//注意放到大于区域的时候cur不能++</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换两个结点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Node[] arrNode, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    Node temp = arrNode[a];</span><br><span class="line">    arrNode[a] = arrNode[b];</span><br><span class="line">    arrNode[b] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="进阶方法，将链表划分成三个子链表，然后合并"><a href="#进阶方法，将链表划分成三个子链表，然后合并" class="headerlink" title="进阶方法，将链表划分成三个子链表，然后合并"></a>进阶方法，将链表划分成三个子链表，然后合并</h3><ul>
<li>这个方法是将原来的链表依次划分成三个链表，三个链表分别为<code>small</code>代表的是左边小于的部分，<code>equal</code>代表的是中间相等的部分，<code>big</code>代表的是右边的大于部分；</li>
<li>这三个链表都有自己的两个指针<code>Head</code>和<code>Tail</code>分别代表各自的头部和尾部，分成三个子链表之后，我们只需要遍历链表，然后和给定的值比较，按照条件，向三个链表中添加值就可以了，最后把三个链表连接起来就可以了；</li>
</ul>
<p>但是，这个题目要注意一些边界条件。具体看下图: </p>
<p><img src="images/l1.png" alt="这里写图片描述"></p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第二种　进阶的方法　不需要额外的空间复杂度，且能达到稳定性</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Node <span class="title">partitionList_2</span><span class="params">(Node head,<span class="keyword">int</span> piovt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Node sH = <span class="keyword">null</span>,sT = <span class="keyword">null</span>; <span class="comment">//小于部分链表的  head 和tail</span></span><br><span class="line">    Node eH = <span class="keyword">null</span>,eT = <span class="keyword">null</span>; <span class="comment">//等于部分链表的　head 和tail</span></span><br><span class="line">    Node bH = <span class="keyword">null</span>,bT = <span class="keyword">null</span>; <span class="comment">//大于部分链表的　head 和tail</span></span><br><span class="line"></span><br><span class="line">    Node next = <span class="keyword">null</span>;  <span class="comment">//用来保存下一个结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//划分到　三个不同的链表</span></span><br><span class="line">    <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        next = head.next;</span><br><span class="line">        head.next = <span class="keyword">null</span>; <span class="comment">//这个是为了链表拼接后　最后一个就不用再去赋值其next域为null 了</span></span><br><span class="line">        <span class="keyword">if</span>(head.value &lt; piovt)&#123;  <span class="comment">//向　small 部分　分布</span></span><br><span class="line">            <span class="keyword">if</span>(sH == <span class="keyword">null</span>)&#123; <span class="comment">//small部分的第一个结点</span></span><br><span class="line">                sH = head;</span><br><span class="line">                sT = head;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                sT.next = head; <span class="comment">//把head放到small最后一个</span></span><br><span class="line">                sT = head;  <span class="comment">//更新small部分的sT</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(head.value == piovt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(eH == <span class="keyword">null</span>)&#123;</span><br><span class="line">                eH = head;</span><br><span class="line">                eT = head;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                eT.next = head;</span><br><span class="line">                eT = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(bH == <span class="keyword">null</span>)&#123;</span><br><span class="line">                bH = head;</span><br><span class="line">                bT = head;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                bT.next = head;</span><br><span class="line">                bT = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将三个链表合并(注意边界的判断)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> != sT) &#123; <span class="comment">//合并small和equal部分</span></span><br><span class="line">        sT.next = eH;</span><br><span class="line">        eT = eT == <span class="keyword">null</span> ? sT : eT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> != eT)&#123;</span><br><span class="line">        eT.next = bH;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sH != <span class="keyword">null</span> ? sH : eH != <span class="keyword">null</span> ? eH : bH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后贴上测试完整代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将一个链表划分成　左边小于num,中间等于num,右边大于num</span></span><br><span class="line"><span class="comment"> * 方法1 : 先将链表存到一个数组中，然后使用　　和　荷兰国旗问题相同的方法进行　划分，然后再重新连成一个链表即可(缺点: 额外的空间复杂度和不能做到稳定性)</span></span><br><span class="line"><span class="comment"> * 方法2 : 使用有限的变量，small equal big 划分成三个链表，这三个链表都分别有自己的头部和尾部，每次一只需要往对应的链表加上相应的数即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmallerEqualBigger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通的需要额外空间O(n)且不能达到稳定性的　方法</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">partitionList_1</span><span class="params">(Node head,<span class="keyword">int</span> pivot)</span></span>&#123; <span class="comment">//pivot表示　枢轴；中心点；旋转运动</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Node[] nodeArr = <span class="keyword">new</span> Node[len];</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodeArr.length; i++)&#123;</span><br><span class="line">            nodeArr[i] = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        arrPartition(nodeArr,pivot);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nodeArr.length; i++)&#123;</span><br><span class="line">            nodeArr[i-<span class="number">1</span>].next = nodeArr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        nodeArr[nodeArr.length-<span class="number">1</span>].next = <span class="keyword">null</span>;  <span class="comment">//一定要记得把最后一个指针指向null</span></span><br><span class="line">        <span class="keyword">return</span> nodeArr[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组划分的paration</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arrPartition</span><span class="params">(Node[] nodeArr, <span class="keyword">int</span> pivot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> less = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> more = nodeArr.length;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur &lt; more)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nodeArr[cur].value &lt; pivot)&#123;</span><br><span class="line">                swap(nodeArr,++less,cur++);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nodeArr[cur].value &gt; pivot)&#123;</span><br><span class="line">                swap(nodeArr,--more,cur); <span class="comment">//注意放到大于区域的时候cur不能++</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换两个结点</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Node[] arrNode,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        Node temp = arrNode[a];</span><br><span class="line">        arrNode[a] = arrNode[b];</span><br><span class="line">        arrNode[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种　进阶的方法　不需要额外的空间复杂度，且能达到稳定性</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">partitionList_2</span><span class="params">(Node head,<span class="keyword">int</span> piovt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Node sH = <span class="keyword">null</span>,sT = <span class="keyword">null</span>; <span class="comment">//小于部分链表的  head 和tail</span></span><br><span class="line">        Node eH = <span class="keyword">null</span>,eT = <span class="keyword">null</span>; <span class="comment">//等于部分链表的　head 和tail</span></span><br><span class="line">        Node bH = <span class="keyword">null</span>,bT = <span class="keyword">null</span>; <span class="comment">//大于部分链表的　head 和tail</span></span><br><span class="line"></span><br><span class="line">        Node next = <span class="keyword">null</span>;  <span class="comment">//用来保存下一个结点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//划分到　三个不同的链表</span></span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            next = head.next;</span><br><span class="line">            head.next = <span class="keyword">null</span>; <span class="comment">//这个是为了链表拼接后　最后一个就不用再去赋值其next域为null 了</span></span><br><span class="line">            <span class="keyword">if</span>(head.value &lt; piovt)&#123;  <span class="comment">//向　small 部分　分布</span></span><br><span class="line">                <span class="keyword">if</span>(sH == <span class="keyword">null</span>)&#123; <span class="comment">//small部分的第一个结点</span></span><br><span class="line">                    sH = head;</span><br><span class="line">                    sT = head;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    sT.next = head; <span class="comment">//把head放到small最后一个</span></span><br><span class="line">                    sT = head;  <span class="comment">//更新small部分的sT</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(head.value == piovt)&#123;</span><br><span class="line">                <span class="keyword">if</span>(eH == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    eH = head;</span><br><span class="line">                    eT = head;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    eT.next = head;</span><br><span class="line">                    eT = head;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(bH == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    bH = head;</span><br><span class="line">                    bT = head;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    bT.next = head;</span><br><span class="line">                    bT = head;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将三个链表合并(注意边界的判断)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != sT) &#123; <span class="comment">//合并small和equal部分</span></span><br><span class="line">            sT.next = eH;</span><br><span class="line">            eT = eT == <span class="keyword">null</span> ? sT : eT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != eT)&#123;</span><br><span class="line">            eT.next = bH;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sH != <span class="keyword">null</span> ? sH : eH != <span class="keyword">null</span> ? eH : bH;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.print(node.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------测试第一种方法----------&quot;</span>);</span><br><span class="line">        Node head = <span class="keyword">new</span> Node(<span class="number">9</span>);</span><br><span class="line">        head.next = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">        head.next.next = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">        head.next.next.next = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">        head.next.next.next.next = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        printList(head);</span><br><span class="line">        head = partitionList_1(head,<span class="number">3</span>);</span><br><span class="line">        printList(head);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------测试第二种方法----------&quot;</span>);</span><br><span class="line">        Node head2 = <span class="keyword">new</span> Node(<span class="number">9</span>);</span><br><span class="line">        head2.next = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">        head2.next.next = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">        head2.next.next.next = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">        head2.next.next.next.next = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        printList(head2);</span><br><span class="line">        head2 = partitionList_2(head2,<span class="number">3</span>);</span><br><span class="line">        printList(head2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果</p>
<p><img src="images/l2.png" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title>最大值减去最小值小于等于aim的子数组数量(单调队列(最大值和最小值更新结构))</title>
    <url>/2022/10/05/%E6%9C%80%E5%A4%A7%E5%80%BC%E5%87%8F%E5%8E%BB%E6%9C%80%E5%B0%8F%E5%80%BC%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8Eaim%20%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0%E9%87%8F(%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97(%E6%9C%80%E5%A4%A7%E5%80%BC%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC%E6%9B%B4%E6%96%B0%E7%BB%93%E6%9E%84))/</url>
    <content><![CDATA[<h2 id="最大值减去最小值小于等于aim的子数组数量-单调队列-最大值和最小值更新结构"><a href="#最大值减去最小值小于等于aim的子数组数量-单调队列-最大值和最小值更新结构" class="headerlink" title="最大值减去最小值小于等于aim的子数组数量(单调队列(最大值和最小值更新结构))"></a>最大值减去最小值小于等于aim的子数组数量(单调队列(最大值和最小值更新结构))</h2><p><img src="images/ms6.png" alt="这里写图片描述"></p>
<p><font color = red>注意: 子数组必须是下标连续的，而且<code>i ~ i</code>自己也算一个子数组。</font></p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>这个题目也是使用单调队列(窗口内更新最大值和最小值)的结构来做，如果不懂单调队列先看<a href="https://blog.csdn.net/zxzxzx0119/article/details/81586455"><strong>这个博客</strong></a>。</p>
<p><font color = red><strong>先准备两个双端队列，分别是最大值更新结构和最小值更新结构：</strong></font></p>
<ul>
<li><strong>先生成两个双端队列<code>qmax</code>和<code>qmin</code>，当子数组为<code>arr[L...R]</code>时，<code>qmax</code>维护了窗口子数组<code>arr[L...R]</code>的最大值更新结构，<code>qmin</code>维护了窗口子数组<code>arr[L....R]</code>的最小值更新结构；</strong></li>
<li><strong>当子数组<code>arr[L....R]</code>向右扩一个位置变成<code>arr[L....R+1]</code>时，<code>qmax</code>和<code>qmin</code>可以在<code>O(1)</code>时间内完成更新；并且可以在<code>O(1)</code>时间内得到窗口的最大值和最小值；</strong></li>
<li><strong>当子数组<code>arr[L....R]</code>左边缩一个位置变成<code>arr[L+1....R]</code>是，<code>qmax</code>和<code>qmin</code>可以在<code>O(1)</code>时间内完成更新；并且可以在<code>O(1)</code>时间内得到窗口的最大值和最小值；</strong></li>
</ul>
<p>然后，我们需要证明两个结论: </p>
<p><img src="images/ms7.png" alt="这里写图片描述"></p>
<h4 id="下面看具体过程"><a href="#下面看具体过程" class="headerlink" title="下面看具体过程:"></a>下面看具体过程:</h4><ul>
<li>找到一个<code>L</code>，此时令<code>R</code>不断向右移动，表示<code>arr[L...R]</code>一直向右扩大，并不断更新<code>qmax</code>和<code>qmin</code>的结构，保证<code>qmax</code>和<code>qmin</code>始终维持动态窗口最大值和最小值的更新结构；</li>
<li>一旦出现<code>arr[L....R]</code>中出现<code>max - min &gt; aim</code>的情况，<code>R</code>向右扩的过程停止(<font color = red>上面证明结论的第二条</font>)，此时<code>arr[L....R-1]，arr[L....R-2]，arr[L....R-3]....arr[L,L]</code>都是满足条件的子数组(<font color = red>上面证明结论的第一条</font>)。也就是说，所以必须以<code>arr[L]</code>开头的子数组，总共<font color = red>有<code>R - L </code>个，<code>res += R-L</code></font>；</li>
<li>然后要<strong>注意两个队列中的过期的元素</strong>，也就是说队头的元素考虑完了之后<strong>要弹出</strong>；</li>
<li>然后，继续考虑下一个<code>L</code>，直到循环结束；</li>
</ul>
<p> <strong>由于<code>L,R</code>的值是一直增加的(不会减小)，且所有的下标最多进<code>qmax、qmin</code>一次，出<code>qmax、qmin</code>一次，时间复杂度为<code>O(n)</code>。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    LinkedList&lt;Integer&gt; qmax = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; qmin = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>, R = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; arr.length) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (R &lt; arr.length) &#123;<span class="comment">//这个While循环就是当L确定的时候，R往右扩到不能再扩</span></span><br><span class="line">            <span class="keyword">while</span> (!qmin.isEmpty() &amp;&amp; arr[qmin.peekLast()] &gt;= arr[R]) qmin.pollLast(); <span class="comment">//最小值更新结构</span></span><br><span class="line">            qmin.addLast(R);</span><br><span class="line">            <span class="keyword">while</span> (!qmax.isEmpty() &amp;&amp; arr[qmax.peekLast()] &lt;= arr[R]) qmax.pollLast();<span class="comment">//最大值更新结构</span></span><br><span class="line">            qmax.addLast(R);</span><br><span class="line">            <span class="comment">//直接取得最大值和最小值判断一下</span></span><br><span class="line">            <span class="keyword">if</span> (arr[qmax.getFirst()] - arr[qmin.getFirst()] &gt; aim) <span class="keyword">break</span>; <span class="comment">//直到扩到R不能再往右扩</span></span><br><span class="line">            R++; <span class="comment">//否则当L确定的是R就一直往右扩</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (qmin.peekFirst() == L) &#123; <span class="comment">//最小值的更新结构判断下标是否过期</span></span><br><span class="line">            qmin.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (qmax.peekFirst() == L) &#123;<span class="comment">//最大值的更新结构判断下标是否过期</span></span><br><span class="line">            qmax.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        res += R - L; <span class="comment">//一次性的就榨取了所有以L开头的子数组的数量</span></span><br><span class="line">        L++; <span class="comment">//换一个L开头</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>完整的测试代码如下(包括使用<code>O(n^3)</code>方法来测试我们的<code>O(n)</code>方法):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最大值减去最小值　&lt;= num 的子数组数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetNumOfMaxMinusMinSubArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ok(arr, i, j, aim)) res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">ok</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            max = Math.max(max, arr[i]);</span><br><span class="line">            min = Math.min(min, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max - min &lt;= aim;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        LinkedList&lt;Integer&gt; qmax = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        LinkedList&lt;Integer&gt; qmin = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>, R = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (L &lt; arr.length) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (R &lt; arr.length) &#123;<span class="comment">//这个While循环就是当L确定的时候，R往右扩到不能再扩</span></span><br><span class="line">                <span class="keyword">while</span> (!qmin.isEmpty() &amp;&amp; arr[qmin.peekLast()] &gt;= arr[R]) qmin.pollLast(); <span class="comment">//最小值更新结构</span></span><br><span class="line">                qmin.addLast(R);</span><br><span class="line">                <span class="keyword">while</span> (!qmax.isEmpty() &amp;&amp; arr[qmax.peekLast()] &lt;= arr[R]) qmax.pollLast();<span class="comment">//最大值更新结构</span></span><br><span class="line">                qmax.addLast(R);</span><br><span class="line">                <span class="comment">//直接取得最大值和最小值判断一下</span></span><br><span class="line">                <span class="keyword">if</span> (arr[qmax.getFirst()] - arr[qmin.getFirst()] &gt; aim) <span class="keyword">break</span>; <span class="comment">//直到扩到R不能再往右扩</span></span><br><span class="line">                R++; <span class="comment">//否则当L确定的是R就一直往右扩</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (qmin.peekFirst() == L) &#123; <span class="comment">//最小值的更新结构判断下标是否过期</span></span><br><span class="line">                qmin.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (qmax.peekFirst() == L) &#123;<span class="comment">//最大值的更新结构判断下标是否过期</span></span><br><span class="line">                qmax.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            res += R - L; <span class="comment">//一次性的就榨取了所有以L开头的子数组的数量</span></span><br><span class="line">            L++; <span class="comment">//换一个L开头</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成随机数组</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] generateRandomArray(<span class="keyword">int</span> size, <span class="keyword">int</span> value) &#123;  <span class="comment">//生成的数组的最大长度和</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>) ((size + <span class="number">1</span>) * Math.random())];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">            arr[i] = (<span class="keyword">int</span>) ((value + <span class="number">1</span>) * Math.random()) - (<span class="keyword">int</span>) (value * Math.random());</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组复制</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] arrayCopy(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) copy[i] = arr[i];</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印出数组</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> testTime = <span class="number">100</span>; <span class="comment">//测试100次</span></span><br><span class="line">        <span class="keyword">boolean</span> success = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testTime; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = <span class="number">7</span>, value = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">int</span> k = (<span class="keyword">int</span>) (<span class="number">10</span> * Math.random());</span><br><span class="line">            <span class="keyword">int</span>[] arr = generateRandomArray(size, value);</span><br><span class="line">            <span class="keyword">int</span>[] arr2 = arrayCopy(arr);</span><br><span class="line">            <span class="keyword">int</span> res1 = getNum(arr, k);</span><br><span class="line">            <span class="keyword">int</span> res2 = getNum2(arr2, k);</span><br><span class="line">            <span class="keyword">if</span> (res1 != res2) &#123;</span><br><span class="line">                printArray(arr);</span><br><span class="line">                System.out.println(k);</span><br><span class="line">                System.out.println(res1 + <span class="string">&quot; &quot;</span> + res2);</span><br><span class="line">                System.out.println(<span class="string">&quot;Wrong!&quot;</span>);</span><br><span class="line">                success = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (success) System.out.println(<span class="string">&quot;Nice!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>MonotoneStack</tag>
      </tags>
  </entry>
  <entry>
    <title>找到二叉树中的最大搜索二叉子树</title>
    <url>/2022/08/19/%E6%89%BE%E5%88%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E5%AD%90%E6%A0%91/</url>
    <content><![CDATA[<h2 id="找到二叉树中的最大搜索二叉子树"><a href="#找到二叉树中的最大搜索二叉子树" class="headerlink" title="找到二叉树中的最大搜索二叉子树"></a>找到二叉树中的最大搜索二叉子树</h2><ul>
<li>递归</li>
<li>技巧的写法</li>
<li>完整测试代码</li>
</ul>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><img src="images/tree3.png" alt="在这里插入图片描述"></p>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>解析:<br>这种题目的解题过程分为三步: </p>
<ul>
<li><strong>列出所有可能性</strong>；</li>
<li>**列出结点需要的信息，并整合信息(成一个结构体)**；</li>
<li><strong>改递归 ，先假设左和右都给我信息(黑盒)，然后怎么利用左边和右边的信息组出来我该返回的信息，最后<code>basecase</code>(边界)填什么</strong>；</li>
</ul>
<p>具体到这个题目：<br><font color = red>第一步，列出所有可能性</font>： </p>
<ul>
<li>第一种可能性，以<code>node</code>为头的结点的最大二叉搜索子树可能来自它左子树；</li>
<li>第二种可能性，以<code>node</code>为头的结点的最大二叉搜索子树可能来自它右子树；</li>
<li>第三种可能性，左树整体是搜索二叉树，右树整体也是搜索二叉树，而且左树的头是<code>node.left</code>，右树的头是<code>node.right</code>，且左树的最大值<code>&lt; node.value</code>，右树的最小值<code> &gt; node.value</code>，  <strong>那么以我为头的整棵树都是搜索二叉树；</strong></li>
</ul>
<p><font color = red>第二步，列出结点需要的信息:</font></p>
<ul>
<li>信息一: 左树最大搜索二叉树大小；</li>
<li>信息二: 右树最大搜索二叉树大小；</li>
<li>信息三: 左树上最大搜索二叉树的头部是什么；</li>
<li>信息四: 右树上最大搜索二叉树的头部是什么；</li>
<li>信息五: 左树上的最大值；</li>
<li>信息六: 右树上的最小值；</li>
</ul>
<p>整合成一个<code>Pair</code>结构: 信息一和信息二整合：<code>size</code> ，信息三和信息四整合 : <code>head</code>(结点类型)，以及信息五和信息六 ；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回的类型</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> size; <span class="comment">//左右子树的大小</span></span><br><span class="line">    <span class="keyword">public</span> Node root; <span class="comment">//左右子树的头</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> min;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后第三部就是改成递归，具体如下(是后序遍历的顺序(需要左右的信息来构造头部的信息)): </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回的类型</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> size; <span class="comment">//左右子树的大小</span></span><br><span class="line">    <span class="keyword">public</span> Node root; <span class="comment">//左右子树的头</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> min;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> max;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> size, Node root, <span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">        <span class="keyword">this</span>.min = min;</span><br><span class="line">        <span class="keyword">this</span>.max = max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Node <span class="title">biggestSubBST</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rec(head).root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Pair <span class="title">rec</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair(<span class="number">0</span>, <span class="keyword">null</span>, Integer.MAX_VALUE, Integer.MIN_VALUE);</span><br><span class="line">    Pair L = rec(head.left);</span><br><span class="line">    Pair R = rec(head.right);</span><br><span class="line">    <span class="keyword">int</span> msize =</span><br><span class="line">            (L.root == head.left &amp;&amp; R.root == head.right &amp;&amp; L.max &lt; head.value &amp;&amp; R.min &gt; head.value)</span><br><span class="line">                    ? L.size + R.size + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxSize = Math.max(Math.max(L.size, R.size), msize);</span><br><span class="line">    Node mroot = L.size &gt; R.size ? L.root : R.root;</span><br><span class="line">    <span class="keyword">if</span> (maxSize == msize) mroot = head;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Pair(maxSize, mroot, Math.min(head.value, Math.min(L.min, R.min)),</span><br><span class="line">            Math.max(head.value, Math.max(L.max, R.max)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="改造的写法"><a href="#改造的写法" class="headerlink" title="改造的写法"></a>改造的写法</h3><p>技巧的写法(使用一个数组来记录<code>size,min,max</code>):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Node <span class="title">biggestSubBST2</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] rec = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];  <span class="comment">//0 记录size 1记录min 2记录max</span></span><br><span class="line">    <span class="keyword">return</span> rec2(head, rec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Node <span class="title">rec2</span><span class="params">(Node head, <span class="keyword">int</span>[] rec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        rec[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        rec[<span class="number">1</span>] = Integer.MAX_VALUE;</span><br><span class="line">        rec[<span class="number">2</span>] = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node L = rec2(head.left, rec);</span><br><span class="line">    <span class="keyword">int</span> lsize = rec[<span class="number">0</span>], lmin = rec[<span class="number">1</span>], lmax = rec[<span class="number">2</span>];</span><br><span class="line">    Node R = rec2(head.right, rec);</span><br><span class="line">    <span class="keyword">int</span> rsize = rec[<span class="number">0</span>], rmin = rec[<span class="number">1</span>], rmax = rec[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> msize = (L == head.left &amp;&amp; R == head.right &amp;&amp; lmax &lt; head.value &amp;&amp; rmin &gt; head.value) ? lsize + rsize + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxSize = Math.max(msize, Math.max(lsize, rsize));</span><br><span class="line">    Node root = lsize &gt; rsize ? L : R;</span><br><span class="line">    <span class="keyword">if</span> (msize == maxSize) root = head;</span><br><span class="line">    rec[<span class="number">0</span>] = maxSize;</span><br><span class="line">    rec[<span class="number">1</span>] = Math.min(head.value, Math.min(lmin, rmin));</span><br><span class="line">    rec[<span class="number">2</span>] = Math.max(head.value, Math.max(lmax, rmax));</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完整测试代码-测试样例"><a href="#完整测试代码-测试样例" class="headerlink" title="完整测试代码(测试样例)"></a>完整测试代码(测试样例)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一棵树中最大的二叉搜索子树的大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BiggestSubBST</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回的类型</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> size; <span class="comment">//左右子树的大小</span></span><br><span class="line">        <span class="keyword">public</span> Node root; <span class="comment">//左右子树的头</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> min;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> max;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> size, Node root, <span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.size = size;</span><br><span class="line">            <span class="keyword">this</span>.root = root;</span><br><span class="line">            <span class="keyword">this</span>.min = min;</span><br><span class="line">            <span class="keyword">this</span>.max = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">biggestSubBST</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rec(head).root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Pair <span class="title">rec</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Pair(<span class="number">0</span>, <span class="keyword">null</span>, Integer.MAX_VALUE, Integer.MIN_VALUE);</span><br><span class="line">        Pair L = rec(head.left);</span><br><span class="line">        Pair R = rec(head.right);</span><br><span class="line">        <span class="keyword">int</span> msize =</span><br><span class="line">                (L.root == head.left &amp;&amp; R.root == head.right &amp;&amp; L.max &lt; head.value &amp;&amp; R.min &gt; head.value)</span><br><span class="line">                        ? L.size + R.size + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxSize = Math.max(Math.max(L.size, R.size), msize);</span><br><span class="line">        Node mroot = L.size &gt; R.size ? L.root : R.root;</span><br><span class="line">        <span class="keyword">if</span> (maxSize == msize) mroot = head;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair(maxSize, mroot, Math.min(head.value, Math.min(L.min, R.min)),</span><br><span class="line">                Math.max(head.value, Math.max(L.max, R.max)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">biggestSubBST2</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] rec = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];  <span class="comment">//0 记录size 1记录min 2记录max</span></span><br><span class="line">        <span class="keyword">return</span> rec2(head, rec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">rec2</span><span class="params">(Node head, <span class="keyword">int</span>[] rec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            rec[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            rec[<span class="number">1</span>] = Integer.MAX_VALUE;</span><br><span class="line">            rec[<span class="number">2</span>] = Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node L = rec2(head.left, rec);</span><br><span class="line">        <span class="keyword">int</span> lsize = rec[<span class="number">0</span>], lmin = rec[<span class="number">1</span>], lmax = rec[<span class="number">2</span>];</span><br><span class="line">        Node R = rec2(head.right, rec);</span><br><span class="line">        <span class="keyword">int</span> rsize = rec[<span class="number">0</span>], rmin = rec[<span class="number">1</span>], rmax = rec[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> msize = (L == head.left &amp;&amp; R == head.right &amp;&amp; lmax &lt; head.value &amp;&amp; rmin &gt; head.value) ? lsize + rsize + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxSize = Math.max(msize, Math.max(lsize, rsize));</span><br><span class="line">        Node root = lsize &gt; rsize ? L : R;</span><br><span class="line">        <span class="keyword">if</span> (msize == maxSize) root = head;</span><br><span class="line">        rec[<span class="number">0</span>] = maxSize;</span><br><span class="line">        rec[<span class="number">1</span>] = Math.min(head.value, Math.min(lmin, rmin));</span><br><span class="line">        rec[<span class="number">2</span>] = Math.max(head.value, Math.max(lmax, rmax));</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">build</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= arr.length || arr[index] == -<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Node root = <span class="keyword">new</span> Node(arr[index]);</span><br><span class="line">        root.left = build(arr, index * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        root.right = build(arr, index * <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head   传入的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> height 　　层数(根节点为0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> to     表示的特定节点  H表示根节点   ^表示父亲节点在左上方　v表示父亲节点在左下方</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len    　　　指定每一个节点打印的宽度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTree</span><span class="params">(Node head, <span class="keyword">int</span> height, String to, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        printTree(head.right, height + <span class="number">1</span>, <span class="string">&quot;v&quot;</span>, len);</span><br><span class="line"></span><br><span class="line">        String val = to + head.value + to;  <span class="comment">//两边指示的字符</span></span><br><span class="line">        <span class="keyword">int</span> lenV = val.length();</span><br><span class="line">        <span class="keyword">int</span> lenL = (len - lenV) / <span class="number">2</span>;  <span class="comment">//左边的空格(分一半)</span></span><br><span class="line">        <span class="keyword">int</span> lenR = len - lenV - lenL; <span class="comment">// 右边的空格</span></span><br><span class="line">        System.out.println(getSpace(len * height) + getSpace(lenL) + val + getSpace(lenR));</span><br><span class="line"></span><br><span class="line">        printTree(head.left, height + <span class="number">1</span>, <span class="string">&quot;^&quot;</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取指定的空格</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">getSpace</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        StringBuffer str = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) str.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">6</span>, <span class="number">1</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">13</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">4</span>, <span class="number">14</span>, <span class="number">20</span>, <span class="number">16</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">15</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        Node head = build(arr, <span class="number">0</span>);</span><br><span class="line">        printTree(head, <span class="number">0</span>, <span class="string">&quot;H&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        System.out.println(biggestSubBST(head).value);</span><br><span class="line">        System.out.println(biggestSubBST2(head).value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>二叉树打印见<a href="https://blog.csdn.net/zxzxzx0119/article/details/81096554">这个博客</a><br>测试效果:<br><img src="images/tree4.png" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
</search>
