<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>地理空间数据EDA数据探索性分析</title>
    <url>/2021/04/17/EDA%E6%95%B0%E6%8D%AE%E6%8E%A2%E7%B4%A2%E6%80%A7%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>EDA——数据探索性分析，是通过了解数据集的基本情况、变量间的相互关系以及变量与预测值之间的关系，为后期特征工程和建立模型做铺垫。本文以<em>智慧海洋建设竞赛</em>为例进行演示。</p>
<h4 id="1-总体了解数据"><a href="#1-总体了解数据" class="headerlink" title="1. 总体了解数据"></a>1. 总体了解数据</h4><h5 id="1-1-查看样本个数和原始特征维度"><a href="#1-1-查看样本个数和原始特征维度" class="headerlink" title="1.1 查看样本个数和原始特征维度"></a>1.1 查看样本个数和原始特征维度</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_train.shape</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_test.shape</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_train.columns	<span class="comment">#查看列名</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.set_option(<span class="string">&#x27;display.max_info_rows&#x27;</span>,<span class="number">2699639</span>)	<span class="comment">#提高非缺失值检查的行数上线</span></span><br><span class="line"><span class="comment">#pd.options.display.max_info_rows = 2699639</span></span><br><span class="line">data_train.info()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看count 非空值数、std 标准差、（25%、50%、75%）分位数等基本情况</span></span><br><span class="line">data_train.describe([<span class="number">0.01</span>,<span class="number">0.025</span>,<span class="number">0.05</span>,<span class="number">0.5</span>,<span class="number">0.75</span>,<span class="number">0.9</span>,<span class="number">0.99</span>])	</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h5 id="1-2-查看缺失值和唯一值等"><a href="#1-2-查看缺失值和唯一值等" class="headerlink" title="1.2 查看缺失值和唯一值等"></a>1.2 查看缺失值和唯一值等</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_train.isnull().<span class="built_in">any</span>()	<span class="comment">#查看缺失值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看含有缺失值的列名</span></span><br><span class="line">data_train.columns[data_train.isnull().<span class="built_in">any</span>()].tolist()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看仅有唯一值的特征</span></span><br><span class="line">one_value_fea_train = [col <span class="keyword">for</span> col <span class="keyword">in</span> data_train.columns <span class="keyword">if</span> data_train[col].nunique() &lt;= <span class="number">1</span>]</span><br><span class="line">one_value_fea_test = [col <span class="keyword">for</span> col <span class="keyword">in</span> data_test.columns <span class="keyword">if</span> data_test[col].nunique() &lt;= <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="2-查看数据特性和特征分布"><a href="#2-查看数据特性和特征分布" class="headerlink" title="2. 查看数据特性和特征分布"></a>2. 查看数据特性和特征分布</h4><h5 id="2-1-渔船轨迹可视化"><a href="#2-1-渔船轨迹可视化" class="headerlink" title="2.1 渔船轨迹可视化"></a>2.1 渔船轨迹可视化</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从每个类别中随机抽取三个渔船的轨迹进行可视化</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visualize_three_traj</span>():</span></span><br><span class="line">    fig,axes = plt.subplots(nrows=<span class="number">3</span>,ncols=<span class="number">3</span>,figsize=(<span class="number">20</span>,<span class="number">15</span>))</span><br><span class="line">    plt.subplots_adjust(wspace=<span class="number">0.2</span>,hspace=<span class="number">0.2</span>)</span><br><span class="line">    <span class="comment"># 对于每一个类别，随机选出刺网的三条轨迹进行可视化</span></span><br><span class="line">    lables = [<span class="string">&quot;ciwang&quot;</span>,<span class="string">&quot;weiwang&quot;</span>,<span class="string">&quot;tuowang&quot;</span>]</span><br><span class="line">    <span class="keyword">for</span> i,file_type <span class="keyword">in</span> tqdm(<span class="built_in">enumerate</span>([<span class="string">&quot;ciwang_data&quot;</span>,<span class="string">&quot;weiwang_data&quot;</span>,<span class="string">&quot;tuowang_data&quot;</span>])):</span><br><span class="line">        data1, data2, data3 = get_random_three_traj(<span class="built_in">type</span>=file_type)</span><br><span class="line">        <span class="keyword">for</span> j, datax <span class="keyword">in</span> <span class="built_in">enumerate</span>([data1, data2, data3]):</span><br><span class="line">            x_data = datax[<span class="string">&quot;x&quot;</span>].loc[-<span class="number">1</span>:].values</span><br><span class="line">            y_data = datax[<span class="string">&quot;y&quot;</span>].loc[-<span class="number">1</span>:].values</span><br><span class="line">            axes[i][j - <span class="number">1</span>].scatter(x_data[<span class="number">0</span>], y_data[<span class="number">0</span>], label=<span class="string">&quot;start&quot;</span>, c=<span class="string">&quot;red&quot;</span>, s=<span class="number">20</span>, marker=<span class="string">&quot;o&quot;</span>)</span><br><span class="line">            axes[i][j - <span class="number">1</span>].plot(x_data, y_data, label=lables[i])</span><br><span class="line">            axes[i][j - <span class="number">1</span>].scatter(x_data[<span class="built_in">len</span>(x_data) - <span class="number">1</span>], y_data[<span class="built_in">len</span>(y_data) - <span class="number">1</span>], label=<span class="string">&quot;end&quot;</span>, c=<span class="string">&quot;green&quot;</span>, s=<span class="number">20</span>,</span><br><span class="line">                                   marker=<span class="string">&quot;D&quot;</span>)</span><br><span class="line">            axes[i][j - <span class="number">1</span>].grid(alpha=<span class="number">2</span>)</span><br><span class="line">            axes[i][j - <span class="number">1</span>].legend(loc=<span class="string">&quot;best&quot;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line">    </span><br><span class="line">visualize_three_traj()</span><br></pre></td></tr></table></figure>
<p>—————-图1——————</p>
<p>从图中可以发现,不同类别的轨迹有一定区分性.</p>
<blockquote>
<p>刺网为规则多边形.</p>
<p>围网为包围的形状.</p>
<p>拖网为点到点,转弯次数少.</p>
</blockquote>
<p>从轨迹数据可以猜测其特征可能为转弯的角度大小\转弯次数\起始点之间的距离和时间\经度和维度变化范围等.</p>
<p>此外,存在一些异常轨迹需要剔除.</p>
<h4 id="3-坐标序列可视化"><a href="#3-坐标序列可视化" class="headerlink" title="3. 坐标序列可视化"></a>3. 坐标序列可视化</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 随机选取某条数据，观察x坐标序列和y坐标序列的变化情况</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visualize_one_traj_x_y</span>():</span></span><br><span class="line">    fig,axes = plt.subplots(nrows=<span class="number">2</span>,ncols=<span class="number">1</span>,figsize=(<span class="number">10</span>,<span class="number">8</span>))</span><br><span class="line">    plt.subplots_adjust(wspace=<span class="number">0.2</span>,hspace=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">    data1 = get_random_one_traj(<span class="built_in">type</span>=<span class="string">&quot;weiwang_data&quot;</span>)</span><br><span class="line">    x = data1[<span class="string">&quot;x&quot;</span>].loc[-<span class="number">1</span>:]</span><br><span class="line">    x = x / <span class="number">10000</span></span><br><span class="line">    </span><br><span class="line">    y = data1[<span class="string">&quot;y&quot;</span>].loc[-<span class="number">1</span>:]</span><br><span class="line">    y = y / <span class="number">10000</span></span><br><span class="line"></span><br><span class="line">    arr1 = np.arange(<span class="built_in">len</span>(x))</span><br><span class="line">    arr2 = np.arange(<span class="built_in">len</span>(y))</span><br><span class="line"></span><br><span class="line">    axes[<span class="number">0</span>].plot(arr1,x,label=<span class="string">&quot;x&quot;</span>)</span><br><span class="line">    axes[<span class="number">1</span>].plot(arr2,y,label=<span class="string">&quot;y&quot;</span>)</span><br><span class="line">    axes[<span class="number">0</span>].grid(alpha=<span class="number">3</span>)</span><br><span class="line">    axes[<span class="number">0</span>].legend(loc=<span class="string">&quot;best&quot;</span>)</span><br><span class="line">    axes[<span class="number">1</span>].grid(alpha=<span class="number">3</span>)</span><br><span class="line">    axes[<span class="number">1</span>].legend(loc=<span class="string">&quot;best&quot;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line">    </span><br><span class="line">visualize_one_traj_x_y()</span><br></pre></td></tr></table></figure>
<p>———-图2———–</p>
<p>由上图可知,存在同一时间段内x\y坐标均未变化,说明可能该时段内渔船正停留在某处.</p>
<h4 id="4-三类渔船速度和方向可视化"><a href="#4-三类渔船速度和方向可视化" class="headerlink" title="4.三类渔船速度和方向可视化"></a>4.三类渔船速度和方向可视化</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 每类轨迹，随机选取某个渔船，可视化速度序列和方向序列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visualize_three_traj_speed_direction</span>():</span></span><br><span class="line">    fig,axes = plt.subplots(nrows=<span class="number">3</span>,ncols=<span class="number">2</span>,figsize=(<span class="number">20</span>,<span class="number">15</span>))</span><br><span class="line">    plt.subplots_adjust(wspace=<span class="number">0.1</span>,hspace=<span class="number">0.1</span>)</span><br><span class="line">    <span class="comment"># 随机选出刺网的三条轨迹进行可视化</span></span><br><span class="line">    file_types = [<span class="string">&quot;ciwang_data&quot;</span>,<span class="string">&quot;weiwang_data&quot;</span>,<span class="string">&quot;tuowang_data&quot;</span>]</span><br><span class="line">    speed_types = [<span class="string">&quot;ciwang_speed&quot;</span>,<span class="string">&quot;weiwang_speed&quot;</span>,<span class="string">&quot;tuowang_speed&quot;</span>]</span><br><span class="line">    doirections = [<span class="string">&quot;ciwang_direction&quot;</span>,<span class="string">&quot;weiwang_direction&quot;</span>,<span class="string">&quot;tuowang_direction&quot;</span>]</span><br><span class="line">    colors = [<span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;brown&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> i,file_name <span class="keyword">in</span> tqdm(<span class="built_in">enumerate</span>(file_types)):</span><br><span class="line">        datax = get_random_one_traj(<span class="built_in">type</span>=file_name)</span><br><span class="line">        x_data = datax[<span class="string">&quot;速度&quot;</span>].loc[-<span class="number">1</span>:].values</span><br><span class="line">        y_data = datax[<span class="string">&quot;方向&quot;</span>].loc[-<span class="number">1</span>:].values</span><br><span class="line">        axes[i][<span class="number">0</span>].plot(<span class="built_in">range</span>(<span class="built_in">len</span>(x_data)), x_data, label=speed_types[i], color=colors[i])</span><br><span class="line">        axes[i][<span class="number">0</span>].grid(alpha=<span class="number">2</span>)</span><br><span class="line">        axes[i][<span class="number">0</span>].legend(loc=<span class="string">&quot;best&quot;</span>)</span><br><span class="line">        axes[i][<span class="number">1</span>].plot(<span class="built_in">range</span>(<span class="built_in">len</span>(y_data)), y_data, label=doirections[i], color=colors[i])</span><br><span class="line">        axes[i][<span class="number">1</span>].grid(alpha=<span class="number">2</span>)</span><br><span class="line">        axes[i][<span class="number">1</span>].legend(loc=<span class="string">&quot;best&quot;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">visualize_three_traj_speed_direction()</span><br></pre></td></tr></table></figure>
<p>————图3—————-<br>由上图可知,不同分类渔船的轨迹速度某些时段均存在连续的低值情况,说明可能存在某些海上停留点;不同类别渔船的方向变化都很大,可能是海上漂泊导致,作为特征对于类别的区分度低,但也存在方向变化不大的时段,强化了对停留点存在的判断.</p>
<h4 id="5-三类渔船速度和方向的数据分布"><a href="#5-三类渔船速度和方向的数据分布" class="headerlink" title="5.三类渔船速度和方向的数据分布"></a>5.三类渔船速度和方向的数据分布</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对某一特征进行数据统计</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data_cummulation</span>(<span class="params"><span class="built_in">type</span>,path,kind,columns</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    type:&quot;ciwang&quot;,&quot;weiwang&quot; or &quot;tuowang&quot;</span></span><br><span class="line"><span class="string">    path:数据路径</span></span><br><span class="line"><span class="string">    kind:&quot;速度&quot;or&quot;方向&quot;</span></span><br><span class="line"><span class="string">    columns:与kind对应，&quot;speed&quot;or&quot;direction&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    data_dict = <span class="built_in">dict</span>()</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path + <span class="built_in">type</span>+<span class="string">&quot;.pkl&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        data_list = pickle.load(file)</span><br><span class="line">    <span class="keyword">for</span> datax <span class="keyword">in</span> tqdm(data_list):</span><br><span class="line">        data = datax[kind].values</span><br><span class="line">        <span class="keyword">for</span> speed <span class="keyword">in</span> data:</span><br><span class="line">            data_dict.setdefault(speed,<span class="number">0</span>)</span><br><span class="line">            data_dict[speed] += <span class="number">1</span></span><br><span class="line">    data_dict = <span class="built_in">dict</span>(<span class="built_in">sorted</span>(data_dict.items(),key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>],reverse=<span class="literal">False</span>))</span><br><span class="line">    data_df = pd.DataFrame.from_dict(data_dict,columns=[columns],orient=<span class="string">&quot;index&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> data_df</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分别得到速度和方向的分布数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_speed_and_direction_distribution_data</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    path = <span class="string">&quot;./data/&quot;</span></span><br><span class="line">    data_speed_df = get_data_cummulation(<span class="built_in">type</span>=<span class="built_in">type</span>, path=path,kind=<span class="string">&quot;速度&quot;</span>,columns=<span class="string">&quot;speed&quot;</span>)</span><br><span class="line">    data_direction_df = get_data_cummulation(<span class="built_in">type</span>=<span class="built_in">type</span>,path=path,kind=<span class="string">&quot;方向&quot;</span>,columns=<span class="string">&quot;direction&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> data_speed_df,data_direction_df</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可视化速度和方向的数据分布</span></span><br><span class="line">df_speeds = []</span><br><span class="line">df_directions = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_speed_direction1_distribution</span>():</span></span><br><span class="line">    plt.subplots(nrows=<span class="number">1</span>, ncols=<span class="number">2</span>, figsize=(<span class="number">15</span>, <span class="number">6</span>))</span><br><span class="line">    plt.subplots_adjust(wspace=<span class="number">0.2</span>, hspace=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">    file_types = [<span class="string">&quot;ciwang_data&quot;</span>, <span class="string">&quot;weiwang_data&quot;</span>, <span class="string">&quot;tuowang_data&quot;</span>]</span><br><span class="line">    lables = [<span class="string">&quot;ciwang&quot;</span>, <span class="string">&quot;weiwang&quot;</span>, <span class="string">&quot;tuowang&quot;</span>]</span><br><span class="line">    colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, filenames <span class="keyword">in</span> <span class="built_in">enumerate</span>(file_types):</span><br><span class="line">        df11, df21 = get_speed_and_direction_distribution_data(file_types[i])</span><br><span class="line">        plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">        ax1 = sns.kdeplot(df11[<span class="string">&quot;speed&quot;</span>].values / <span class="number">1000000</span>, color=colors[i],shade=<span class="literal">True</span>)</span><br><span class="line">        plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">        ax3 = sns.kdeplot(df21[<span class="string">&quot;direction&quot;</span>].values / <span class="number">1000000</span>, color=colors[i],shade=<span class="literal">True</span>)</span><br><span class="line">        df_speeds.append(df11)</span><br><span class="line">        df_directions.append(df21)</span><br><span class="line">    ax1.legend(lables)</span><br><span class="line">    ax1.set_xlabel(<span class="string">&quot;Speed&quot;</span>)</span><br><span class="line">    ax3.set_xlabel(<span class="string">&quot;Direction&quot;</span>)</span><br><span class="line">    ax3.legend(lables)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">plot_speed_direction1_distribution()</span><br></pre></td></tr></table></figure>
<p>———–图4———————</p>
<p>由上图可知,三种类别渔船的速度分布差异较大,而刺网和围网方向分布差异不明显,拖网方向分布有差异.</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>DataFrame</tag>
        <tag>Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>LightGBM调参_1</title>
    <url>/2021/03/26/lightGBM%E8%B0%83%E5%8F%82/</url>
    <content><![CDATA[<p>#1简单列举一下日常调参过程中常用的几种方法，具体的原理下次补上。</p>
<h4 id="1-经验法"><a href="#1-经验法" class="headerlink" title="1. 经验法:"></a>1. 经验法:</h4><blockquote>
<p>往两个方向调：</p>
<p>1.提高准确率：max_depth, num_leaves, learning_rate</p>
<p>2.降低过拟合：max_bin, min_data_in_leaf；L1, L2正则化；数据抽样, 列采样</p>
</blockquote>
<p>1.使用较小的num_leaves，max_depth和max_bin，降低复杂度。</p>
<p>2.使用min_data_in_leaf和min_sum_hessian_in_leaf，该值越大，模型的学习越保守。</p>
<span id="more"></span>

<p>3.设置bagging_freq和bagging_fraction使用bagging。</p>
<p>4.设置feature_fraction进行特征采样。</p>
<p>5.使用lambda_l1,lambda_l2和min_gain_to_split正则化。</p>
<h4 id="2-贪心调参"><a href="#2-贪心调参" class="headerlink" title="2. 贪心调参:"></a>2. 贪心调参:</h4><p>先调整对模型影响最大的参数，再调整对模型影响次大的参数，缺点是容易调成局部最优，需要多次调试。日常调参顺序如下:</p>
<p>① num_leaves, max_depth</p>
<p>② min_data_in_leaf, min_child_weight</p>
<p>③ bagging_freq, bagging_fraction,  feature_fraction,</p>
<p>④ reg_lambda, reg_alpha</p>
<p>⑤ min_split_gain</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="comment"># 调objective</span></span><br><span class="line">best_obj = <span class="built_in">dict</span>()</span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> objective:</span><br><span class="line">    model = LGBMRegressor(objective=obj)</span><br><span class="line">    score = cross_val_score(model, X_train, y_train, cv=<span class="number">5</span>, scoring=<span class="string">&#x27;f1&#x27;</span>).mean()</span><br><span class="line">    best_obj[obj] = score</span><br><span class="line"></span><br><span class="line"><span class="comment"># num_leaves</span></span><br><span class="line">best_leaves = <span class="built_in">dict</span>()</span><br><span class="line"><span class="keyword">for</span> leaves <span class="keyword">in</span> num_leaves:</span><br><span class="line">    model = LGBMRegressor(objective=<span class="built_in">min</span>(best_obj.items(), key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])[<span class="number">0</span>], num_leaves=leaves)</span><br><span class="line">    score = cross_val_score(model, X_train, y_train, cv=<span class="number">5</span>, scoring=<span class="string">&#x27;f1&#x27;</span>).mean()</span><br><span class="line">    best_leaves[leaves] = score</span><br><span class="line"></span><br><span class="line"><span class="comment"># max_depth</span></span><br><span class="line">best_depth = <span class="built_in">dict</span>()</span><br><span class="line"><span class="keyword">for</span> depth <span class="keyword">in</span> max_depth:</span><br><span class="line">    model = LGBMRegressor(objective=<span class="built_in">min</span>(best_obj.items(), key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])[<span class="number">0</span>],</span><br><span class="line">                          num_leaves=<span class="built_in">min</span>(best_leaves.items(), key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])[<span class="number">0</span>],</span><br><span class="line">                          max_depth=depth)</span><br><span class="line">    score = cross_val_score(model, X_train, y_train, cv=<span class="number">5</span>, scoring=<span class="string">&#x27;f1&#x27;</span>).mean()</span><br><span class="line">    best_depth[depth] = score</span><br></pre></td></tr></table></figure>

<p>以此类推，按调参顺序依次调整优化，并且可以对每一个最优参数下模型的得分进行可视化。</p>
<h4 id="3-网格搜索"><a href="#3-网格搜索" class="headerlink" title="3. 网格搜索"></a>3. 网格搜索</h4><p>即穷举搜索，在参数数组里循环遍历，一般大数据集不会用到，因为速度太慢。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_best_cv_params</span>(<span class="params">learning_rate=<span class="number">0.1</span>, n_estimators=<span class="number">581</span>, num_leaves=<span class="number">31</span>, max_depth=-<span class="number">1</span>, bagging_fraction=<span class="number">1.0</span>, feature_fraction=<span class="number">1.0</span>, bagging_freq=<span class="number">0</span>, min_data_in_leaf=<span class="number">20</span>, min_child_weight=<span class="number">0.001</span>, min_split_gain=<span class="number">0</span>, reg_lambda=<span class="number">0</span>, reg_alpha=<span class="number">0</span>, param_grid=<span class="literal">None</span></span>):</span></span><br><span class="line"></span><br><span class="line">    cv_fold = KFold(n_splits=<span class="number">5</span>, shuffle=<span class="literal">True</span>, random_state=<span class="number">2021</span>)</span><br><span class="line"></span><br><span class="line">    model_lgb = lgb.LGBMClassifier(learning_rate=learning_rate,</span><br><span class="line">                                   n_estimators=n_estimators,</span><br><span class="line">                                   num_leaves=num_leaves,</span><br><span class="line">                                   max_depth=max_depth,</span><br><span class="line">                                   bagging_fraction=bagging_fraction,</span><br><span class="line">                                   feature_fraction=feature_fraction,</span><br><span class="line">                                   bagging_freq=bagging_freq,</span><br><span class="line">                                   min_data_in_leaf=min_data_in_leaf,</span><br><span class="line">                                   min_child_weight=min_child_weight,</span><br><span class="line">                                   min_split_gain=min_split_gain,</span><br><span class="line">                                   reg_lambda=reg_lambda,</span><br><span class="line">                                   reg_alpha=reg_alpha,</span><br><span class="line">                                   n_jobs= <span class="number">8</span></span><br><span class="line">                                  )</span><br><span class="line"></span><br><span class="line">    f1 = make_scorer(f1_score, average=<span class="string">&#x27;micro&#x27;</span>)</span><br><span class="line">    grid_search = GridSearchCV(estimator=model_lgb, </span><br><span class="line">                               cv=cv_fold,</span><br><span class="line">                               param_grid=param_grid,</span><br><span class="line">                               scoring=f1</span><br><span class="line"></span><br><span class="line">                              )</span><br><span class="line">    grid_search.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;模型当前最优参数为:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(grid_search.best_params_))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;模型当前最优得分为:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(grid_search.best_score_))</span><br></pre></td></tr></table></figure>
<p>总体思路是先粗调再细调。在一开始调整时，可设置较大的学习率如0.1，先确定树的个数，再依次调整参数，最后设置较小的学习率如0.05，确定最终参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lgb_params = &#123;<span class="string">&#x27;num_leaves&#x27;</span>: <span class="built_in">range</span>(<span class="number">10</span>, <span class="number">80</span>, <span class="number">5</span>), <span class="string">&#x27;max_depth&#x27;</span>: <span class="built_in">range</span>(<span class="number">3</span>,<span class="number">10</span>,<span class="number">2</span>)&#125;</span><br><span class="line">get_best_cv_params()</span><br><span class="line"><span class="comment">#----------------------------------------</span></span><br><span class="line">lgb_params = &#123;<span class="string">&#x27;num_leaves&#x27;</span>: <span class="built_in">range</span>(<span class="number">25</span>, <span class="number">35</span>, <span class="number">1</span>), <span class="string">&#x27;max_depth&#x27;</span>: <span class="built_in">range</span>(<span class="number">5</span>,<span class="number">9</span>,<span class="number">1</span>)&#125;</span><br><span class="line">get_best_cv_params(n_estimators=<span class="number">85</span>)</span><br><span class="line"><span class="comment">#----------------------------------------</span></span><br><span class="line">lgb_params = &#123;<span class="string">&#x27;bagging_fraction&#x27;</span>: [i/<span class="number">10</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>,<span class="number">10</span>,<span class="number">1</span>)], </span><br><span class="line">              <span class="string">&#x27;feature_fraction&#x27;</span>: [i/<span class="number">10</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>,<span class="number">10</span>,<span class="number">1</span>)],</span><br><span class="line">              <span class="string">&#x27;bagging_freq&#x27;</span>: <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">81</span>,<span class="number">10</span>)&#125;</span><br><span class="line">get_best_cv_params(n_estimators=<span class="number">85</span>, num_leaves=<span class="number">29</span>, max_depth=<span class="number">7</span>, min_data_in_leaf=<span class="number">45</span>）</span><br><span class="line"><span class="comment">#----------------------------------------</span></span><br><span class="line">lgb_params = &#123;<span class="string">&#x27;reg_lambda&#x27;</span>: [<span class="number">0</span>,<span class="number">0.001</span>,<span class="number">0.01</span>,<span class="number">0.03</span>,<span class="number">0.08</span>,<span class="number">0.3</span>,<span class="number">0.5</span>], <span class="string">&#x27;reg_alpha&#x27;</span>: [<span class="number">0</span>,<span class="number">0.001</span>,<span class="number">0.01</span>,<span class="number">0.03</span>,<span class="number">0.08</span>,<span class="number">0.3</span>,<span class="number">0.5</span>]&#125;</span><br><span class="line">get_best_cv_params(n_estimators=<span class="number">85</span>, num_leaves=<span class="number">29</span>, max_depth=<span class="number">7</span>, min_data_in_leaf=<span class="number">45</span>, bagging_fraction=<span class="number">0.9</span>, feature_fraction=<span class="number">0.9</span>, bagging_freq=<span class="number">40</span>)</span><br><span class="line"><span class="comment">#----------------------------------------</span></span><br><span class="line">lgb_params = &#123;<span class="string">&#x27;min_split_gain&#x27;</span>: [i/<span class="number">10</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">11</span>,<span class="number">1</span>)]&#125;</span><br><span class="line">get_best_cv_params(n_estimators=<span class="number">85</span>, num_leaves=<span class="number">29</span>, max_depth=<span class="number">7</span>, min_data_in_leaf=<span class="number">45</span>, bagging_fraction=<span class="number">0.9</span>, feature_fraction=<span class="number">0.9</span>, bagging_freq=<span class="number">40</span>, min_split_gain=<span class="literal">None</span>)</span><br><span class="line"><span class="comment">#----------------------------------------</span></span><br><span class="line">final_params = &#123;</span><br><span class="line">                <span class="string">&#x27;boosting_type&#x27;</span>: <span class="string">&#x27;gbdt&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;learning_rate&#x27;</span>: <span class="number">0.01</span>,</span><br><span class="line">                <span class="string">&#x27;num_leaves&#x27;</span>: <span class="number">29</span>,</span><br><span class="line">                <span class="string">&#x27;max_depth&#x27;</span>: <span class="number">7</span>,</span><br><span class="line">                <span class="string">&#x27;objective&#x27;</span>: <span class="string">&#x27;multiclass&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;num_class&#x27;</span>: <span class="number">4</span>,</span><br><span class="line">                <span class="string">&#x27;min_data_in_leaf&#x27;</span>:<span class="number">45</span>,</span><br><span class="line">                <span class="string">&#x27;min_child_weight&#x27;</span>:<span class="number">0.001</span>,</span><br><span class="line">                <span class="string">&#x27;bagging_fraction&#x27;</span>: <span class="number">0.9</span>,</span><br><span class="line">                <span class="string">&#x27;feature_fraction&#x27;</span>: <span class="number">0.9</span>,</span><br><span class="line">                <span class="string">&#x27;bagging_freq&#x27;</span>: <span class="number">40</span>,</span><br><span class="line">                <span class="string">&#x27;min_split_gain&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="string">&#x27;reg_lambda&#x27;</span>:<span class="number">0</span>,</span><br><span class="line">                <span class="string">&#x27;reg_alpha&#x27;</span>:<span class="number">0</span>,</span><br><span class="line">                <span class="string">&#x27;nthread&#x27;</span>: <span class="number">6</span></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">cv_result = lgb.cv(train_set=lgb_train,</span><br><span class="line">                   early_stopping_rounds=<span class="number">20</span>,</span><br><span class="line">                   num_boost_round=<span class="number">5000</span>,</span><br><span class="line">                   nfold=<span class="number">5</span>,</span><br><span class="line">                   stratified=<span class="literal">True</span>,</span><br><span class="line">                   shuffle=<span class="literal">True</span>,</span><br><span class="line">                   params=final_params,</span><br><span class="line">                   feval=f1_score_vali,</span><br><span class="line">                   seed=<span class="number">0</span>,</span><br><span class="line">                  )</span><br></pre></td></tr></table></figure>
<h4 id="4-贝叶斯调参"><a href="#4-贝叶斯调参" class="headerlink" title="4. 贝叶斯调参"></a>4. 贝叶斯调参</h4><p>是一种用模型找到目标函数最小值的方法，比网格和随机搜索省时。步骤如下：</p>
<p>① 定义优化函数(rf_cv）</p>
<p>② 建立模型</p>
<p>③ 定义待优化的参数</p>
<p>④ 得到优化结果，并返回要优化的分数指标</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="comment">#定义优化函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rf_cv_lgb</span>(<span class="params">num_leaves, max_depth, bagging_fraction, feature_fraction, bagging_freq, min_data_in_leaf, </span></span></span><br><span class="line"><span class="function"><span class="params">              min_child_weight, min_split_gain, reg_lambda, reg_alpha</span>):</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立模型</span></span><br><span class="line">    model_lgb = lgb.LGBMClassifier(boosting_type=<span class="string">&#x27;gbdt&#x27;</span>, objective=<span class="string">&#x27;multiclass&#x27;</span>, num_class=<span class="number">4</span>,learning_rate=<span class="number">0.1</span>, n_estimators=<span class="number">5000</span>,num_leaves=<span class="built_in">int</span>(num_leaves), max_depth=<span class="built_in">int</span>(max_depth), bagging_fraction=<span class="built_in">round</span>(bagging_fraction, <span class="number">2</span>), feature_fraction=<span class="built_in">round</span>(feature_fraction, <span class="number">2</span>),bagging_freq=<span class="built_in">int</span>(bagging_freq), min_data_in_leaf=<span class="built_in">int</span>(min_data_in_leaf),min_child_weight=min_child_weight)</span><br><span class="line">    f1 = make_scorer(f1_score, average=<span class="string">&#x27;micro&#x27;</span>)</span><br><span class="line">    val = cross_val_score(model_lgb, X_train_split, y_train_split, cv=<span class="number">5</span>, scoring=f1).mean()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> val</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bayes_opt <span class="keyword">import</span> BayesianOptimization</span><br><span class="line"><span class="comment">#定义优化参数</span></span><br><span class="line">bayes_lgb = BayesianOptimization(</span><br><span class="line">    rf_cv_lgb, </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;num_leaves&#x27;</span>:(<span class="number">10</span>, <span class="number">200</span>),</span><br><span class="line">        <span class="string">&#x27;max_depth&#x27;</span>:(<span class="number">3</span>, <span class="number">20</span>),</span><br><span class="line">        <span class="string">&#x27;bagging_fraction&#x27;</span>:(<span class="number">0.5</span>, <span class="number">1.0</span>),</span><br><span class="line">        <span class="string">&#x27;feature_fraction&#x27;</span>:(<span class="number">0.5</span>, <span class="number">1.0</span>),</span><br><span class="line">        <span class="string">&#x27;bagging_freq&#x27;</span>:(<span class="number">0</span>, <span class="number">100</span>),</span><br><span class="line">        <span class="string">&#x27;min_data_in_leaf&#x27;</span>:(<span class="number">10</span>,<span class="number">100</span>),</span><br><span class="line">        <span class="string">&#x27;min_child_weight&#x27;</span>:(<span class="number">0</span>, <span class="number">10</span>),</span><br><span class="line">        <span class="string">&#x27;min_split_gain&#x27;</span>:(<span class="number">0.0</span>, <span class="number">1.0</span>),</span><br><span class="line">        <span class="string">&#x27;reg_alpha&#x27;</span>:(<span class="number">0.0</span>, <span class="number">10</span>),</span><br><span class="line">        <span class="string">&#x27;reg_lambda&#x27;</span>:(<span class="number">0.0</span>, <span class="number">10</span>),</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">#开始优化</span></span><br><span class="line">bayes_lgb.maximize(n_iter=<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#显示优化结果</span></span><br><span class="line">bayes_lgb.<span class="built_in">max</span></span><br></pre></td></tr></table></figure>

<p>参数优化完成后，可根据优化后的参数建立新的模型，降低学习率并寻找最优模型迭代次数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置较小的学习率，并通过cv函数确定当前最优的迭代次数</span></span><br><span class="line">base_params_lgb = &#123;</span><br><span class="line">                    <span class="string">&#x27;boosting_type&#x27;</span>: <span class="string">&#x27;gbdt&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;objective&#x27;</span>: <span class="string">&#x27;multiclass&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;num_class&#x27;</span>: <span class="number">4</span>,</span><br><span class="line">                    <span class="string">&#x27;learning_rate&#x27;</span>: <span class="number">0.01</span>,</span><br><span class="line">                    <span class="string">&#x27;num_leaves&#x27;</span>: <span class="number">138</span>,</span><br><span class="line">                    <span class="string">&#x27;max_depth&#x27;</span>: <span class="number">11</span>,</span><br><span class="line">                    <span class="string">&#x27;min_data_in_leaf&#x27;</span>: <span class="number">43</span>,</span><br><span class="line">                    <span class="string">&#x27;min_child_weight&#x27;</span>: <span class="number">6.5</span>,</span><br><span class="line">                    <span class="string">&#x27;bagging_fraction&#x27;</span>: <span class="number">0.64</span>,</span><br><span class="line">                    <span class="string">&#x27;feature_fraction&#x27;</span>: <span class="number">0.93</span>,</span><br><span class="line">                    <span class="string">&#x27;bagging_freq&#x27;</span>: <span class="number">49</span>,</span><br><span class="line">                    <span class="string">&#x27;reg_lambda&#x27;</span>: <span class="number">7</span>,</span><br><span class="line">                    <span class="string">&#x27;reg_alpha&#x27;</span>: <span class="number">0.21</span>,</span><br><span class="line">                    <span class="string">&#x27;min_split_gain&#x27;</span>: <span class="number">0.288</span>,</span><br><span class="line">                    <span class="string">&#x27;nthread&#x27;</span>: <span class="number">10</span>,</span><br><span class="line">                    <span class="string">&#x27;verbose&#x27;</span>: -<span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cv_result_lgb = lgb.cv(</span><br><span class="line">    train_set=train_matrix,</span><br><span class="line">    early_stopping_rounds=<span class="number">1000</span>, </span><br><span class="line">    num_boost_round=<span class="number">20000</span>,</span><br><span class="line">    nfold=<span class="number">5</span>,</span><br><span class="line">    stratified=<span class="literal">True</span>,</span><br><span class="line">    shuffle=<span class="literal">True</span>,</span><br><span class="line">    params=base_params_lgb,</span><br><span class="line">    feval=f1_score_vali,</span><br><span class="line">    seed=<span class="number">0</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;迭代次数&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(cv_result_lgb[<span class="string">&#x27;f1_score-mean&#x27;</span>])))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最终模型的f1为&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">max</span>(cv_result_lgb[<span class="string">&#x27;f1_score-mean&#x27;</span>])))</span><br></pre></td></tr></table></figure>

<p>模型参数确定之后，建立最终模型并对验证集进行验证。</p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Grid search</tag>
        <tag>Bayesian optimization</tag>
        <tag>Cross validation</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas的一些常用操作_1</title>
    <url>/2021/02/21/pandas_1/</url>
    <content><![CDATA[<blockquote>
<p>今天介绍几个常用的Pandas操作。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;./economics.csv&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="1-DataFrame-to-markdown-latex"><a href="#1-DataFrame-to-markdown-latex" class="headerlink" title="1.DataFrame to markdown/latex"></a>1.DataFrame to markdown/latex</h4><p>dataframe可以转换为许多常用格式，如csv,excel,sql,json,html,latex等等，这里以markdown和latex为例。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(df.to_markdown())</span><br><span class="line"><span class="built_in">print</span>(df.to_latex())</span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.to_markdown(<span class="string">&#x27;table.md&#x27;</span>)</span><br><span class="line">df.to_latex(<span class="string">&#x27;table.tex&#x27;</span>)</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>也可以自定义输出latex格式，如表格宽度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.to_latex(<span class="string">&#x27;tb.tex&#x27;</span>,column_format=<span class="string">&#x27;lp&#123;1.8cm&#125;p&#123;1.8cm&#125;p&#123;1.8cm&#125;p&#123;1.8cm&#125;p&#123;1.8cm&#125;p&#123;1.8cm&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>除此以外，dataframe还可以保存为图片。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> dataframe_image <span class="keyword">as</span> dfi</span><br><span class="line">dfi.export(obj = df, filename = <span class="string">&#x27;table.jpg&#x27;</span>, fontsize=<span class="number">15</span>)</span><br></pre></td></tr></table></figure>
<h4 id="2-DataFrame常用属性查询"><a href="#2-DataFrame常用属性查询" class="headerlink" title="2.DataFrame常用属性查询"></a>2.DataFrame常用属性查询</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.values	<span class="comment">#值</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.index	<span class="comment">#索引号</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.columns	<span class="comment">#列标签</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.dtypes	<span class="comment">#数据类型</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.shape	<span class="comment">#形状(几行几列)</span></span><br></pre></td></tr></table></figure>
<h4 id="3-DataFrame常用基本函数"><a href="#3-DataFrame常用基本函数" class="headerlink" title="3.DataFrame常用基本函数"></a>3.DataFrame常用基本函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.head(<span class="number">5</span>)	<span class="comment">#前5行</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.tail(<span class="number">5</span>)	<span class="comment">#后5行</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.info()	<span class="comment">#信息概况</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.describe()	<span class="comment">#主要统计量(count、mean、std、max、min、quartile)</span></span><br></pre></td></tr></table></figure>
<h4 id="4-DataFrame唯一值函数"><a href="#4-DataFrame唯一值函数" class="headerlink" title="4.DataFrame唯一值函数"></a>4.DataFrame唯一值函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;psavert&#x27;</span>].unique()	<span class="comment">#唯一值组成的数组</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;psavert&#x27;</span>].nunique()    <span class="comment">#唯一值个数</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;psavert&#x27;</span>].value_counts()    <span class="comment">#唯一值及其频数</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.describe()    <span class="comment">#主要统计量(count、mean、std、max、min、quartile)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;psavert&#x27;</span>].duplicated()    <span class="comment">#重复行的布尔值</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[df[<span class="string">&#x27;psavert&#x27;</span>].duplicated()]    <span class="comment">#单列去重(删除重复行)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.drop_duplicates(subset=[<span class="string">&#x27;psavert&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>], keep=<span class="string">&#x27;first&#x27;</span>)    <span class="comment">#多列去重(保留first唯一值)</span></span><br></pre></td></tr></table></figure>
<h4 id="5-DataFrame替换函数"><a href="#5-DataFrame替换函数" class="headerlink" title="5.DataFrame替换函数"></a>5.DataFrame替换函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;psavert&#x27;</span>].replace(<span class="number">12.5</span>, <span class="string">&#x27;A&#x27;</span>, inplace = <span class="literal">True</span>)    <span class="comment">#替换某列的单个值</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;psavert&#x27;</span>].replace(&#123;<span class="number">12.5</span>:<span class="string">&#x27;A&#x27;</span>, <span class="number">11.7</span>:<span class="string">&#x27;B&#x27;</span>&#125;, inplace = <span class="literal">True</span>)    <span class="comment">#替换某列的多个值</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;date&#x27;</span>].replace(&#123;<span class="string">r&#x27;2\d+&#x27;</span>: <span class="string">&#x27;The 21st century&#x27;</span>&#125;, regex=<span class="literal">True</span>, inplace = <span class="literal">True</span>)    <span class="comment">#正则替换</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;psavert&#x27;</span>].mask(df[<span class="string">&#x27;psavert&#x27;</span>]&gt;<span class="number">12.0</span> ,<span class="string">&#x27;A&#x27;</span>, inplace = <span class="literal">True</span>)    <span class="comment">#条件符合，进行替换</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;psavert&#x27;</span>].where(df[<span class="string">&#x27;psavert&#x27;</span>]&lt;<span class="number">12.0</span> ,<span class="string">&#x27;A&#x27;</span>, inplace = <span class="literal">True</span>)    <span class="comment">#条件不符合，进行替换</span></span><br></pre></td></tr></table></figure>
<h4 id="5-DataFrame排序函数"><a href="#5-DataFrame排序函数" class="headerlink" title="5.DataFrame排序函数"></a>5.DataFrame排序函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.sort_values(<span class="string">&#x27;psavert&#x27;</span>,ascending = <span class="literal">False</span>)    <span class="comment">#单列降序排序</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.sort_values([<span class="string">&#x27;psavert&#x27;</span>,<span class="string">&#x27;uempmed&#x27;</span>],ascending=[<span class="literal">True</span>,<span class="literal">False</span>])    <span class="comment">#前者升序情况下，后降序</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>今天先写到这，下一期接着写DataFrame的apply方法。</p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas的一些常用操作_2</title>
    <url>/2021/02/21/pandas_2/</url>
    <content><![CDATA[<blockquote>
<p>今天继续介绍几个常用的Pandas操作。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;./economics.csv&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="1-DataFrame的apply方法"><a href="#1-DataFrame的apply方法" class="headerlink" title="1.DataFrame的apply方法"></a>1.DataFrame的apply方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[[<span class="string">&#x27;psavert&#x27;</span>,<span class="string">&#x27;uempmed&#x27;</span>]].apply(<span class="keyword">lambda</span> x:x.<span class="built_in">max</span>()-x.<span class="built_in">min</span>(), axis=<span class="number">1</span>)<span class="comment">#axis=1 将函数应用到列</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.applymap(<span class="keyword">lambda</span> x:x*<span class="number">10</span>)<span class="comment">#applymap 将函数应用到每个元素</span></span><br></pre></td></tr></table></figure>
<h4 id="2-DataFrame的分组"><a href="#2-DataFrame的分组" class="headerlink" title="2.DataFrame的分组"></a>2.DataFrame的分组</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.groupby(<span class="string">&#x27;unemploy&#x27;</span>)[<span class="string">&#x27;psavert&#x27;</span>].median()<span class="comment">#样例:df.groupby(分组依据)[数据来源].使用操作</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">condition = df.unemploy &gt; df.unemploy.mean()<span class="comment">#使用condition定义分组依据</span></span><br><span class="line">df.groupby(condition)[<span class="string">&#x27;psavert&#x27;</span>].mean()<span class="comment">#分为True和False两组</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.groupby([condition, df[<span class="string">&#x27;unemploy&#x27;</span>]])[<span class="string">&#x27;psavert&#x27;</span>].mean()<span class="comment">#True组和False两组分别细分</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.groupby([df[<span class="string">&#x27;unemploy&#x27;</span>], df[<span class="string">&#x27;uempmed&#x27;</span>]])[<span class="string">&#x27;psavert&#x27;</span>].mean()<span class="comment">#两级分组</span></span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gb = df.groupby([<span class="string">&#x27;unemploy&#x27;</span>])<span class="comment">#Groupby对象</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gb.size()<span class="comment">#每组的元素个数</span></span><br><span class="line"><span class="comment">#和DataFrame一样，Groupby对象也有max\idxmin\all\\nunique\quantile\prod等函数，这里不一一列举。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gb.agg([<span class="string">&#x27;skew&#x27;</span>, <span class="string">&#x27;sum&#x27;</span>, <span class="string">&#x27;idxmax&#x27;</span>])<span class="comment">#agg聚合函数，查看每个分组的三个统计量</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gb.agg(<span class="keyword">lambda</span> x: x.mean()-x.<span class="built_in">min</span>())<span class="comment">#在agg中自定义函数</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gb.<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x.shape[<span class="number">0</span>] &gt; <span class="number">100</span>)<span class="comment">#组过滤</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gb.apply(<span class="keyword">lambda</span> x: x**<span class="number">2</span>)<span class="comment">#组的apply方法</span></span><br></pre></td></tr></table></figure>
<h4 id="3-DataFrame的连接"><a href="#3-DataFrame的连接" class="headerlink" title="3.DataFrame的连接"></a>3.DataFrame的连接</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df1 = df[<span class="number">0</span>:<span class="number">10</span>]</span><br><span class="line">df2 = df[<span class="number">10</span>:<span class="number">20</span>]</span><br><span class="line">df1.merge(df2, on=<span class="string">&#x27;date&#x27;</span>, how=<span class="string">&#x27;outer&#x27;</span>)<span class="comment">#merge表示关系型连接，包括左连接、右连接、内连接和外(全)连接</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.concat([df1, df2], axis=<span class="number">0</span>)<span class="comment">#concat是方向性连接，axis=0表示纵向连接</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">choose_min</span>(<span class="params">x1, x2</span>):</span></span><br><span class="line">    <span class="built_in">min</span> = x1.where(x1&lt;x2, x1)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span></span><br><span class="line">df1.combine(df2, choose_min)<span class="comment">#使用combine函数自定义连接规则</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>下一期是Pandas的常见数据处理，包括缺失数据、文本数据、分类数据和时序数据。</p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas的一些常用操作_3</title>
    <url>/2021/02/21/pandas_3/</url>
    <content><![CDATA[<blockquote>
<p>今天介绍Pandas对一些常见数据的处理方法。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;./economics.csv&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="1-缺失数据处理"><a href="#1-缺失数据处理" class="headerlink" title="1.缺失数据处理"></a>1.缺失数据处理</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.isna()<span class="comment">#是否有缺失值</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.isna().mean()<span class="comment">#缺失的比例 </span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[df.psavert.isna()]<span class="comment">#查看某列是否有缺失值</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[df[[<span class="string">&#x27;psavert&#x27;</span>,<span class="string">&#x27;pop&#x27;</span>,<span class="string">&#x27;uempmed&#x27;</span>]].isna().<span class="built_in">any</span>(<span class="number">1</span>)]<span class="comment">#查看所有列至少有一个缺失值的行“any()至少有一个为空,all()都为空”</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[df[[<span class="string">&#x27;psavert&#x27;</span>,<span class="string">&#x27;pop&#x27;</span>,<span class="string">&#x27;uempmed&#x27;</span>]].notna().<span class="built_in">all</span>(<span class="number">1</span>)]<span class="comment">#查看所有没有缺失值的行</span></span><br><span class="line">df.loc[df[[<span class="string">&#x27;psavert&#x27;</span>,<span class="string">&#x27;pop&#x27;</span>,<span class="string">&#x27;uempmed&#x27;</span>]].notna().<span class="built_in">all</span>(<span class="number">1</span>)]<span class="comment">#查看所有没有缺失值的区域</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.dropna(axis = <span class="number">0</span>, how = <span class="string">&#x27;any&#x27;</span>, subset = [<span class="string">&#x27;psavert&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>])<span class="comment">#axis=0(删除)行,how=&#x27;any&#x27;至少有一个缺失的行</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.dropna(axis = <span class="number">1</span>, thresh = df.shape[<span class="number">0</span>]-<span class="number">5</span>)<span class="comment">#删除超过5个缺失值的列</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.fillna(method = <span class="string">&#x27;ffill&#x27;</span>, limit = <span class="number">1</span>)<span class="comment">#method=&#x27;ffill&#x27;用前面的元素填充/method=&#x27;bfill&#x27;用后面的元素填充,limit=1连续缺失值的最大填充次数为1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.fillna(df.mean())<span class="comment">#用每列的均值填充</span></span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.interpolate(limit_direction=<span class="string">&#x27;both&#x27;</span>, limit=<span class="number">1</span>)<span class="comment">#用线性插值填充(both为双向限制插值)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.interpolate(<span class="string">&#x27;nearest&#x27;</span>).values<span class="comment">#用最近邻插值填充</span></span><br></pre></td></tr></table></figure>
<p>此外，也可以<a href="https://blog.csdn.net/wj1298250240/article/details/103600075">使用KNN来填充缺失值</a>。</p>
<h4 id="2-文本数据处理"><a href="#2-文本数据处理" class="headerlink" title="2.文本数据处理"></a>2.文本数据处理</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts = pd.Series(df[<span class="string">&#x27;Area&#x27;</span>].values, index=df[<span class="string">&#x27;pct_2014&#x27;</span>])<span class="comment">#DataFrame转换为Series</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts.<span class="built_in">str</span>[<span class="number">0</span>]<span class="comment">#查看第一个字符</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts.<span class="built_in">str</span>.<span class="built_in">len</span>()<span class="comment">#查看字符长度</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts.<span class="built_in">str</span>.split(<span class="string">&#x27;[aon]&#x27;</span>, n=<span class="number">3</span>, expand=<span class="literal">True</span>)<span class="comment">#从左到右拆分字符串，最大拆分次数3次，生成多列</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts.<span class="built_in">str</span>.join(<span class="string">&#x27;-&#x27;</span>)<span class="comment">#每个字符用“-”连接</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts.<span class="built_in">str</span>.cat(ts2, sep=<span class="string">&#x27;-&#x27;</span>)<span class="comment">#合并两个字符Series，连接符为“-”</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts.<span class="built_in">str</span>.contains(<span class="string">&#x27;[a-z]u&#x27;</span>)<span class="comment">#查看包含正则模式的序列</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts.<span class="built_in">str</span>.startswith(<span class="string">&#x27;A&#x27;</span>)<span class="comment">#查看以A为开始的序列</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts.<span class="built_in">str</span>.endswith(<span class="string">&#x27;e&#x27;</span>)<span class="comment">#查看以e为结尾的序列</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts.<span class="built_in">str</span>.match(<span class="string">&#x27;A|s&#x27;</span>)<span class="comment">#查看以A为开头,s为结尾的序列</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts.<span class="built_in">str</span>.count(<span class="string">&#x27;[A|s]&#x27;</span>)<span class="comment">#查看以A为开头,s为结尾的序列数量</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts.<span class="built_in">str</span>.find(<span class="string">&#x27;de&#x27;</span>)<span class="comment">#从左往右寻找&#x27;de&#x27;,匹配返回位置索引,未找到返回&#x27;-1&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts.<span class="built_in">str</span>.rfind(<span class="string">&#x27;de&#x27;</span>)<span class="comment">#从右往左寻找</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts.<span class="built_in">str</span>.replace(<span class="string">&#x27;\s?&#x27;</span>, <span class="string">&#x27;LA&#x27;</span>, regex=<span class="literal">True</span>)<span class="comment">#使用正则进行字符串替换</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pat = <span class="string">&#x27;(\w+o)(\w+s)(\w+u)(\w+n)&#x27;</span></span><br><span class="line">ts.<span class="built_in">str</span>.extract(pat)<span class="comment">#拆分&#x27;o&#x27;,&#x27;s&#x27;,&#x27;u&#x27;,&#x27;n&#x27;为4列</span></span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.to_numeric(ts, errors=<span class="string">&#x27;ignore&#x27;</span>)<span class="comment">#将可以转为数值的字符转为数值</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts.<span class="built_in">str</span>.pad(<span class="number">6</span>,<span class="string">&#x27;left&#x27;</span>,<span class="string">&#x27;*&#x27;</span>)<span class="comment">#选定字符串长度为6的填充为&quot;*&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts.<span class="built_in">str</span>.lstrip()<span class="comment">#去掉字符串左侧空格</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts.<span class="built_in">str</span>.zfill(<span class="number">8</span>)<span class="comment">#用0补足8位</span></span><br></pre></td></tr></table></figure>
<h4 id="3-分类数据"><a href="#3-分类数据" class="headerlink" title="3.分类数据"></a>3.分类数据</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = df.psavert.astype(<span class="string">&#x27;category&#x27;</span>)<span class="comment">#Dataframe转为category对象</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s.cat.categories<span class="comment">#查看分类对象属性</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s.cat.add_categories(<span class="string">&#x27;C1&#x27;</span>)<span class="comment">#增加一个类别</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s.cat.remove_categories(<span class="number">11.7</span>)<span class="comment">#删除一个类别</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = s.cat.rename_categories(&#123;<span class="string">&#x27;S1&#x27;</span>:<span class="string">&#x27;xxx&#x27;</span>&#125;)<span class="comment">#重命名类别及其值</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s.cat.reorder_categories([<span class="string">&#x27;S1&#x27;</span>, <span class="string">&#x27;S2&#x27;</span>, <span class="string">&#x27;S3&#x27;</span>, <span class="string">&#x27;S4&#x27;</span>], ordered=<span class="literal">True</span>)<span class="comment">#设置排序</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.sort_values(<span class="string">&#x27;psavert&#x27;</span>)<span class="comment">#值排序</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.set_index(<span class="string">&#x27;psavert&#x27;</span>).sort_index()<span class="comment">#作为索引排序</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = df.psavert &lt;= <span class="string">&#x27;S4&#x27;</span><span class="comment">#比较顺序</span></span><br><span class="line">res</span><br></pre></td></tr></table></figure>
<h4 id="4-时序数据"><a href="#4-时序数据" class="headerlink" title="4.时序数据"></a>4.时序数据</h4><p>————-图——————–</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = pd.to_datetime(df.date)<span class="comment">#生成时间序列</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s2 = pd.to_datetime([<span class="string">&#x27;2020\\1\\1&#x27;</span>,<span class="string">&#x27;2020\\1\\3&#x27;</span>],<span class="built_in">format</span>=<span class="string">&#x27;%Y\\%m\\%d&#x27;</span>)<span class="comment">#强制格式转换,生成时间序列</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.date_range(<span class="string">&#x27;1967-07-01&#x27;</span>,<span class="string">&#x27;2015-04-01&#x27;</span>, freq=<span class="string">&#x27;D&#x27;</span>)<span class="comment">#查看两个时间之间的时间,间隔1天</span></span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#dt对象</span></span><br><span class="line">s.dt.daysinmonth<span class="comment">#每个月几天</span></span><br><span class="line">s.dt.dayofweek<span class="comment">#每周几天</span></span><br><span class="line">s.dt.dayofweek.isin([<span class="number">5</span>,<span class="number">6</span>])<span class="comment">#是否包含双休日</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.Timestamp(<span class="string">&#x27;20210223 22:00:00&#x27;</span>)-pd.Timestamp(<span class="string">&#x27;20210222 18:35:00&#x27;</span>)<span class="comment">#计算两个时间之差</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>图神经网络——基于图神经网络的节点表征学习</title>
    <url>/2021/06/23/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%8A%82%E7%82%B9%E8%A1%A8%E5%BE%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>Graph的特征表示非常复杂：</p>
<blockquote>
<p>1.复杂的拓扑结构，较难从图像中的感受野提取有效信息；<br>2.无特定的节点顺序；<br>3.通常graph会是动态变化的， 且使用多模态特征。</p>
</blockquote>
<p>高质量的节点表征能够用于衡量节点的相似性，同时高质量的节点表征也是准确分类节点的前提。</p>
<p>本文以Cora论文引用网络数据集为例，对MLP、GCN、GAT三种神经网络的分类性能进行对比。首先载入数据集并定义可视化函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#载入数据集</span></span><br><span class="line"><span class="keyword">from</span> torch_geometric.datasets <span class="keyword">import</span> Planetoid</span><br><span class="line"><span class="keyword">from</span> torch_geometric.transforms <span class="keyword">import</span> NormalizeFeatures</span><br><span class="line"></span><br><span class="line">dataset = Planetoid(root=<span class="string">&#x27;dataset&#x27;</span>, name=<span class="string">&#x27;Cora&#x27;</span>, transform=NormalizeFeatures())</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义可视化函数，并观察整体数据分布</span></span><br><span class="line"><span class="keyword">from</span> sklearn.manifold <span class="keyword">import</span> TSNE</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visualize</span>(<span class="params">h, color</span>):</span></span><br><span class="line">    z = TSNE(n_components=<span class="number">2</span>).fit_transform(out.detach().cpu().numpy())</span><br><span class="line">    plt.figure(figsize=(<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line">    plt.xticks([])</span><br><span class="line">    plt.yticks([])</span><br><span class="line"></span><br><span class="line">    plt.scatter(z[:, <span class="number">0</span>], z[:, <span class="number">1</span>], s=<span class="number">70</span>, c=color, cmap=<span class="string">&quot;Set2&quot;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line">    </span><br><span class="line">out = data.x</span><br><span class="line">visualize(out,data.y)</span><br></pre></td></tr></table></figure>
<p><img src="https://z3.ax1x.com/2021/06/28/RtavIs.png" alt="整张图"></p>
<h4 id="1-MLP-Multi-layer-Perceptron-在图节点分类中的应用"><a href="#1-MLP-Multi-layer-Perceptron-在图节点分类中的应用" class="headerlink" title="1. MLP(Multi-layer Perceptron)在图节点分类中的应用"></a>1. MLP(Multi-layer Perceptron)在图节点分类中的应用</h4><p>多层感知机（MLP，Multilayer Perceptron）也叫人工神经网络（ANN，Artificial Neural Network）.</p>
<h5 id="1-1-MLP代码"><a href="#1-1-MLP代码" class="headerlink" title="1.1 MLP代码"></a>1.1 MLP代码</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#构造MLP</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Linear</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MLP</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, hidden_channels</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(MLP, self).__init__()</span><br><span class="line">        torch.manual_seed(<span class="number">2021</span>)</span><br><span class="line">        self.lin1 = Linear(dataset.num_features, hidden_channels)</span><br><span class="line">        self.lin2 = Linear(hidden_channels, dataset.num_classes)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.lin1(x)</span><br><span class="line">        x = x.relu()</span><br><span class="line">        x = F.dropout(x, p=<span class="number">0.5</span>, training=self.training)</span><br><span class="line">        x = self.lin2(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">model = MLP(hidden_channels=<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(model)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果：<br>MLP(<br>       (lin1): Linear(in_features=1433, out_features=16, bias=True)<br>       (lin2): Linear(in_features=16, out_features=7, bias=True)<br>)</p>
</blockquote>
<p>该MLP由两个线性层、一个ReLU非线性层和一个dropout组成。第一个线程层将1433维的节点表征嵌入(embedding)到低维空间中(hidden_channels=16)，第二个线性层将节点表征嵌入到类别空间中(num_classes=7)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#训练MLP</span></span><br><span class="line">model = MLP(hidden_channels=<span class="number">16</span>)</span><br><span class="line">criterion = torch.nn.CrossEntropyLoss()  <span class="comment"># Define loss criterion.</span></span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">0.01</span>, weight_decay=<span class="number">5e-4</span>)  <span class="comment"># Define optimizer.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>():</span></span><br><span class="line">    model.train()</span><br><span class="line">    optimizer.zero_grad()  <span class="comment"># Clear gradients.</span></span><br><span class="line">    out = model(data.x)  <span class="comment"># Perform a single forward pass.</span></span><br><span class="line">    loss = criterion(out[data.train_mask], data.y[data.train_mask])  <span class="comment"># Compute the loss solely based on the training nodes.</span></span><br><span class="line">    loss.backward()  <span class="comment"># Derive gradients.</span></span><br><span class="line">    optimizer.step()  <span class="comment"># Update parameters based on gradients.</span></span><br><span class="line">    <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">201</span>):</span><br><span class="line">    <span class="keyword">if</span> epoch % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">        loss = train()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Epoch: <span class="subst">&#123;epoch:03d&#125;</span>, Loss: <span class="subst">&#123;loss:<span class="number">.4</span>f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果:<br>Epoch: 050, Loss: 1.1777<br>Epoch: 100, Loss: 0.5491<br>Epoch: 150, Loss: 0.4577<br>Epoch: 200, Loss: 0.2876</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#测试训练后的MLP</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    out = model(data.x)</span><br><span class="line">    pred = out.argmax(dim=<span class="number">1</span>)  <span class="comment"># Use the class with highest probability.</span></span><br><span class="line">    test_correct = pred[data.test_mask] == data.y[data.test_mask]  <span class="comment"># Check against ground-truth labels.</span></span><br><span class="line">    test_acc = <span class="built_in">int</span>(test_correct.<span class="built_in">sum</span>()) / <span class="built_in">int</span>(data.test_mask.<span class="built_in">sum</span>())  <span class="comment"># Derive ratio of correct predictions.</span></span><br><span class="line">    <span class="keyword">return</span> test_acc</span><br><span class="line"></span><br><span class="line">test_acc = test()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Test Accuracy: <span class="subst">&#123;test_acc:<span class="number">.4</span>f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果：<br>Test Accuracy: 0.5850</p>
</blockquote>
<p>MLP的结果较差，是因为用于训练此神经网络的有标签节点数量过少，它对未见过的节点泛化能力很差。</p>
<h4 id="2-GCN-Graph-Convolutional-Network-在图节点分类中的应用"><a href="#2-GCN-Graph-Convolutional-Network-在图节点分类中的应用" class="headerlink" title="2 GCN(Graph Convolutional Network)在图节点分类中的应用"></a>2 GCN(Graph Convolutional Network)在图节点分类中的应用</h4><p>GCN，图卷积神经网络，本质上和CNN的作用一样，就是一个特征提取器，只不过它的对象是图数据。关键在于如何定义局部感受域:</p>
<ul>
<li>Spatial approach: 指定节点的边的方向;</li>
<li>Spectral approach: 通过图的拉普拉斯矩阵的特征值和特征向量对图结构进行处理.</li>
</ul>
<h5 id="2-1-GCN公式"><a href="#2-1-GCN公式" class="headerlink" title="2.1 GCN公式"></a>2.1 GCN公式</h5><p>$$<br>\mathbf{X}^{\prime} = \mathbf{\hat{D}}^{-1/2} \mathbf{\hat{A}}\mathbf{\hat{D}}^{-1/2} \mathbf{X} \mathbf{\Theta}<br>$$<br>其中$\mathbf{\hat{A}} = \mathbf{A} + \mathbf{I}$表示插入自环的邻接矩阵,$\mathbf{I}$是单位矩阵，$\hat{D}<em>{ii} = \sum</em>{j=0} \hat{A}<em>{ij}$表示$\mathbf{\hat{A}}$的对角线度矩阵。$\mathbf{\hat{D}}^{-1/2} \mathbf{\hat{A}}<br>\mathbf{\hat{D}}^{-1/2}$是对称归一化矩阵，它的节点式公式为：<br>$$<br>\mathbf{x}^{\prime}<em>i = \mathbf{\Theta} \sum</em>{j \in \mathcal{N}(v) \cup{ i }} \frac{e</em>{j,i}}{\sqrt{\hat{d}_j \hat{d}<em>i}} \mathbf{x}<em>j<br>$$<br>其中，$\hat{d}<em>i = 1 + \sum</em>{j \in \mathcal{N}(i)} e</em>{j,i}$，$e</em>{j,i}$表示从源节点$j$到目标节点$i$的边的对称归一化系数（默认值为1.0）。</p>
<h5 id="2-2-GCN代码"><a href="#2-2-GCN代码" class="headerlink" title="2.2 GCN代码"></a>2.2 GCN代码</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#构造GCN</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch_geometric.nn <span class="keyword">import</span> GCNConv</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GCN</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, hidden_channels</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(GCN, self).__init__()</span><br><span class="line">        torch.manual_seed(<span class="number">2021</span>)</span><br><span class="line">        self.conv1 = GCNConv(dataset.num_features, hidden_channels)</span><br><span class="line">        self.conv2 = GCNConv(hidden_channels, dataset.num_classes)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x, edge_index</span>):</span></span><br><span class="line">        <span class="comment"># x:输入节点特征,可以是节点特征矩阵或一维节点索引张量</span></span><br><span class="line">        <span class="comment"># edge_type:每条边的一维关系类型/索引</span></span><br><span class="line">        x = self.conv1(x, edge_index)</span><br><span class="line">        x = x.relu()</span><br><span class="line">        x = F.dropout(x, p=<span class="number">0.5</span>, training=self.training)</span><br><span class="line">        x = self.conv2(x, edge_index)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">model = GCN(hidden_channels=<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(model)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果：<br>GCN(<br>      (conv1): GCNConv(1433, 16)<br>      (conv2): GCNConv(16, 7)<br>)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#可视化未训练的GCN</span></span><br><span class="line">model = GCN(hidden_channels=<span class="number">16</span>)</span><br><span class="line">model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line">out = model(data.x, data.edge_index)</span><br><span class="line">visualize(out, color=data.y)</span><br></pre></td></tr></table></figure>
<p><img src="https://z3.ax1x.com/2021/06/28/RtaLqg.png" alt="未训练GCN"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#训练GCN</span></span><br><span class="line">model = GCN(hidden_channels=<span class="number">16</span>)</span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">0.01</span>, weight_decay=<span class="number">5e-4</span>)</span><br><span class="line">criterion = torch.nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>():</span></span><br><span class="line">      model.train()</span><br><span class="line">      optimizer.zero_grad()  <span class="comment"># Clear gradients.</span></span><br><span class="line">      out = model(data.x, data.edge_index)  <span class="comment"># Perform a single forward pass.</span></span><br><span class="line">      loss = criterion(out[data.train_mask], data.y[data.train_mask])  <span class="comment"># Compute the loss solely based on the training nodes.</span></span><br><span class="line">      loss.backward()  <span class="comment"># Derive gradients.</span></span><br><span class="line">      optimizer.step()  <span class="comment"># Update parameters based on gradients.</span></span><br><span class="line">      <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">201</span>):</span><br><span class="line">    loss = train()</span><br><span class="line">    <span class="keyword">if</span> epoch % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Epoch: <span class="subst">&#123;epoch:03d&#125;</span>, Loss: <span class="subst">&#123;loss:<span class="number">.4</span>f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果：<br>Epoch: 050, Loss: 1.1346<br>Epoch: 100, Loss: 0.5471<br>Epoch: 150, Loss: 0.4021<br>Epoch: 200, Loss: 0.3391</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#测试</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">      model.<span class="built_in">eval</span>()</span><br><span class="line">      out = model(data.x, data.edge_index)</span><br><span class="line">      pred = out.argmax(dim=<span class="number">1</span>)  <span class="comment"># Use the class with highest probability.</span></span><br><span class="line">      test_correct = pred[data.test_mask] == data.y[data.test_mask]  <span class="comment"># Check against ground-truth labels.</span></span><br><span class="line">      test_acc = <span class="built_in">int</span>(test_correct.<span class="built_in">sum</span>()) / <span class="built_in">int</span>(data.test_mask.<span class="built_in">sum</span>())  <span class="comment"># Derive ratio of correct predictions.</span></span><br><span class="line">      <span class="keyword">return</span> test_acc</span><br><span class="line"></span><br><span class="line">test_acc = test()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Test Accuracy: <span class="subst">&#123;test_acc:<span class="number">.4</span>f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果:Test Accuracy: 0.8090</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#可视化训练后的GCN</span></span><br><span class="line">model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line">out = model(data.x, data.edge_index)</span><br><span class="line">visualize(out, color=data.y)</span><br></pre></td></tr></table></figure>
<p><img src="https://z3.ax1x.com/2021/06/28/Rtajaj.png" alt="训练后GCN"></p>
<h4 id="3-GAT-Graph-Attention-Network-在图节点分类中的应用"><a href="#3-GAT-Graph-Attention-Network-在图节点分类中的应用" class="headerlink" title="3.GAT(Graph Attention Network)在图节点分类中的应用"></a>3.GAT(Graph Attention Network)在图节点分类中的应用</h4><p>GAT的提出解决了GCN存在的问题:</p>
<ul>
<li>GCN 假设图是无向的,因为利用了对称的拉普拉斯矩阵 (只有邻接矩阵 A 是对称的，拉普拉斯矩阵才可以正交分解)，不能直接用于有向图。</li>
<li>GCN 不能处理动态图,GCN 在训练时依赖于具体的图结构，测试的时候也要在相同的图上进行。因此只能处理 transductive 任务，不能处理 inductive 任务。</li>
<li>GCN 不能为每个邻居分配不同的权重,GCN 在卷积时对所有邻居节点均一视同仁，不能根据节点重要性分配不同的权重。<h5 id="3-1-GAT公式"><a href="#3-1-GAT公式" class="headerlink" title="3.1 GAT公式"></a>3.1 GAT公式</h5>图注意力算子:<br>$$<br>\mathbf{x}^{\prime}<em>i = \alpha</em>{i,i}\mathbf{\Theta}\mathbf{x}<em>{i} +<br>\sum</em>{j \in \mathcal{N}(i)} \alpha_{i,j}\mathbf{\Theta}\mathbf{x}<em>{j}<br>$$<br>注意力系数$\alpha</em>{i,j}$为:<br>$$<br>\alpha_{i,j} =<br>\frac{<br>\exp\left(\mathrm{LeakyReLU}\left(\mathbf{a}^{\top}<br>[\mathbf{\Theta}\mathbf{x}_i , \Vert , \mathbf{\Theta}\mathbf{x}<em>j]<br>\right)\right)}<br>{\sum</em>{k \in \mathcal{N}(i) \cup { i }}<br>\exp\left(\mathrm{LeakyReLU}\left(\mathbf{a}^{\top}<br>[\mathbf{\Theta}\mathbf{x}_i , \Vert , \mathbf{\Theta}\mathbf{x}_k]<br>\right)\right)}<br>$$<h5 id="3-2-GAT代码"><a href="#3-2-GAT代码" class="headerlink" title="3.2 GAT代码"></a>3.2 GAT代码</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#构造GAT</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Linear</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> torch_geometric.nn <span class="keyword">import</span> GATConv</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GAT</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, hidden_channels</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(GAT, self).__init__()</span><br><span class="line">        torch.manual_seed(<span class="number">2021</span>)</span><br><span class="line">        self.conv1 = GATConv(dataset.num_features, hidden_channels)</span><br><span class="line">        self.conv2 = GATConv(hidden_channels, dataset.num_classes)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x, edge_index</span>):</span></span><br><span class="line">        x = self.conv1(x, edge_index)</span><br><span class="line">        x = x.relu()</span><br><span class="line">        x = F.dropout(x, p=<span class="number">0.5</span>, training=self.training)</span><br><span class="line">        x = self.conv2(x, edge_index)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">model = GAT(hidden_channels=<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(model)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果:<br>GAT(</p>
<pre><code>(conv1): GATConv(1433, 16, heads=1)
(conv2): GATConv(16, 7, heads=1)
</code></pre>
<p>)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#可视化未训练的GAT</span></span><br><span class="line">model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line">out = model(data.x, data.edge_index)</span><br><span class="line">visualize(out, color=data.y)</span><br></pre></td></tr></table></figure>
<img src="https://z3.ax1x.com/2021/06/28/RtaqsS.png" alt="未训练GAT"></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#训练GAT</span></span><br><span class="line">model = GAT(hidden_channels=<span class="number">16</span>)</span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">0.01</span>, weight_decay=<span class="number">5e-4</span>)</span><br><span class="line">criterion = torch.nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>():</span></span><br><span class="line">      model.train()</span><br><span class="line">      optimizer.zero_grad()  <span class="comment"># Clear gradients.</span></span><br><span class="line">      out = model(data.x, data.edge_index)  <span class="comment"># Perform a single forward pass.</span></span><br><span class="line">      loss = criterion(out[data.train_mask], data.y[data.train_mask])  <span class="comment"># 只根据训练节点计算损失</span></span><br><span class="line">      loss.backward()  <span class="comment"># Derive gradients.</span></span><br><span class="line">      optimizer.step()  <span class="comment"># 根据梯度更新参数</span></span><br><span class="line">      <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">201</span>):</span><br><span class="line">    loss = train()</span><br><span class="line">    <span class="keyword">if</span> epoch % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Epoch: <span class="subst">&#123;epoch:03d&#125;</span>, Loss: <span class="subst">&#123;loss:<span class="number">.4</span>f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果:<br>Epoch: 050, Loss: 0.8583<br>Epoch: 100, Loss: 0.3209<br>Epoch: 150, Loss: 0.2267<br>Epoch: 200, Loss: 0.1939</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#测试GAT</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">      model.<span class="built_in">eval</span>()</span><br><span class="line">      out = model(data.x, data.edge_index)</span><br><span class="line">      pred = out.argmax(dim=<span class="number">1</span>)  <span class="comment"># 选取概率最高的一类</span></span><br><span class="line">      test_correct = pred[data.test_mask] == data.y[data.test_mask]		<span class="comment"># 预测与真实对比</span></span><br><span class="line">      test_acc = <span class="built_in">int</span>(test_correct.<span class="built_in">sum</span>()) / <span class="built_in">int</span>(data.test_mask.<span class="built_in">sum</span>())	<span class="comment"># 准确率</span></span><br><span class="line">      <span class="keyword">return</span> test_acc</span><br><span class="line"></span><br><span class="line">test_acc = test()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Test Accuracy: <span class="subst">&#123;test_acc:<span class="number">.4</span>f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果:Test Accuracy: 0.7310</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#可视化训练后的GAT</span></span><br><span class="line">model = GAT(hidden_channels=<span class="number">16</span>)</span><br><span class="line">model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line">out = model(data.x, data.edge_index)</span><br><span class="line">visualize(out, color=data.y)</span><br></pre></td></tr></table></figure>
<p><img src="https://z3.ax1x.com/2021/06/28/RtaXZQ.png" alt="训练后GAT"></p>
<h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h4><p>GCN和GAT的结果都优于MLP,原因是他们同时考虑了节点自身信息与周围邻接节点的信息.</p>
<p>GCN和GAT的共同点:</p>
<ul>
<li>都遵循消息传递范式；</li>
<li>在邻接节点信息变换阶段，它们都对邻接节点做归一化和线性变换；</li>
<li>在邻接节点信息聚合阶段，它们都将变换后的邻接节点信息做求和聚合；</li>
<li>在中心节点信息变换阶段，它们都只是简单返回邻接节点信息聚合阶段的聚合结果。</li>
</ul>
<p>GCN和GAT的不同点在于归一化方法不同():</p>
<ul>
<li>GCN根据中心节点与邻接节点的度计算归一化系数;GAT根据中心节点与邻接节点的相似度计算归一化系数。</li>
<li>GCN的归一化方式依赖于图的拓扑结构：不同的节点会有不同的度，同时不同节点的邻接节点的度也不同，于是在一些应用中GCN图神经网络会表现出较差的泛化能力;GAT的归一化方式依赖于中心节点与邻接节点的相似度，相似度是训练得到的，因此不受图的拓扑结构的影响，在不同的任务中都会有较好的泛化表现。</li>
</ul>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>1.<a href="https://github.com/datawhalechina/team-learning-nlp/tree/master/GNN">datawhale-GNN开源学习资料</a><br>2.<a href="https://zhuanlan.zhihu.com/p/306261981">知乎-图节点表征学习</a><br>3.<a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/nn.html#torch_geometric.nn.conv.RGCNConv">GCNConv官方文档</a><br>4.<a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/nn.html#torch_geometric.nn.conv.GATConv">GATConv官方文档</a><br>5.<a href="https://baijiahao.baidu.com/s?id=1671028964544884749&wfr=spider&for=pc">GAT图注意力网络</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>PyG</tag>
        <tag>Graph</tag>
        <tag>MLP</tag>
        <tag>GCN</tag>
        <tag>GAT</tag>
      </tags>
  </entry>
  <entry>
    <title>Tsfresh——自动化特征工程工具</title>
    <url>/2021/03/25/tsfresh/</url>
    <content><![CDATA[<blockquote>
<p>改进模型的潜在途径之一是：生成更多的潜在特征，输入更多的样本。</p>
</blockquote>
<p>Tsfresh是处理时间序列数据的特征工程工具，能够自动计算大量时间序列特征，如平均值、最大值、峰度等。之后，可以使用这些特征集构建机器学习模型。</p>
<p>本文以<em>天池-心跳信号分类预测</em>为例，演示tsfresh工具的用法。</p>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><h5 id="1-合并train和test数据"><a href="#1-合并train和test数据" class="headerlink" title="1. 合并train和test数据"></a>1. 合并train和test数据</h5><p>合并数据集，对整体数据做统一的特征工程。(注意需要为test数据添加label列，值为-1，方便后续操作)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_test[<span class="string">&#x27;label&#x27;</span>] = -<span class="number">1</span></span><br><span class="line">all_data = pd.concat((data_train, data_test)).reset_index(drop = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h5 id="2-对原特征一列拆成多列，并为每条数据添加时间特征time"><a href="#2-对原特征一列拆成多列，并为每条数据添加时间特征time" class="headerlink" title="2. 对原特征一列拆成多列，并为每条数据添加时间特征time"></a>2. 对原特征一列拆成多列，并为每条数据添加时间特征time</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">all_heatbeat_df = all_data[<span class="string">&#x27;heartbeat_signals&#x27;</span>].<span class="built_in">str</span>.split(<span class="string">&#x27;,&#x27;</span>, expand = <span class="literal">True</span>).stack()</span><br></pre></td></tr></table></figure>
<h5 id="3-Index处理"><a href="#3-Index处理" class="headerlink" title="3. Index处理"></a>3. Index处理</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">all_heatbeat_df = all_heatbeat_df.reset_inex()</span><br><span class="line">all_heatbeat_df = all_heatbeat_df.set_inex(<span class="string">&#x27;level_0&#x27;</span>)</span><br><span class="line">all_heatbeat_df.index.name = <span class="literal">None</span></span><br><span class="line">all_heatbeat_df.rename(columns=&#123;<span class="string">&#x27;level_1&#x27;</span>:<span class="string">&#x27;time&#x27;</span>, <span class="number">0</span>:<span class="string">&#x27;heartbeat_signals&#x27;</span>, inpalce = <span class="literal">True</span>&#125;)</span><br><span class="line">all_heatbeat_df[<span class="string">&#x27;heartbeat_signals&#x27;</span>].astype(<span class="built_in">float</span>)</span><br></pre></td></tr></table></figure>

<h5 id="4-label列单独存储，不进入tsfresh"><a href="#4-label列单独存储，不进入tsfresh" class="headerlink" title="4. label列单独存储，不进入tsfresh"></a>4. label列单独存储，不进入tsfresh</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">all_data_label = all_data[<span class="string">&#x27;label&#x27;</span>]</span><br><span class="line">all_data = all_data.drop[<span class="string">&#x27;label&#x27;</span>, axis=<span class="number">1</span>].drop[<span class="string">&#x27;heartbeat_signals&#x27;</span>, axis=<span class="number">1</span>]</span><br><span class="line">all_data = all_data.join(all_heatbeat_df)</span><br></pre></td></tr></table></figure>

<h5 id="5-tsfresh特征抽取"><a href="#5-tsfresh特征抽取" class="headerlink" title="5. tsfresh特征抽取"></a>5. tsfresh特征抽取</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tsfresh <span class="keyword">import</span> extract_features</span><br><span class="line">all_features = extract_features(all_data, column_id=<span class="string">&#x27;id&#x27;</span>, column_sort=<span class="string">&#x27;time&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="6-特征选择"><a href="#6-特征选择" class="headerlink" title="6.特征选择"></a>6.特征选择</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#删除nan值</span></span><br><span class="line"><span class="keyword">from</span> tsfresh.utilities.dataframe_functions <span class="keyword">import</span> impute</span><br><span class="line">impute(all_features)</span><br></pre></td></tr></table></figure>

<h5 id="7-相关性特征提取"><a href="#7-相关性特征提取" class="headerlink" title="7.相关性特征提取"></a>7.相关性特征提取</h5><p>衍生众多特征之后，许多特征之间可能有很多相关性，需进一步筛选。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tsfresh <span class="keyword">import</span> select_features</span><br><span class="line">all_features_filtered = select_features(all_features, all_data_label)</span><br></pre></td></tr></table></figure>
<h5 id="8-特征重命名，重新添加label"><a href="#8-特征重命名，重新添加label" class="headerlink" title="8.特征重命名，重新添加label"></a>8.特征重命名，重新添加label</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = all_features_filtered.columns.size</span><br><span class="line">all_features_filtered.columns = [<span class="string">&#x27;f_&#x27;</span> + <span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">0</span>, num)]</span><br><span class="line">all_features_filtered[<span class="string">&#x27;label&#x27;</span>] = all_data_label</span><br></pre></td></tr></table></figure>

<h4 id="tsfresh包深入探究"><a href="#tsfresh包深入探究" class="headerlink" title="tsfresh包深入探究"></a>tsfresh包深入探究</h4><h5 id="1-筛选特征的方法"><a href="#1-筛选特征的方法" class="headerlink" title="1. 筛选特征的方法"></a>1. 筛选特征的方法</h5><p>上文采用了手工打标签的方式划分训练集和测试集，略显麻烦，可以通过tsfresh的内置方法来提取训练数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kind_to_fc_parameters = tsfresh.feature_extration.settings.from_columns(directed_features)</span><br></pre></td></tr></table></figure>
<p>生成的params为训练集的特征字典，可以当作参数传入后续计算中。</p>
<h5 id="2-自定义特征衍生规则"><a href="#2-自定义特征衍生规则" class="headerlink" title="2. 自定义特征衍生规则"></a>2. 自定义特征衍生规则</h5><p>tsfresh自带的衍生规则以字典的形式存放，可以直接调用，也可以自定义。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#单个特征计算</span></span><br><span class="line">tsfresh.feature_extraction.feature_calculators.abs_energy(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设定衍生规则</span></span><br><span class="line"><span class="keyword">from</span> tsfresh.featureextraction <span class="keyword">import</span> extractfeatures</span><br><span class="line">params = &#123;<span class="string">&#x27;fft_coefficient:[&#123;&#x27;</span>coe<span class="string">f&#x27;:0, &#x27;</span>att<span class="string">r&#x27;:&#x27;</span><span class="built_in">abs</span><span class="string">&#x27;&#125;], &#x27;</span>kurtosis<span class="string">&#x27;: None, &#x27;</span>skewness<span class="string">&#x27;: None&#125;</span></span><br></pre></td></tr></table></figure>

<p>后续可以在extractfeatures中设置defaultparameters = params，具体用法见<a href="https://tsfresh.readthedocs.io/en/latest/text/feature_extraction_settings.html">操作文档</a>。</p>
<h5 id="3-减小内存使用"><a href="#3-减小内存使用" class="headerlink" title="3. 减小内存使用"></a>3. 减小内存使用</h5><p>tsfresh默认参数太吃内存，且耗时长，笔者i7的16G笔记本最多只能跑到60%的进度就会卡住，天池notebook和谷歌colab都是没跑出结果就断线了，硬要跑的话只能租个高配服务器，或者调整衍生特征的数量，通过<strong>chunksize</strong>设置，具体用法见<a href="https://tsfresh.readthedocs.io/en/latest/text/feature_extraction_settings.html">操作文档</a>。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Feature engineering</tag>
      </tags>
  </entry>
  <entry>
    <title>图神经网络——基本图论与PyG库</title>
    <url>/2021/07/05/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%9B%BE%E8%A1%A8%E5%BE%81%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="图神经网络——基于图神经网络的图表征学习方法"><a href="#图神经网络——基于图神经网络的图表征学习方法" class="headerlink" title="图神经网络——基于图神经网络的图表征学习方法"></a>图神经网络——基于图神经网络的图表征学习方法</h3><p>图表征学习要求在输入节点属性、边和边的属性（如果有的话）得到一个向量作为图的表征，基于图表征进一步的我们可以做图的预测，而图同构网络（Graph Isomorphism Network, GIN）的图表征网络是当前最经典的图表征学习网络。</p>
<h4 id="1-GNN的邻域聚合-消息传递"><a href="#1-GNN的邻域聚合-消息传递" class="headerlink" title="1.GNN的邻域聚合(消息传递)"></a>1.GNN的邻域聚合(消息传递)</h4><p>GNN的目标是以图结构数据和节点特征作为输入，以学习到节点（或图）的embedding，用于分类任务。<br>基于邻域聚合的GNN可以拆分为以下三个模块：</p>
<ul>
<li>Aggregate：聚合一阶邻域特征。</li>
<li>Combine：将邻居聚合的特征 与 当前节点特征合并， 以更新当前节点特征。</li>
<li>Readout（可选）：如果是对graph分类，需要将graph中所有节点特征转变成graph特征。</li>
</ul>
<p>但是Aggregate的三种方式sum、mean、max的表征能力不够强大。</p>
<span id="more"></span>

<p><img src="https://i.loli.net/2021/07/12/XQxKfkPsL14g2O5.jpg" alt="FFFF.jpg"><br>如上图，节点v和v’为中心节点，通过聚合邻居特征生成embedding来分析不同aggregate设置下是否能区分不同的结构。设红绿蓝色节点特征值分别为r,g,b，不考虑combine。</p>
<blockquote>
<p>图a中：<br>mean：左$\frac{1}{2}(b+b)=b$，右$\frac{1}{3}(b+b+b)=b$，无法区分；<br>max：左$b$，右$b$，无法区分；<br>sum：左$2b$，右$3b$，可以区分。</p>
</blockquote>
<blockquote>
<p>图b中：<br>mean：左$\frac{1}{2}(r+g)$，右$\frac{1}{3}(g+2r)=b$，可以区分；<br>max：左$max(r,g)$，右$max(r,r,g)$，无法区分；<br>sum：左$r+g$，右$2r+g$，可以区分。</p>
</blockquote>
<blockquote>
<p>图c中：<br>mean：左$\frac{1}{2}(r+g)$，右$\frac{1}{4}(2g+2r)=b$，无法区分；<br>max：左$max(r,g)$，右$max(r,r,g,g)$，无法区分；<br>sum：左$r+g$，右$2r+2g$，可以区分。</p>
</blockquote>
<p>这说明，sum基本可以学习精确的结构信息、mean偏向学习分布信息，max偏向学习有代表性的元素信息，无法区分某些结构的图，故性能会比sum差一点。</p>
<h4 id="2-Weisfeiler-Lehman-Test-WL-Test"><a href="#2-Weisfeiler-Lehman-Test-WL-Test" class="headerlink" title="2.Weisfeiler-Lehman Test (WL Test)"></a>2.Weisfeiler-Lehman Test (WL Test)</h4><p>图的同构性测试算法（Weisfeiler-Lehman），简称WL Test，是一种用于测试两个图是否同构的算法。<br>WL Test 的一维形式，类似GNN中的邻接节点聚合。WL Test先迭代地聚合节点及其邻接节点的标签，然后将聚合的标签散列（hash）成新标签，该过程形式化为下方的公示，<br>$$<br>L^{h}<em>{u} \leftarrow \operatorname{hash}\left(L^{h-1}</em>{u} + \sum_{v \in \mathcal{N}(U)} L^{h-1}<em>{v}\right)<br>$$<br>上式中，$L^{h}</em>{u}$表示节点$u$的第$h$次迭代的标签，第$0$次迭代的标签为节点原始标签。</p>
<p>在迭代过程中，发现两个图之间的节点的标签不同时，就可以确定这两个图是非同构的。需要注意的是节点标签可能的取值只能是有限个数。</p>
<p>WL测试不能保证对所有图都有效，特别是对于具有高度对称性的图，如链式图、完全图、环图和星图，它会判断错误。</p>
<p>给定两个图$G$和$G^{\prime}$，每个节点拥有标签（实际中，一些图没有节点标签，我们可以以节点的度作为标签）。</p>
<p><img src="https://i.loli.net/2021/07/12/yr3axiC4PFOdqkJ.png" alt="C1.png"></p>
<p><strong>Weisfeiler-Leman Test 算法通过重复执行以下给节点打标签的过程来实现图是否同构的判断</strong>：</p>
<ol>
<li>聚合自身与邻接节点的标签得到一串字符串，自身标签与邻接节点的标签中间用<code>,</code>分隔，邻接节点的标签按升序排序。<strong>排序的原因在于要保证单射性，即保证输出的结果不因邻接节点的顺序改变而改变。</strong></li>
</ol>
<p><img src="https://i.loli.net/2021/07/12/wREO2ejIZMWicHv.png" alt="C2.png"></p>
<ol start="2">
<li><strong>标签散列，即标签压缩，将较长的字符串映射到一个简短的标签。</strong></li>
</ol>
<p><img src="https://i.loli.net/2021/07/12/pgdboxL6BKAr9Rz.png" alt="C3.png"></p>
<ol start="3">
<li><strong>给节点重新打上标签。</strong><br><img src="https://i.loli.net/2021/07/12/TOFRUV2INngGCxo.png" alt="C4.png"></li>
</ol>
<p>每重复一次以上的过程，就完成一次节点自身标签与邻接节点标签的聚合。</p>
<p><strong>当出现两个图相同节点标签的出现次数不一致时，即可判断两个图不相似</strong>。如果上述的步骤重复一定的次数后，没有发现有相同节点标签的出现次数不一致的情况，那么我们无法判断两个图是否同构。</p>
<p>当两个节点的$h$层的标签一样时，表示分别以这两个节点为根节点的WL子树是一致的。<strong>WL子树与普通子树不同</strong>，WL子树包含重复的节点。下图展示了一棵以1节点为根节点高为2的WL子树。</p>
<p><img src="https://i.loli.net/2021/07/12/KVkxiSlCvDf63F8.png" alt="C5.png"></p>
<h4 id="3-图相似性评估"><a href="#3-图相似性评估" class="headerlink" title="3.图相似性评估"></a>3.图相似性评估</h4><p>WL Test只能判断两个图的相似性，无法衡量图之间的相似性。要衡量两个图的相似性，需要用WL Subtree Kernel方法。该方法的思想是用WL Test算法得到节点的多层的标签，分别统计图中各类标签出现的次数，存于一个向量，这个向量可以作为图的表征<strong>。</strong>两个图的表征向量的内积，即可作为这两个图的相似性估计，内积越大表示相似性越高。</p>
<p><img src="https://i.loli.net/2021/07/12/IbyZ7h8JEXYRk3t.jpg" alt="gggg.jpg"></p>
<h4 id="4-图同构网络模型的构建"><a href="#4-图同构网络模型的构建" class="headerlink" title="4.图同构网络模型的构建"></a>4.图同构网络模型的构建</h4><p>通过GIN学习的节点表征向量可以用于类似于节点分类、边预测这样的任务。而对于图分类任务。READOUT函数：给定独立的节点的表征向量集，生成整个图的表征向量。</p>
<p>GIN的READOUT模块使用concat+sum，对每次迭代得到的所有节点特征求和得到图的特征，然后拼接起来，公式如下：<br>$$<br>h_{G} = \text{CONCAT}(\text{READOUT}\left({h_{v}^{(k)}|v\in G}\right)|k=0,1,\cdots, K)<br>$$</p>
<h4 id="5-基于图同构网络（GIN）的图表征网络的实现"><a href="#5-基于图同构网络（GIN）的图表征网络的实现" class="headerlink" title="5.基于图同构网络（GIN）的图表征网络的实现"></a>5.基于图同构网络（GIN）的图表征网络的实现</h4><p>基于图同构网络的图表征学习主要包含以下两个过程：</p>
<ol>
<li>计算得到节点表征；</li>
<li>对图上各个节点的表征做图池化（Graph Pooling），或称为图读出（Graph Readout），得到图的表征（Graph Representation）。</li>
</ol>
<p>基于图同构网络的图表征模块（GINGraphRepr Module），首先采用<code>GINNodeEmbedding</code>模块对图上每一个节点做节点嵌入（Node Embedding），得到节点表征；然后对节点表征做图池化得到图的表征；最后用一层线性变换对图表征转换为对图的预测。代码实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch_geometric.nn <span class="keyword">import</span> global_add_pool, global_mean_pool, global_max_pool, GlobalAttention, Set2Set</span><br><span class="line"><span class="keyword">from</span> gin_node <span class="keyword">import</span> GINNodeEmbedding</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GINGraphRepr</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_tasks=<span class="number">1</span>, num_layers=<span class="number">5</span>, emb_dim=<span class="number">300</span>, residual=<span class="literal">False</span>, drop_ratio=<span class="number">0</span>, JK=<span class="string">&quot;last&quot;</span>, graph_pooling=<span class="string">&quot;sum&quot;</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        num_tasks(int, optional)：图表征的维度；</span></span><br><span class="line"><span class="string">    	num_layers(int, optional)：卷积层数；</span></span><br><span class="line"><span class="string">        emb_dim(int, optional)：node embedding的维度；</span></span><br><span class="line"><span class="string">        residual(bool, optional)：是否添加剩余的连接；</span></span><br><span class="line"><span class="string">        drop_ratio (float, optional)：dropout rate；</span></span><br><span class="line"><span class="string">        JK (str, optional)：可选的值为&quot;last&quot;和&quot;sum&quot;。选&quot;last&quot;，只取最后一层的结点的嵌入，选&quot;sum&quot;对各层的结点的嵌入求和。</span></span><br><span class="line"><span class="string">        raph_pooling (str, optional)：node embedding的池化方法，可选的值为&quot;sum&quot;，&quot;mean&quot;，&quot;max&quot;，&quot;attention&quot;和&quot;set2set&quot;。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>(GINGraphPooling, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.num_layers = num_layers</span><br><span class="line">        self.drop_ratio = drop_ratio</span><br><span class="line">        self.JK = JK</span><br><span class="line">        self.emb_dim = emb_dim</span><br><span class="line">        self.num_tasks = num_tasks</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.num_layers &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;Number of GNN layers must be greater than 1.&quot;</span>)</span><br><span class="line"></span><br><span class="line">        self.gnn_node = GINNodeEmbedding(num_layers, emb_dim, JK=JK, drop_ratio=drop_ratio, residual=residual)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Pooling function to generate whole-graph embeddings</span></span><br><span class="line">        <span class="keyword">if</span> graph_pooling == <span class="string">&quot;sum&quot;</span>:</span><br><span class="line">            self.pool = global_add_pool</span><br><span class="line">        <span class="keyword">elif</span> graph_pooling == <span class="string">&quot;mean&quot;</span>:</span><br><span class="line">            self.pool = global_mean_pool</span><br><span class="line">        <span class="keyword">elif</span> graph_pooling == <span class="string">&quot;max&quot;</span>:</span><br><span class="line">            self.pool = global_max_pool</span><br><span class="line">        <span class="keyword">elif</span> graph_pooling == <span class="string">&quot;attention&quot;</span>:</span><br><span class="line">            self.pool = GlobalAttention(gate_nn=nn.Sequential(</span><br><span class="line">                nn.Linear(emb_dim, emb_dim), nn.BatchNorm1d(emb_dim), nn.ReLU(), nn.Linear(emb_dim, <span class="number">1</span>)))</span><br><span class="line">        <span class="keyword">elif</span> graph_pooling == <span class="string">&quot;set2set&quot;</span>:</span><br><span class="line">            self.pool = Set2Set(emb_dim, processing_steps=<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;Invalid graph pooling type.&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> graph_pooling == <span class="string">&quot;set2set&quot;</span>:</span><br><span class="line">            self.graph_pred_linear = nn.Linear(<span class="number">2</span>*self.emb_dim, self.num_tasks)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.graph_pred_linear = nn.Linear(self.emb_dim, self.num_tasks)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, batched_data</span>):</span></span><br><span class="line">        h_node = self.gnn_node(batched_data)</span><br><span class="line"></span><br><span class="line">        h_graph = self.pool(h_node, batched_data.batch)</span><br><span class="line">        output = self.graph_pred_linear(h_graph)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.training:</span><br><span class="line">            <span class="keyword">return</span> output</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># At inference time, relu is applied to output to ensure positivity</span></span><br><span class="line">            <span class="comment"># 因为预测目标的取值范围就在 (0, 50] 内</span></span><br><span class="line">            <span class="keyword">return</span> torch.clamp(output, <span class="built_in">min</span>=<span class="number">0</span>, <span class="built_in">max</span>=<span class="number">50</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>attention：基于Attention对节点表征加权求和，使用模块 <a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/nn.html#torch_geometric.nn.glob.GlobalAttention">torch_geometric.nn.glob.GlobalAttention</a>。<br>set2set：另一种基于Attention对节点表征加权求和的方法，使用模块 <a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/nn.html#torch_geometric.nn.glob.Set2Set">torch_geometric.nn.glob.Set2Set</a>。</p>
</blockquote>
<h4 id="6-基于图同构网络的节点嵌入模块（GINNodeEmbedding-Module）"><a href="#6-基于图同构网络的节点嵌入模块（GINNodeEmbedding-Module）" class="headerlink" title="6.基于图同构网络的节点嵌入模块（GINNodeEmbedding Module）"></a>6.基于图同构网络的节点嵌入模块（GINNodeEmbedding Module）</h4><p>此节点嵌入模块基于多层<code>GINConv</code>实现结点嵌入的计算。首先用<code>AtomEncoder</code>对其做嵌入得到第0层节点表征然后我们逐层计算节点表征，从第1层开始到第num_layers层，每一层节点表征的计算都以上一层的节点表征<code>h_list[layer]</code>、边<code>edge_index</code>和边的属性<code>edge_attr</code>为输入。<br>需要注意的是，<code>GINConv</code>的层数越多，此节点嵌入模块的感受野（receptive field）越大，结点<code>i</code>的表征最远能捕获到结点<code>i</code>的距离为<code>num_layers</code>的邻接节点的信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> mol_encoder <span class="keyword">import</span> AtomEncoder</span><br><span class="line"><span class="keyword">from</span> gin_conv <span class="keyword">import</span> GINConv</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="comment"># GNN to generate node embedding</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GINNodeEmbedding</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Output:</span></span><br><span class="line"><span class="string">        node representations</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_layers, emb_dim, drop_ratio=<span class="number">0.5</span>, JK=<span class="string">&quot;last&quot;</span>, residual=<span class="literal">False</span></span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>(GINNodeEmbedding, self).__init__()</span><br><span class="line">        self.num_layers = num_layers</span><br><span class="line">        self.drop_ratio = drop_ratio</span><br><span class="line">        self.JK = JK</span><br><span class="line">        self.residual = residual</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.num_layers &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;Number of GNN layers must be greater than 1.&quot;</span>)</span><br><span class="line"></span><br><span class="line">        self.atom_encoder = AtomEncoder(emb_dim)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># List of GNNs</span></span><br><span class="line">        self.convs = torch.nn.ModuleList()</span><br><span class="line">        self.batch_norms = torch.nn.ModuleList()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> <span class="built_in">range</span>(num_layers):</span><br><span class="line">            self.convs.append(GINConv(emb_dim))</span><br><span class="line">            self.batch_norms.append(torch.nn.BatchNorm1d(emb_dim))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, batched_data</span>):</span></span><br><span class="line">        x, edge_index, edge_attr = batched_data.x, batched_data.edge_index, batched_data.edge_attr</span><br><span class="line"></span><br><span class="line">        <span class="comment"># computing input node embedding</span></span><br><span class="line">        h_list = [self.atom_encoder(x)]  <span class="comment"># 先将类别型原子属性转化为原子表征</span></span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> <span class="built_in">range</span>(self.num_layers):</span><br><span class="line">            h = self.convs[layer](h_list[layer], edge_index, edge_attr)</span><br><span class="line">            h = self.batch_norms[layer](h)</span><br><span class="line">            <span class="keyword">if</span> layer == self.num_layers - <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># remove relu for the last layer</span></span><br><span class="line">                h = F.dropout(h, self.drop_ratio, training=self.training)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                h = F.dropout(F.relu(h), self.drop_ratio, training=self.training)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.residual:</span><br><span class="line">                h += h_list[layer]</span><br><span class="line"></span><br><span class="line">            h_list.append(h)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Different implementations of Jk-concat</span></span><br><span class="line">        <span class="keyword">if</span> self.JK == <span class="string">&quot;last&quot;</span>:</span><br><span class="line">            node_representation = h_list[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">elif</span> self.JK == <span class="string">&quot;sum&quot;</span>:</span><br><span class="line">            node_representation = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> layer <span class="keyword">in</span> <span class="built_in">range</span>(self.num_layers + <span class="number">1</span>):</span><br><span class="line">                node_representation += h_list[layer]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node_representation</span><br></pre></td></tr></table></figure>
<h4 id="7-图同构卷积层（GINConv）"><a href="#7-图同构卷积层（GINConv）" class="headerlink" title="7.图同构卷积层（GINConv）"></a>7.图同构卷积层（GINConv）</h4><p>图同构卷积层<code>GINConv</code>的数学定义如下：<br>$$<br>\mathbf{x}^{\prime}<em>i = h</em>{\mathbf{\Theta}} \left( (1 + \epsilon) \cdot\mathbf{x}<em>i + \sum</em>{j \in \mathcal{N}(i)} \mathbf{x}_j \right)<br>$$<br>构建代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch_geometric.nn <span class="keyword">import</span> MessagePassing</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> ogb.graphproppred.mol_encoder <span class="keyword">import</span> BondEncoder</span><br><span class="line"></span><br><span class="line"><span class="comment"># GIN convolution along the graph structure</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GINConv</span>(<span class="params">MessagePassing</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, emb_dim</span>):</span></span><br><span class="line">        <span class="comment">#emb_dim (int): node embedding dimensionality</span></span><br><span class="line">        <span class="built_in">super</span>(GINConv, self).__init__(aggr = <span class="string">&quot;add&quot;</span>)</span><br><span class="line"></span><br><span class="line">        self.mlp = nn.Sequential(nn.Linear(emb_dim, emb_dim), nn.BatchNorm1d(emb_dim), nn.ReLU(), nn.Linear(emb_dim, emb_dim))</span><br><span class="line">        self.eps = nn.Parameter(torch.Tensor([<span class="number">0</span>]))</span><br><span class="line">        self.bond_encoder = BondEncoder(emb_dim = emb_dim)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x, edge_index, edge_attr</span>):</span></span><br><span class="line">        edge_embedding = self.bond_encoder(edge_attr) <span class="comment"># 先将类别型边属性转换为边表征</span></span><br><span class="line">        out = self.mlp((<span class="number">1</span> + self.eps) *x + self.propagate(edge_index, x=x, edge_attr=edge_embedding))</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">message</span>(<span class="params">self, x_j, edge_attr</span>):</span></span><br><span class="line">        <span class="keyword">return</span> F.relu(x_j + edge_attr)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, aggr_out</span>):</span></span><br><span class="line">        <span class="keyword">return</span> aggr_out</span><br></pre></td></tr></table></figure>

<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>1.<a href="https://github.com/datawhalechina/team-learning-nlp/tree/master/GNN">datawhale-GNN开源学习资料</a><br>2.<a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/nn.html#global-pooling-layers">Global Pooling Layers</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>GIN</tag>
        <tag>GNN</tag>
      </tags>
  </entry>
  <entry>
    <title>图神经网络——基本图论与PyG库</title>
    <url>/2021/06/15/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E5%9B%BE%E8%AE%BA%E4%B8%8EPyG%E5%BA%93/</url>
    <content><![CDATA[<p>在以往的深度学习中，主要的数据形式包括矩阵、张量、序列(sequence)和时间序列(time series)，然而还有许多数据是图的结构，如社交网络、知识图谱等。图结构数据具有以下特点：</p>
<blockquote>
<p>任意的大小和复杂的拓扑结构；<br>没有固定的节点排序或参考点；<br>通常是动态的，并具有多模态的特征；<br>图的信息包括节点信息、边信息和拓扑结构信息。</p>
</blockquote>
<h4 id="1-图结构数据"><a href="#1-图结构数据" class="headerlink" title="1. 图结构数据"></a>1. 图结构数据</h4><h5 id="1-1-图-Graphs"><a href="#1-1-图-Graphs" class="headerlink" title="1.1 图(Graphs)"></a>1.1 图(Graphs)</h5><p><strong>·</strong> 一个图记作$\mathcal{G}={\mathcal{V}, \mathcal{E}}$，其中 $\mathcal{V}=\left{v_{1}, \ldots, v_{N}\right}$是数量为$N=|\mathcal{V}|$ 的节点的集合， $\mathcal{E}=\left{e_{1}, \ldots, e_{M}\right}$ 是数量为 $M$ 的边的集合。<br><strong>·</strong> 节点表示实体(entities)，边表示实体间的关系(relations)；节点和边的信息可以是类别型或数值型的。<br><strong>·</strong> 只有一种类型的节点和一种类型的边的图称为同质图(Homogeneous Graph)。<br><strong>·</strong> 存在多种类型的节点和多种类型的边的图称为异质图(Heterogeneous Graph)</p>
<span id="more"></span>

<h5 id="1-2-图的邻接矩阵-Adjacency-Matrix"><a href="#1-2-图的邻接矩阵-Adjacency-Matrix" class="headerlink" title="1.2 图的邻接矩阵(Adjacency Matrix)"></a>1.2 图的邻接矩阵(Adjacency Matrix)</h5><p><strong>·</strong> 图$\mathcal{G}={\mathcal{V}, \mathcal{E}}$，其对应的邻接矩阵记为$\mathbf{A} \in{0,1}^{N \times N}$。$\mathbf{A}<em>{i, j}=1$表示存在从节点$v_i$到$v_j$的边，反之表示不存在从节点$v_i$到$v_j$的边。<br><strong>·</strong> 在无向图中，节点$v_i$到$v_j$的边存在，则节点$v_j$到$v_i$的边也存在，所以无向图的邻接矩阵的对称的。<br><img src="https://z3.ax1x.com/2021/06/28/RtabM8.png" alt="图1"><br>其邻接矩阵为：<br><img src="https://z3.ax1x.com/2021/06/28/RtaoGt.png" alt="图2"><br><strong>·</strong> 在无权图中，各条边的权重是等价的，都为1。<br><strong>·</strong> 在有权图中，其对应的邻接矩阵通常被记为$\mathbf{W} \in{0,1}^{N \times N}$，其中$\mathbf{W}</em>{i, j}=w_{ij}$表示从节点$v_i$到$v_j$的边的权重。若边不存在时，边的权重为$0$。</p>
<h5 id="1-3-节点的度-degree"><a href="#1-3-节点的度-degree" class="headerlink" title="1.3 节点的度(degree)"></a>1.3 节点的度(degree)</h5><p><strong>·</strong> 在有向有权图中，节点$v_i$的出度(out degree)等于从$v_i$出发的边的权重之和，节点$v_i$的入度(in degree)等于从连向$v_i$的边的权重之和；节点$v_i$的度记为$d(v_i)$，入度记为$d_{in}(v_i)$，出度记为$d_{out}(v_i)$。<br><strong>·</strong> 在无向图中，出度=入度。<br><strong>·</strong> 在无权图中，入读等于连向$v_i$的边的数量，出度等于从$v_i$出发的边的数量。</p>
<h5 id="1-4-邻接节点-neighbors"><a href="#1-4-邻接节点-neighbors" class="headerlink" title="1.4 邻接节点(neighbors)"></a>1.4 邻接节点(neighbors)</h5><p><strong>·</strong> 与节点$v_i$直接相连的节点称为邻接节点，记为**$\mathcal{N(v_i)}$**。<br><strong>·</strong> 与节点$v_i$距离$k$步的称为$k$跳远的邻接节点(neighbors with $k$-hop) [一个节点的$2$跳远的邻接节点包含自身]</p>
<h5 id="1-5-行走-walk"><a href="#1-5-行走-walk" class="headerlink" title="1.5 行走(walk)"></a>1.5 行走(walk)</h5><p><strong>·</strong> $walk(v_1, v_2) = (v_1, e_6,e_5,e_4,e_1,v_2)$，这是一次“行走”，从节点$v_1$出发，依次经过边$e_6,e_5,e_4,e_1$，最终到达节点$v_2$的“行走”。<br><strong>·</strong> “行走”中，节点允许重复。<br><img src="https://z3.ax1x.com/2021/06/28/Rta7xf.png" alt="图3"></p>
<h5 id="1-6-路径-path"><a href="#1-6-路径-path" class="headerlink" title="1.6 路径(path)"></a>1.6 路径(path)</h5><p>“路径”是节点不可重复的“行走”。</p>
<h5 id="1-7-子图-subgraph"><a href="#1-7-子图-subgraph" class="headerlink" title="1.7 子图(subgraph)"></a>1.7 子图(subgraph)</h5><p>指节点集和边集分别是整图的节点集的子集和边集的子集的图。</p>
<h5 id="1-8-连通分量-connected-component"><a href="#1-8-连通分量-connected-component" class="headerlink" title="1.8 连通分量(connected component)"></a>1.8 连通分量(connected component)</h5><p>图$\mathcal{G}={\mathcal{V}, \mathcal{E}}$的子图为$\mathcal{G}^{\prime}$，记属于图$\mathcal{G}$但不属于$\mathcal{G}^{\prime}$图的节点集合记为$\mathcal{V}/\mathcal{V}^{\prime}$，属于$\mathcal{V}^{\prime}$的任意节点对之间存在至少一条路径，但不存在一条边连接属于$\mathcal{V}^{\prime}$的节点与属于$\mathcal{V}/\mathcal{V}^{\prime}$的节点，则图$\mathcal{G}^{\prime}$是图$\mathcal{G}$的连通分量。<br><img src="https://z3.ax1x.com/2021/06/28/RtaTRP.png" alt="图4"><br>左右两个子图都是整图的连通分量。</p>
<h5 id="1-8-连通图-connected-graph"><a href="#1-8-连通图-connected-graph" class="headerlink" title="1.8 连通图(connected graph)"></a>1.8 连通图(connected graph)</h5><p>只包含一个连通分量(即其自身)的图是一个连通图。</p>
<h5 id="1-9-最短路径-shortest-path"><a href="#1-9-最短路径-shortest-path" class="headerlink" title="1.9 最短路径(shortest path)"></a>1.9 最短路径(shortest path)</h5><p>$v_{s}, v_{t} \in \mathcal{V}$ 是图$\mathcal{G}={\mathcal{V}, \mathcal{E}}$上的一对节点，节点对$v_{s}, v_{t} \in \mathcal{V}$之间所有路径集合$\mathcal{P}<em>{\mathrm{st}}$。节点对$v</em>{s}, v_{t}$之间的最短路径$p_{\mathrm{s} t}^{\mathrm{sp}}$为$\mathcal{P}<em>{\mathrm{st}}$中长度最短的一条路径，即$p</em>{\mathrm{s} t}^{\mathrm{sp}}=\arg \min <em>{p \in \mathcal{P}</em>{\mathrm{st}}}|p|$，$p$表示$\mathcal{P}_{\mathrm{st}}$中的一条路径，$|p|$是路径$p$的长度(边数量×权重)。</p>
<h5 id="1-10-直径-diameter"><a href="#1-10-直径-diameter" class="headerlink" title="1.10 直径(diameter)"></a>1.10 直径(diameter)</h5><p>一个连通图$\mathcal{G}={\mathcal{V}, \mathcal{E}}$中，其直径为其所有节点对之间的最短路径的最大值，即$\operatorname{diameter}(\mathcal{G})=\max <em>{v</em>{s}, v_{t} \in \mathcal{V}} \min <em>{p \in \mathcal{P}</em>{s t}}|p|$</p>
<h5 id="1-11-拉普拉斯矩阵-Laplacian-Matrix"><a href="#1-11-拉普拉斯矩阵-Laplacian-Matrix" class="headerlink" title="1.11 拉普拉斯矩阵(Laplacian Matrix)"></a>1.11 拉普拉斯矩阵(Laplacian Matrix)</h5><p>图$\mathcal{G}={\mathcal{V}, \mathcal{E}}$，其邻接矩阵为$A$，其拉普拉斯矩阵定义为$\mathbf{L=D-A}$，其中$\mathbf{D=diag(d(v_1), \cdots, d(v_N))}$。</p>
<h5 id="1-12-对称归一化的拉普拉斯矩阵-Symmetric-normalized-Laplacian"><a href="#1-12-对称归一化的拉普拉斯矩阵-Symmetric-normalized-Laplacian" class="headerlink" title="1.12 对称归一化的拉普拉斯矩阵(Symmetric normalized Laplacian)"></a>1.12 对称归一化的拉普拉斯矩阵(Symmetric normalized Laplacian)</h5><p>图$\mathcal{G}={\mathcal{V}, \mathcal{E}}$，其邻接矩阵为$A$，其规范化的拉普拉斯矩阵定义为$\mathbf{L=D^{-\frac{1}{2}}(D-A)D^{-\frac{1}{2}}=I-D^{-\frac{1}{2}}AD^{-\frac{1}{2}}}$。</p>
<h4 id="2-图结构数据上的机器学习"><a href="#2-图结构数据上的机器学习" class="headerlink" title="2. 图结构数据上的机器学习"></a>2. 图结构数据上的机器学习</h4><blockquote>
<p><strong>节点预测</strong>：预测节点的类别或某类属性的取值。<br><strong>边预测</strong>：预测两个节点间是否存在链接。<br><strong>图预测</strong>：对不同的图进行分类或预测图的属性。<br><strong>节点聚类</strong>：检测节点是否形成一个类。</p>
</blockquote>
<h4 id="3-环境配置"><a href="#3-环境配置" class="headerlink" title="3. 环境配置"></a>3. 环境配置</h4><p><a href="https://pytorch-geometric.readthedocs.io/en/latest/">PyTorch Geometric</a> (PyG)是面向几何深度学习的PyTorch的扩展库，基于PyG库，我们可以轻松地根据数据生成一个图对象。</p>
<h5 id="3-1-安装的pytorch和cudatoolkit"><a href="#3-1-安装的pytorch和cudatoolkit" class="headerlink" title="3.1 安装的pytorch和cudatoolkit"></a>3.1 安装的pytorch和cudatoolkit</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda install pytorch torchvision torchaudio cudatoolkit&#x3D;11.1 -c pytorch -c nvidia</span><br></pre></td></tr></table></figure>
<p>安装成功后可以验证一下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="built_in">print</span>(torch.__version__)</span><br><span class="line"><span class="built_in">print</span>(torch.version.cuda)</span><br></pre></td></tr></table></figure>
<h5 id="3-2-安装PyG"><a href="#3-2-安装PyG" class="headerlink" title="3.2 安装PyG"></a>3.2 安装PyG</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install torch-scatter -f https://pytorch-geometric.com/whl/torch-<span class="number">1.8</span><span class="number">.0</span>+cu111.html</span><br><span class="line">pip install torch-sparse -f https://pytorch-geometric.com/whl/torch-<span class="number">1.8</span><span class="number">.0</span>+cu111.html</span><br><span class="line">pip install torch-cluster -f https://pytorch-geometric.com/whl/torch-<span class="number">1.8</span><span class="number">.0</span>+cu111.html</span><br><span class="line">pip install torch-spline-conv -f https://pytorch-geometric.com/whl/torch-<span class="number">1.8</span><span class="number">.0</span>+cu111.html</span><br><span class="line">pip install torch-geometric</span><br></pre></td></tr></table></figure>

<h4 id="4-Data类——PyG中图的表示"><a href="#4-Data类——PyG中图的表示" class="headerlink" title="4. Data类——PyG中图的表示"></a>4. Data类——PyG中图的表示</h4><h5 id="4-1-构造函数"><a href="#4-1-构造函数" class="headerlink" title="4.1 构造函数"></a>4.1 构造函数</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x=<span class="literal">None</span>, edge_index=<span class="literal">None</span>, edge_attr=<span class="literal">None</span>, y=<span class="literal">None</span>, **kwargs</span>):</span></span><br><span class="line">    self.x = x</span><br><span class="line">    self.edge_index = edge_index</span><br><span class="line">    self.edge_attr = edge_attr</span><br><span class="line">    self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> key, item <span class="keyword">in</span> kwargs.items():</span><br><span class="line">        <span class="keyword">if</span> key == <span class="string">&#x27;num_nodes&#x27;</span>:</span><br><span class="line">            self.__num_nodes__ = item</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self[key] = item</span><br></pre></td></tr></table></figure>
<p>Args:<br><strong>·</strong> x (Tensor, optional): 节点属性矩阵，大小为<code>[num_nodes, num_node_features]</code><br><strong>·</strong> edge_index (LongTensor, optional): 边索引矩阵，大小为<code>[2, num_edges]</code>，第0行为尾节点，第1行为头节点，头指向尾。<br><strong>·</strong> edge_attr (Tensor, optional): 边属性矩阵，大小为<code>[num_edges, num_edge_features]</code><br><strong>·</strong> y (Tensor, optional): 节点或图的标签，任意大小(其实也可以是边的标签)</p>
<h5 id="4-2-参数"><a href="#4-2-参数" class="headerlink" title="4.2 参数"></a>4.2 参数</h5><p>一个图至少包含<code>x, edge_index, edge_attr, y, num_nodes</code>5个属性，也可以指定额外参数使<code>Data</code>对象包含其他的属性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">graph = Data(x=x, edge_index=edge_index, edge_attr=edge_attr, y=y, num_nodes=num_nodes, other_attr=other_attr)</span><br></pre></td></tr></table></figure>

<h5 id="4-3-Data对象与其他数据互转"><a href="#4-3-Data对象与其他数据互转" class="headerlink" title="4.3 Data对象与其他数据互转"></a>4.3 Data对象与其他数据互转</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#dict to Data</span></span><br><span class="line">graph_dict = &#123;</span><br><span class="line">    <span class="string">&#x27;x&#x27;</span>: x,</span><br><span class="line">    <span class="string">&#x27;edge_index&#x27;</span>: edge_index,</span><br><span class="line">    <span class="string">&#x27;edge_attr&#x27;</span>: edge_attr,</span><br><span class="line">    <span class="string">&#x27;y&#x27;</span>: y,</span><br><span class="line">    <span class="string">&#x27;num_nodes&#x27;</span>: num_nodes,</span><br><span class="line">    <span class="string">&#x27;other_attr&#x27;</span>: other_attr</span><br><span class="line">&#125;</span><br><span class="line">graph_data = Data.from_dict(graph_dict)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Data to dict</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Data_to_dict</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;key: item <span class="keyword">for</span> key, item <span class="keyword">in</span> self&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Data to namedtuple</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Data_to_namedtuple</span>(<span class="params">self</span>):</span></span><br><span class="line">    keys = self.keys</span><br><span class="line">    DataTuple = collections.namedtuple(<span class="string">&#x27;DataTuple&#x27;</span>, keys)</span><br><span class="line">    <span class="keyword">return</span> DataTuple(*[self[key] <span class="keyword">for</span> key <span class="keyword">in</span> keys])</span><br></pre></td></tr></table></figure>

<h5 id="4-4-Data对象属性"><a href="#4-4-Data对象属性" class="headerlink" title="4.4 Data对象属性"></a>4.4 Data对象属性</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#获取Data对象属性</span></span><br><span class="line">x = graph_data[<span class="string">&#x27;x&#x27;</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#获取Data对象属性关键字</span></span><br><span class="line">graph_data.keys()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#对边排序并移除重复的边</span></span><br><span class="line">graph_data.coalesce()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch_geometric.datasets <span class="keyword">import</span> KarateClub</span><br><span class="line">dataset = KarateClub()</span><br><span class="line">data = dataset[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(data.num_nodes) <span class="comment">#节点数量</span></span><br><span class="line"><span class="built_in">print</span>(data.num_edges) <span class="comment">#边数量</span></span><br><span class="line"><span class="built_in">print</span>(data.num_node_features) <span class="comment">#节点属性维度</span></span><br><span class="line"><span class="built_in">print</span>(data.num_edge_features) <span class="comment">#边属性维度</span></span><br><span class="line"><span class="built_in">print</span>(data.num_edges/data.num_nodes) <span class="comment">#平均节点度</span></span><br><span class="line"><span class="built_in">print</span>(data.is_coalesced()) <span class="comment">#是否边是有序的同时不含有重复的边</span></span><br><span class="line"><span class="built_in">print</span>(data.train_mask.<span class="built_in">sum</span>()) <span class="comment">#用作训练集的节点</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(data.train_mask.<span class="built_in">sum</span>())/data.num_nodes) <span class="comment">#用作训练集的节点数占比</span></span><br><span class="line"><span class="built_in">print</span>(data.contains_isolated_nodes()) <span class="comment">#此图是否包含孤立的节点</span></span><br><span class="line"><span class="built_in">print</span>(data.contains_self_loops()) <span class="comment">#此图是否包含自环的边</span></span><br><span class="line"><span class="built_in">print</span>(data.is_undirected()) <span class="comment">#此图是否是无向图</span></span><br></pre></td></tr></table></figure>

<h4 id="5-Dataset类——PyG中图数据集的表示"><a href="#5-Dataset类——PyG中图数据集的表示" class="headerlink" title="5.Dataset类——PyG中图数据集的表示"></a>5.Dataset类——PyG中图数据集的表示</h4><h5 id="5-1-数据集的下载"><a href="#5-1-数据集的下载" class="headerlink" title="5.1 数据集的下载"></a>5.1 数据集的下载</h5><p>首先下载PyG内置的Planetoid数据集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch_geometric.datasets <span class="keyword">import</span> Planetoid</span><br><span class="line">dataset = Planetoid(root=<span class="string">&#x27;/dataset/Cora&#x27;</span>, name=<span class="string">&#x27;Cora&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(dataset))    <span class="comment">#数据集中图的数量</span></span><br><span class="line"><span class="built_in">print</span>(dataset.num_classes)   <span class="comment">#分类任务的数量</span></span><br><span class="line"><span class="built_in">print</span>(dataset.num_node_features)   <span class="comment">##节点属性维度</span></span><br></pre></td></tr></table></figure>
<h5 id="5-1-数据集的使用"><a href="#5-1-数据集的使用" class="headerlink" title="5.1 数据集的使用"></a>5.1 数据集的使用</h5><p>定义一个名为<code>Net</code>的图神经网络模型，将节点分类图数据集加入训练。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = Net().to(device)</span><br><span class="line">data = dataset[<span class="number">0</span>].to(device)</span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">0.01</span>, weight_decay=<span class="number">5e-4</span>)</span><br><span class="line"></span><br><span class="line">model.train()</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">500</span>):</span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    out = model(data)</span><br><span class="line">    loss = F.nll_loss(out[data.train_mask], data.y[data.train_mask])</span><br><span class="line">    loss.backward()</span><br><span class="line">    optimizer.step()</span><br></pre></td></tr></table></figure>

<p>1.<a href="https://github.com/datawhalechina/team-learning-nlp/tree/master/GNN">datawhale-GNN开源学习资料</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Graph</tag>
        <tag>GNN</tag>
      </tags>
  </entry>
  <entry>
    <title>图神经网络——消息传递网络</title>
    <url>/2021/06/19/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>消息传递(Message Passing) 指的是目标节点$S1$的邻居$\mathcal{N(S1)}$——B1、B2、B3，这些邻居节点根据一定的规则将信息(特征)，汇总到目标节点上。信息汇总中最简单的规则就是逐个元素相加。<br>在pytorch-geometric的官方文档中，消息传递图神经网络被描述为:<br>$$<br>\mathbf{x}_i^{(k)} = \gamma^{(k)} \left( \mathbf{x}<em>i^{(k-1)}, \square</em>{j \in \mathcal{N}(i)} , \phi^{(k)}\left(\mathbf{x}<em>i^{(k-1)}, \mathbf{x}<em>j^{(k-1)},\mathbf{e}</em>{j,i}\right) \right),<br>$$<br>其中，$\mathbf{e}</em>{j,i} \in \mathbb{R}^D$ 表示从节点$j$到节点$i$的边的属性，$\mathbf{x}^{(k-1)}_i\in\mathbb{R}^F$表示$(k-1)$层中节点$i$的节点表征，$\square$表示聚合策略，$\gamma$和$\phi$表示一些神经网络方法，比如MLPs多层感知器、LSTM等。<br>从公式中可以看出，目标节点$x_i$在k层的特征可以通过$x_i$在上一层(k-1层)的特征与其相邻节点$x_j$在上一层(k-1层)的特征以及相邻节点到目标节点的边的特征，这三个特征在k层通过$\square$的聚合策略(aggregate)，通过一个$\gamma$在k层的分析方法来导出目标节点$x_i$的特征。</p>
<span id="more"></span>

<h4 id="2-MessagePassing基类"><a href="#2-MessagePassing基类" class="headerlink" title="2. MessagePassing基类"></a>2. MessagePassing基类</h4><p>Pytorch Geometric(PyG)提供了<a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/nn.html#torch_geometric.nn.conv.message_passing.MessagePassing">MessagePassing</a>基类，通过继承基类，并定义message()方法、update()方法、aggregate()方法，可以构造消息传递图神经网络。</p>
<h5 id="2-1-MessagePassing-init-aggr-”add”-flow-”source-to-target”-node-dim-2"><a href="#2-1-MessagePassing-init-aggr-”add”-flow-”source-to-target”-node-dim-2" class="headerlink" title="2.1 MessagePassing.__init__(aggr=”add”, flow=”source_to_target”, node_dim=-2)"></a>2.1 MessagePassing.__init__(aggr=”add”, flow=”source_to_target”, node_dim=-2)</h5><blockquote>
<p>aggr：定义聚合方案(“add”、”mean”或 “max”)，默认值”add”；<br>flow：定义消息传递方向(“source_to_target”或 “target_to_source”)，默认值”source_to_target”；<br>node_dim：定义沿哪个维度传播，指的是节点表征张量(Tensor)的哪一个维度是节点维度，默认值-2(第0维)。</p>
</blockquote>
<h5 id="2-2-MessagePassing-propagate-edge-index-size-None-kwargs"><a href="#2-2-MessagePassing-propagate-edge-index-size-None-kwargs" class="headerlink" title="2.2 MessagePassing.propagate(edge_index, size=None, **kwargs)"></a>2.2 MessagePassing.propagate(edge_index, size=None, **kwargs)</h5><blockquote>
<p>这是一个集成方法，调用其会依次调用message、aggregate、update方法。<br>edge_index：边的端点的索引，当flow=”source_to_target”时，节点edge_index[0]的信息将被传递到节点edge_index[1]；当flow=”target_to_source”时，节点edge_index[1]的信息将被传递到节点edge_index[0]。<br>size：邻接节点的数量与中心节点的数量，默认值None(对称矩阵)；<br>**kwaegs：图的其他属性或额外的数据。</p>
</blockquote>
<h5 id="2-3-MessagePassing-message-…"><a href="#2-3-MessagePassing-message-…" class="headerlink" title="2.3 MessagePassing.message(…)"></a>2.3 MessagePassing.message(…)</h5><blockquote>
<p>以函数的方式构造消息；<br>flow=”source_to_target”，此方式下，message方法负责产生source node需要传出的信息。</p>
</blockquote>
<h5 id="2-4-MessagePassing-update-aggr-out-…"><a href="#2-4-MessagePassing-update-aggr-out-…" class="headerlink" title="2.4 MessagePassing.update(aggr_out, …)"></a>2.4 MessagePassing.update(aggr_out, …)</h5><blockquote>
<p>为每个节点$i \in \mathcal{V}$更新节点表征。</p>
</blockquote>
<h5 id="2-5-MessagePassing-aggregate-…"><a href="#2-5-MessagePassing-aggregate-…" class="headerlink" title="2.5 MessagePassing.aggregate(…)"></a>2.5 MessagePassing.aggregate(…)</h5><p>将从源节点传递过来的消息聚合在目标节点上，一般可选的聚合方式有sum, mean和max。</p>
<h4 id="3-MessagePassing子类"><a href="#3-MessagePassing子类" class="headerlink" title="3. MessagePassing子类"></a>3. MessagePassing子类</h4><h5 id="3-1-GCNConv类"><a href="#3-1-GCNConv类" class="headerlink" title="3.1 GCNConv类"></a>3.1 GCNConv类</h5><p>以继承MessagePassing基类的GCNConv类为例，可以实现一个简单的GNN。<br>GCNConv的公式如下:<br>$$<br>\mathbf{x}<em>i^{(k)} = \sum</em>{j \in \mathcal{N}(i) \cup { i }} \frac{1}{\sqrt{\deg(i)} \cdot \sqrt{\deg(j)}} \cdot \left( \mathbf{\Theta} \cdot \mathbf{x}_j^{(k-1)} \right)<br>$$<br>其中，邻接节点的表征$\mathbf{x}_j^{(k-1)}$首先通过与权重矩阵$\mathbf{\Theta}$相乘进行变换，然后按端点的度(degree)$\deg(i), \deg(j)$进行归一化处理，最后进行求和。这个公式可以分为以下几个步骤：</p>
<blockquote>
<p>向邻接矩阵添加自环边。<br>对节点表征做线性转换。<br>计算归一化系数。<br>归一化邻接节点的节点表征。<br>将相邻节点表征相加（”求和 “聚合）。</p>
</blockquote>
<p>GCNConv继承了MessagePassing，并以”求和”作为领域节点信息聚合方式。该层的所有逻辑都在forward()方法中：<br>1.通过torch_geometric.utils.add_self_loops()函数向边索引添加自循环边，目的是改进原始不考虑中心节点自身的信息量的问题；<br>2.通过torch.nn.Linear实例对节点表征进行线性变换；<br>3.归一化系数是由每个节点的节点度得出的，它被转换为每条边的节点度。结果被保存在形状为[num_edges,]的变量norm中。</p>
<h5 id="3-2-实现"><a href="#3-2-实现" class="headerlink" title="3.2 实现"></a>3.2 实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch_geometric.datasets <span class="keyword">import</span> Planetoid</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch_geometric.nn <span class="keyword">import</span> MessagePassing</span><br><span class="line"><span class="keyword">from</span> torch_geometric.utils <span class="keyword">import</span> add_self_loops, degree</span><br><span class="line"><span class="keyword">from</span> torch_sparse <span class="keyword">import</span> SparseTensor</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GCNConv</span>(<span class="params">MessagePassing</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, in_channels, out_channels</span>):</span></span><br><span class="line">        <span class="comment">#in_channels可理解为输入通道数，out_channels可理解为卷积核数量</span></span><br><span class="line">        <span class="built_in">super</span>(GCNConv, self).__init__(aggr=<span class="string">&#x27;add&#x27;</span>, flow=<span class="string">&#x27;source_to_target&#x27;</span>) <span class="comment">#继承，策略为合并</span></span><br><span class="line">        <span class="comment"># &quot;Add&quot; aggregation (Step 5).</span></span><br><span class="line">        <span class="comment"># flow=&#x27;source_to_target&#x27; 表示消息从源节点传播到目标节点</span></span><br><span class="line">        self.lin = torch.nn.Linear(in_channels, out_channels)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x, edge_index</span>):</span></span><br><span class="line">        <span class="comment"># x has shape [N, in_channels]</span></span><br><span class="line">        <span class="comment"># edge_index has shape [2, E]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 1: 添加自循环到节点特征矩阵(Add self-loops to the adjacency matrix.)</span></span><br><span class="line">        edge_index, _ = add_self_loops(edge_index, num_nodes=x.size(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 节点特征矩阵的线性变换(Linearly transform node feature matrix.)</span></span><br><span class="line">        x = self.lin(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 3: Compute normalization.</span></span><br><span class="line">        row, col = edge_index <span class="comment">#用行、列描述特征矩阵</span></span><br><span class="line">        deg = degree(col, x.size(<span class="number">0</span>), dtype=x.dtype)</span><br><span class="line">        deg_inv_sqrt = deg.<span class="built_in">pow</span>(-<span class="number">0.5</span>)</span><br><span class="line">        norm = deg_inv_sqrt[row] * deg_inv_sqrt[col]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 4-5: Start propagating messages.</span></span><br><span class="line">        adjmat = SparseTensor(row=edge_index[<span class="number">0</span>], col=edge_index[<span class="number">1</span>], value=torch.ones(edge_index.shape[<span class="number">1</span>]))</span><br><span class="line">        <span class="comment"># 此处传的不再是edge_index，而是SparseTensor类型的Adjancency Matrix</span></span><br><span class="line">        <span class="keyword">return</span> self.propagate的(adjmat, x=x, norm=norm, deg=deg.view((-<span class="number">1</span>, <span class="number">1</span>)))</span><br><span class="line">		<span class="comment"># 此处省略MessagePassing.propagate的代码.</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">message</span>(<span class="params">self, x_j, norm</span>):</span></span><br><span class="line">        <span class="comment"># x_j has shape [E, out_channels]</span></span><br><span class="line">        <span class="comment"># deg_i has shape [E, 1]</span></span><br><span class="line">        <span class="comment"># Step 4: Normalize node features.</span></span><br><span class="line">        <span class="keyword">return</span> norm.view(-<span class="number">1</span>, <span class="number">1</span>) * x_j</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">aggregate</span>(<span class="params">self, inputs, index, ptr, dim_size</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;self.aggr:&#x27;</span>, self.aggr)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;`aggregate` is called&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().aggregate(inputs, index, ptr=ptr, dim_size=dim_size)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">message_and_aggregate</span>(<span class="params">self, adj_t, x, norm</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;`message_and_aggregate` is called&#x27;</span>)</span><br><span class="line">        <span class="comment"># 没有实现真实的消息传递与消息聚合的操作</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, inputs, deg</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(deg)</span><br><span class="line">        <span class="keyword">return</span> inputs</span><br><span class="line"></span><br><span class="line">dataset = Planetoid(root=<span class="string">&#x27;dataset&#x27;</span>, name=<span class="string">&#x27;Cora&#x27;</span>)</span><br><span class="line">data = dataset[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">net = GCNConv(data.num_features, <span class="number">64</span>)</span><br><span class="line">h_nodes = net(data.x, data.edge_index)</span><br><span class="line"><span class="comment"># print(h_nodes.shape)</span></span><br></pre></td></tr></table></figure>

<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>1.<a href="https://github.com/datawhalechina/team-learning-nlp/tree/master/GNN">datawhale-GNN开源学习资料</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>GCN</tag>
      </tags>
  </entry>
  <entry>
    <title>图神经网络——节点分类与边预测</title>
    <url>/2021/06/27/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%8A%82%E7%82%B9%E5%88%86%E7%B1%BB%E4%B8%8E%E8%BE%B9%E9%A2%84%E6%B5%8B/</url>
    <content><![CDATA[<h4 id="1-InMemoryDataset基类"><a href="#1-InMemoryDataset基类" class="headerlink" title="1.InMemoryDataset基类"></a>1.InMemoryDataset基类</h4><p>在PyG中，可以通过继承InMemoryDataset类来自定义一个数据可全部存储到内存的数据集类。(继承Dataset是分次加载到内存，继承InMemoryDataset是一次性加载所有数据到内存)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InMemoryDataset</span>(<span class="params">root: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>, transform: <span class="type">Optional</span>[<span class="type">Callable</span>] = <span class="literal">None</span>, pre_transform: <span class="type">Optional</span>[<span class="type">Callable</span>] = <span class="literal">None</span>, pre_filter: <span class="type">Optional</span>[<span class="type">Callable</span>] = <span class="literal">None</span></span>)</span></span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<blockquote>
<p>transform：数据转换函数，用于转换Data对象，每一次数据获取过程中都会被执行。<br>pre_transform：数据转换函数，用于转换Data对象，在Data对象被保存到文件前调用。<br>pre_filter：检查数据是否要保留的函数，接收一个Data对象，返回此Data对象是否应该被包含在最终的数据集中，在Data对象被保存到文件前调用。</p>
</blockquote>
<span id="more"></span>
<h4 id="2-Sequential容器"><a href="#2-Sequential容器" class="headerlink" title="2.Sequential容器"></a>2.Sequential容器</h4><p>nn.Sequential是nn.module的容器，用于按顺序包装一组网络层。参数说明：</p>
<blockquote>
<p>args(str)：模型的全局输入参数；<br>modules ([(str, Callable) or Callable]) ：模块列表。</p>
</blockquote>
<h4 id="3-节点分类"><a href="#3-节点分类" class="headerlink" title="3. 节点分类"></a>3. 节点分类</h4><p>定义一个GAT图神经网络，通过hidden_channels_list参数来设置每一层GATConv的outchannel，所以hidden_channels_list长度即为GATConv的层数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#载入数据集</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch_geometric.datasets <span class="keyword">import</span> Planetoid</span><br><span class="line"><span class="keyword">from</span> torch_geometric.transforms <span class="keyword">import</span> NormalizeFeatures</span><br><span class="line">dataset = Planetoid(root=<span class="string">&#x27;dataset&#x27;</span>, ame=<span class="string">&#x27;Cora&#x27;</span>,transform=NormalizeFeatures())</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Linear,ReLU</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torch_geometric.nn <span class="keyword">import</span> GATConv, Sequential</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用Sequential容器定义一个GAT网络</span></span><br><span class="line"><span class="keyword">from</span> torch_geometric.nn <span class="keyword">import</span> GATConv</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GAT</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_features, hidden_channels_list, num_classes</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(GAT, self).__init__()</span><br><span class="line">        torch.manual_seed(<span class="number">2021</span>)</span><br><span class="line">        hns = [num_features] + hidden_channels_list</span><br><span class="line">        conv_list = []</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(hidden_channels_list)):</span><br><span class="line">            conv_list.append((GATConv(hns[idx], hns[idx+<span class="number">1</span>]), <span class="string">&#x27;x, edge_index -&gt; x&#x27;</span>))</span><br><span class="line">            conv_list.append(ReLU(inplace=<span class="literal">True</span>),)</span><br><span class="line"></span><br><span class="line">        self.convseq = Sequential(<span class="string">&#x27;x, edge_index&#x27;</span>, conv_list)</span><br><span class="line">        self.linear = Linear(hidden_channels_list[-<span class="number">1</span>], num_classes)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x, edge_index</span>):</span></span><br><span class="line">        x = self.convseq(x, edge_index)</span><br><span class="line">        x = F.dropout(x, p=<span class="number">0.5</span>, training=self.training)</span><br><span class="line">        x = self.linear(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#训练和测试</span></span><br><span class="line">device = torch.device(<span class="string">&quot;cuda:0&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line">model = GAT(num_features=dataset.num_features, hidden_channels_list=[<span class="number">200</span>, <span class="number">100</span>], num_classes=dataset.num_classes).to(device)</span><br><span class="line"><span class="built_in">print</span>(model)</span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">0.01</span>, weight_decay=<span class="number">5e-4</span>)</span><br><span class="line">criterion = torch.nn.CrossEntropyLoss()</span><br><span class="line"><span class="comment">#train()、test()省略，与上章一致</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">201</span>):</span><br><span class="line">    loss = train()</span><br><span class="line">    <span class="keyword">if</span> epoch % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Epoch: <span class="subst">&#123;epoch:03d&#125;</span>, Loss: <span class="subst">&#123;loss:<span class="number">.4</span>f&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">test_acc = test()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Test Accuracy: <span class="subst">&#123;test_acc:<span class="number">.4</span>f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>构建2层GAT，Accuracy为0.7640；构建2层GCN，Accuracy为0.6490。<br>构造3层GAT(将hidden_channels_list的值改为[200,100,50])，Accuracy为0.7680；构建3层GCN，Accuracy为0.5190。</p>
</blockquote>
<h4 id="4-边预测"><a href="#4-边预测" class="headerlink" title="4 边预测"></a>4 边预测</h4><p>边预测任务的目标是预测两个节点间是否有边。做边预测任务首先需要获取正负样本数量平衡的数据集(edge_index存储的是正样本，需要采样一些不存在边的节点对作为负样本边)，PyG中可以通过train_test_split_edges(data, val_ratio=0.05, test_ratio=0.1)采样负样本边。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#构造边预测神经网络</span></span><br><span class="line"><span class="keyword">import</span> os.path <span class="keyword">as</span> osp</span><br><span class="line"><span class="keyword">from</span> torch_geometric.utils <span class="keyword">import</span> negative_sampling</span><br><span class="line"><span class="keyword">from</span> torch_geometric.datasets <span class="keyword">import</span> Planetoid</span><br><span class="line"><span class="keyword">import</span> torch_geometric.transforms <span class="keyword">as</span> T</span><br><span class="line"><span class="keyword">from</span> torch_geometric.utils <span class="keyword">import</span> train_test_split_edges</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch_geometric.nn <span class="keyword">import</span> GCNConv</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, in_channels, out_channels</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        self.conv1 = GCNConv(in_channels, <span class="number">128</span>)</span><br><span class="line">        self.conv2 = GCNConv(<span class="number">128</span>, out_channels)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">encode</span>(<span class="params">self, x, edge_index</span>):</span></span><br><span class="line">        x = self.conv1(x, edge_index)</span><br><span class="line">        x = x.relu()</span><br><span class="line">        <span class="keyword">return</span> self.conv2(x, edge_index)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decode</span>(<span class="params">self, z, pos_edge_index, neg_edge_index</span>):</span></span><br><span class="line">        edge_index =  torch.cat([pos_edge_index, neg_edge_index], dim=-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> (z[edge_index[<span class="number">0</span>]] * z[edge_index[<span class="number">1</span>]]).<span class="built_in">sum</span>(dim=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decode_all</span>(<span class="params">self, z</span>):</span></span><br><span class="line">        <span class="comment">#对所有的节点对预测存在边的几率</span></span><br><span class="line">        prob_adj = z @ z.t()    <span class="comment"># @ 表示矩阵乘法</span></span><br><span class="line">        <span class="keyword">return</span> (prob_adj &gt; <span class="number">0</span>).nonzero(as_tuple=<span class="literal">False</span>).t()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义单个epoch的训练过程</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_link_labels</span>(<span class="params">pos_edge_index, neg_edge_index</span>):</span></span><br><span class="line">    num_links = pos_edge_index.size(<span class="number">1</span>) + neg_edge_index.size(<span class="number">1</span>)</span><br><span class="line">    link_labels = torch.zeros(num_links, dtype=torch.<span class="built_in">float</span>)</span><br><span class="line">    link_labels[:pos_edge_index.size(<span class="number">1</span>)] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> link_labels</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">data, model, optimizer</span>):</span></span><br><span class="line">    model.train()</span><br><span class="line"></span><br><span class="line">    neg_edge_index = negative_sampling(</span><br><span class="line">        edge_index = data.train_pos_edge_index,</span><br><span class="line">        num_nodes = data.num_nodes,</span><br><span class="line">        num_neg_samples = data.train_pos_edge_index.size(<span class="number">1</span>)</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    train_neg_edge_set = <span class="built_in">set</span>(<span class="built_in">map</span>(<span class="built_in">tuple</span>, neg_edge_index.T.tolist()))</span><br><span class="line">    val_pos_edge_set = <span class="built_in">set</span>(<span class="built_in">map</span>(<span class="built_in">tuple</span>, data.val_pos_edge_index.T.tolist()))</span><br><span class="line">    test_pos_edge_set = <span class="built_in">set</span>(<span class="built_in">map</span>(<span class="built_in">tuple</span>, data.test_pos_edge_index.T.tolist()))</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">len</span>(train_neg_edge_set &amp; val_pos_edge_set) &gt; <span class="number">0</span>) <span class="keyword">or</span> (<span class="built_in">len</span>(train_neg_edge_set &amp; test_pos_edge_set) &gt; <span class="number">0</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;wrong!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    z = model.encode(data.x, data.train_pos_edge_index)</span><br><span class="line">    link_logits = model.decode(z, data.train_pos_edge_index, neg_edge_index)</span><br><span class="line">    link_labels = get_link_labels(data.train_pos_edge_index, neg_edge_index).to(data.x.device)</span><br><span class="line">    loss = F.binary_cross_entropy_with_logits(link_logits, link_labels)</span><br><span class="line">    loss.backward()</span><br><span class="line">    optimizer.step()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> loss</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义单个epoch验证与测试过程</span></span><br><span class="line"><span class="meta">@torch.no_grad()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">data, model</span>):</span></span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line">    z = model.encode(data.x, data.train_pos_edge_index)</span><br><span class="line"></span><br><span class="line">    results = []</span><br><span class="line">    <span class="keyword">for</span> prefix <span class="keyword">in</span> [<span class="string">&#x27;val&#x27;</span>, <span class="string">&#x27;test&#x27;</span>]:</span><br><span class="line">        pos_edge_index = data[<span class="string">f&#x27;<span class="subst">&#123;prefix&#125;</span>_pos_edge_index&#x27;</span>]</span><br><span class="line">        neg_edge_index = data[<span class="string">f&#x27;<span class="subst">&#123;prefix&#125;</span>_neg_edge_index&#x27;</span>]</span><br><span class="line">        link_logits = model.decode(z, pos_edge_index, neg_edge_index)</span><br><span class="line">        link_probs = link_logits.sigmoid()</span><br><span class="line">        link_labels = get_link_labels(pos_edge_index, neg_edge_index)</span><br><span class="line">        results.append(roc_auc_score(link_labels.cpu(), link_probs.cpu()))</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#完整的训练、验证与测试</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_auc_score</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    device = torch.device(<span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line">	dataset = Planetoid(<span class="string">&#x27;/Dataset/Planetoid/Cora&#x27;</span>, <span class="string">&#x27;Cora&#x27;</span>, transform=T.NormalizeFeatures())</span><br><span class="line">    data = dataset[<span class="number">0</span>]</span><br><span class="line">    ground_truth_edge_index = data.edge_index.to(device)</span><br><span class="line">    data.train_mask = data.val_mask = data.test_mask = data.y = <span class="literal">None</span></span><br><span class="line">    data = train_test_split_edges(data)</span><br><span class="line">    data = data.to(device)</span><br><span class="line"></span><br><span class="line">    model = Net(dataset.num_features, <span class="number">64</span>).to(device)</span><br><span class="line">    optimizer = torch.optim.Adam(params=model.parameters(), lr=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">    best_val_auc = test_auc = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">101</span>):</span><br><span class="line">        loss = train(data, model, optimizer)</span><br><span class="line">        val_auc, tmp_test_auc = test(data, model)</span><br><span class="line">        <span class="keyword">if</span> val_auc &gt; best_val_auc:</span><br><span class="line">            best_val_auc = val_auc</span><br><span class="line">            test_auc = tmp_test_auc</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Epoch: <span class="subst">&#123;epoch:03d&#125;</span>, Loss: <span class="subst">&#123;loss:<span class="number">.4</span>f&#125;</span>, Val: <span class="subst">&#123;val_auc:<span class="number">.4</span>f&#125;</span>, &#x27;</span></span><br><span class="line">              <span class="string">f&#x27;Test: <span class="subst">&#123;test_auc:<span class="number">.4</span>f&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    z = model.encode(data.x, data.train_pos_edge_index)</span><br><span class="line">    final_edge_index = model.decode_all(z)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果：Epoch: 100, Loss: 0.4414, Val: 0.9330, Test: 0.8943</p>
</blockquote>
<p>将Sequential容器用于边预测，需要在Net类定义中将__init_函数和main()做部分修改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#替换上面的对应代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, in_channels, hidden_channels_list, out_channels</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        torch.manual_seed(<span class="number">2021</span>)</span><br><span class="line">        hns = [in_channels] + hidden_channels_list</span><br><span class="line">        conv_list = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(hidden_channels_list)-<span class="number">1</span>):</span><br><span class="line">            conv_list.append((GCNConv(hns[idx], hns[idx+<span class="number">1</span>]), <span class="string">&#x27;x, edge_index -&gt; x&#x27;</span>))</span><br><span class="line">            conv_list.append(ReLU(inplace=<span class="literal">True</span>), )</span><br><span class="line">        conv_list.append((GCNConv(hns[-<span class="number">2</span>], hns[-<span class="number">1</span>]), <span class="string">&#x27;x, edge_index -&gt; x&#x27;</span>))</span><br><span class="line"></span><br><span class="line">        self.convseq = Sequential(<span class="string">&#x27;x, edge_index&#x27;</span>, conv_list)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">        model = Net(dataset.num_features,[<span class="number">200</span>,<span class="number">100</span>],dataset.num_classes).to(device)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在边预测任务用Sequential容器的结果：<br>Epoch: 100, Loss: 0.4226, Val: 0.9123, Test: 0.8958</p>
</blockquote>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>1.<a href="https://github.com/datawhalechina/team-learning-nlp/tree/master/GNN">datawhale-GNN开源学习资料</a><br>2.<a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/nn.html#torch_geometric.nn.sequential.Sequential">GNN官方文档</a><br>3.<a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/nn.html#torch_geometric.nn.sequential.Sequential">Sequential官网文档</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>PyG</tag>
        <tag>GCN</tag>
        <tag>GAT</tag>
      </tags>
  </entry>
  <entry>
    <title>图神经网络——超大图上的节点表征学习</title>
    <url>/2021/07/01/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%B6%85%E5%A4%A7%E5%9B%BE%E4%B8%8A%E7%9A%84%E8%8A%82%E7%82%B9%E8%A1%A8%E5%BE%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>图卷积网络(GCN)已经成功地应用于许多基于图形的应用，然而大规模的GCN的训练仍然具有挑战性。目前基于SGD的算法要么面临着随GCN层数呈指数增长的高计算成本，要么面临着保存整个图形和每个节点的embedding到内存的巨大空间(显存)需求。于是论文<a href="https://arxiv.org/abs/1905.07953">Cluster-GCN: An Efficient Algorithm for Training Deep and Large Graph Convolutional Network</a>提出了Cluster-GCN方法来解决超大图的训练问题。</p>
<h4 id="1-Cluster-GCN方法简单概括"><a href="#1-Cluster-GCN方法简单概括" class="headerlink" title="1.Cluster-GCN方法简单概括"></a>1.Cluster-GCN方法简单概括</h4><ul>
<li>利用图节点聚类算法将一个图的节点划分为$c$个簇，每一次选择几个簇的节点和这些节点对应的边构成一个子图，然后对子图做训练。</li>
<li>由于是利用图节点聚类算法将节点划分为多个簇，所以簇内边的数量要比簇间边的数量多得多，所以可以提高表征利用率，并提高图神经网络的训练效率。</li>
<li>每一次随机选择多个簇来组成一个batch，这样不会丢失簇间的边，同时也不会有batch内类别分布偏差过大的问题。</li>
<li>基于小图进行训练，不会消耗很多内存空间，于是我们可以训练更深的神经网络，进而可以达到更高的精度。</li>
</ul>
<span id="more"></span>
<h4 id="2-GCN回顾"><a href="#2-GCN回顾" class="headerlink" title="2.GCN回顾"></a>2.GCN回顾</h4><p>论文<a href="https://arxiv.org/abs/1609.02907">2017. Semi-supervised classification with graph convolutional networks</a>中提出了GCN。作者定义了一种类似卷积的运算，称为谱图卷积。这使得CNN可以直接在图形上操作。GCN中的每一层通过考虑相邻节点的embedding，来更新Graph中的每个节点的特征向量表示。GCN的逐层正向传播可以总结为：<br>$$<br>X^{\left( l+1 \right)}=f\left( X^l,A \right) =\sigma \left( \tilde{D}^{-\frac{1}{2}}\tilde{A}D^{-\frac{1}{2}}X^{\left( l \right)}W^{\left( l \right)} \right)<br>$$</p>
<ul>
<li>$X$是所有节点的特征向量构成的特征矩阵。</li>
<li>$X^l$和$X^{l+1}$分别是$l$层的输入和输出矩阵，$X^l$也是第$l$层对于所有节点的embedding。</li>
<li>A是图的邻接矩阵。</li>
<li>${A}=A+I_N$是带有自环的无向图的邻接矩阵。</li>
<li>$I_N$是单位矩阵。</li>
<li>$\tilde{D}<em>{ii}=\sum{\tilde{A}</em>{ij}}$是带有自环的无向图的度矩阵，是一个对角矩阵。</li>
<li>$W^{(l)}$是一个可训练权重矩阵或参数矩阵。</li>
<li>$\sigma(\cdot)$是激活函数，通常被设为<code>ReLU</code>。</li>
</ul>
<p>为了简化计算，假设所有层的表征维度都是F，上式写为：<br>$$<br>Z^{(l+1)}=A^{\prime} X^{(l)} W^{(l)}, X^{(l+1)}=\sigma\left(Z^{(l+1)}\right)<br>$$</p>
<ul>
<li>$A^{\prime}$是归一化和规范化后的邻接矩阵</li>
</ul>
<p>将GCN用于半监督节点分类时，目标是通过最小化损失函数来学习上式中的权重矩阵：<br>$$<br>\mathcal{L}=\frac{1}{\left|\mathcal{Y}<em>{L}\right|} \sum</em>{i \in \mathcal{Y}<em>{L}} \operatorname{loss}\left(y</em>{i}, z_{i}^{L}\right)<br>$$</p>
<ul>
<li>$\mathcal{Y}_{\mathcal{L}}$是节点类别。</li>
<li>$z_{i}^{(L)}$是$Z^{(L)}$的第$i$行，表示节点$i$的最终层预测。</li>
<li>$y_{i}$为节点$i$的真实类别。<h4 id="3-Cluster-GCN的速度"><a href="#3-Cluster-GCN的速度" class="headerlink" title="3.Cluster-GCN的速度"></a>3.Cluster-GCN的速度</h4>原始的GCN的训练使用的是全批量梯度下降(Full Gradient Descent)，它的计算和内存成本很高:</li>
<li>在内存方面，通过反向传播来计算full gradient需要存储所有的embedding矩阵，这需要O(NFL)的内存空间（F是特征数量，N是结点数量，L是网络层数）。</li>
<li>在收敛速度方面，由于在每个epoch模型才更新一次，所以需要很多个epoch才会使模型达到收敛。</li>
</ul>
<p>mini-batch SGD可以提高GCN的训练速度，其不需要计算整个梯度，只需要计算每次更新的mini-batch的梯度。使用大小为$b=|\mathcal{B}|$的$\mathcal{B} \subseteq[N]$来表示一个batch的节点索引。SGD的每一步都将计算梯度估计值$\frac{1}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \nabla \operatorname{loss}\left(y_{i}, z_{i}^{(L)}\right)$来进行参数更新。</p>
<p>尽管在每个epoch收敛得更快，但SGD在GCN训练上引入了另一个计算开销（邻域扩展），这使得SGD的每个epoch时间内比全梯度下降（full gradient descent）要慢得多——计算一个节点$i$的梯度，需要节点$i$的embedding，而节点$i$的embedding的依赖于前面的层里的它的邻居的embeddings，为了提取前面的层中它的邻居节点embeddings，还需要进一步聚合每个邻居节点的邻居节点的embeddings。假设一个图神经网络有$L+1$层，节点的平均的度为$d$。为了得到节点$i$的梯度，需要聚合图上$O\left(d^{L}\right)$的节点的表征，与权重矩阵$W^{(l)}$相乘，所以计算任意节点表征的时间开销是$O\left(F^{2}\right)$。所以SGD一个节点的梯度的计算需要$O\left(d^{L} F^{2}\right)$的时间。</p>
<h4 id="4-Cluster-GCN详解"><a href="#4-Cluster-GCN详解" class="headerlink" title="4.Cluster-GCN详解"></a>4.Cluster-GCN详解</h4><p>在mini-batch SGD更新中，设计一个batch和相应的计算sub graph来最大限度地提高embedding utilization。Cluster-GCN通过将embedding utilization连接到一个聚类目标上来实现。</p>
<p>对于一个Graph$G$，我们将其节点划分为$c$个簇：$\mathcal{V}=\left[\mathcal{V}<em>{1}, \cdots \mathcal{V}</em>{c}\right]$，其中$\mathcal{V}<em>{t}$由第$t$个簇中的节点组成，得到$c$个子图:<br>$$<br>\bar{G}=\left[G</em>{1}, \cdots, G_{c}\right]=\left[\left{\mathcal{V}<em>{1}, \mathcal{E}</em>{1}\right}, \cdots,\left{\mathcal{V}<em>{c}, \mathcal{E}</em>{c}\right}\right]<br>\notag<br>$$<br>其中$\mathcal{E}<em>{t}$只由$\mathcal{V}</em>{t}$中的节点之间的边组成。经过节点重组，邻接矩阵被划分为大小为$c^{2}$的块矩阵，如下所示<br>$$<br>A=\bar{A}+\Delta=\left[\begin{array}{ccc}<br>A_{11} &amp; \cdots &amp; A_{1 c} \<br>\vdots &amp; \ddots &amp; \vdots \<br>A_{c 1} &amp; \cdots &amp; A_{c c}<br>\end{array}\right]<br>$$<br>其中<br>$$<br>\bar{A}=\left[\begin{array}{ccc}<br>A_{11} &amp; \cdots &amp; 0 \<br>\vdots &amp; \ddots &amp; \vdots \<br>0 &amp; \cdots &amp; A_{c c}<br>\end{array}\right], \Delta=\left[\begin{array}{ccc}<br>0 &amp; \cdots &amp; A_{1 c} \<br>\vdots &amp; \ddots &amp; \vdots \<br>A_{c 1} &amp; \cdots &amp; 0<br>\end{array}\right]<br>$$</p>
<ul>
<li>对角线上的块$A_{t t}$是大小为$\left|\mathcal{V}<em>{t}\right| \times\left|\mathcal{V}</em>{t}\right|$的邻接矩阵，它由$G_{t}$内部的边构成。</li>
<li>$\bar{A}$是图$\bar{G}$的邻接矩阵。</li>
<li>$A_{s t}$由两个簇$\mathcal{V}<em>{s}$和$\mathcal{V}</em>{t}$之间的边构成。</li>
<li>$\Delta$是由$A$的所有非对角线块组成的矩阵。</li>
</ul>
<p>用块对角线邻接矩阵$\bar{A}$去近似邻接矩阵$A$之后，完整的损失函数可以根据batch分解成多个部分之和：</p>
<p><a href="https://imgtu.com/i/W2fREV"><img src="https://z3.ax1x.com/2021/07/25/W2fREV.png" alt="W2fREV.png"></a></p>
<p><a href="https://imgtu.com/i/W2fX4O"><img src="https://z3.ax1x.com/2021/07/25/W2fX4O.png" alt="W2fX4O.png"></a></p>
<p>Cluster-GCN使用了Graph聚类算法来划分Graph。Graph聚类的方法，如metis和graclus等，旨在在Graph中的顶点上构建分区，使得簇内连接远大于簇间连接，从而更好的捕捉聚类和区分结构。</p>
<p><img src="https://i.loli.net/2021/07/12/h2CLbu9VMEzyNTa.jpg" alt="LAYER.jpg"></p>
<h4 id="5-Cluster-GCN实践"><a href="#5-Cluster-GCN实践" class="headerlink" title="5.Cluster-GCN实践"></a>5.Cluster-GCN实践</h4><p>PyG库中提供了Cluster-GCN的接口，可以像训练普通神经网络一样在超大图上训练图神经网络。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导入库和数据集</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> ModuleList</span><br><span class="line"><span class="keyword">from</span> torch_geometric.nn <span class="keyword">import</span> SAGEConv</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> torch_geometric.datasets <span class="keyword">import</span> Reddit, Reddit2</span><br><span class="line"><span class="keyword">from</span> torch_geometric.data <span class="keyword">import</span> ClusterData, ClusterLoader, NeighborSampler</span><br><span class="line"></span><br><span class="line">dataset = Reddit(<span class="string">&#x27;../dataset/Reddit&#x27;</span>)</span><br><span class="line">data = dataset[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(dataset.num_classes)</span><br><span class="line"><span class="built_in">print</span>(data.num_nodes)</span><br><span class="line"><span class="built_in">print</span>(data.num_edges)</span><br><span class="line"><span class="built_in">print</span>(data.num_features)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果：<br>41, 232965, 114615892, 602</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#图节点聚类并生成数据加载器</span></span><br><span class="line">cluster_data = ClusterData(data, num_parts=<span class="number">1500</span>, recursive=<span class="literal">False</span>, save_dir=dataset.processed_dir)</span><br><span class="line"></span><br><span class="line">train_loader = ClusterLoader(cluster_data, batch_size=<span class="number">20</span>, shuffle=<span class="literal">True</span>, num_workers=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">subgraph_loader = NeighborSampler(data.edge_index, sizes=[-<span class="number">1</span>], batch_size=<span class="number">1024</span>, shuffle=<span class="literal">False</span>,num_workers=<span class="number">12</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#构建网络</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, in_channels, out_channels</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        self.convs = ModuleList(</span><br><span class="line">            [SAGEConv(in_channels, <span class="number">128</span>),</span><br><span class="line">             SAGEConv(<span class="number">128</span>, out_channels)])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x, edge_index</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i, conv <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.convs):</span><br><span class="line">            x = conv(x, edge_index)</span><br><span class="line">            <span class="keyword">if</span> i != <span class="built_in">len</span>(self.convs) - <span class="number">1</span>:</span><br><span class="line">                x = F.relu(x)</span><br><span class="line">                x = F.dropout(x, p=<span class="number">0.5</span>, training=self.training)</span><br><span class="line">        <span class="keyword">return</span> F.log_softmax(x, dim=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inference</span>(<span class="params">self, x_all</span>):</span></span><br><span class="line">        pbar = tqdm(total=x_all.size(<span class="number">0</span>) * <span class="built_in">len</span>(self.convs))</span><br><span class="line">        pbar.set_description(<span class="string">&#x27;Evaluating&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i, conv <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.convs):</span><br><span class="line">            xs = []</span><br><span class="line">            <span class="keyword">for</span> batch_size, n_id, adj <span class="keyword">in</span> subgraph_loader:</span><br><span class="line">                edge_index, _, size = adj.to(device)</span><br><span class="line">                x = x_all[n_id].to(device)</span><br><span class="line">                x_target = x[:size[<span class="number">1</span>]]</span><br><span class="line">                x = conv((x, x_target), edge_index)</span><br><span class="line">                <span class="keyword">if</span> i != <span class="built_in">len</span>(self.convs) - <span class="number">1</span>:</span><br><span class="line">                    x = F.relu(x)</span><br><span class="line">                xs.append(x.cpu())</span><br><span class="line"></span><br><span class="line">                pbar.update(batch_size)</span><br><span class="line"></span><br><span class="line">            x_all = torch.cat(xs, dim=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        pbar.close()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x_all</span><br></pre></td></tr></table></figure>
<p>此神经网络的forward函数的定义与普通的图神经网络并无区别，而inference方法应用于推理阶段，为了获取更高的预测精度，所以使用subgraph_loader。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#训练、验证、测试</span></span><br><span class="line">device = torch.device(<span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line">model = Net(dataset.num_features, dataset.num_classes).to(device)</span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">0.005</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>():</span></span><br><span class="line">    model.train()</span><br><span class="line"></span><br><span class="line">    total_loss = total_nodes = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> train_loader:</span><br><span class="line">        batch = batch.to(device)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        out = model(batch.x, batch.edge_index)</span><br><span class="line">        loss = F.nll_loss(out[batch.train_mask], batch.y[batch.train_mask])</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        nodes = batch.train_mask.<span class="built_in">sum</span>().item()</span><br><span class="line">        total_loss += loss.item() * nodes</span><br><span class="line">        total_nodes += nodes</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total_loss / total_nodes</span><br><span class="line"></span><br><span class="line"><span class="meta">@torch.no_grad()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span>  <span class="comment"># Inference should be performed on the full graph.</span></span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line">    out = model.inference(data.x)</span><br><span class="line">    y_pred = out.argmax(dim=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    accs = []</span><br><span class="line">    <span class="keyword">for</span> mask <span class="keyword">in</span> [data.train_mask, data.val_mask, data.test_mask]:</span><br><span class="line">        correct = y_pred[mask].eq(data.y[mask]).<span class="built_in">sum</span>().item()</span><br><span class="line">        accs.append(correct / mask.<span class="built_in">sum</span>().item())</span><br><span class="line">    <span class="keyword">return</span> accs</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">31</span>):</span><br><span class="line">    loss = train()</span><br><span class="line">    <span class="keyword">if</span> epoch % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">        train_acc, val_acc, test_acc = test()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Epoch: <span class="subst">&#123;epoch:02d&#125;</span>, Loss: <span class="subst">&#123;loss:<span class="number">.4</span>f&#125;</span>, Train: <span class="subst">&#123;train_acc:<span class="number">.4</span>f&#125;</span>, &#x27;</span></span><br><span class="line">              <span class="string">f&#x27;Val: <span class="subst">&#123;val_acc:<span class="number">.4</span>f&#125;</span>, test: <span class="subst">&#123;test_acc:<span class="number">.4</span>f&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Epoch: <span class="subst">&#123;epoch:02d&#125;</span>, Loss: <span class="subst">&#123;loss:<span class="number">.4</span>f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果：<br>Epoch: 10, Loss: 0.2893, Train: 0.9620, Val: 0.9516, test: 0.9496<br>Epoch: 20, Loss: 0.2478, Train: 0.9664, Val: 0.9546, test: 0.9560<br>Epoch: 30, Loss: 0.2397, Train: 0.9689, Val: 0.9515, test: 0.9502</p>
</blockquote>
<p>在训练过程中，使用train_loader获取batch，每次根据多个簇组成的batch进行训练；在验证阶段，使用subgraph_loader，在计算一个节点的表征时会计算该节点的距离从$0$到$L$的邻接节点，可以更好地测试神经网络的性能。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>1.<a href="https://github.com/datawhalechina/team-learning-nlp/tree/master/GNN">datawhale-GNN开源学习资料</a><br>2.<a href="https://arxiv.org/abs/1905.07953">Cluster-GCN论文</a> </p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>GCN</tag>
      </tags>
  </entry>
  <entry>
    <title>图神经网络——基本图论与PyG库</title>
    <url>/2021/07/09/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%B6%85%E5%A4%A7%E8%A7%84%E6%A8%A1%E6%95%B0%E6%8D%AE%E9%9B%86%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%9B%BE%E9%A2%84%E6%B5%8B%E4%BB%BB%E5%8A%A1%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h3 id="图神经网络——超大规模数据集类的创建和图预测任务实践"><a href="#图神经网络——超大规模数据集类的创建和图预测任务实践" class="headerlink" title="图神经网络——超大规模数据集类的创建和图预测任务实践"></a>图神经网络——超大规模数据集类的创建和图预测任务实践</h3><p>当数据集规模超级大时，很难有足够大的内存完全存下所有数据。因此需要一个按需加载样本到内存的数据集类。</p>
<h4 id="1-Dataset基类"><a href="#1-Dataset基类" class="headerlink" title="1 Dataset基类"></a>1 <code>Dataset</code>基类</h4><h5 id="1-1-Dataset基类介绍"><a href="#1-1-Dataset基类介绍" class="headerlink" title="1.1 Dataset基类介绍"></a>1.1 <code>Dataset</code>基类介绍</h5><p>在PyG中，通过继承<code>torch_geometric.data.Dataset</code>基类来自定义一个按需加载样本到内存的数据集类。<br>继承此基类相比较继承<code>torch_geometric.data.InMemoryDataset</code>基类要多实现以下方法：</p>
<ul>
<li><code>len()</code>：返回数据集中的样本的数量。</li>
<li><code>get()</code>：实现加载单个图的操作。注意：在内部，getitem()返回通过调用get()来获取Data对象，并根据transform参数对它们进行选择性转换。</li>
</ul>
<span id="more"></span>
<h5 id="1-2-继承torch-geometric-data-Dataset基类的代码实现"><a href="#1-2-继承torch-geometric-data-Dataset基类的代码实现" class="headerlink" title="1.2 继承torch_geometric.data.Dataset基类的代码实现"></a>1.2 继承torch_geometric.data.Dataset基类的代码实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os.path <span class="keyword">as</span> osp</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch_geometric.data <span class="keyword">import</span> Dataset, download_url</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyOwnDataset</span>(<span class="params">Dataset</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, root, transform=<span class="literal">None</span>, pre_transform=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(MyOwnDataset, self).__init__(root, transform, pre_transform)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">raw_file_names</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;some_file_1&#x27;</span>, <span class="string">&#x27;some_file_2&#x27;</span>, ...]</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">processed_file_names</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;data_1.pt&#x27;</span>, <span class="string">&#x27;data_2.pt&#x27;</span>, ...]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">download</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># Download to `self.raw_dir`.</span></span><br><span class="line">        path = download_url(url, self.raw_dir)</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self</span>):</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> raw_path <span class="keyword">in</span> self.raw_paths:</span><br><span class="line">            <span class="comment"># Read data from `raw_path`.</span></span><br><span class="line">            data = Data(...)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.pre_filter <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> self.pre_filter(data):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.pre_transform <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                data = self.pre_transform(data)</span><br><span class="line"></span><br><span class="line">            torch.save(data, osp.join(self.processed_dir, <span class="string">&#x27;data_&#123;&#125;.pt&#x27;</span>.<span class="built_in">format</span>(i)))</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">len</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.processed_file_names)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, idx</span>):</span></span><br><span class="line">        data = torch.load(osp.join(self.processed_dir, <span class="string">&#x27;data_&#123;&#125;.pt&#x27;</span>.<span class="built_in">format</span>(idx)))</span><br><span class="line">        <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>
<h5 id="1-3-特殊情况"><a href="#1-3-特殊情况" class="headerlink" title="1.3 特殊情况"></a>1.3 特殊情况</h5><ul>
<li>download/process步骤可以跳过<br>对于无需下载数据集原文件的情况，不重写（override）<code>download</code>方法即可跳过下载。<br>对于无需对数据集做预处理的情况，不重写<code>process</code>方法即可跳过预处理。</li>
<li>有些Dataset类无需定义<br>可以不用定义一个<code>Dataset</code>类，而直接生成一个<code>Dataloader</code>对象，直接用于训练：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch_geometric.data <span class="keyword">import</span> Data, DataLoader</span><br><span class="line"></span><br><span class="line">data_list = [Data(...), ..., Data(...)]</span><br><span class="line">loader = DataLoader(data_list, batch_size=<span class="number">32</span>)</span><br></pre></td></tr></table></figure>
或者将一个列表的<code>Data</code>对象组成一个<code>batch</code>：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch_geometric.data <span class="keyword">import</span> Data, Batch</span><br><span class="line"></span><br><span class="line">data_list = [Data(...), ..., Data(...)]</span><br><span class="line">loader = Batch.from_data_list(data_list, batch_size=<span class="number">32</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-图样本封装成批（BATCHING）与DataLoader类"><a href="#2-图样本封装成批（BATCHING）与DataLoader类" class="headerlink" title="2 图样本封装成批（BATCHING）与DataLoader类"></a>2 图样本封装成批（BATCHING）与<code>DataLoader</code>类</h4><h5 id="2-1-合并小图组成大图"><a href="#2-1-合并小图组成大图" class="headerlink" title="2.1 合并小图组成大图"></a>2.1 合并小图组成大图</h5><p>PyTorch Geometric中采用的是将多个图封装成批的方式，将小图作为连通组件（connected component）的形式合并，构建一个大图。于是小图的邻接矩阵存储在大图邻接矩阵的对角线上。<br>该方法的优势在于：</p>
<ul>
<li>依靠消息传递方案的GNN运算不需要被修改。</li>
<li>没有额外的计算或内存的开销。（因为它们是以稀疏的方式保存的，只保留非零项）</li>
</ul>
<p>通过<a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/data.html#torch_geometric.data.DataLoader"><code>torch_geometric.data.DataLoader</code></a>类，多个小图被封装成一个大图。</p>
<h5 id="2-2-小图的属性增值与拼接"><a href="#2-2-小图的属性增值与拼接" class="headerlink" title="2.2 小图的属性增值与拼接"></a>2.2 小图的属性增值与拼接</h5><p>将小图存储到大图中时需要对小图的属性做一些修改，比如对节点序号增值，PyTorch Geometric的<code>DataLoader</code>类会自动对<code>edge_index</code>张量增值，增加的值为当前被处理图的前面的图的累积节点数量。</p>
<h5 id="2-3-图的匹配（Pairs-of-Graphs）"><a href="#2-3-图的匹配（Pairs-of-Graphs）" class="headerlink" title="2.3 图的匹配（Pairs of Graphs）"></a>2.3 图的匹配（Pairs of Graphs）</h5><p>不同类型的节点数量不一致，<code>edge_index</code>边的源节点与目标节点进行增值操作不同。</p>
<h5 id="2-4-二部图（Bipartite-Graphs）"><a href="#2-4-二部图（Bipartite-Graphs）" class="headerlink" title="2.4 二部图（Bipartite Graphs）"></a>2.4 二部图（Bipartite Graphs）</h5><p>部图是图论中的一种特殊模型。设$G=(V,E)$是一个无向图，如果顶点$V$可分割为两个互不相交的子集$(A,B)$，并且图中的每条边$(i,j)$所关联的两个顶点i和j分别属于这两个不同的顶点集$(i in A,j in B)$，则称图$G$为一个二部图。它的邻接矩阵定义两种类型的节点之间的连接关系。一般来说，不同类型的节点数量不需要一致，于是二部图的邻接矩阵$A \in {0,1}^{N \times M}$可能为平方矩阵，即可能有$N \neq M$。</p>
<h5 id="2-5-在新的维度上做拼接"><a href="#2-5-在新的维度上做拼接" class="headerlink" title="2.5 在新的维度上做拼接"></a>2.5 在新的维度上做拼接</h5><p>图级别属性或预测目标,<code>Data</code>对象的属性需要在一个新的维度上做拼接，此时形状为<code>[num_features]</code>的属性列表应该被返回为<code>[num_examples, num_features]</code>，而不是<code>[num_examples * num_features]</code>。</p>
<h4 id="3-创建超大规模数据集类实践"><a href="#3-创建超大规模数据集类实践" class="headerlink" title="3 创建超大规模数据集类实践"></a>3 创建超大规模数据集类实践</h4><p><a href="https://ogb.stanford.edu/kddcup2021/pcqm4m/"><strong>PCQM4M-LSC</strong></a>是一个分子图的量子特性回归数据集，它包含了3,803,453个图。<br>定义的数据集类如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> os.path <span class="keyword">as</span> osp</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> ogb.utils <span class="keyword">import</span> smiles2graph</span><br><span class="line"><span class="keyword">from</span> ogb.utils.torch_util <span class="keyword">import</span> replace_numpy_with_torchtensor</span><br><span class="line"><span class="keyword">from</span> ogb.utils.url <span class="keyword">import</span> download_url, extract_zip</span><br><span class="line"><span class="keyword">from</span> rdkit <span class="keyword">import</span> RDLogger</span><br><span class="line"><span class="keyword">from</span> torch_geometric.data <span class="keyword">import</span> Data, Dataset</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line">RDLogger.DisableLog(<span class="string">&#x27;rdApp.*&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPCQM4MDataset</span>(<span class="params">Dataset</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        self.url = <span class="string">&#x27;https://dgl-data.s3-accelerate.amazonaws.com/dataset/OGB-LSC/pcqm4m_kddcup2021.zip&#x27;</span></span><br><span class="line">        <span class="built_in">super</span>(MyPCQM4MDataset, self).__init__(root)</span><br><span class="line"></span><br><span class="line">        filepath = osp.join(root, <span class="string">&#x27;raw/data.csv.gz&#x27;</span>)</span><br><span class="line">        data_df = pd.read_csv(filepath)</span><br><span class="line">        self.smiles_list = data_df[<span class="string">&#x27;smiles&#x27;</span>]</span><br><span class="line">        self.homolumogap_list = data_df[<span class="string">&#x27;homolumogap&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">raw_file_names</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;data.csv.gz&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">download</span>(<span class="params">self</span>):</span></span><br><span class="line">        path = download_url(self.url, self.root)</span><br><span class="line">        extract_zip(path, self.root)</span><br><span class="line">        os.unlink(path)</span><br><span class="line">        shutil.move(osp.join(self.root, <span class="string">&#x27;pcqm4m_kddcup2021/raw/data.csv.gz&#x27;</span>), osp.join(self.root, <span class="string">&#x27;raw/data.csv.gz&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">len</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.smiles_list)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, idx</span>):</span></span><br><span class="line">        smiles, homolumogap = self.smiles_list[idx], self.homolumogap_list[idx]</span><br><span class="line">        graph = smiles2graph(smiles)</span><br><span class="line">        <span class="keyword">assert</span>(<span class="built_in">len</span>(graph[<span class="string">&#x27;edge_feat&#x27;</span>]) == graph[<span class="string">&#x27;edge_index&#x27;</span>].shape[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">assert</span>(<span class="built_in">len</span>(graph[<span class="string">&#x27;node_feat&#x27;</span>]) == graph[<span class="string">&#x27;num_nodes&#x27;</span>])</span><br><span class="line"></span><br><span class="line">        x = torch.from_numpy(graph[<span class="string">&#x27;node_feat&#x27;</span>]).to(torch.int64)</span><br><span class="line">        edge_index = torch.from_numpy(graph[<span class="string">&#x27;edge_index&#x27;</span>]).to(torch.int64)</span><br><span class="line">        edge_attr = torch.from_numpy(graph[<span class="string">&#x27;edge_feat&#x27;</span>]).to(torch.int64)</span><br><span class="line">        y = torch.Tensor([homolumogap])</span><br><span class="line">        num_nodes = <span class="built_in">int</span>(graph[<span class="string">&#x27;num_nodes&#x27;</span>])</span><br><span class="line">        data = Data(x, edge_index, edge_attr, y, num_nodes=num_nodes)</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取数据集划分</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_idx_split</span>(<span class="params">self</span>):</span></span><br><span class="line">        split_dict = replace_numpy_with_torchtensor(torch.load(osp.join(self.root, <span class="string">&#x27;pcqm4m_kddcup2021/split_dict.pt&#x27;</span>)))</span><br><span class="line">        <span class="keyword">return</span> split_dict</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    dataset = MyPCQM4MDataset(<span class="string">&#x27;dataset2&#x27;</span>)</span><br><span class="line">    <span class="keyword">from</span> torch_geometric.data <span class="keyword">import</span> DataLoader</span><br><span class="line">    <span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line">    dataloader = DataLoader(dataset, batch_size=<span class="number">256</span>, shuffle=<span class="literal">True</span>, num_workers=<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> tqdm(dataloader):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>在生成一个该数据集类的对象时:</p>
<ul>
<li>首先会检查指定的文件夹下是否存在<code>data.csv.gz</code>文件，如果不在，则会执行<code>download</code>方法，这一过程是在运行<code>super</code>类的<code>__init__</code>方法中发生的。</li>
<li>然后程序继续执行<code>__init__</code>方法的剩余部分，读取<code>data.csv.gz</code>文件，获取存储图信息的<code>smiles</code>格式的字符串，以及回归预测的目标<code>homolumogap</code>。由<code>smiles</code>格式的字符串转成图的过程在<code>get()</code>方法中实现，这样在生成一个<code>ataLoader</code>变量时，通过指定<code>num_workers</code>可以实现并行执行生成多个图。</li>
</ul>
<h4 id="4-图预测任务实践"><a href="#4-图预测任务实践" class="headerlink" title="4 图预测任务实践"></a>4 图预测任务实践</h4><h5 id="4-1-通过试验寻找最佳超参数"><a href="#4-1-通过试验寻找最佳超参数" class="headerlink" title="4.1 通过试验寻找最佳超参数"></a>4.1 通过试验寻找最佳超参数</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">python main.py  --task_name GINGraphPooling\    # 为当前试验取名</span><br><span class="line">                --device 0\                     </span><br><span class="line">                --num_layers 5\                 # 使用GINConv层数</span><br><span class="line">                --graph_pooling sum\            # 图读出方法</span><br><span class="line">                --emb_dim 256\                  # 节点嵌入维度</span><br><span class="line">                --drop_ratio 0.\</span><br><span class="line">                --save_test\                    # 是否对测试集做预测并保留预测结果</span><br><span class="line">                --batch_size 512\</span><br><span class="line">                --epochs 100\</span><br><span class="line">                --weight_decay 0.00001\</span><br><span class="line">                --early_stop 10\                # 当有early_stop个epoches验证集结果没有提升，则停止训练</span><br><span class="line">                --num_workers 4\</span><br><span class="line">                --dataset_root dataset          # 存放数据集的根目录</span><br></pre></td></tr></table></figure>
<p>这段代码运行后，程序会在<code>saves</code>目录下创建一个<code>task_name</code>参数指定名称的文件夹用于记录试验过程。试验运行过程中，所有的<code>print</code>输出都会写入到试验文件夹下的<code>output</code>文件，<code>tensorboard.SummaryWriter</code>记录的信息也存储在试验文件夹下的文件中。<br>修改上方的命令再执行，即可试验不同的超参数，所有试验的过程与结果信息都存储于<code>saves</code>文件夹下。启动<code>TensorBoard</code>会话，选择<code>saves</code>文件夹，即可查看所有试验的过程与结果信息。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>1.<a href="https://github.com/datawhalechina/team-learning-nlp/tree/master/GNN">datawhale-GNN开源学习资料</a><br>2.<a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/data.html#torch_geometric.data.InMemoryDataset"><code>Dataset</code>类官方文档</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>GNN</tag>
      </tags>
  </entry>
  <entry>
    <title>地理数据分析常用工具</title>
    <url>/2021/04/15/%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>在地理空间数据分析中，常用一些模块进行地理数据分析、特征提取及可视化，包括shapely、geopandas、folium、kepler.gl、geohash等工具。</p>
<h4 id="1-shapely"><a href="#1-shapely" class="headerlink" title="1. shapely"></a>1. shapely</h4><p>shapely是基于笛卡尔坐标的几何对象操作和分析Python库，底层基于GEOS和JTS拓扑运算库。</p>
<h5 id="1-1-Point对象"><a href="#1-1-Point对象" class="headerlink" title="1.1 Point对象"></a>1.1 Point对象</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> shapely.geometry <span class="keyword">import</span> Point</span><br><span class="line"></span><br><span class="line">point1 = Point(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">point2 = Point(<span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">point3 = Point(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#点的可视化</span></span><br><span class="line">geo.GeometryCollection([point1,point2,point3])</span><br><span class="line"></span><br><span class="line"><span class="comment">#Point转为numpy数组</span></span><br><span class="line"><span class="built_in">print</span>(np.array(point))</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h5 id="1-2-LineString对象"><a href="#1-2-LineString对象" class="headerlink" title="1.2 LineString对象"></a>1.2 LineString对象</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建LineString对象</span></span><br><span class="line">line1 = geo.LineString([(<span class="number">0</span>,<span class="number">0</span>),(<span class="number">2</span>,-<span class="number">2.2</span>),(<span class="number">3</span>,<span class="number">3.3</span>),(<span class="number">4</span>,-<span class="number">4.4</span>),(<span class="number">5</span>,-<span class="number">5.5</span>),(<span class="number">6</span>,<span class="number">6.6</span>)])</span><br><span class="line">line1 </span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#点和线的可视化</span></span><br><span class="line">geo.GeometryCollection([line1,Point(<span class="number">1</span>,<span class="number">1</span>)])</span><br><span class="line"></span><br><span class="line"><span class="comment">#计算点线或线线的最短距离</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;点线距离:&#x27;</span>+<span class="built_in">str</span>(Point(<span class="number">1</span>,<span class="number">1</span>).distance(line1)))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#几何中心</span></span><br><span class="line">center = line1.centroid </span><br><span class="line">geo.GeometryCollection([line1,center])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#几何对象的最小外接矩形</span></span><br><span class="line">b_rect = line1.envelope </span><br><span class="line">geo.GeometryCollection([line1,b_rect]) </span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="comment">#简化线(Douglas-Pucker算法)</span></span><br><span class="line">line1_simplify = line1.simplify(<span class="number">0.4</span>, preserve_topology=<span class="literal">False</span>) </span><br><span class="line">line1</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#生成线的缓冲区</span></span><br><span class="line">buffer_with_circle = line1.buffer(<span class="number">0.3</span>)  </span><br><span class="line">geo.GeometryCollection([line1,buffer_with_circle])</span><br></pre></td></tr></table></figure>
<h5 id="1-3-LinearRings对象"><a href="#1-3-LinearRings对象" class="headerlink" title="1.3 LinearRings对象"></a>1.3 LinearRings对象</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> shapely.geometry.polygon <span class="keyword">import</span> LinearRing</span><br><span class="line"></span><br><span class="line">ring = geo.polygon.LinearRing([(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">1</span>, -<span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>)])</span><br><span class="line">geo.GeometryCollection([ring])</span><br></pre></td></tr></table></figure>

<h5 id="1-4-Polygon对象"><a href="#1-4-Polygon对象" class="headerlink" title="1.4 Polygon对象"></a>1.4 Polygon对象</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> shapely.geometry <span class="keyword">import</span> Polygon</span><br><span class="line"></span><br><span class="line">poly1 = Polygon([(<span class="number">0</span>,<span class="number">0</span>),(<span class="number">2</span>,<span class="number">0</span>),(<span class="number">1</span>,-<span class="number">1</span>),(-<span class="number">3</span>,<span class="number">1</span>),(<span class="number">0</span>,<span class="number">0</span>)]) <span class="comment">#起点和终点相同</span></span><br><span class="line">poly1</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#通过numpy生成多边形</span></span><br><span class="line">coords = np.array([(<span class="number">0</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0.1</span>),(<span class="number">2</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">0</span>,<span class="number">0</span>)])</span><br><span class="line">poly2 = Polygon(coords)</span><br><span class="line">poly2 </span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#多个polygon的集合</span></span><br><span class="line">geo.GeometryCollection([poly1,poly2])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#几何中心</span></span><br><span class="line">center = poly1.centroid <span class="comment">#几何中心</span></span><br><span class="line">geo.GeometryCollection([center,poly1]) </span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#最小外接矩形</span></span><br><span class="line">rect = poly1.minimum_rotated_rectangle <span class="comment">#最小外接矩形</span></span><br><span class="line">geo.GeometryCollection([rect,poly1])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">poly1.boundary<span class="comment">#边缘</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">poly2.simplify(<span class="number">0.5</span>)<span class="comment">#简化面</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r1 = poly2.contains(point2) <span class="comment">#面点关系</span></span><br><span class="line"><span class="built_in">print</span>(r1)</span><br><span class="line"></span><br><span class="line">r2 = poly2.intersects(line1) <span class="comment">#面线关系</span></span><br><span class="line"><span class="built_in">print</span>(r2)</span><br><span class="line"></span><br><span class="line">r3 = poly1.intersects(poly2) <span class="comment">#面面关系</span></span><br><span class="line"><span class="built_in">print</span>(r3)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">poly1.intersection(poly2) <span class="comment">#面面交集</span></span><br><span class="line">poly1.union(poly2) 		  <span class="comment">#面面并集</span></span><br><span class="line">poly2.difference(poly1)   <span class="comment">#面面补集</span></span><br></pre></td></tr></table></figure>
<h4 id="2-geopandas"><a href="#2-geopandas" class="headerlink" title="2. geopandas"></a>2. geopandas</h4><p>geopandas是pandas在地理数据处理领域的扩展包，其核心数据结构是GeoSeries和GeoDataFrame。<br>geopandasd 主要功能为:</p>
<blockquote>
<p>1.文件读写<br>2.空间查询<br>3.坐标转换<br>4.空间join<br>5.地理数据可视化</p>
</blockquote>
<h5 id="2-1-文件读写"><a href="#2-1-文件读写" class="headerlink" title="2.1 文件读写"></a>2.1 文件读写</h5><p>geopandas可读geojson和shp等空间文件，也可读含有geometry字段的csv文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line"><span class="keyword">import</span> shapely </span><br><span class="line"><span class="keyword">import</span> geopandas <span class="keyword">as</span> gpd </span><br><span class="line"><span class="keyword">from</span> shapely <span class="keyword">import</span> wkt </span><br><span class="line"><span class="keyword">from</span> shapely <span class="keyword">import</span> geometry <span class="keyword">as</span> geo</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#读取geojson</span></span><br><span class="line">countries = gpd.read_file(<span class="string">&quot;dfcountries.geojson&quot;</span>,bbox = [-<span class="number">180</span>,-<span class="number">80</span>,<span class="number">180</span>,<span class="number">80</span>])</span><br><span class="line">countries.plot()<span class="comment">#显示图</span></span><br><span class="line">countries		<span class="comment">#显示表格</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#读取shp</span></span><br><span class="line">cities = gpd.GeoDataFrame.from_file(<span class="string">&#x27;./cities.shp&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">cities.plot()<span class="comment">#显示图</span></span><br><span class="line">cities		 <span class="comment">#显示表格</span></span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/U1e0d77ed2da2455cb9957e8ed6f59c20a.jpg" alt="f1"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#保存成geojson</span></span><br><span class="line">countries.to_file(<span class="string">&quot;dfcountries.geojson&quot;</span>,driver = <span class="string">&quot;GeoJSON&quot;</span>)</span><br><span class="line"><span class="comment">#保存成csv</span></span><br><span class="line">cities.to_csv(<span class="string">&quot;dfcountries.csv&quot;</span>,index = <span class="literal">False</span>,sep = <span class="string">&quot;\t&quot;</span>)</span><br><span class="line"><span class="comment">#保存成shp</span></span><br><span class="line">cities.to_file(<span class="string">&quot;.a/cities.shp&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#按值的大小填充颜色</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">9</span>,<span class="number">6</span>),dpi = <span class="number">100</span>)</span><br><span class="line">cities.plot(<span class="string">&#x27;area&#x27;</span>,ax = ax,legend = <span class="literal">True</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/U31c06924a773420bb62cc56d2ee9442ft.jpg" alt="f2"></p>
<h4 id="3-Folium"><a href="#3-Folium" class="headerlink" title="3.Folium"></a>3.Folium</h4><p>folium是一种交互式动态地图接口，可以用来画热力图、填充地图、路径图、散点标记等图。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> folium</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment">#指定坐标中心和缩放尺寸，生成交互式地图</span></span><br><span class="line">m = folium.Map(location=[<span class="number">30.33</span>,<span class="number">120.37</span>],zoom_start=<span class="number">10</span>)</span><br><span class="line">m</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/Uc6be8164498d4fda99801e6d30ac676eV.jpg" alt="f3"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> folium.plugins <span class="keyword">import</span> HeatMap</span><br><span class="line"><span class="comment">#生成随机数据，指定坐标中心和缩放尺寸，生成热力图</span></span><br><span class="line">data=(np.random.normal(size=(<span class="number">100</span>,<span class="number">3</span>))*np.array([[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]])+np.array([[<span class="number">30.33</span>,<span class="number">120.37</span>,<span class="number">1</span>]])).tolist()</span><br><span class="line">m=folium.Map([<span class="number">30.33</span>,<span class="number">120.37</span>],tiles=<span class="string">&#x27;Stamen Toner&#x27;</span>,zoom_start=<span class="number">6</span>)</span><br><span class="line">HeatMap(data).add_to(m)</span><br><span class="line">m </span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/U1fe179343a464ab1926cd10582207986X.jpg" alt="f4"></p>
<p>folium的MarkerCluster()聚类函数，可以用来反映一个区域的拥挤程度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> folium.plugins <span class="keyword">import</span> MarkerCluster</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建对象</span></span><br><span class="line">marker_cluster = MarkerCluster().add_to(m)</span><br><span class="line"></span><br><span class="line"><span class="comment">#将经纬度加入聚类</span></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> data:</span><br><span class="line">    folium.Marker(location=[element[<span class="number">0</span>], element[<span class="number">1</span>]],icon=<span class="literal">None</span>).add_to(marker_cluster)</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加至地图</span></span><br><span class="line">m.add_child(marker_cluster)</span><br><span class="line">m</span><br></pre></td></tr></table></figure>

<h4 id="4-Kepler-gl"><a href="#4-Kepler-gl" class="headerlink" title="4.Kepler.gl"></a>4.Kepler.gl</h4><p>Kepler.gl是Uber联合Mapbox推出的地理空间可视化工具，支持3种数据格式：CSV、JSON、GeoJSON。接下来将以杭州市OSM路网为例，制作路径流动动画。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keplergl <span class="keyword">import</span> KeplerGl</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#读取geojson</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./hzroad.json&#x27;</span>,encoding=<span class="string">&#x27;gb18030&#x27;</span>, errors=<span class="string">&#x27;ignore&#x27;</span>) <span class="keyword">as</span> g:</span><br><span class="line">    raw_roads = json.load(g)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#生成虚构时间戳信息和高度0</span></span><br><span class="line">start_time = time.mktime(time.strptime(<span class="string">&#x27;2020-05-29 20:00:00&#x27;</span>, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(raw_roads[<span class="string">&#x27;features&#x27;</span>].__len__()):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(raw_roads[<span class="string">&#x27;features&#x27;</span>][i][<span class="string">&#x27;geometry&#x27;</span>][<span class="string">&#x27;coordinates&#x27;</span>].__len__()):</span><br><span class="line">        <span class="comment"># 更新当前对应的时间戳</span></span><br><span class="line">        shift_time = <span class="built_in">int</span>((j / raw_roads[<span class="string">&#x27;features&#x27;</span>][i][<span class="string">&#x27;geometry&#x27;</span>][<span class="string">&#x27;coordinates&#x27;</span>].__len__())*<span class="number">3600</span>) </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 高度设置为0</span></span><br><span class="line">        raw_roads[<span class="string">&#x27;features&#x27;</span>][i][<span class="string">&#x27;geometry&#x27;</span>][<span class="string">&#x27;coordinates&#x27;</span>][j] \</span><br><span class="line">            .extend([<span class="number">0</span>, </span><br><span class="line">                     <span class="built_in">int</span>(start_time) + shift_time])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keplergl <span class="keyword">import</span> KeplerGl</span><br><span class="line"><span class="comment"># 生成KeplerGl对象</span></span><br><span class="line">m = KeplerGl(height=<span class="number">400</span>, </span><br><span class="line">                data=&#123;<span class="string">&#x27;flow&#x27;</span>: raw_roads&#125;) <span class="comment"># data以图层名为键，对应的矢量数据为值</span></span><br><span class="line">m</span><br><span class="line">m.save_to_html(file_name=<span class="string">&#x27;./hangzhou.html&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="5-Geohash"><a href="#5-Geohash" class="headerlink" title="5.Geohash"></a>5.Geohash</h4><p>GeoHash是一种地址编码方法，可以将地理经纬度坐标编码为由字母和数字所构成的字符串。其原理类似哈希表：由于遍历列表查找时间复杂度高，而创建散列函数能够更高效地定位数据。而GeoHash将二维的经纬度坐标编码到一维的字符串中，在做地理位置索引时只需匹配字符串，便于信息的缓存和压缩。</p>
<p>GeoHash采用二分法不断缩小经度和纬度的区间来进行二进制编码，最后将经纬度分别产生的编码奇偶位交叉合并，再用字母数字表示。</p>
<p><img src="https://ae01.alicdn.com/kf/Uf288553e6d2c43038976764613dd1cc1x.jpg" alt="f6"></p>
<blockquote>
<p>p.s. 酷炫动图见公众号</p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>geopandas</tag>
        <tag>shapely</tag>
        <tag>Kepler.gl</tag>
        <tag>folium</tag>
        <tag>geohash</tag>
      </tags>
  </entry>
  <entry>
    <title>异常检测——基于相似度的方法</title>
    <url>/2021/05/20/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E%E7%9B%B8%E4%BC%BC%E5%BA%A6%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>异常值通常具有更高的离群程度分数值，同时也更具有可解释性。在基于相似度的异常检测方法中，主要思想是异常点的表示与正常点不同。</p>
<h4 id="1-基于距离的度量"><a href="#1-基于距离的度量" class="headerlink" title="1.  基于距离的度量"></a>1.  基于距离的度量</h4><p>基于距离的异常检测有这样一个前提假设，即异常点的k近邻距离要远大于正常点。常见的方法是嵌套循环，第一层循环遍历每个数据，第二层循环进行异常判断计算当前点与其他点的距离，一旦发现多于k个数据点与当前点的距离在D之内，则将该点标记为非异常值。 此法计算的时间复杂度为O(N<sup>2</sup>)，当数据量比较大时需要修剪方法以加快距离计算。</p>
<span id="more"></span>
<h5 id="1-1-基于单元的方法"><a href="#1-1-基于单元的方法" class="headerlink" title="1.1 基于单元的方法"></a>1.1 基于单元的方法</h5><p>在基于单元格的技术中，数据空间被划分为单元格，单元格的宽度是阈值D和数据维数d的函数。<br><img src="https://z3.ax1x.com/2021/05/25/gzuzmn.jpg" alt="xx"><br>L1邻居表示通过最多1个单元间的边界可从该单元到达的单元格的集合，L2邻居表示通过跨越2个或3个边界而获得的那些单元格。<br>以二维数据为例，网格间的距离为D/2√d，其具有以下性质：<br>①单元格中两点之间的距离最多为D/2 。<br>②一个点与L1邻接点之间的距离最大为D。<br>③一个点与它的Lr邻居(其中r&gt;2)中的一个点之间的距离至少为D。</p>
<p>但是L2中并不能直接得出结论，需要另外定义规则，如：<br>①如果一个单元格中包含超过k个数据点及其L1邻居，那么这些数据点都不是异常值。<br>②如果单元A及其相邻L1和L2中包含少于k个数据点，则单元A中的所有点都是异常值。<br>利用第二条规则的修剪能力，对于包含至少一个数据点的每个单元格A，计算其中的点数及其L1和L2邻居的总和。 如果该数字不超过k，则将单元格A中的所有点标记为离群值。</p>
<p>对于此时仍未标记为异常值或非异常值的单元格中的数据点，需要明确计算其k最近邻距离，在L1和L2中不超过k个且距离小于D的数据点，则声明为异常值。</p>
<h5 id="1-2-基于索引的方法"><a href="#1-2-基于索引的方法" class="headerlink" title="1.2 基于索引的方法"></a>1.2 基于索引的方法</h5><p>对于一个给定数据集，基于索引的方法利用多维索引结构(如R树、k-d树)来搜索每个数据对象A在半径范围D内的相邻点。设M是一个异常值在其D-邻域内允许含有对象数的最大值，若发现某个数据对象A的D-邻域内出现M+1甚至更多个相邻点， 则判定对象A不是异常值。该算法时间复杂度在最坏情况下为O(kN<sup>2</sup>)，其中k是数据集维数，N是数据集包含对象的个数。但是构造索引的任务本身也需要密集复杂的计算量。</p>
<h4 id="2-基于密度的度量"><a href="#2-基于密度的度量" class="headerlink" title="2.  基于密度的度量"></a>2.  基于密度的度量</h4><p>基于密度的算法主要有局部离群因子(LocalOutlierFactor，LOF)，以及LOCI、CLOF等基于LOF的改进算法。LOF的关键步骤在于给每个数据点都分配一个离散度，其主要思想是：针对给定的数据集，对其中的任意一个数据点，如果在其局部邻域内的点都很密集，那么认为此数据点为正常数据点；而离群点则是距离正常数据点最近邻的点都比较远的数据点。</p>
<h5 id="2-1-k-距离"><a href="#2-1-k-距离" class="headerlink" title="2.1 k-距离"></a>2.1 k-距离</h5><p>类似k近邻的思路，首先定义一个k-距离，对于数据集D中的给定对象p，对象p与数据集D中任意点o的距离为d(po)。我们把数据集D中与对象p距离最近的k个相邻点的最远距离表示为k-distance(p)，把距离对象p距离第k近的点表示为o<sub>k</sub>，那么给定对象p和点o<sub>k</sub>之间的距离d(p,o<sub>k</sub>)=k-distance(p)，满足：<br>①在集合D中至少有不包括p在内的k个点 o’，其中o’∈D \ {p}，满足d(p,o’)≤d(p,o<sub>k</sub>)<br>②在集合D中最多有不包括p在内的k-1个点o’，其中o’∈D \ {p}，满足d(p,o’)&lt;d(po<sub>k</sub>)<br>直观一些理解，就是以对象p为中心，对数据集D中的所有点到p的距离进行排序，距离对象p第k近的点o<sub>k</sub>与p之间的距离就是k-距离。</p>
<h5 id="2-2-k-邻域"><a href="#2-2-k-邻域" class="headerlink" title="2.2 k-邻域"></a>2.2 k-邻域</h5><p>到对象p的距离小于等于k-距离的所有点的集合就是k-邻域：<br>$$<br>N_{k-dis\tan ce\left(p \right)}\left(p \right) =\left{ q\in D\backslash{q}\left| d\left(p,d \right) \right. \le k-ds\tan ce\left(p \right) \right}<br>$$<br>k-邻域包含对象p的第k距离以内的所有点，包括第k距离点；对象p的第k邻域点的个数丨N<sub>k</sub>(p)≥3丨。<br>在二维平面上展示，对象p的k-邻域是以对象p为圆心、k-距离为半径围成的圆形区域。<br><img src="https://www.hualigs.cn/image/608950de59262%E3%80%82jpg" alt="img"></p>
<h5 id="2-3-可达距离"><a href="#2-3-可达距离" class="headerlink" title="2.3  可达距离"></a>2.3  可达距离</h5><p>按照到对象o的距离远近，将数据集D内的点按照到o 的距离分为两类:<br>①若p<sub>i</sub>在对象o的k-邻域内，则可达距离就是给定点p<sub>i</sub>关于对象o的k-距离；<br>②若p<sub>i</sub>在对象o的k-邻域外，则可达距离就是给定点p<sub>i</sub>关于对象o的实际距离。<br>给定点p<sub>i</sub>关于对象o的可达距离用数学公式可以表示为：<br>$$<br>r e a c h−d i s t_ k (p,o) = max {k−distance(o),d (p,o)}<br>$$<br>这样的分类处理可以简化后续的计算，同时让得到的数值区分度更高。<br><img src="https://www.hualigs.cn/image/608951ddb06ae%E3%80%82jpg" alt="可达距离。jpg"><br>如图所示：<br>①p<sub>1</sub>在对象o的k-邻域内，d(p<sub>1</sub>,o)&lt;k−distance(o)，<br>可达距离reach−dist<sub>k</sub>(p<sub>1</sub>,o)=k−distance(o) ;<br>②p<sub>2</sub>在对象o的k-邻域外，d (p<sub>2</sub>,o)&gt;k−distance(o)，<br>可达距离reach−dist<sub>k</sub>(p<sub>2</sub>,o)= d(p<sub>2</sub>,o) ;</p>
<blockquote>
<p>需要注意的是:为了减少距离的计算开销，对象的k-邻域内的所有对象的k-距离计算量可以被显著降低，相当于使用一个阈值把需要计算的部分“截断”了， 的值越高，无需计算的邻近点越多，计算开销越小。但是另一方面，k的值变高，可能意味着可达距离变远，对集群点和离群点的区分度可能变低。因此，如何选择k值，是LOF算法能否达到效率与效果平衡的重要因素。</p>
</blockquote>
<h5 id="3-4-局部可达密度"><a href="#3-4-局部可达密度" class="headerlink" title="3.4 局部可达密度"></a>3.4 局部可达密度</h5><p>可以将“密度”直观地理解为点的聚集程度，简单来说，点与点之间距离越短，则密度越大。我们使用数据集D中对象p与对象o的k-邻域内所有点的可达距离平均值的倒数来定义局部可达密度。<br>在进行局部可达密度的计算的时候，我们需要避免数据集内所有数据落在同一点上，即所有可达距离之和为0的情况：此时局部密度为∞，后续计算将无法进行。</p>
<p>LOF算法中针对这一问题进行了如下的定义：对于数据集D内的给定对象p，存在至少MinPts(p)≥1个不同于p的点。因此，我们使用对象p到o∈N_{MinPts}(p)的可达距离reach-dist<sub>{MinPts}</sub>(p, o)作为度量对象p邻域的密度的值。点p的局部可达密度计算公式为：<br>$$<br>lrd_{MinPts}(p)=1/(\frac {\sum\limits_{o∈N_{MinPts}(p)} reach-dist_{MinPts}(p,o)} {\left\vert N_{MinPts}(p) \right\vert})<br>$$<br>由公式可看出，这里是对给定点p进行度量，计算其邻域内的所有对象o到给定点p的可达距离平均值。给定点p的局部可达密度越高，越可能与其邻域内的点p属于同一簇；密度越低，越可能是离群点。  </p>
<h5 id="3-5-局部异常因子"><a href="#3-5-局部异常因子" class="headerlink" title="3.5 局部异常因子"></a>3.5 局部异常因子</h5><p>得到lrd(局部可达密度)以后就可以将每个点的lrd将与它们的k个邻点的lrd进行比较，得到局部异常因子LOF。 LOF是对象p的邻居点o(o∈N<sub>MinPts</sub>(p))的lrd平均值与p的lrd的比值。</p>
<p>p的局部可达密度越低，且它的MinPts近邻的平均局部可达密度越高，则p的LOF值越高。如果这个比值越接近1，说明o的邻域点密度差不多，o可能和邻域同属一簇；如果这个比值小于1，说明o的密度高于其邻域点密度，o为密集点；如果这个比值大于1，说明o的密度小于其邻域点密度，o可能是异常点。<br><img src="https://www.hualigs.cn/image/6089531d9e0f7.jpg" alt="局部异常因子公式.png"><br>由上述公式计算出的LOF数值，就是我们所需要的离群点分数。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>1.<a href="https://github.com/datawhalechina/team-learning-data-mining/tree/master/AnomalyDetection">datawhale-异常检测开源学习资料</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>LOF</tag>
      </tags>
  </entry>
  <entry>
    <title>异常检测——基于统计学的方法</title>
    <url>/2021/05/14/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E%E7%BB%9F%E8%AE%A1%E5%AD%A6%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>异常检测的统计方法包含两种主要类型：参数方法和非参数方法。<br><strong>参数方法：</strong>假定数据服从以θ为参数的参数分布，该参数分布的概率密度函数f(x,θ)给出x属于该分布的概率，该值越小，x越可能是异常点。(仅对数据做的统计假定满足实际约束时可行)<br><strong>非参数方法</strong>：不假定先验统计模型，假定参数的个数较为灵活，并非完全无参。</p>
<span id="more"></span>
<h4 id="1-参数方法"><a href="#1-参数方法" class="headerlink" title="1. 参数方法"></a>1. 参数方法</h4><h5 id="1-1-基于正态分布的一元异常点检测"><a href="#1-1-基于正态分布的一元异常点检测" class="headerlink" title="1.1 基于正态分布的一元异常点检测"></a>1.1 基于正态分布的一元异常点检测</h5><p>仅涉及单变量的数据称为一元数据，假定数据由正态分布产生，由输入数据学习正态分布的参数，并把低概率的点识别为异常点。<br>输入数据集<img src="https://ae01.alicdn.com/kf/U0f09d41be5f54bc4892bab4863e0cc3b6.jpg" alt="公式1"> ，根据公式可以求出参数均值μ和方差σ，和概率密度函数p(x)。<br>$$<br>\mu =\frac{1}{n}\sum_{i=1}^n{x_i}<br>$$<br>$$<br>\sigma ^2=\frac{1}{n}\sum_{i=1}^n{\left( x_i-\mu \right)}^2<br>$$<br>$$<br>p\left( x \right) =\frac{1}{\sqrt{2\pi}\sigma}\exp \left( -\frac{\left( x-\mu \right) ^2}{2\sigma ^2} \right)<br>$$<br>在正太分布的假设中，可以为p(x)取值设置阈值来判断异常点。<br>或者简单地用3σ法则来判断，(μ-3σ，μ+3σ)包含99.7%的数据，某数据超出这个范围，可以简单的标记为异常点(Outlier)。</p>
<h5 id="1-2-多元离群点的检测方法"><a href="#1-2-多元离群点的检测方法" class="headerlink" title="1.2 多元离群点的检测方法"></a>1.2 多元离群点的检测方法</h5><p>一元异常点检测的方法可以扩展为多元异常点检测。<br>对于一个n维数据集合<img src="https://ae01.alicdn.com/kf/U22473047196a4af9b6ebca2d9ed966d3A.jpg" alt="公式2">，当各个维度的特征之间相互独立，可以按上述公式计算每个维度的均值和方差。基于正态分布的假设，根据概率<img src="https://ae01.alicdn.com/kf/U98b94844e25b4646a6538fab43facfbc8.jpg" alt="公式3">的大小判断x是否属于异常值。<br>$$<br>p\left(\vec{x} \right) =\prod_{j=1}^n{p\left(x_j;\mu _j;\sigma <em>{j}^{2} \right)}=\prod</em>{j=1}^n{\frac{1}{\sqrt{2\pi}\sigma _j}}\exp \left(-\frac{\left(x_j-\mu <em>j \right) ^2}{2\sigma <em>{j}^{2}} \right)<br>$$<br>当各个维度的特征相关时，需要用到基于多元正太分布来进行异常点检测，首先计算n维的均值向量<br>$$<br>\vec{\mu}=\left( E\left( x_1 \right) ,…,E\left( x_n \right) \right)<br>$$<br>和n×n的协方差矩阵：<br>$$<br>\sum{=\frac{1}{m}}\sum</em>{i=1}^m{\left( \vec{x}-\vec{\mu} \right) \left( \vec{x}-\vec{\mu} \right) ^T}<br>$$<br>如有新数据，可以计算<img src="https://ae01.alicdn.com/kf/U98b94844e25b4646a6538fab43facfbc8.jpg" alt="公式3">,根据概率值大小判断是否属于异常值。<br>$$<br>p\left( \vec{x} \right) =\frac{1}{\left( 2\pi ^{\frac{n}{2}}\left| \sum{} \right|^{</em>{2}^{1}} \right)}\exp \left( -\frac{1}{2}\left( \vec{x}-\vec{\mu} \right) ^T\sum{^{-1}\left( \vec{x}-\vec{\mu} \right)} \right)<br>$$</p>
<h4 id="2-非参数方法"><a href="#2-非参数方法" class="headerlink" title="2. 非参数方法"></a>2. 非参数方法</h4><p>非参数方法是对数据做较少的假定，因而适合多数情况。</p>
<h5 id="2-1-基于角度的方法"><a href="#2-1-基于角度的方法" class="headerlink" title="2.1 基于角度的方法"></a>2.1 基于角度的方法</h5><p>基于角度的方法往往在高维空间里会很有效，其主要思想是：数据边界上的数据很可能将整个数据包围在一个较小的角度内，而内部的数据点则可能以不同的角度围绕着他们。如下图所示，其中点A是一个异常点，点B位于数据内部。<br><img src="https://z3.ax1x.com/2021/05/25/gzJbtA.png" alt="a"><br>如果数据点与其余点离得较远，则潜在角度可能越小。因此，具有较小角度谱的数据点较有可能异常值，而具有较大角度谱的数据点不太可能是异常值。</p>
<h5 id="2-2-基于频数直方图的无监督异常点检测算法-HBOS"><a href="#2-2-基于频数直方图的无监督异常点检测算法-HBOS" class="headerlink" title="2.2 基于频数直方图的无监督异常点检测算法(HBOS)"></a>2.2 基于频数直方图的无监督异常点检测算法(HBOS)</h5><p>HBOS(Histogram-based Outlier Score)是一种单变量方法组合，HBOS在全局异常检测问题上表现良好，但不能检测局部异常值。但是HBOS比标准算法快得多，尤其是在大数据集上。<br>HOBS不能对特征之间的依赖关系进行建模，其基本假设是数据集的每个维度相互独立。然后对每个维度进行区间(bin)划分，对每一个bin进行评分。区间的密度越低，异常评分越高，越可能是异常点。<br>①等宽分桶：标准直方图构建，在值范围内构造k个等宽箱，样本若如每个箱的概率作为密度的估计[时间复杂度O(n)]<br>②动态宽度分桶：对所有值进行排序，将固定数量的N/k个连续值装进一个箱。N是总实例数，k是箱个数，所有箱面积一样，跨度大的箱的高度低，即密度小(例外情况：超过k个数相等，此时允许在同一个箱里超过N/k值)<br>对每个维度都计算一个独立的直方图，其中每个箱子的高度表示密度的估计，对直方图进行归一化处理，最后计算每一个实例的HBOS值。<br>$$<br>HBOS\left( p \right) =\sum_{i=0}^d{\log \left( \frac{1}{hist_i\left( p \right)} \right)}<br>$$<br>详细推导过程：<br>假设样本o的第i个特征概率密度为<img src="https://ae01.alicdn.com/kf/U3264e024f94c45a0bbe5110c82bca661k.jpg" alt="x">，则o的概率密度为：<br>$$<br>P\left( p \right) =P_1\left( p \right) P_2\left( p \right) …P_d\left( p \right)<br>$$<br>两边取对数<br>$$<br>\log \left( P\left( p \right) \right) =\log \left( P_1\left( p \right) P_2\left( p \right) …P_d\left( p \right) \right) =\sum_{i=1}^d{\log \left( P_i\left( p \right) \right)}<br>$$<br>为了达到概率密度越大异常评分越小，两边同乘-1。<br>$$<br>-\log \left( P\left( p \right) \right) =-\sum_{i=1}^d{\log \left( P_i\left( p \right) \right)}=\sum_{i=1}^d{\frac{1}{\log \left( P_i\left( p \right) \right)}}<br>$$<br>最后：<br>$$<br>HOBS\left( p \right) =-\log \left( P\left( p \right) \right) =\sum_{i=1}^d{\frac{1}{\log \left( P_i\left( p \right) \right)}}<br>$$</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>1.<a href="https://github.com/datawhalechina/team-learning-data-mining/tree/master/AnomalyDetection">datawhale-异常检测开源学习资料</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Normal distribution</tag>
        <tag>HBOS</tag>
      </tags>
  </entry>
  <entry>
    <title>异常检测——线性相关方法</title>
    <url>/2021/05/17/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>真实数据集中不同维度的特征可能具有高度相关性，这是因为不同的特征往往是由相同的基础过程以密切相关的方式产生的。这被称为——回归建模，是一种参数化的相关性分析。<br>一类相关性分析通过其他变量预测单独的属性值，另一类方法用一些潜在变量来代表整个数<br>据。前者的代表是<strong>线性回归</strong>，后者一个典型的例子是<strong>主成分分析</strong>。<br>线性相关分析基于的假设是：①近似线性相关假设；②子空间假设。为了确定线性模型是否适合数据集，需要进行探索性和可视化分析。</p>
<span id="more"></span>
<h4 id="0-探索性和可视化分析"><a href="#0-探索性和可视化分析" class="headerlink" title="0. 探索性和可视化分析"></a>0. 探索性和可视化分析</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_data.describe()</span><br><span class="line">train_data.info()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#相关性分析</span></span><br><span class="line">numeric_features = [<span class="string">&#x27;f&#x27;</span>+<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>)]</span><br><span class="line">numeric = train_data[numeric_features]</span><br><span class="line">correlation.numeric.corr()</span><br><span class="line"></span><br><span class="line">f,ax = plt.subplots(figsize=(<span class="number">15</span>,<span class="number">15</span>))</span><br><span class="line">sns.heatmap(correlation,square=<span class="literal">True</span>)</span><br><span class="line">plt.tile(<span class="string">&#x27;Correlation of Numeric features&#x27;</span>,y=<span class="number">1</span>,size=<span class="number">16</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://z3.ax1x.com/2021/05/25/gzuhyd.jpg" alt="xx"></p>
<h4 id="1-线性回归"><a href="#1-线性回归" class="headerlink" title="1. 线性回归"></a>1. 线性回归</h4><p>线性回归：假设不同维度的变量具有一定的相关性，并可以通过一个相关系数矩阵进行衡量。<br>在线性回归中，异常值是根据自变量对因变量的影响来定义的，自变量之间相互关系中的异常则不那么重要。(此处的异常点检测是基于数据点的整体分布)</p>
<h5 id="1-1-最小二乘法"><a href="#1-1-最小二乘法" class="headerlink" title="1.1 最小二乘法"></a>1.1 最小二乘法</h5><p>基于最小二乘拟合的线性回归可以如下定义：带标签数据集<br>$$<br>D=\left{ \left( x_1,y_1 \right) ,…,\left( x_m,y_m \right) \right}<br>$$<br>m个样本的特征组成矩阵X；m个样本的标签组成标签向量<br>$$<br>y=\left( y_1,…,y_m \right) ^T<br>$$<br>目的是求出θ，使得目标函数J(θ)最小。<br>$$<br>J\left( \theta \right) =\lVert \left. X\theta -y \rVert <em>{2}^{2} \right.<br>$$<br>为什么目标函数J(θ)是残差向量的2-范数的平方？可以这样解释：<br>某个样本(x<sub>i</sub>,y<sub>i</sub>)在θ确定情况下满足：<br>$$<br>y_i=\theta ^Tx_i+\epsilon <em>i<br>$$<br>ϵi为误差项，可以看作独立同分布的随机变量，且服从高斯分布。可以以计算yi的概率密度函数：<br>$$<br>L\left( \theta \right) =p\left( y_i\left| x_i;\theta \right. \right) =\frac{1}{\sqrt{2\pi}\sigma}\exp \left( -\frac{\left( y_i-\theta ^Tx_i \right) ^2}{2\sigma ^2} \right)<br>$$<br>要使J(θ)最小，就要使使L(θ)最大，可使用最大似然估计法。<br>$$<br>L\left( \theta \right) =\log \prod</em>{i=1}^m{\frac{1}{\sqrt{2\pi}\sigma}\exp \left( -\frac{\left( y_i-\theta ^Tx_i \right) ^2}{2\sigma ^2} \right)}=m\log \frac{1}{\sqrt{2\pi}\sigma}-\frac{1}{\sigma ^2}·\frac{1}{2}\sum</em>{i-=1}^m{\left( y_i-\theta ^Tx_i \right)}^2<br>$$<br>通常做法是对似然函数求导，使导数为0。上述也证明了要让L(θ)最大就是要让J(θ)最小。<br>$$<br>\sum_{i-=1}^m{\left( y_i-\theta ^Tx_i \right)}^2=\lVert \left. X\theta -y \rVert \right. _{2}^{2}<br>$$<br>说回最小二乘，目的是求出最优点θ使J(θ)最小。<br>设残差向量r=Xθ−y，在二维空间中讨论，Xθ为一条直线，y为一个向量，存在最优点θ<sup>✲</sup>使得J(θ)最小，这个θ<sup>✲</sup>是最小二乘解集合中的一个元素，如图所示：<br><img src="https://z3.ax1x.com/2021/05/25/gzufQH.png" alt="xx"><br>由图看出这个θ<sup>✲</sup>是r垂直于Xθ时取到。由定义，Xθ是矩阵X的列空间C(X)，与C(X)垂直的是矩阵X的左零空间N(X<sup>T</sup>)，由左零空间定义：<br>$$<br>X^Tr=0<br>$$<br>把r=Xθ−y带入，得到：<br>$$<br>X^T\left( X\theta -y \right) =0<br>$$<br>整理得最优参数θ为：<br>$$<br>\theta =\left( X^T·X \right) ^{-1}·\left( X^T·y \right)<br>$$<br>个人觉得J(θ)也可以认为是某种异常得分。</p>
<h5 id="1-2-梯度下降"><a href="#1-2-梯度下降" class="headerlink" title="1.2 梯度下降"></a>1.2 梯度下降</h5><p>线性回归的优化目标是损失函数，就需要一种优化算法。<br>线性回归中的常用损失函数是均方误差MSE，表达式为：<br>$$<br>L\left( w,b \right) =\frac{1}{2}\left( \hat{y}^{\left( i \right)}-y^{\left( i \right)} \right) ^2 = \frac{1}{n}\sum_{i=1}^n{l^{\left( i \right)}}\left( w,b \right) =\frac{1}{n}\sum_{i=1}{\frac{1}{2}\left( W^Tx^{\left( i \right)}+b-y^{\left( i \right)} \right)}^2<br>$$<br>当模型和损失函数形式较为简单时，面的误差最小化问题的解可以直接用公式表达出来。然而，大多数深度学习模型并没有解析解，只能通过优化算法有限次迭代模型参数来尽可能降低损失函数的值。<br>在求数值解的优化算法中，小批量随机梯度下降（mini-batch stochastic gradient descent）被广泛使用。他的算法是：先选取一组模型参数的初始值，如随机选取；接下来对参数进行多次迭代，使每次迭代都可能降低损失函数的值。在每次迭代中，先随机均匀采样一个由固定数目训练数据样本所组成的小批量（mini-batch），然后求小批量中数据样本的平均损失和有关模型参数的导数（梯度），最后用此结果与预先设定的学习率的乘积作为模型参数在本次迭代的减小量。如下式所示：<br>$$<br>\left( w,b \right) \gets \left( w,b \right) -\frac{\eta}{\left| \left. \mathbb{B} \right| \right.}\sum_{i\in \mathbb{B}}{\partial _{\left( w,b \right)}}l^{\left( i \right)}\left( w,b \right)<br>$$<br>B表示批量大小batch size；η表示学习率，代表每次学习的步长大小。</p>
<h4 id="2-主成分分析"><a href="#2-主成分分析" class="headerlink" title="2. 主成分分析"></a>2. 主成分分析</h4><p>最小二乘法试图找到一个与数据具有最佳匹配(d-1)维超平面；主成分分析方法可用于解决这一问题的广义版本，它可以找到任意k(k&lt;d)维的最优表示超平面，从而使平方投<br>影误差最小化。</p>
<h5 id="2-1-原理"><a href="#2-1-原理" class="headerlink" title="2.1 原理"></a>2.1 原理</h5><p>对于d维，包含N个样本的数据，用R<sub>i</sub>表示其中第i行[x<sub>i1</sub>,…x<sub>id</sub>]，可得到d×d的协方差矩阵：<br>$$<br>\sum{=\left( R-\bar{R} \right)}^T·\left( R-\bar{R} \right)<br>$$<br>∑是对称并且半正定的，因此可以进行相似对角化：<br>$$<br>\sum{=P·D·P^T}<br>$$<br>这里的D为对角矩阵，对角元素为特征值。P为标准正交矩阵，每一行为对应的特征向量；这些标准正交向量提供了数据应该投影的轴线方向。<br>将样本的协方差矩阵特征值分解以后，特征值就是样本投影到这个轴上后对应的方差，特征值越小，说明投影以后在这个轴上样本点分布集中，而异常点在这种情况下更容易偏移，利用这一点可以作为衡量样本异常的一个指标。在PCA做降维的时候，起作用的是大的特征值对应的特征向量，而在异常检测中，起作用的是特征值小的对应的特征向量。根据以上思想，我们可以定义PCA中一个点x的异常评分：<br>$$<br>Score\left( x \right) =\sum_{i=1}^d{\frac{\left| \left. x^Te_i \right| \right.}{\lambda _i}}<br>$$<br>其中，e<sub>i</sub>为第i个特征向量，λ为沿该方向的方差(也是特征值)，可以看出对异常得分的大部分贡献是由λ值较小的主成分的提供的。</p>
<h5 id="2-2-PyOD实例"><a href="#2-2-PyOD实例" class="headerlink" title="2.2 PyOD实例"></a>2.2 PyOD实例</h5><p>测试PCA和HBOS的性能对比。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> pyod.models.pca <span class="keyword">import</span> PCA</span><br><span class="line"><span class="keyword">from</span> pyod.models.hbos <span class="keyword">import</span> HBOS</span><br><span class="line"><span class="keyword">from</span> pyod.utils.data <span class="keyword">import</span> evaluate_print</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    data = pd.read_csv(<span class="string">&#x27;dataverse_files/breast-cancer-unsupervised-ad.csv&#x27;</span>, header=<span class="literal">None</span>)</span><br><span class="line">    data_x=data[[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>)]].values <span class="comment">#特征</span></span><br><span class="line">    data_y=data[<span class="number">30</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="number">1</span> <span class="keyword">if</span> x==<span class="string">&#x27;o&#x27;</span> <span class="keyword">else</span> <span class="number">0</span>).values <span class="comment">#标签</span></span><br><span class="line">    X_train, X_test, y_train, y_test = train_test_split(data_x, data_y, test_size=<span class="number">0.3</span>,stratify=data_y)<span class="comment">#使用分层抽样，构建训练集和测试集</span></span><br><span class="line">    train_number=X_train.shape[<span class="number">0</span>]<span class="comment">#训练集样本的个数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">#PCA方法</span></span><br><span class="line">    clf1 = PCA(n_components=<span class="number">15</span>)</span><br><span class="line">    clf1.fit(X_train)</span><br><span class="line">    y_train_scores_clf1 = clf1.decision_scores_</span><br><span class="line">    y_test_scores_clf1 = clf1.decision_function(X_test)</span><br><span class="line"></span><br><span class="line">	<span class="comment">#HBOS方法</span></span><br><span class="line">    clf2 = HBOS(n_bins=(<span class="built_in">int</span>)(np.sqrt(train_number)))</span><br><span class="line">    clf2.fit(X_train)</span><br><span class="line">    y_train_scores_clf2 = clf2.decision_scores_</span><br><span class="line">    y_test_scores_clf2 = clf2.decision_function(X_test)</span><br><span class="line"></span><br><span class="line">	<span class="comment">#结果对比</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Training Data:&quot;</span>)</span><br><span class="line">    evaluate_print(<span class="string">&#x27;PCA&#x27;</span>, y_train, y_train_scores_clf1)</span><br><span class="line">    evaluate_print(<span class="string">&#x27;HBOS&#x27;</span>, y_train, y_train_scores_clf2)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Test Data:&quot;</span>)</span><br><span class="line">    evaluate_print(<span class="string">&#x27;PCA&#x27;</span>, y_test, y_test_scores_clf1)</span><br><span class="line">    evaluate_print(<span class="string">&#x27;HBOS&#x27;</span>, y_test, y_test_scores_clf2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果发现，PCA的性能优于HBOS。</p>
<blockquote>
<p>局限性:<br>1.回归分析作为检测离群值的工具有一些局限性：为了使回归分析技术有效，数据需要高度相关，并沿着低维子空间对齐。当数据不相关，但在某些区域高度聚集时，这种方法可能不会有效。<br>2.数据中的相关性在本质上可能不是全局性的。子空间相关性可能是特定于数<br>据的特定位置的。在这种情况下，由主成分分析发现的全局子空间对于异常检测是次优的。因此，为了创建更一般的局部子空间模型，有时将线性模型与邻近模型结合起来是有用的。</p>
</blockquote>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>1.<a href="https://github.com/datawhalechina/team-learning-data-mining/tree/master/AnomalyDetection">datawhale-异常检测开源学习资料</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>OLSE</tag>
        <tag>Linear Regression</tag>
        <tag>Gradient descent</tag>
        <tag>PCA</tag>
        <tag>PyOD</tag>
      </tags>
  </entry>
  <entry>
    <title>异常检测——集成方法</title>
    <url>/2021/05/23/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E2%80%94%E2%80%94%E9%9B%86%E6%88%90%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>一般情况下，可以把异常检测看成是数据不平衡下的分类问题，如果数据条件允许，优先使用有监督异常检测如XGBOOST；仅有少量标签时，可以用无监督学习作为一种特征抽取方式，最后喂给有监督的分类模型。<br>之前介绍的统计与概率模型、线性模型、基于相似度的模型，和今天要介绍的集成学习都是无监督模型。</p>
</blockquote>
<p>为什么要使用集成学习？——①适合高维度数据(空间稀疏)，②提高模型鲁棒性。<br>值得注意的时，异常检测没有标签，所以feature bagging、bagging比boosting多。而使用boosting进行异常检测，需要生成伪标签。</p>
<span id="more"></span>
<h4 id="1-Feature-Bagging"><a href="#1-Feature-Bagging" class="headerlink" title="1. Feature Bagging"></a>1. Feature Bagging</h4><p>Feature Bagging，基本思想与bagging相似，只是对象是feature。<br>基本检测器可以彼此完全不同，或不同的参数设置，或使用不同采样的子数据集。Feature bagging常用lof算法为基算法。</p>
<h5 id="1-1-算法原理"><a href="#1-1-算法原理" class="headerlink" title="1.1 算法原理"></a>1.1 算法原理</h5><p><img src="https://z3.ax1x.com/2021/05/25/gzMCDA.png" alt="x"></p>
<h5 id="1-2-不同检测器的分数标准化"><a href="#1-2-不同检测器的分数标准化" class="headerlink" title="1.2 不同检测器的分数标准化"></a>1.2 不同检测器的分数标准化</h5><p>不同检测器可能会在不同的尺度上产生分数。例如，平均k近邻检测器会输出原始距离分数，而LOF算法会输出归一化值。另外，检测器输出的异常值分数大小不一，因此需要归一化，常见方法包括平均和最大化组合函数。<br>以累积求和法和广度优先法为例，简单介绍下：<br>①累积求和：针对每组样本，分别累加对应的全部基本检测器的结果；共输出T组求和结果。<br>②广度优先：枚举每一种基本检测器(共m种)，再嵌套枚举每一组异常值输出（共T种），每种异常检测算法分别检测T组样本数据，共有m*T种组合，按照广度优先搜索，先到先占位，重复数据取后来的异常值的最大值、平均值等。</p>
<h5 id="1-3-Feature-Bagging的缺陷"><a href="#1-3-Feature-Bagging的缺陷" class="headerlink" title="1.3 Feature Bagging的缺陷"></a>1.3 Feature Bagging的缺陷</h5><p>①bagging有放回抽样，会损失部分特征的信息，或者特征始终无法被采样也无法被模型训练到。因此使用bagging实际上需要处理偏差和方差之间的一种微妙的均衡。<br>②bagging的比例通常在0.5到0.99之间，如果存在过多的相关性特征，会导致泛化能力下降。所以进行异常检测之前，必须进行严格的相关性分析或者主成分分析。</p>
<h4 id="2-Isolation-Forest"><a href="#2-Isolation-Forest" class="headerlink" title="2. Isolation Forest"></a>2. Isolation Forest</h4><p>周志华老师在2008年提出的算法，在工业界应用广泛，其不需要定义数学模型也不需要训练数据有标签。<br>这种算法在全局和局部都通过采样引入了随机性，往往要比单纯的feature bagging的效果更好。</p>
<h5 id="2-1-关于异常的定义"><a href="#2-1-关于异常的定义" class="headerlink" title="2.1 关于异常的定义"></a>2.1 关于异常的定义</h5><p>使用孤立森林(Isolation Forests)的前提是，将异常点定义为那些 <em>“容易被孤立的离群点”</em> —— 可以理解为分布稀疏，且距离高密度群体较远的点。即默认①异常数据占总样本量的比例很小，②异常点的特征值与正常点的差异很大。</p>
<h5 id="2-2-查找孤立点的策略"><a href="#2-2-查找孤立点的策略" class="headerlink" title="2.2 查找孤立点的策略"></a>2.2 查找孤立点的策略</h5><p>用一个随机超平面来切割数据空间，切一次可以生成两个子空间。继续用随机超平面来切割每个子空间并循环，直到每个子空间只有一个数据点为止。<br>以二维空间作为演示，点B’跟其他数据点比较疏离，只需要很少的几次操作就可以将它细分出来；点A’需要的切分次数会更多一些。<br><img src="https://z3.ax1x.com/2021/05/25/gzK31e.png" alt="xx"></p>
<h5 id="2-3-树的构造方法"><a href="#2-3-树的构造方法" class="headerlink" title="2.3 树的构造方法"></a>2.3 树的构造方法</h5><p><strong>训练：</strong>构建一棵 iTree 时，先从全量数据中抽取一批样本，然后随机选择一个特征作为起始节点，并在该特征的最大值和最小值之间随机选择一个值，将样本中小于该取值的数据划到左分支，大于等于该取值的划到右分支。然后，在左右两个分支数据中，重复上述步骤，直到满足如下条件：①数据不可再分，即：只包含一条数据，或者全部数据相同。②二叉树达到限定的最大深度。</p>
<p><strong>预测：</strong>计算数据 x 的异常分值时，先要估算它在每棵 iTree 中的路径深度。先沿着一棵 iTree，从根节点开始按不同特征的取值从上往下，直到到达某叶子节点。假设 iTree 的训练样本中同样落在 x 所在叶子节点的样本数为 T.size，则数据 x 在这棵 iTree 上的路径深度 h(x)，可以用下面这个公式计算：<br>$$<br>h\left( x \right) =e+C\left( T.size \right)<br>$$<br>式中，e 表示数据 x 从 iTree 的根节点到叶节点过程中经过的边的数目，C(T.size) 可以认为是一个修正值，它表示在一棵用 T.size 条样本数据构建的二叉树的平均路径长度。C(n) 的计算公式如下：<br>$$<br>C\left( n \right) =2H\left( n-1 \right) -\frac{2\left( n-1 \right)}{n}<br>$$<br>其中，H(n-1) 可用 ln(n-1)+0.5772156649(欧拉常数)估算。数据 x 最终的异常分值 Score(x) 综合了多棵 iTree 的结果：<br>$$<br>Score\left( x \right) =2^{-\frac{E\left( h\left( x \right) \right)}{C\left( \varPsi \right)}}<br>$$<br>公式中，E(h(x)) 表示数据 x 在多棵 iTree 的路径长度的均值，ψ表示单棵 iTree 的训练样本的样本数，C(ψ)表示用ψ条数据构建的二叉树的平均路径长度，它在这里主要用来做归一化。</p>
<p>从异常分值的公式看，如果数据 x 在多棵 iTree 中的平均路径长度越短，得分越接近 1，表明数据 x 越异常；如果数据 x 在多棵 iTree 中的平均路径长度越长，得分越接近 0，表示数据 x 越正常；如果数据 x 在多棵 iTree 中的平均路径长度接近整体均值，则打分会在 0.5 附近。</p>
<blockquote>
<p>在实际情况中，不同模型在不同的数据集上表现不一。但是总体而言KNN等基于位置和距离度量的算法原理不太复杂，表现也较为稳定。<br>唯一的缺点是，KNN等基于距离度量模型受到数据维度的影响较大，当维度比较低时表现很好。如果异常特征隐藏在少数维度上时，KNN和LOF类的效果就不会太好，此时该选择Isolation Forest(适合高维空间)。</p>
</blockquote>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>1.<a href="https://github.com/datawhalechina/team-learning-data-mining/tree/master/AnomalyDetection">datawhale-异常检测开源学习资料</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Feature Bagging</tag>
        <tag>Isolation Forest</tag>
      </tags>
  </entry>
  <entry>
    <title>李宏毅机器学习——反向传播</title>
    <url>/2021/07/18/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/</url>
    <content><![CDATA[<h3 id="李宏毅机器学习——反向传播"><a href="#李宏毅机器学习——反向传播" class="headerlink" title="李宏毅机器学习——反向传播"></a>李宏毅机器学习——反向传播</h3><h4 id="1-反向传播原理"><a href="#1-反向传播原理" class="headerlink" title="1 反向传播原理"></a>1 反向传播原理</h4><p>神经网络中求解权重W的算法，分为信号的前向传播（Forward propagation，FP）和反向传播（Back propagation，BP）。前向传播得到预测值，计算输出误差，然后计算每个神经元节点对误差的贡献；反向传播根据前向传播的误差来求梯度，然后根据贡献调整原来的权重，最终达到最小化损失函数的目的。<br><a href="https://imgtu.com/i/W2hxoV"><img src="https://z3.ax1x.com/2021/07/25/W2hxoV.png" alt="W2hxoV.png"></a></p>
<span id="more"></span>

<p>假设只有一个隐含层，设L为损失函数。<br>在输出层上的误差（这里$O_{k}$就是输出值$y_{out}$。）：<br>$$<br>L_{total}=\frac{1}{2}(d-O)^{2}=\frac{1}{2} \sum_{k=1}^{\ell}\left(d_{k}-O_{k}\right)^{2}<br>$$</p>
<p>在隐含层上的误差（这里$net_{k}=\sum(w_i*O_{k})+b$。）：<br>$$<br>L_{total}=\frac{1}{2} \sum_{k=1}^{c}(d_{k}-f[\sum_{j=0}^{m} w_{j k} f(n e t_{j})])^{2}=\frac{1}{2} \sum_{k=1}^{c}(d_{k}-f[\sum_{j=0}^{m} w_{j k} f(\sum_{i=1}^{n} v_{i j} x_{i}))^{2}<br>$$</p>
<p>在输入层上的误差：<br>$$<br>L_{total}=\frac{1}{2} \sum_{k=1}^{c}\left(d_{k}-f\left[\sum_{j=0}^{m} w_{j k} f\left(n e t_{j}\right)\right]\right)^{2}=\frac{1}{2} \sum_{k=1}^{c}\left(d_{k}-f\left[\sum_{j=0}^{m} w_{j k} f\left(\sum_{i=1}^{n} v_{i j} x_{i}\right)\right]\right)^{2}<br>$$</p>
<p>用误差L对每一个权重$w$求偏导（链式法则），就是代表该权重$w$对总体误差产生了多少影响。<br>$$<br>w_{i}^{+}=w_{i}-\eta * \frac{\partial L_{\text {total }}}{\partial w_{i}}<br>$$<br>用同样的方法更新所有权重$w$，最后不停地迭代使误差降低。</p>
<h4 id="2-numpy实现反向传播"><a href="#2-numpy实现反向传播" class="headerlink" title="2 numpy实现反向传播"></a>2 numpy实现反向传播</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scaling</span>(<span class="params">data</span>):</span>	<span class="comment">#数据归一化</span></span><br><span class="line">    <span class="built_in">max</span> = np.<span class="built_in">max</span>(data,<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">min</span> = np.<span class="built_in">min</span>(data,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> (data-<span class="built_in">min</span>)/(<span class="built_in">max</span>-<span class="built_in">min</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span>(<span class="params">data</span>):</span>	<span class="comment">#激活函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span>+np.exp(-data))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wb_calc</span>(<span class="params">X,y,alpha=<span class="number">0.1</span>,maxIter=<span class="number">10000</span>,n_hidden_dim=<span class="number">3</span>,reg_lamda=<span class="number">0</span></span>):</span></span><br><span class="line">	<span class="comment">#FP</span></span><br><span class="line">	<span class="comment">#初始化</span></span><br><span class="line">    W1 = np.mat(np.random.randn(<span class="number">2</span>,n_hidden_dim))</span><br><span class="line">    b1 = np.mat(np.random.randn(<span class="number">1</span>,n_hidden_dim))</span><br><span class="line">    W2 = np.mat(np.random.randn(n_hidden_dim,<span class="number">1</span>))</span><br><span class="line">    b2 = np.mat(np.random.randn(<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> stepi <span class="keyword">in</span> <span class="built_in">range</span>(maxIter):</span><br><span class="line">        z1 = x*W1 + b1</span><br><span class="line">        a1 = sigmoid(z1)</span><br><span class="line">        z2 = a1*W2 + b2</span><br><span class="line">        a2 = sigmoid(z2)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#BP</span></span><br><span class="line">    	<span class="comment">#初始化</span></span><br><span class="line">        a0 = X.copy()</span><br><span class="line">		deltal2 = a2 - ymat</span><br><span class="line">        deltal1 = np.mat((deltal2*W2.T).A * a1.A(<span class="number">1</span>-a1).A)	<span class="comment">#.A表示转化为数组</span></span><br><span class="line">    	dW1 = a0.T+deltal1 + reg_lambda*W1</span><br><span class="line">        db1 = np.<span class="built_in">sum</span>(deltal1,<span class="number">0</span>)</span><br><span class="line">        dW2 = a1.T+deltal2 + reg_lambda*W2</span><br><span class="line">        db2 = np.<span class="built_in">sum</span>(deltal2,<span class="number">0</span>)</span><br><span class="line">        <span class="comment">#更新w,b</span></span><br><span class="line">        W1 = W1 - alpha*dW1</span><br><span class="line">        b1 = b1 - alpha*db1</span><br><span class="line">        W2 = W2 - alpha*dW2</span><br><span class="line">        b2 = b2 - alpha*db2</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> W1,b1,W2,b2</span><br></pre></td></tr></table></figure>


<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>1.<a href="https://www.bilibili.com/video/av59538266">b站李宏毅《机器学习》</a><br>2.<a href="https://datawhalechina.github.io/leeml-notes/#/">datawhale李宏毅机器学习笔记(LeeML-Notes)</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Back Propagation</tag>
      </tags>
  </entry>
  <entry>
    <title>异常检测(Anomaly Detection)简介</title>
    <url>/2021/05/12/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>异常检测顾名思义就是检测出与正常数据不同的数据，检测给定的新数据是否属于这组数据集。</p>
<h4 id="1-异常检测的任务类型"><a href="#1-异常检测的任务类型" class="headerlink" title="1. 异常检测的任务类型"></a>1. 异常检测的任务类型</h4><p><strong>无监督</strong>：训练集无标签<br><strong>有监督</strong>：训练集的正例和反例均有标签<br><strong>半监督</strong>：在训练集中只有正例，异常实例不参与训练</p>
<span id="more"></span>
<h4 id="2-异常检测的难点"><a href="#2-异常检测的难点" class="headerlink" title="2. 异常检测的难点"></a>2. 异常检测的难点</h4><p><strong>数据量少</strong>：异常检测任务通常情况下负样本（abnormal）较少，0、1两类样本严重不均衡，有时候依赖于人工标签。<br><strong>噪音</strong>：异常和噪音有时容易混淆，如两幅图中的A点识别难度就不一样。<br><img src="https://z3.ax1x.com/2021/05/25/gzuSPO.png" alt="xx"></p>
<h4 id="3-异常检测方法简介"><a href="#3-异常检测方法简介" class="headerlink" title="3. 异常检测方法简介"></a>3. 异常检测方法简介</h4><h5 id="3-1-基于统计学的方法"><a href="#3-1-基于统计学的方法" class="headerlink" title="3.1 基于统计学的方法"></a>3.1 基于统计学的方法</h5><p>通常做法是假设样本服从高斯分布，计算p(x)=ϵ作为判定正常和异常的阈值。<br><img src="https://z3.ax1x.com/2021/05/25/gzu9Re.png" alt="xx"></p>
<h5 id="3-2-线性模型"><a href="#3-2-线性模型" class="headerlink" title="3.2 线性模型"></a>3.2 线性模型</h5><p>在线性模型中，有2个假设：<br>①不同维度的变量近似线性相关，可以通过一个相关系数矩阵进行衡量。<br>②数据是镶嵌在低维子空间中的，线性建模是为了找到某个低维子空间使异常点区别于正常点。<br>常用模型的包括：<br><strong>最小二乘法</strong>——最小化目标函数得到直线方程,计算每个变量与回归方程之间的残差,可通过3σ 法则判断异常值.<br><strong>PCA</strong>——将样本的协方差矩阵特征值分解后，特征值是样本投影到轴上对应的方差，特征值越小，投影后样本点分布越集中，异常点容易偏离，以此作为判定异常值的一个指标。</p>
<h5 id="3-3-基于邻近度的方法"><a href="#3-3-基于邻近度的方法" class="headerlink" title="3.3 基于邻近度的方法"></a>3.3 基于邻近度的方法</h5><p>这类算法适用于数据点的聚集程度高、离群点较少的情况，不适用于数据量大、维度高的数据。<br>①基于集群（簇）的检测——DBSCAN，核心点距离ℇ内最小包含点数、距离ℇ与阈值比较。<br>②基于距离的度量——KNN，将K-近邻距离与阈值比较。<br>③基于密度的度量——LOF(局部离群因子)，邻域点密度与阈值比较。<br><img src="https://z3.ax1x.com/2021/05/25/gzupGD.png" alt="xx"></p>
<h5 id="3-4-集成方法"><a href="#3-4-集成方法" class="headerlink" title="3.4 集成方法"></a>3.4 集成方法</h5><p>①<strong>孤立森林（Isolation Forest）</strong>——不停地使用随机超平面分隔每个子空间，直到每个子空间只有一个数据点为止，低密度的点被单独分配到一个子空间，孤立数低于阈值时，定义为异常值。<br><img src="https://z3.ax1x.com/2021/05/25/gznxIK.png" alt="xx"><br>②树模型——通过树不断划分子空间,数据点在多个树上的平均深度越浅,越可能为异常值。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>1.<a href="https://github.com/datawhalechina/team-learning-data-mining/tree/master/AnomalyDetection">datawhale-异常检测开源学习资料</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>LOF</tag>
        <tag>OLSE</tag>
        <tag>Isolation Forest</tag>
        <tag>PCV</tag>
        <tag>KNN</tag>
        <tag>DBSCAN</tag>
      </tags>
  </entry>
  <entry>
    <title>李宏毅机器学习——机器学习介绍</title>
    <url>/2021/07/12/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="李宏毅机器学习——机器学习介绍"><a href="#李宏毅机器学习——机器学习介绍" class="headerlink" title="李宏毅机器学习——机器学习介绍"></a>李宏毅机器学习——机器学习介绍</h3><h4 id="1-机器学习简介"><a href="#1-机器学习简介" class="headerlink" title="1. 机器学习简介"></a>1. 机器学习简介</h4><p>机器学习是人工智能的一部分, 研究如何让计算机从数据学习某种规律。机器学习的目的是通过计算机程序根据数据去优化某一个评价指标，自动的从数据发现规律, 使用这些规律做出预测。<br><a href="https://imgtu.com/i/W2huKs"><img src="https://z3.ax1x.com/2021/07/25/W2huKs.png" alt="W2huKs.png"></a><br>如图，机器学习可以简化为三个步骤，一、找一个function，二、让machine评价这个function，三、让machine自动地挑出最好的function。</p>
<h4 id="2-机器学习分类"><a href="#2-机器学习分类" class="headerlink" title="2. 机器学习分类"></a>2. 机器学习分类</h4><p><a href="https://imgtu.com/i/W2hlV0"><img src="https://z3.ax1x.com/2021/07/25/W2hlV0.png" alt="W2hlV0.png"></a><br>机器学习可大致分为监督学习、无监督学习、半监督学习、迁移学习和强化学习。</p>
<h5 id="2-1-监督学习"><a href="#2-1-监督学习" class="headerlink" title="2.1 监督学习"></a>2.1 监督学习</h5><p>监督学习是机器学习任务的一种。它从有标签的训练数据中推导出预测函数。有标签的训练数据是指每个训练实例都包括输入和期望的输出。简单来说就是给定数据，预测标签。<br>监督学习包括<code>分类</code>和<code>回归</code>。</p>
<span id="more"></span>

<h5 id="2-2-无监督学习"><a href="#2-2-无监督学习" class="headerlink" title="2.2 无监督学习"></a>2.2 无监督学习</h5><p>无监督学习是机器学习任务的一种。它从无标签的训练数据中推断结论。它可以在探索性数据分析阶段用于发现隐藏的模式或者对数据进行分组。简单来说就是给定数据，寻找隐藏的结构。<br>无监督学习包括<code>聚类</code>和<code>降维</code>。</p>
<h5 id="2-3-半监督学习"><a href="#2-3-半监督学习" class="headerlink" title="2.3 半监督学习"></a>2.3 半监督学习</h5><p>半监督学习介于监督学习与无监督学习之间。半监督学习的任务与监督学习一致，任务中包含有明确的目标，如分类。但其所采用的数据既包括有标签的数据，也包括无标签的数据。简单来说，半监督学习是同时运用了标签数据和无标签数据来进行训练的监督学习。</p>
<h5 id="2-5-迁移学习"><a href="#2-5-迁移学习" class="headerlink" title="2.5 迁移学习"></a>2.5 迁移学习</h5><p>迁移学习是把已训练好的或者模型（预训练模型）参数或者标注数据迁移到新的模型来帮助新模型训练。其中需要关注的是源领域与目标领域之间相关性。</p>
<h5 id="2-6-强化学习"><a href="#2-6-强化学习" class="headerlink" title="2.6 强化学习"></a>2.6 强化学习</h5><p>强化学习是机器学习的另一个领域。它关注的是软件代理如何在一个环境中采取行动以便最大化某种累积的回报。简单来说就是给定数据，学习如何选择一系列行动，以最大化长期收益。<br>强化学习包括<code>马尔可夫决策过程</code>和<code>动态规划</code>。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>1.<a href="https://www.bilibili.com/video/av59538266">b站李宏毅《机器学习》</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
  </entry>
  <entry>
    <title>李宏毅机器学习——回归</title>
    <url>/2021/07/14/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<h3 id="李宏毅机器学习——回归"><a href="#李宏毅机器学习——回归" class="headerlink" title="李宏毅机器学习——回归"></a>李宏毅机器学习——回归</h3><p>回归大致可以理解为根据数据集$D$，拟合出近似的曲线，所以回归也常称为拟合（Fit）。按照自变量的数量可以分为一元回归和多元回归，按照自变量与因变量之间的函数表达式可以分为线性回归(Linear Regression)和非线性回归(Non-linear Regression)。</p>
<h4 id="1-模型步骤"><a href="#1-模型步骤" class="headerlink" title="1 模型步骤"></a>1 模型步骤</h4><ul>
<li>Step1：模型假设，选择模型框架（线性模型）</li>
<li>Step2：模型评估，如何判断众多模型的好坏（损失函数）</li>
<li>Step3：模型优化，如何筛选最优的模型（梯度下降）</li>
</ul>
<h5 id="1-1-模型假设（多元线性模型）"><a href="#1-1-模型假设（多元线性模型）" class="headerlink" title="1.1 模型假设（多元线性模型）"></a>1.1 模型假设（多元线性模型）</h5><p>多元线性模型就是特征x的线性组合的函数，可以表示为$y=\sum{w_ix_i}+b$，$x_i$为特征，$w_i$为权重，b为偏移量。</p>
<span id="more"></span>

<h5 id="1-2-模型评估（损失函数）"><a href="#1-2-模型评估（损失函数）" class="headerlink" title="1.2 模型评估（损失函数）"></a>1.2 模型评估（损失函数）</h5><p>常用的损失函数是均方误差（mean-square error, MSE），也被称为最小二乘法 (least square method)，其几何意义就是欧氏距离。</p>
<blockquote>
<p>不同的loss函数，具有不同的拟合特性：<br>Hinge Loss——SVM；<br>exp-Loss ——Boosting；<br>log-Loss——Logistic Regression。</p>
</blockquote>
<p>Square loss损失函数表示为：<br>$$<br>L\left( w,b \right) =\sum_{i=1}^m{\left( f\left( x_i \right) -y_i \right) ^2}，<br>$$<br>我们需要找到令结果最小的$w^*$和$b^*$，即<br>$$<br>\left( w^*,b^* \right) =arg\min <em>{\left( w,b \right)}\sum</em>{i=1}^m{\left( f\left( x_i \right) -y_i \right) ^2}。<br>$$</p>
<h5 id="1-3-最佳模型（解析解）"><a href="#1-3-最佳模型（解析解）" class="headerlink" title="1.3 最佳模型（解析解）"></a>1.3 最佳模型（解析解）</h5><p>多元（多个特征）的情况下，损失函数可以引入矩阵表示为：<br>$$<br>L\left( w,b \right) =\sum_{i=1}^m{\left( f\left( x_i \right) -y_i \right) ^2}=\left( XW-y \right) ^T\left( XW-y \right)<br>$$<br>式中，$X$是一组样本形成的样本矩阵，$W$是权重矩阵，$y$是样本真实值形成的矩阵。<br>上式可以展开为：<br>$$<br>L\left( w,b \right) =\left( XW-y \right) ^T\left( XW+y \right)<br>$$<br>$$<br>=\left( \left( XW \right) ^T-y^T \right) \left( XW-y \right)<br>$$<br>$$<br>=\left( X^TW^T-y^T \right) \left( XW-y \right)<br>$$<br>$$<br>=X^TW^TXW-y^TXW-W^TX^Ty+y^Ty<br>$$<br>对$w$求导：<br>$$<br>\frac{\partial L\left( W \right)}{\partial W}=2X^TXW-\left( y^TX \right) ^T-X^Ty<br>$$<br>$$<br>=2X^TXW-2X^Ty<br>$$<br>偏导等于零时可以求得损失函数最小时对应的$W$，即我们最终想要获得的系数矩阵：<br>$$<br>X^TXW-X^Ty=0<br>$$<br>$$<br>X^TXW=X^Ty<br>$$<br>$$<br>((X^TX)^{-1}X^TX)W=(X^TX)^{-1}X^Ty<br>$$<br>$$<br>IW=(X^TX)^{-1}X^Ty<br>$$<br>$$<br>W=(X^TX)^{-1}X^Ty<br>$$</p>
<p>上式必须满足矩阵的逆存在，而矩阵可逆需要方正且满秩。但是因为不能保证所选的特征是完全线性无关的，所以矩阵不一定满秩，这导致线性回归有解析解但存在无穷多解，还是无法求得一个准确的解，这时候就需要使用梯度下降法来逼近一个解。</p>
<h5 id="1-4-最佳模型（梯度下降法）"><a href="#1-4-最佳模型（梯度下降法）" class="headerlink" title="1.4 最佳模型（梯度下降法）"></a>1.4 最佳模型（梯度下降法）</h5><p>首先设置初始的$w_0$和$b_0$，然后通过求$L$对$w$和$b$的偏导不断地更新$w$和$b$，直到找到$L$的最小值。<br>整个过程可以表示为：<br>$$<br>repeat,,until,,converge{w_i:=w_i-\eta \frac{\partial L\left( w_i \right)}{w_i};\ b_i:=b_i-\eta \frac{\partial L\left( b_i \right)}{b_i}}<br>$$<br>其中$\eta $是学习率，用来控制每步下降的距离（太小收敛会很慢，太大则可能跳过最优点），一般按照对数的方法来选择，例如0.1, 0.03, 0.01, 0.003…这种方法称为批量梯度下降（batch gradient descent, BGD）</p>
<p>original-loss存在很多奇点，而BGD每次下降的方向就是original-loss的负梯度，因此BGD很容易陷入某个奇点，而无法达到global minimal（或者比较好的local minimal）。随机梯度下降（stochastic gradient descent, SGD）一定程度上可以避免这个情况——不容易陷入original-loss和minibatch-loss的奇点：</p>
<ul>
<li>引入randomness，SGD中计算的梯度是对original-loss梯度的近似，相当于在original-loss梯度的基础上加了randomness，因此即使当前走到了original-loss的奇点，SGD计算的梯度因为引入了randomness，所以也不接近0，比较容易跳出奇点。</li>
<li>SGD计算的不是original-loss的梯度，而是minibatch-loss的梯度，original-loss和minibatch-loss的形状不同，奇点分布也不同，如果当前这个点在original-loss上是奇点，但这个点在minibatch-loss中并不是奇点，此时使用minibatch-loss的负梯度作为下降方向，自然不会陷入这个点。</li>
<li>每次迭代，都会使用不同的mini batch，而不同的minibatch-loss的形状不同。就算此时陷入了当前minibatch-loss的奇点，那么下一次迭代，这个点也不一定就是下一个minibatch-loss的奇点，如果不是的话，自然就跳出来了。</li>
</ul>
<h5 id="1-5-正则化"><a href="#1-5-正则化" class="headerlink" title="1.5 正则化"></a>1.5 正则化</h5><p>当我们筛选出模型进行拟合数据时，可能会没有很好地拟合数据，称为欠拟合（underfitting），或者叫做高偏差（bias）；也可能对训练集拟合得很好，但在测试集上拟合不好，称为过拟合（overfitting），也叫高方差（variance）。</p>
<p>对于过拟合，我们可以</p>
<ul>
<li>1.减少选取变量的数量（通过特征选择保留更为重要的特征变量）</li>
</ul>
<p>特征选择的缺点在于：舍弃一部分特征变量的同时，也舍弃了问题中的一些信息。<br>如果我们不想舍弃这些信息，可以使用正则化。</p>
<ul>
<li>2.正则化</li>
</ul>
<p>当线性回归从1次变成高次的过程中，在训练集上的拟合越来越好，但在测试集上并不是这样。于是我们可以采用正则化，去惩罚$w_1$到$w_n$，以L2正则化为例，原始的损失函数$L$上加上$\lambda \sum{\left( w_i \right) ^2}$，使得权重的绝对值大小整体倾向于减小（权重衰减），这样可以使函数更加平滑，也就是更加简单，不容易发生过拟合。形象一点看，损失函数曲面通过L2正则化的加持，最小值所在的位置从一条山岭变成一个山谷，故L2正则化在机器学习中也叫做“岭回归”（ridge regression）。<br><a href="https://imgtu.com/i/W2hcxH"><img src="https://z3.ax1x.com/2021/07/25/W2hcxH.png" alt="W2hcxH.png"></a></p>
<p>L1正则化则是加上$\lambda \sum{\left| \left. w_i \right| \right.}$，L1 正则化除了和L2正则化一样可以约束数量级外，还能使参数更加稀疏，参数一部分为0，另一部分为非零实值。非零实值的那部分参数值可起到选择重要参数或特征维度的作用，同时可起到去除噪声的效果。</p>
<h4 id="2-sklearn实现多元线性回归"><a href="#2-sklearn实现多元线性回归" class="headerlink" title="2 sklearn实现多元线性回归"></a>2 sklearn实现多元线性回归</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> pltfrom sklearn.linear_model</span><br><span class="line"><span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;./data.csv&#x27;</span>)</span><br><span class="line">X_train,X_test,Y_train,Y_test = train_test_split(train_size = <span class="number">0.7</span>)</span><br><span class="line">model = LinearRegression()model.fit(X_train,Y_train)</span><br><span class="line"></span><br><span class="line">a = model.intercept_</span><br><span class="line">b = model.coef_</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最佳拟合线:截距&quot;</span>,a,<span class="string">&quot;,回归系数：&quot;</span>,b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;拟合函数: y = %f * x+%f * x+%f * x+ %f&#x27;</span>%(b[<span class="number">0</span>],b[<span class="number">1</span>],b[<span class="number">2</span>],a))</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = <span class="string">&#x27;SimHei&#x27;</span></span><br><span class="line">score = model.score(X_test,Y_test)</span><br><span class="line"><span class="built_in">print</span>(score)</span><br><span class="line">Y_test_pred = model.predict(X_test)</span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="built_in">len</span>(Y_test_pred))</span><br><span class="line">Y_test,label = <span class="string">&#x27;test&#x27;</span>,color = <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="built_in">len</span>(Y_test_pred)),Y_test_pred,color = <span class="string">&#x27;r&#x27;</span>,label = <span class="string">&#x27;predict&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.legend()</span><br></pre></td></tr></table></figure>


<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>1.<a href="https://www.bilibili.com/video/av59538266">b站李宏毅《机器学习》</a><br>2.<a href="https://datawhalechina.github.io/leeml-notes/#/">datawhale李宏毅机器学习笔记(LeeML-Notes)</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Regression</tag>
      </tags>
  </entry>
  <entry>
    <title>李宏毅机器学习——梯度下降</title>
    <url>/2021/07/16/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/</url>
    <content><![CDATA[<h3 id="李宏毅机器学习——梯度下降"><a href="#李宏毅机器学习——梯度下降" class="headerlink" title="李宏毅机器学习——梯度下降"></a>李宏毅机器学习——梯度下降</h3><h4 id="1-偏差与方差"><a href="#1-偏差与方差" class="headerlink" title="1 偏差与方差"></a>1 偏差与方差</h4><p>使用样本数据拟合函数，由于样本数据使采样而并非真实值本身，采样本身会带来误差。经过研究发现，其误差的期望值可以分解为三个部分：样本<strong>噪音</strong>、模型预测值的<strong>方差</strong>、预测值相对真实值的<strong>偏差</strong>，公式为：<br>$$<br>E\left((y-\hat{f}(x))^{2}\right)=\sigma^{2}+\operatorname{Var}[\hat{f}(x)]+(\operatorname{Bias}[\hat{f}(x)])^{2}<br>$$<br>其中$Bias[\hat{f}(x)] = E[\hat{f}(x) - f(x)]$，即误差的期望值 = 噪音的方差 + 模型预测值的方差 + 预测值相对真实值的偏差的平方，如下图所示。</p>
<p><a href="https://imgtu.com/i/W2h4dP"><img src="https://z3.ax1x.com/2021/07/25/W2h4dP.png" alt="W2h4dP.png"></a></p>
<span id="more"></span>
<p>靶心（红点）是测试样本的真实值，测试样本的y（橙色点）是真实值加上噪音，特定模型重复多次训练会得到多个具体的模型，每一个具体模型对测试样本进行一次预测，就在靶上打出一个预测值（图上蓝色的点）。所有预测值的平均就是预测值的期望（较大的浅蓝色点），浅蓝色的圆圈表示预测值的离散程度，即预测值的方差。</p>
<h4 id="2-调整梯度下降的学习率"><a href="#2-调整梯度下降的学习率" class="headerlink" title="2 调整梯度下降的学习率"></a>2 调整梯度下降的学习率</h4><p>如果每次调的太大，loss变化就很快：调的太小，loss变化的太慢，这样都找不到最小的loss。<br><a href="https://imgtu.com/i/W2h5If"><img src="https://z3.ax1x.com/2021/07/25/W2h5If.png" alt="W2h5If.png"></a><br>此时我们可以采用自适应学习率，即刚开始时，初始点距离最低点较远，采用较大的学习率，在每次更新参数后，更接近最低点了，调小学习率。于是就有了不同的优化梯度下降的方法，这类优化梯度下降的方法有SGD、AdaGrad、Adam等等。</p>
<h5 id="2-1-SGD"><a href="#2-1-SGD" class="headerlink" title="2.1 SGD"></a>2.1 SGD</h5><p>批量梯度下降（Batch Gradient Descent，BGD）是在全部训练集上计算准确的梯度，即<br>$$<br>\sum_{i=1}^{n} \nabla_{\theta} f\left(\theta ; x_{i}, y_{i}\right)+\nabla_{\theta} \phi(\theta)<br>$$<br>而随机梯度下降（Stochastic Gradient Descent，SGD）则是采样单个样本来估计当前的梯度，即<br>$$<br>\nabla_{\theta} f\left(\theta ; x_{i}, y_{i}\right)+\nabla_{\theta} \phi(\theta)<br>$$<br>SGD最大的缺点是下降速度慢和不稳定，而且可能会在沟壑的两边持续震荡，停留在一个局部最优点。</p>
<h5 id="2-2-SGD-with-Momentum"><a href="#2-2-SGD-with-Momentum" class="headerlink" title="2.2 SGD with Momentum"></a>2.2 SGD with Momentum</h5><p>为了抑制SGD的震荡，SGDM认为梯度下降过程可以加入惯性。下坡的时候，如果发现是陡坡，那就利用惯性跑的快一些。SGDM在SGD基础上引入了一阶动量：<br>$$<br>m_{t}=\beta_{1} \cdot m_{t-1}+\left(1-\beta_{1}\right) \cdot g_{t}<br>$$<br>一阶动量是各个时刻梯度方向的指数移动平均值，约等于最近$1 /\left(1-\beta_{1}\right)$个时刻的梯度向量和的平均值。也就是说，t时刻的下降方向，不仅由当前点的梯度方向决定，而且由此前累积的下降方向决定。这就意味着下降方向主要是此前累积的下降方向，并略微偏向当前时刻的下降方向。</p>
<h5 id="2-3-SGD-with-Nesterov-Acceleration"><a href="#2-3-SGD-with-Nesterov-Acceleration" class="headerlink" title="2.3 SGD with Nesterov Acceleration"></a>2.3 SGD with Nesterov Acceleration</h5><p>SGD 还有一个问题是困在局部最优的沟壑里面震荡。因此，我们不能停留在当前位置去观察未来的方向，而要向前一步、多看一步、看远一些。<br>NAG全称Nesterov Accelerated Gradient，是在SGD、SGD-M的基础上的进一步改进。NAG不计算当前位置的梯度方向，而是计算如果按照累积动量走了一步，那个时候的下降方向：<br>$$<br>g_{t}=\nabla f\left(w_{t}-\alpha \cdot m_{t-1} / \sqrt{V_{t-1}}\right)<br>$$</p>
<h5 id="2-5-Adgrad"><a href="#2-5-Adgrad" class="headerlink" title="2.5 Adgrad"></a>2.5 Adgrad</h5><p>Adagrad是解决不同参数应该使用不同的更新速率的问题。Adagrad自适应地为各个参数分配不同学习率的算法。<br>其公式如下：<br><a href="https://imgtu.com/i/W2hTJS"><img src="https://z3.ax1x.com/2021/07/25/W2hTJS.png" alt="W2hTJS.png"></a><br>Adagrad设置全局学习率之后，每次通过全局学习率逐参数的除以历史梯度平方和的平方根，使得每个参数的学习率不同。这里的梯度平方和就是二阶动量。</p>
<p>Adagrad起到的效果是在参数空间更为平缓的方向会取得更大的进步（因为平缓，所以历史梯度平方和较小，对应学习下降的幅度较小），并且能够使得陡峭的方向变得平缓，从而加快训练速度。</p>
<p>Adagrad的缺点是由于是累积平方梯度，平方梯度是单调递增函数，会使得学习率单调递减至0，从而使训练过程提前结束。</p>
<h5 id="2-6-AdaDelta-RMSProp"><a href="#2-6-AdaDelta-RMSProp" class="headerlink" title="2.6 AdaDelta / RMSProp"></a>2.6 AdaDelta / RMSProp</h5><p>由于AdaGrad单调递减的学习率变化过于激进，可以改进二阶动量计算方法：不累积全部历史梯度，而只关注过去一段时间窗口的下降梯度。（这也是AdaDelta名称中Delta的来历。）</p>
<p>指数移动平均值大约就是过去一段时间的平均值，因此可以用这一方法来计算二阶累积动量：<br>$$<br>V_{t}=\beta_{2} * V_{t-1}+\left(1-\beta_{2}\right) g_{t}^{2}<br>$$<br>这可以避免二阶动量持续累积、导致训练过程提前结束的问题。</p>
<h5 id="2-7-Adam"><a href="#2-7-Adam" class="headerlink" title="2.7 Adam"></a>2.7 Adam</h5><p>SGD-M在SGD基础上增加了一阶动量，AdaGrad和AdaDelta在SGD基础上增加了二阶动量。把一阶动量和二阶动量都用起来，就是Adam了——Adaptive + Momentum。<br>SGD的一阶动量：<br>$$<br>m_{t}=\beta_{1} \cdot m_{t-1}+\left(1-\beta_{1}\right) \cdot g_{t}<br>$$<br>加上AdaDelta的二阶动量：<br>$$<br>V_{t}=\beta_{2} * V_{t-1}+\left(1-\beta_{2}\right) g_{t}^{2}<br>$$<br>其中$\beta_{1}$控制一阶动量，$\beta_{2}$控制二阶动量。</p>
<h5 id="2-8-Nadam"><a href="#2-8-Nadam" class="headerlink" title="2.8 Nadam"></a>2.8 Nadam</h5><p>在Adam的基础上增加了Nesterov，即同时用上一二阶动量，且按照累积动量走了一步。<br>$$<br>g_{t}=\nabla f\left(w_{t}-\alpha \cdot m_{t-1} / \sqrt{V_{t}}\right)<br>$$</p>
<h4 id="3-特征缩放（Feature-Scaling）"><a href="#3-特征缩放（Feature-Scaling）" class="headerlink" title="3 特征缩放（Feature Scaling）"></a>3 特征缩放（Feature Scaling）</h4><p>特征缩放（Feature Scaling）包括标准化（Standardization/Z-Score Normalization）和归一化（Normalization）。特征缩放可以同一量纲和数量级，可以提高某些基于距离的算法（Distance-Based Algorithms），如KNN、K-Means、SVM、PCA等距离计算算法的性能，但对基于树的算法（Tree-Based Algorithms）、线性判别分析、朴素贝叶斯等算法无帮助。</p>
<p>特征缩放对于基于梯度下降的算法（Gradient Descent Based Algorithms）有加速作用——未经标准化的特征的损失函数是椭圆形，梯度下降方向垂直于等高线，形成zigzag的路线，并非指向local mininum。对特征进行归一化Normalization后，其损失函数的等高线图更接近圆形，梯度下降的方向震荡更小，收敛更快。<br><a href="https://imgtu.com/i/W2hHzQ"><img src="https://z3.ax1x.com/2021/07/25/W2hHzQ.png" alt="W2hHzQ.png"></a></p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>1.<a href="https://www.bilibili.com/video/av59538266">b站李宏毅《机器学习》</a><br>2.<a href="https://datawhalechina.github.io/leeml-notes/#/">datawhale李宏毅机器学习笔记(LeeML-Notes)</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Gradient Descent</tag>
      </tags>
  </entry>
  <entry>
    <title>李宏毅机器学习——神经网络设计技巧</title>
    <url>/2021/07/20/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h3 id="李宏毅机器学习——神经网络设计技巧"><a href="#李宏毅机器学习——神经网络设计技巧" class="headerlink" title="李宏毅机器学习——神经网络设计技巧"></a>李宏毅机器学习——神经网络设计技巧</h3><h4 id="1-鞍点-Saddle-Point"><a href="#1-鞍点-Saddle-Point" class="headerlink" title="1 鞍点(Saddle Point)"></a>1 鞍点(<em>Saddle</em> <em>Point</em>)</h4><p>神经网络中，Gradient为0(或不存在)的点称为临界点(critical point)，其有两种可能性：局部极小(local minima)和鞍点(saddle point)。</p>
<p>长期以来，人们普遍认为，神经网络优化问题困难是因为较大的神经网络中包含很多局部极小值，使得算法容易陷入到其中某些点。2014年的一篇论文中提出高维非凸优化问题之所以困难，是因为存在大量的鞍点而不是局部极值。</p>
<blockquote>
<p>鞍点：</p>
<ul>
<li>一个维度向上倾斜且另一维度向下倾斜的点。这些鞍点通常被相同误差值的平面所包围，这使得算法陷入其中很难脱离出来，因为梯度在所有维度上接近于零</li>
<li>梯度等于零，在其附近Hessian矩阵有正的和负的特征值，行列式小于0，即是不定的。</li>
</ul>
</blockquote>
<p><a href="https://imgtu.com/i/W24pJU"><img src="https://z3.ax1x.com/2021/07/25/W24pJU.png" alt="W24pJU.png"></a></p>
<span id="more"></span>

<p>在鞍点附近，基于梯度的优化算法会遇到较为严重的问题：鞍点处的梯度为零，鞍点通常被相同误差值的平面所包围（这个平面称为Plateaus，Plateaus是梯度接近于零的平缓区域，会降低神经网络学习速度），在高维的情形，这个鞍点附近的平坦区域范围可能非常大，这使得SGD算法很难脱离区域，即可能会长时间卡在该点附近（因为梯度在所有维度上接近于零）。</p>
<p>在鞍点数目极大的时候，这个问题会变得非常严重。高维非凸优化问题之所以困难，是因为高维参数空间存在大量的鞍点。</p>
<p>鞍点和局部极小值相同的是，在该点处的梯度都等于零，不同在于在鞍点附近Hessian矩阵是不定的(行列式小于0)，而在局部极值附近的Hessian矩阵是正定的。</p>
<blockquote>
<p>Hessian矩阵是一个多元函数的二阶偏导数构成的方阵，描述了函数的局部曲率。可用于判定多元函数的极值。</p>
</blockquote>
<blockquote>
<p>$$<br>H(f)=\left[\begin{array}{cccc}<br>\frac{\partial^{2} f}{\partial x_{1}^{2}} &amp; \frac{\partial^{2} f}{\partial x_{1} \partial x_{2}} &amp; \cdots &amp; \frac{\partial^{2} f}{\partial x_{1} \partial x_{n}} \<br>\frac{\partial^{2} f}{\partial x_{2} \partial x_{1}} &amp; \frac{\partial^{2} f}{\partial x_{2}^{2}} &amp; \cdots &amp; \frac{\partial^{2} f}{\partial x_{2} \partial x_{n}} \<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>\frac{\partial^{2} f}{\partial x_{n} \partial x_{1}} &amp; \frac{\partial^{2} f}{\partial x_{n} \partial x_{2}} &amp; \cdots &amp; \frac{\partial^{2} f}{\partial x_{n}^{2}}<br>\end{array}\right]<br>$$</p>
</blockquote>
<ul>
<li>当函数的Hessian矩阵在梯度为零的位置上的特征值全为正(正定矩阵)时，该函数得到局部最小值。</li>
<li>当函数的Hessian矩阵在梯度为零的位置上的特征值全为负(负定矩阵)时，该函数得到局部最⼤值。</li>
<li>当函数的Hessian矩阵在梯度为零的位置上的特征值有正有负(不定矩阵)时，该函数得到鞍点。</li>
</ul>
<h4 id="2-批次和动量-Batch-and-Momentum"><a href="#2-批次和动量-Batch-and-Momentum" class="headerlink" title="2 批次和动量(Batch and Momentum)"></a>2 批次和动量(Batch and Momentum)</h4><h5 id="2-1-Batch"><a href="#2-1-Batch" class="headerlink" title="2.1 Batch"></a>2.1 Batch</h5><p>批梯度下降（Batch gradient descent，BGD）遍历全部数据集算一次损失函数，然后算函数对各个参数的梯度，然后更新梯度。BGD的优点在于由全数据集确定的方向能够更好地代表样本总体，如果函数为凸函数，BGD一定能得到全局最优。其缺点在于每更新一次参数都要把数据集里的所有样本都看一遍，计算量开销大，计算速度慢。</p>
<p>随机梯度下降（stochastic gradient descent，SGD）每看一个数据就算一下损失函数，然后求梯度更新参数，这个称为随机梯度下降。SGD方法速度比较快，但是由于单个样本并不能代表全体样本的趋势，所以其收敛性能不太好，遇上噪声则容易陷入局部最优解，也可能在最优点附近晃来晃去，收敛不到最优点。两次参数的更新也有可能互相抵消掉，造成目标函数震荡的比较剧烈。</p>
<p>小批量梯度下降（mini-batch gradient descent，mini-batch GD）每次选取一定数目(mini-batch)的样本组成一个小批量样本，然后用这个小批量来更新梯度。每次使用一个batch可以大大减小收敛所需要的迭代次数，同时可以使收敛到的结果更加接近梯度下降的效果，可以提高算法稳定性。</p>
<h5 id="2-2-Momentum"><a href="#2-2-Momentum" class="headerlink" title="2.2 Momentum"></a>2.2 Momentum</h5><p>动量梯度下降法（Gradient descent with Momentum）或者叫做Momentum，通过计算梯度的指数加权平均数，并利用该梯度更新权重。<br><a href="https://imgtu.com/i/W2TLVA"><img src="https://z3.ax1x.com/2021/07/25/W2TLVA.png" alt="W2TLVA.png"></a></p>
<p>其每一次梯度下降都会有一个之前的速度的作用，如果这次的方向与之前相同，则会因为之前的速度继续加速；如果这次的方向与之前相反，则会由于之前存在速度的作用不会产生一个急转弯。简而言之，Momentum对原始梯度做了修正和平滑，具有更快的收敛速度。</p>
<h4 id="3-自动调整学习速率-Adaptive-Learning-rate"><a href="#3-自动调整学习速率-Adaptive-Learning-rate" class="headerlink" title="3 自动调整学习速率(Adaptive Learning rate)"></a>3 自动调整学习速率(Adaptive Learning rate)</h4><h5 id="2-1-AdaGrad"><a href="#2-1-AdaGrad" class="headerlink" title="2.1 AdaGrad"></a>2.1 AdaGrad</h5><p>设置全局学习率之后，每次通过全局学习率逐参数的除以历史梯度平方和的平方根，使得每个参数的学习率不同，可以使参数空间更为平缓的方向，会取得更大的进步（因为平缓，所以历史梯度平方和较小，对应学习下降的幅度较小），并且能够使得陡峭的方向变得平缓，从而加快训练速度。<br><a href="https://imgtu.com/i/W27CrQ"><img src="https://z3.ax1x.com/2021/07/25/W27CrQ.png" alt="W27CrQ.png"></a></p>
<h5 id="2-2-RMSprop"><a href="#2-2-RMSprop" class="headerlink" title="2.2 RMSprop"></a>2.2 RMSprop</h5><p>Adagrad会记录过去所有梯度的平方和。因此，学习越深入，更新的幅度就越小。实际上，如果无止境地学习，更新量就会变为0，完全不再更新。为了改善这个问题，可以使用 RMSProp方法。RMSProp方法并不是将过去所有的梯度一视同仁地相加，而是逐渐地遗忘过去的梯度，在做加法运算时将新梯度的信息更多地反映出来。这种方法也被称为“指数移动平均”，呈指数函数式地减小过去的梯度的尺度。</p>
<p>RMSProp算法不是像AdaGrad算法那样暴力直接的累加平方梯度，而是加了一个衰减系数来控制历史信息的获取多少。相比于AdaGrad的历史梯度$r \leftarrow r+g \odot g$，RMSProp增加了一个衰减系数来控制历史信息的获取多少：$r \leftarrow \rho r+(1-\rho) \boldsymbol{g} \odot \boldsymbol{g}$。</p>
<p><a href="https://imgtu.com/i/W27FVs"><img src="https://z3.ax1x.com/2021/07/25/W27FVs.png" alt="W27FVs.png"></a></p>
<p>第一个等式类似Momentum，计算了梯度平方的指数平均；第二个等式根据指数平均决定步幅大小，初始化学习率η，接着除以平均数；第三个等式是权重更新步骤。其中超参数ρ一般取0.9，ε一般取1e-10。</p>
<p>RMSProp隐式地应用了模拟退火。在向最小值移动的过程中，RMSProp会自动降低学习步幅，以免跳过最小值。</p>
<h5 id="2-3-Adam"><a href="#2-3-Adam" class="headerlink" title="2.3 Adam"></a>2.3 Adam</h5><p>Adam（Adaptive Moment Estimation）相当于RMSprop+Momentum，</p>
<p><a href="https://imgtu.com/i/W27Kr4"><img src="https://z3.ax1x.com/2021/07/25/W27Kr4.png" alt="W27Kr4.png"></a></p>
<p>等式1和等式2计算了梯度的指数平均和梯度平方的指数平均；等式3在学习率上乘以梯度的平均（类似动量），除以梯度平方平均的均方根（类似RMSProp），得出学习步幅；等式4是权重更新步骤。其中超参数β1一般取0.9，β2一般取0.99，ε一般取1e-10。</p>
<h5 id="2-4-Learning-Rate-Scheduling"><a href="#2-4-Learning-Rate-Scheduling" class="headerlink" title="2.4 Learning Rate Scheduling"></a>2.4 Learning Rate Scheduling</h5><ul>
<li>学习率衰减（Learning Rate Decay）——为了防止学习率过大，在收敛到全局最优点的时候会来回摆荡，所以要让学习率随着训练轮数不断下降，收敛梯度下降的学习步长。其中包括线性衰减（例如：每过5个epochs学习率减半）、指数衰减（随着迭代轮数的增加学习率自动发生衰减）、分段常数衰减等方法。</li>
<li>热启动（Warm up）——warmup是初始阶段使用较小学习率启动，后期恢复正常；而decay是初始时使用较大的学习率，之后进行衰减。其有助于减缓模型在初始阶段对mini-batch的提前过拟合现象，保持分布的平稳。</li>
</ul>
<h4 id="4-损失函数-Loss-的影响"><a href="#4-损失函数-Loss-的影响" class="headerlink" title="4 损失函数(Loss)的影响"></a>4 损失函数(Loss)的影响</h4><p>均方误差（Mean Square Error，MSE）适用于回归问题，而交叉熵（Cross Entropy）适用于分类问题。<br>在分类问题中，MSE损失函数为$\text { loss }=\frac{1}{2 m} \sum_{i}^{m}\left(y_{i}-y^{\prime}\right)^{2}$，加上softmax之后为$\operatorname{los} s_{i}=\left(c_{1}-\frac{e^{y i^{\prime}}}{c_{2}}\right)^{2}$，是一个非凸函数，梯度下降算法难以达到全局最优解。所以MSE在分类问题中，并不是一个好的loss函数；而交叉熵损失函数为$\operatorname{loss}=-\sum_{i=1}^{n} y_{i} * \log \left(y_{i}\right)$，加入softmax得到$\operatorname{loss}<em>{i}=-\log \left(c</em>{1}-\frac{e^{x}}{c_{2}}\right)$。</p>
<p><a href="https://imgtu.com/i/W27DII"><img src="https://z3.ax1x.com/2021/07/25/W27DII.jpg" alt="W27DII.jpg"></a></p>
<p>相对MSE而言，交叉熵曲线整体呈单调性，loss越大，梯度越大。便于梯度下降反向传播，利于优化。所以一般针对分类问题采用交叉熵作为loss函数。（P.S.在广义伯努利分布下，最小化交叉熵损失等同于极大似然估计）</p>
<h4 id="5-批量标准化-归一化-Batch-Normalization，BN"><a href="#5-批量标准化-归一化-Batch-Normalization，BN" class="headerlink" title="5 批量标准化/归一化(Batch Normalization，BN)"></a>5 批量标准化/归一化(Batch Normalization，BN)</h4><p>Batch Normalization，简称BatchNorm或BN，翻译为“批归一化”，是神经网络中一种特殊的层，如今已是各种流行网络的标配。在原始论文中，BN被建议插入在（每个）ReLU激活层前面。</p>
<p><a href="https://imgtu.com/i/W27cz8"><img src="https://z3.ax1x.com/2021/07/25/W27cz8.png" alt="W27cz8.png"></a></p>
<p>BN操作分为两步：</p>
<ol>
<li>Standardization：首先对$m$个$x$进行Standardization，得到zero mean unit variance的分布$\hat{x}$。</li>
<li>scale and shift：然后再对$\hat{x}$进行scale and shift，缩放并变换回原始的分布$y$。（这样的目的是为了补偿网络的非线性表达能力，因为经过标准化之后，偏移量丢失。均值$\beta$方差$\gamma$相当于输入数据分布的方差和偏移。）</li>
</ol>
<p>Batch Normalization有以下几点优势：</p>
<ul>
<li>BN使得网络中每层输入数据的分布相对稳定，加速模型学习速度</li>
<li>BN使得模型对网络中的参数不那么敏感，简化调参过程，使得网络学习更加稳定</li>
<li>BN允许网络使用饱和性激活函数（例如sigmoid，tanh等），缓解梯度消失问题</li>
<li>BN具有一定的正则化效果</li>
</ul>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>1.<a href="https://www.bilibili.com/video/av59538266">b站李宏毅《机器学习》</a><br>2.<a href="https://datawhalechina.github.io/leeml-notes/#/">datawhale李宏毅机器学习笔记(LeeML-Notes)</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Neural Networks</tag>
      </tags>
  </entry>
  <entry>
    <title>模型融合_1</title>
    <url>/2021/03/15/%E6%A8%A1%E5%9E%8B%E8%9E%8D%E5%90%88_1/</url>
    <content><![CDATA[<p>Kaggle和天池比赛中常用提高成绩的三种方法：</p>
<blockquote>
<p>1.特征工程<br>2.模型调参<br>3.模型融合<br>模型融合主要有以下几种方式：</p>
</blockquote>
<h4 id="简单加权融合"><a href="#简单加权融合" class="headerlink" title="简单加权融合:"></a>简单加权融合:</h4><blockquote>
<p>①回归（分类概率）：算术平均融合（Arithmetic mean），几何平均融合（Geometric mean）；<br>②分类：投票（Voting)<br>③综合：排序融合(Rank averaging)，log融合</p>
</blockquote>
<h4 id="stacking-blending"><a href="#stacking-blending" class="headerlink" title="stacking/blending:"></a>stacking/blending:</h4><blockquote>
<p>构建多层模型，把初级学习器的输出当作下一层的输入。</p>
</blockquote>
<span id="more"></span>
<h4 id="boosting-bagging（在xgboost-Adaboost-GBDT中已经用到）"><a href="#boosting-bagging（在xgboost-Adaboost-GBDT中已经用到）" class="headerlink" title="boosting/bagging（在xgboost,Adaboost,GBDT中已经用到）:"></a>boosting/bagging（在xgboost,Adaboost,GBDT中已经用到）:</h4><blockquote>
<p>多个分类器的整合</p>
</blockquote>
<h4 id="部分代码案例"><a href="#部分代码案例" class="headerlink" title="部分代码案例:"></a>部分代码案例:</h4><h5 id="1-简单加权平均"><a href="#1-简单加权平均" class="headerlink" title="1.简单加权平均"></a>1.简单加权平均</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Weighted_method</span>(<span class="params">test_pre1,test_pre2,test_pre3,w=[<span class="number">1</span>/<span class="number">3</span>,<span class="number">1</span>/<span class="number">3</span>,<span class="number">1</span>/<span class="number">3</span>]</span>):</span></span><br><span class="line">    Weighted_result = w[<span class="number">0</span>]*pd.Series(test_pre1)+w[<span class="number">1</span>]*pd.Series(test_pre2)+w[<span class="number">2</span>]*pd.Series(test_pre3)</span><br><span class="line">    <span class="keyword">return</span> Weighted_result</span><br><span class="line">    </span><br><span class="line">Weighted_pre = Weighted_method(test_pre1,test_pre2,test_pre3,w)</span><br></pre></td></tr></table></figure>
<h5 id="2-Stacking融合-回归"><a href="#2-Stacking融合-回归" class="headerlink" title="2.Stacking融合(回归)"></a>2.Stacking融合(回归)</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Stacking_method</span>(<span class="params">train_reg1,train_reg2,train_reg3,y_train_true,test_pre1,test_pre2,test_pre3,model_L2= linear_model.LinearRegression(<span class="params"></span>)</span>):</span>    model_L2.fit(pd.concat([pd.Series(train_reg1),pd.Series(train_reg2),pd.Series(train_reg3)],axis=<span class="number">1</span>).values,y_train_true)</span><br><span class="line">    Stacking_result = model_L2.predict(pd.concat([pd.Series(test_pre1),pd.Series(test_pre2),pd.Series(test_pre3)],axis=<span class="number">1</span>).values)</span><br><span class="line">    <span class="keyword">return</span> Stacking_result</span><br><span class="line"></span><br><span class="line">Stacking_pre = Stacking_method(train_reg1,train_reg2,train_reg3,y_train_true,</span><br><span class="line">                               test_pre1,test_pre2,test_pre3,model_L2)</span><br></pre></td></tr></table></figure>
<h5 id="3-Voting投票机制"><a href="#3-Voting投票机制" class="headerlink" title="3.Voting投票机制"></a>3.Voting投票机制</h5><blockquote>
<p>硬投票：对多个模型直接进行投票，不区分模型结果的相对重要度，最终投票数最多的类为最终被预测的类。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">eclf = VotingClassifier(estimators=[(<span class="string">&#x27;lgb&#x27;</span>, clf1), (<span class="string">&#x27;rf&#x27;</span>, clf2), (<span class="string">&#x27;svc&#x27;</span>, clf3)], voting=<span class="string">&#x27;hard&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> clf, label <span class="keyword">in</span> <span class="built_in">zip</span>([clf1, clf2, clf3, eclf], [<span class="string">&#x27;LGB&#x27;</span>, <span class="string">&#x27;Random Forest&#x27;</span>, <span class="string">&#x27;SVM&#x27;</span>, <span class="string">&#x27;Ensemble&#x27;</span>]):</span><br><span class="line">    scores = cross_val_score(clf, x, y, cv=<span class="number">5</span>, scoring=<span class="string">&#x27;accuracy&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Accuracy: %0.2f (+/- %0.2f) [%s]&quot;</span> % (scores.mean(), scores.std(), label))</span><br></pre></td></tr></table></figure>
<h5 id="4-分类模型的Stacking融合"><a href="#4-分类模型的Stacking融合" class="headerlink" title="4.分类模型的Stacking融合"></a>4.分类模型的Stacking融合</h5><blockquote>
<p>Stacking与Blending相比存在一定优势:<br>1.充分使用数据<br>2.使用多次的交叉验证会比较稳健<br>3.不容易过拟合</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clfs = [LogisticRegression(solver=<span class="string">&#x27;lbfgs&#x27;</span>),</span><br><span class="line">        RandomForestClassifier(n_estimators=<span class="number">5</span>, n_jobs=-<span class="number">1</span>, criterion=<span class="string">&#x27;gini&#x27;</span>),</span><br><span class="line">        RandomForestClassifier(n_estimators=<span class="number">5</span>, n_jobs=-<span class="number">1</span>, criterion=<span class="string">&#x27;entropy&#x27;</span>),</span><br><span class="line">        ExtraTreesClassifier(n_estimators=<span class="number">5</span>, n_jobs=-<span class="number">1</span>, criterion=<span class="string">&#x27;gini&#x27;</span>),</span><br><span class="line">        GradientBoostingClassifier(learning_rate=<span class="number">0.05</span>, subsample=<span class="number">0.5</span>, max_depth=<span class="number">6</span>, n_estimators=<span class="number">5</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j, clf <span class="keyword">in</span> <span class="built_in">enumerate</span>(clfs):</span><br><span class="line">    <span class="comment">#依次训练各个单模型</span></span><br><span class="line">    clf.fit(X_d1, y_d1)</span><br><span class="line">    y_submission = clf.predict_proba(X_d2)[:, <span class="number">1</span>]</span><br><span class="line">    dataset_d1[:, j] = y_submission</span><br><span class="line">    <span class="comment">#对于测试集，直接用这k个模型的预测值作为新的特征。</span></span><br><span class="line">    dataset_d2[:, j] = clf.predict_proba(X_predict)[:, <span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;val auc Score: %f&quot;</span> % roc_auc_score(y_predict, dataset_d2[:, j]))</span><br><span class="line"></span><br><span class="line"><span class="comment">#融合使用的模型</span></span><br><span class="line">clf = GradientBoostingClassifier(learning_rate=<span class="number">0.02</span>, subsample=<span class="number">0.5</span>, max_depth=<span class="number">6</span>, n_estimators=<span class="number">30</span>)</span><br><span class="line">clf.fit(dataset_d1, y_d2)</span><br></pre></td></tr></table></figure>
<h5 id="5-其他Stacking"><a href="#5-其他Stacking" class="headerlink" title="5.其他Stacking"></a>5.其他Stacking</h5><blockquote>
<p>将特征放进模型中预测，并将预测结果变换并作为新的特征加入原有特征中再经过模型预测结果</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Ensemble_add_feature</span>(<span class="params">train,test,target,clfs</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j,clf <span class="keyword">in</span> <span class="built_in">enumerate</span>(clfs):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;依次训练各个单模型&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># print(j, clf)</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;使用第1个部分作为预测，第2部分来训练模型，获得其预测的输出作为第2部分的新特征。&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># X_train, y_train, X_test, y_test = X[train], y[train], X[test], y[test]</span></span><br><span class="line"></span><br><span class="line">        clf.fit(train,target)</span><br><span class="line">        y_train = clf.predict(train)</span><br><span class="line">        y_test = clf.predict(test)</span><br><span class="line"></span><br><span class="line">        <span class="comment">## 新特征生成</span></span><br><span class="line">        train_[:,j*<span class="number">2</span>] = y_train**<span class="number">2</span></span><br><span class="line">        test_[:,j*<span class="number">2</span>] = y_test**<span class="number">2</span></span><br><span class="line">        train_[:, j+<span class="number">1</span>] = np.exp(y_train)</span><br><span class="line">        test_[:, j+<span class="number">1</span>] = np.exp(y_test)</span><br><span class="line">        <span class="comment"># print(&quot;val auc Score: %f&quot; % r2_score(y_predict, dataset_d2[:, j]))</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Method &#x27;</span>,j)</span><br><span class="line"></span><br><span class="line">    train_ = pd.DataFrame(train_)</span><br><span class="line">    test_ = pd.DataFrame(test_)</span><br><span class="line">    <span class="keyword">return</span> train_,test_</span><br><span class="line"></span><br><span class="line"><span class="comment">#模型融合中使用到的各个单模型</span></span><br><span class="line">clfs = [LogisticRegression(),</span><br><span class="line">        RandomForestClassifier(n_estimators=<span class="number">5</span>, n_jobs=-<span class="number">1</span>, criterion=<span class="string">&#x27;gini&#x27;</span>),</span><br><span class="line">        ExtraTreesClassifier(n_estimators=<span class="number">5</span>, n_jobs=-<span class="number">1</span>, criterion=<span class="string">&#x27;gini&#x27;</span>),</span><br><span class="line">        ExtraTreesClassifier(n_estimators=<span class="number">5</span>, n_jobs=-<span class="number">1</span>, criterion=<span class="string">&#x27;entropy&#x27;</span>),</span><br><span class="line">        GradientBoostingClassifier(learning_rate=<span class="number">0.05</span>, subsample=<span class="number">0.5</span>, max_depth=<span class="number">6</span>, n_estimators=<span class="number">5</span>)]</span><br><span class="line"></span><br><span class="line">New_train,New_test = Ensemble_add_feature(x_train,x_test,y_train,clfs)</span><br><span class="line">clf = GradientBoostingClassifier(learning_rate=<span class="number">0.02</span>, subsample=<span class="number">0.5</span>, max_depth=<span class="number">6</span>, n_estimators=<span class="number">30</span>)</span><br><span class="line">clf.fit(New_train, y_train)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>voting</tag>
        <tag>Stacking</tag>
        <tag>Blending</tag>
      </tags>
  </entry>
  <entry>
    <title>特征工程_1</title>
    <url>/2021/04/21/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B_1/</url>
    <content><![CDATA[<p>特征工程就是将原始数据空间变换到新的特征空间，在新的特征空间中，模型能够更好地学习数据中的规律。特征的选择和构造，就是人为地帮助模型学习到原本很难学好的东西，从而使模型达到更好的效果。</p>
<h4 id="1-根据现实情况构造特征"><a href="#1-根据现实情况构造特征" class="headerlink" title="1. 根据现实情况构造特征"></a>1. 根据现实情况构造特征</h4><h5 id="1-1-各点与特定点的距离"><a href="#1-1-各点与特定点的距离" class="headerlink" title="1.1 各点与特定点的距离"></a>1.1 各点与特定点的距离</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;x_dis&#x27;</span>] = (df[<span class="string">&#x27;x&#x27;</span>] - <span class="number">6165599</span>).<span class="built_in">abs</span>()</span><br><span class="line">df[<span class="string">&#x27;y_dis&#x27;</span>] = (df[<span class="string">&#x27;y&#x27;</span>] - <span class="number">5202660</span>).<span class="built_in">abs</span>()</span><br><span class="line">df[<span class="string">&#x27;base_dis] = (df[&#x27;</span>y_dis<span class="string">&#x27;]**2))**0.5 + ((df[&#x27;</span>x_dis<span class="string">&#x27;]**2)</span></span><br><span class="line"><span class="string">del df[&#x27;</span>x_dis<span class="string">&#x27;],df[&#x27;</span>y_dis<span class="string">&#x27;] </span></span><br><span class="line"><span class="string">df[&#x27;</span>base_dis_dif<span class="string">f&#x27;].head()</span></span><br></pre></td></tr></table></figure>
<h5 id="1-2-将时间划分为白天与黑夜"><a href="#1-2-将时间划分为白天与黑夜" class="headerlink" title="1.2 将时间划分为白天与黑夜"></a>1.2 将时间划分为白天与黑夜</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;day_night&#x27;</span>] = <span class="number">0</span></span><br><span class="line">df.loc[(df[<span class="string">&#x27;hour&#x27;</span>] &gt; <span class="number">5</span>) &amp; (df[<span class="string">&#x27;hour&#x27;</span>] &lt; <span class="number">20</span>),<span class="string">&#x27;day_night&#x27;</span>] = <span class="number">1</span></span><br><span class="line">df[<span class="string">&#x27;day_night&#x27;</span>].head()</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h5 id="1-3-将月份划分为季度"><a href="#1-3-将月份划分为季度" class="headerlink" title="1.3 将月份划分为季度"></a>1.3 将月份划分为季度</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;quarter&#x27;</span>] = <span class="number">0</span></span><br><span class="line">df.loc[(df[<span class="string">&#x27;month&#x27;</span>].isin([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])), <span class="string">&#x27;quarter&#x27;</span>] = <span class="number">1</span></span><br><span class="line">df.loc[(df[<span class="string">&#x27;month&#x27;</span>].isin([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, ])), <span class="string">&#x27;quarter&#x27;</span>] = <span class="number">2</span></span><br><span class="line">df.loc[(df[<span class="string">&#x27;month&#x27;</span>].isin([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])), <span class="string">&#x27;quarter&#x27;</span>] = <span class="number">3</span></span><br><span class="line">df.loc[(df[<span class="string">&#x27;month&#x27;</span>].isin([<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>])), <span class="string">&#x27;quarter&#x27;</span>] = <span class="number">4</span></span><br></pre></td></tr></table></figure>
<h5 id="1-4-特征变化量之间的相似性"><a href="#1-4-特征变化量之间的相似性" class="headerlink" title="1.4 特征变化量之间的相似性"></a>1.4 特征变化量之间的相似性</h5><p>①统计每个ship的对应速度等级的个数.<br>②对方位进行16均分.<br>③统计速度为0的个数，以及速度不为0的统计量.<br>④加入x，v，d，y的中位数和各种位数,并删去count\mean\min\max\std等多余统计特征.<br>⑤以shift为主键,求相邻差异值(偏移量).</p>
<h4 id="2-构造分箱特征"><a href="#2-构造分箱特征" class="headerlink" title="2. 构造分箱特征"></a>2. 构造分箱特征</h4><h5 id="2-1-经纬度和速度的分箱特征"><a href="#2-1-经纬度和速度的分箱特征" class="headerlink" title="2.1 经纬度和速度的分箱特征"></a>2.1 经纬度和速度的分箱特征</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;v_bin&#x27;</span>] = pd.qcut(df[<span class="string">&#x27;v&#x27;</span>], <span class="number">200</span>, duplicates=<span class="string">&#x27;drop&#x27;</span>) <span class="comment"># 速度进行 200分位数分箱</span></span><br><span class="line">df[<span class="string">&#x27;v_bin&#x27;</span>] = df[<span class="string">&#x27;v_bin&#x27;</span>].<span class="built_in">map</span>(<span class="built_in">dict</span>(<span class="built_in">zip</span>(df[<span class="string">&#x27;v_bin&#x27;</span>].unique().<span class="built_in">range</span>(df[<span class="string">&#x27;v_bin&#x27;</span>].nunique())))) <span class="comment"># 分箱后映射编码</span></span><br></pre></td></tr></table></figure>

<h5 id="2-2-经纬度分箱后并构造区域"><a href="#2-2-经纬度分箱后并构造区域" class="headerlink" title="2.2 经纬度分箱后并构造区域"></a>2.2 经纬度分箱后并构造区域</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">traj.sort_values(by=<span class="string">&#x27;x&#x27;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">x_res = np.zeros((<span class="built_in">len</span>(traj), ))</span><br><span class="line">j = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, col_bins + <span class="number">1</span>):</span><br><span class="line">    low, high = x_bins[i-<span class="number">1</span>], x_bins[i]</span><br><span class="line">    <span class="keyword">while</span>( j &lt; <span class="built_in">len</span>(traj)):</span><br><span class="line">        <span class="keyword">if</span> (traj[<span class="string">&quot;x&quot;</span>].iloc[j] &lt;= high) &amp; (traj[<span class="string">&quot;x&quot;</span>].iloc[j] &gt; low - <span class="number">0.001</span>):</span><br><span class="line">            x_res[j] = i</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h4 id="3-构造DataFramte特征"><a href="#3-构造DataFramte特征" class="headerlink" title="3. 构造DataFramte特征"></a>3. 构造DataFramte特征</h4><h5 id="3-1-count计数值"><a href="#3-1-count计数值" class="headerlink" title="3.1 count计数值"></a>3.1 count计数值</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_save_unique_visit_count_table</span>(<span class="params">traj_data_df=<span class="literal">None</span>, bin_to_coord_df=<span class="literal">None</span></span>):</span></span><br><span class="line">    unique_boat_count_df = traj_data_df.groupby([<span class="string">&quot;no_bin&quot;</span>])[<span class="string">&quot;id&quot;</span>].nunique().reset_index()</span><br><span class="line">    unique_boat_count_df.rename(&#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;visit_boat_count&quot;</span>&#125;, axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    unique_boat_count_df_save = pd.merge(bin_to_coord_df, unique_boat_count_df,</span><br><span class="line">                                         on=<span class="string">&quot;no_bin&quot;</span>, how=<span class="string">&quot;left&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> unique_boat_count_d</span><br></pre></td></tr></table></figure>
<h5 id="3-2-shift偏移量"><a href="#3-2-shift偏移量" class="headerlink" title="3.2 shift偏移量"></a>3.2 shift偏移量</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>]:</span><br><span class="line">    <span class="comment">#对x,y坐标进行时间平移 1 -1 2</span></span><br><span class="line">    df[f + <span class="string">&#x27;_prev_diff&#x27;</span>] = df[f] - g[f].shift(<span class="number">1</span>)</span><br><span class="line">    df[f + <span class="string">&#x27;_next_diff&#x27;</span>] = df[f] - g[f].shift(-<span class="number">1</span>)</span><br><span class="line">    df[f + <span class="string">&#x27;_prev_next_diff&#x27;</span>] = g[f].shift(<span class="number">1</span>) - g[f].shift(-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h5 id="3-3-统计特征"><a href="#3-3-统计特征" class="headerlink" title="3.3 统计特征"></a>3.3 统计特征</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">group_feature</span>(<span class="params">df, key, target, aggs,flag</span>):</span>   </span><br><span class="line">    <span class="comment">#通过字典的形式来构建方法和重命名</span></span><br><span class="line">    agg_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> ag <span class="keyword">in</span> aggs:</span><br><span class="line">        agg_dict[<span class="string">&#x27;&#123;&#125;_&#123;&#125;_&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(target,ag,flag)] = ag</span><br><span class="line">        </span><br><span class="line">    t = df.groupby(key)[target].agg(agg_dict).reset_index()</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line"></span><br><span class="line">t = group_feature(df, <span class="string">&#x27;ship&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,[<span class="string">&#x27;max&#x27;</span>,<span class="string">&#x27;min&#x27;</span>,<span class="string">&#x27;mean&#x27;</span>,<span class="string">&#x27;median&#x27;</span>,<span class="string">&#x27;std&#x27;</span>,<span class="string">&#x27;skew&#x27;</span>],flag)</span><br><span class="line">train = pd.merge(train, t, on=<span class="string">&#x27;ship&#x27;</span>, how=<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line">t = group_feature(df, <span class="string">&#x27;ship&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,[<span class="string">&#x27;max&#x27;</span>,<span class="string">&#x27;min&#x27;</span>,<span class="string">&#x27;mean&#x27;</span>,<span class="string">&#x27;median&#x27;</span>,<span class="string">&#x27;std&#x27;</span>,<span class="string">&#x27;skew&#x27;</span>],flag)</span><br><span class="line">train = pd.merge(train, t, on=<span class="string">&#x27;ship&#x27;</span>, how=<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line">t = group_feature(df, <span class="string">&#x27;ship&#x27;</span>,<span class="string">&#x27;base_dis_diff&#x27;</span>,[<span class="string">&#x27;max&#x27;</span>,<span class="string">&#x27;min&#x27;</span>,<span class="string">&#x27;mean&#x27;</span>,<span class="string">&#x27;std&#x27;</span>,<span class="string">&#x27;skew&#x27;</span>],flag)</span><br><span class="line">train = pd.merge(train, t, on=<span class="string">&#x27;ship&#x27;</span>, how=<span class="string">&#x27;left&#x27;</span>)</span><br></pre></td></tr></table></figure>


<h4 id="4-构造Embedding特征"><a href="#4-构造Embedding特征" class="headerlink" title="4.构造Embedding特征"></a>4.构造Embedding特征</h4><p>word embedding就是将词映射到另外一个空间,相同类型的词在投影之后的向量空间距离更近,倾向于归到一起.</p>
<h5 id="4-1-Word2vec构造词向量"><a href="#4-1-Word2vec构造词向量" class="headerlink" title="4.1 Word2vec构造词向量"></a>4.1 Word2vec构造词向量</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tqdm(<span class="built_in">range</span>(num_runs)):</span><br><span class="line">    model = Word2Vec(sentences, size=embedding_size,</span><br><span class="line">                              min_count=min_count,</span><br><span class="line">                              workers=mp.cpu_count(),</span><br><span class="line">                              window=window_size,</span><br><span class="line">                              seed=seed, <span class="built_in">iter</span>=iters, sg=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    embedding_vec = []</span><br><span class="line">    <span class="keyword">for</span> ind, seq <span class="keyword">in</span> <span class="built_in">enumerate</span>(sentences):</span><br><span class="line">        seq_vec, word_count = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> seq:</span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> model:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                seq_vec += model[word]</span><br><span class="line">                word_count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> word_count == <span class="number">0</span>:</span><br><span class="line">            embedding_vec.append(embedding_size * [<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            embedding_vec.append(seq_vec / word_count)</span><br></pre></td></tr></table></figure>

<h5 id="4-2-NMF提取文本的主题分布"><a href="#4-2-NMF提取文本的主题分布" class="headerlink" title="4.2 NMF提取文本的主题分布"></a>4.2 NMF提取文本的主题分布</h5><p>TF-IDF是衡量字词的出现频率来定义其重要性的加权技术.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用tfidf对元素进行处理</span></span><br><span class="line">tfidf_vectorizer = TfidfVectorizer(ngram_range=(tf_n,tf_n))</span><br><span class="line">tfidf = tfidf_vectorizer.fit_transform(self.data[<span class="string">&#x27;title_feature&#x27;</span>].values)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用nmf算法，提取文本的主题分布</span></span><br><span class="line">text_nmf = NMF(n_components=self.nmf_n).fit_transform(tfidf)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Pandas</tag>
        <tag>Embedding</tag>
        <tag>Word2vec</tag>
        <tag>NMF</tag>
        <tag>DataFramte</tag>
      </tags>
  </entry>
  <entry>
    <title>特征选择_1</title>
    <url>/2021/03/20/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9_1/</url>
    <content><![CDATA[<p>在数据预处理过程中，特征选择是一个重要的过程，选择出重要的特征可以加快模型训练速度。通常可以从以下两方面来选择特征：</p>
<blockquote>
<p>1.特征是否发散（对于样本区分作用的大小）<br>2.特征与标签的相关性</p>
</blockquote>
<span id="more"></span>
<p>特征选择的方法主要有3种：</p>
<blockquote>
<p>1.Filter Method：先根据统计量设置阈值选择特征，之后再训练模型。<br>2.Wrapper Method：把最终将要使用的模型的性能作为特征子集的评价标准，多次训练模型选择有利于模型性能的特征子集。<br>3.Embedding Method：将特征选择过程与模型训练过程融为一体，在模型训练的过程中自动进行特征选择。</p>
</blockquote>
<p>常用sklearn中的feature_selection库来进行特征选择。</p>
<h4 id="1-Fliter-过滤法"><a href="#1-Fliter-过滤法" class="headerlink" title="1. Fliter 过滤法:"></a>1. Fliter 过滤法:</h4><blockquote>
<p>Fliter的优点在于只训练一次模型，速度快。但是选择与标签相关性最强的特征子集不一定是最佳特征，甚至可能对结果负优化。</p>
</blockquote>
<h5 id="1-1-方差选择法"><a href="#1-1-方差选择法" class="headerlink" title="1.1 方差选择法"></a>1.1 方差选择法</h5><p>计算各个特征的方差，设置阈值，选择方差大于阈值的特征。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> VarianceThreshold</span><br><span class="line"><span class="comment">#参数threshold为方差的阈值</span></span><br><span class="line">VarianceThreshold(threshold=<span class="number">3</span>).fit_transform(iris.data)</span><br></pre></td></tr></table></figure>

<h5 id="1-2-Pearson相关系数法"><a href="#1-2-Pearson相关系数法" class="headerlink" title="1.2 Pearson相关系数法"></a>1.2 Pearson相关系数法</h5><p>计算各个特征对于标签的Pearson相关系数和p值，选择前k名的特征。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> pearsonr</span><br><span class="line"><span class="comment">#参数k为选择的特征个数</span></span><br><span class="line">SelectKBest(<span class="keyword">lambda</span> X, Y: array(<span class="built_in">map</span>(<span class="keyword">lambda</span> x:pearsonr(x, Y), X.T)).T, k=<span class="number">2</span>).fit_transform(iris.data, iris.target)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Pearson法的缺陷在于只对线性相关敏感，对非线性关系不敏感。</p>
</blockquote>
<h5 id="1-3-卡方检验-互信息法等方法"><a href="#1-3-卡方检验-互信息法等方法" class="headerlink" title="1.3 卡方检验\互信息法等方法"></a>1.3 卡方检验\互信息法等方法</h5><p>也是用来评价X与y的相关性，先构建评价函数，再选择前K名的特征。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#chi2</span></span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> chi2</span><br><span class="line">SelectKBest(chi2, k=<span class="number">2</span>).fit_transform(iris.data, iris.target)</span><br><span class="line"></span><br><span class="line"><span class="comment">#MIC</span></span><br><span class="line"><span class="keyword">from</span> minepy <span class="keyword">import</span> MINE</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mic</span>(<span class="params">x, y</span>):</span></span><br><span class="line">     m = MINE()</span><br><span class="line">     m.compute_score(x, y)</span><br><span class="line">     <span class="keyword">return</span> (m.mic(), <span class="number">0.5</span>)</span><br><span class="line">SelectKBest(<span class="keyword">lambda</span> X, Y: array(<span class="built_in">map</span>(<span class="keyword">lambda</span> x:mic(x, Y), X.T)).T, k=<span class="number">2</span>).fit_transform(iris.data, iris.target)</span><br></pre></td></tr></table></figure>

<h4 id="2-Wrapper-包装法"><a href="#2-Wrapper-包装法" class="headerlink" title="2. Wrapper 包装法:"></a>2. Wrapper 包装法:</h4><blockquote>
<p>Wrapper的优点在于能够识别模型最适宜的特征子集，缺点在于训练多次模型，算法复杂性高，且特征子集不一定是<u>大多数解释变量</u>。</p>
</blockquote>
<p>Wrapper最具代表性的方法就是RFE递归消除特征法，即使用一个基模型来进行多轮训练，每轮训练都遍历所有特征，之后消除重要性(feature_importances_)低的特征，再基于新的特征集进行下一轮训练。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#RFE</span></span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> RFE</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line">rfe = RFE(estimator=LogisticRegression(), n_features_to_select=<span class="number">2</span>).fit_transform(iris.data, iris.target)</span><br><span class="line"></span><br><span class="line"><span class="comment">#RFECV</span></span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> RFECV</span><br><span class="line">rfecv = RFECV(estimator=svc, step=<span class="number">1</span>, cv=StratifiedKFold(<span class="number">2</span>), scoring=<span class="string">&#x27;roc_auc&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="3-Embedded-嵌入法"><a href="#3-Embedded-嵌入法" class="headerlink" title="3. Embedded 嵌入法"></a>3. Embedded 嵌入法</h4><h5 id="3-1-基于惩罚项的特征选择法"><a href="#3-1-基于惩罚项的特征选择法" class="headerlink" title="3.1 基于惩罚项的特征选择法"></a>3.1 基于惩罚项的特征选择法</h5><p>使用带惩罚项的基模型，除了筛选出特征外，同时也进行了降维。由于L1正则化会产生稀疏权值矩阵，所以其自带特征选择的特性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#L1正则</span></span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectFromModel</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line">SelectFromModel(LogisticRegression(penalty=<span class="string">&quot;l1&quot;</span>, C=<span class="number">0.1</span>)).fit_transform(iris.data, iris.target)</span><br><span class="line"></span><br><span class="line"><span class="comment">#L2正则</span></span><br><span class="line">SelectFromModel(LogisticRegression(penalty=<span class="string">&quot;l2&quot;</span>,threshold=<span class="number">0.5</span>, C=<span class="number">0.1</span>)).fit_transform(iris.data, iris.target)</span><br></pre></td></tr></table></figure>

<h5 id="3-2-基于树模型的特征选择法"><a href="#3-2-基于树模型的特征选择法" class="headerlink" title="3.2 基于树模型的特征选择法"></a>3.2 基于树模型的特征选择法</h5><p>树模型中GBDT也可用来作为基模型进行特征选择。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectFromModel</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> GradientBoostingClassifier</span><br><span class="line">SelectFromModel(GradientBoostingClassifier()).fit_transform(iris.data, iris.target)</span><br></pre></td></tr></table></figure>

<h4 id="4-基于SHAP值的特征筛选"><a href="#4-基于SHAP值的特征筛选" class="headerlink" title="4. 基于SHAP值的特征筛选"></a>4. 基于SHAP值的特征筛选</h4><p>SHAP是由Shapley value启发的可加性解释模型。对于每条样本，每个特征都会对应一个SHAP value值体现其对结果的贡献。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> shap</span><br><span class="line"><span class="comment"># 创建模型解释器</span></span><br><span class="line">explainer_xgb = shap.TreeExplainer(model1)</span><br><span class="line">explainer_lgb = shap.TreeExplainer(model2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取训练集每个样本每个特征特征的SHAP值，并对特征进行整体的可视化</span></span><br><span class="line">shape_values = explainer_lgb.shap_values(data[cols])</span><br><span class="line">shap.summary_plot(shape_values, data[cols], plot_type=<span class="string">&#x27;bar&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="5-基于对抗验证-Adversarial-Validation-的特征筛选"><a href="#5-基于对抗验证-Adversarial-Validation-的特征筛选" class="headerlink" title="5. 基于对抗验证(Adversarial Validation)的特征筛选"></a>5. 基于对抗验证(Adversarial Validation)的特征筛选</h4><p>常用于训练集与测试集相差非常大的情况。实现步骤：<br>1.将训练集和测试集合并，分别打上0和1的标签。<br>2.构建模型进行训练，逐个将特征输入模型，记录AUC。<br>3.最后将AUC高的特征删除(将测试和训练样本差别很大的特征删除)，通过删掉这些特征实现模型效果提升。</p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Embedding</tag>
        <tag>Wapper</tag>
        <tag>Filter</tag>
      </tags>
  </entry>
  <entry>
    <title>复盘｜天堂硅谷·数字经济算法编程大赛</title>
    <url>/2021/07/21/%E5%A4%8D%E7%9B%98%EF%BD%9C%E5%A4%A9%E5%A0%82%E7%A1%85%E8%B0%B7%C2%B7%E6%95%B0%E5%AD%97%E7%BB%8F%E6%B5%8E%E7%AE%97%E6%B3%95%E7%BC%96%E7%A8%8B%E5%A4%A7%E8%B5%9B/</url>
    <content><![CDATA[<h1 id="复盘｜天堂硅谷·数字经济算法编程大赛"><a href="#复盘｜天堂硅谷·数字经济算法编程大赛" class="headerlink" title="复盘｜天堂硅谷·数字经济算法编程大赛"></a>复盘｜天堂硅谷·数字经济算法编程大赛</h1><h3 id="题目-01-化学反应"><a href="#题目-01-化学反应" class="headerlink" title="题目-01 化学反应"></a>题目-01 <a href="https://leetcode.cn/contest/hhrc2022/problems/o0Ma2v/">化学反应</a></h3><p>【模拟】按题意模拟（可以用大根堆或者平衡树），每次找两个最大的出来，直到没有剩余或只剩一个。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#平衡树</span></span><br><span class="line"><span class="keyword">from</span> sortedcontainers <span class="keyword">import</span> SortedList</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastMaterial</span>(<span class="params">self, material: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        s = SortedList(material)</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(s) &gt; <span class="number">1</span>:</span><br><span class="line">            a, b = s.pop(), s.pop()</span><br><span class="line">            <span class="keyword">if</span> a != b: s.add(a - b)</span><br><span class="line">        <span class="keyword">return</span> s[<span class="number">0</span>] <span class="keyword">if</span> s <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#大根堆</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastMaterial</span>(<span class="params">self, material: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        h = [-m <span class="keyword">for</span> m <span class="keyword">in</span> material]</span><br><span class="line">        heapify(h)</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(h) &gt; <span class="number">1</span>:</span><br><span class="line">            a, b = heappop(h), heappop(h)</span><br><span class="line">            <span class="keyword">if</span> a != b: heappush(h, a - b)</span><br><span class="line">        <span class="keyword">return</span> -h[<span class="number">0</span>] <span class="keyword">if</span> h <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="题目-02-销售出色区间"><a href="#题目-02-销售出色区间" class="headerlink" title="题目-02 销售出色区间"></a>题目-02 <a href="https://leetcode.cn/contest/hhrc2022/problems/0Wx4Pc/">销售出色区间</a></h3><p>【前缀和 + 单调栈】把销售产品&gt;8的天数当成增1，&lt;=8的天数当成减1，判断的同时把前缀和算出来，寻找最长presum[i] - presum[j] &gt;0的区间。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestESR</span>(<span class="params">self, sales: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(sales)</span><br><span class="line">        presum = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            presum[i] = presum[i - <span class="number">1</span>] + <span class="number">1</span> <span class="keyword">if</span> sales[i - <span class="number">1</span>] &gt; <span class="number">8</span> <span class="keyword">else</span> presum[i - <span class="number">1</span>] - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        st = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> presum[i] &lt; presum[st[-<span class="number">1</span>]]:</span><br><span class="line">                st.append(i)</span><br><span class="line">                </span><br><span class="line">        j = n</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> j &gt; ans:</span><br><span class="line">            <span class="keyword">while</span> st <span class="keyword">and</span> presum[j] &gt; presum[st[-<span class="number">1</span>]]:</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, j - st[-<span class="number">1</span>])</span><br><span class="line">                st.pop()</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="题目-03-重复的彩灯树"><a href="#题目-03-重复的彩灯树" class="headerlink" title="题目-03 重复的彩灯树"></a>题目-03 <a href="https://leetcode.cn/contest/hhrc2022/problems/VAc7h3/">重复的彩灯树</a></h3><p>【二叉树的序列化】在先序的位置递归序列化每棵树，每次用哈希表计数并找到重复次数为2的子树。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lightDistribution</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">Optional</span>[TreeNode]]:</span></span><br><span class="line">        d, res = defaultdict(<span class="built_in">int</span>), []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span></span><br><span class="line">            left, right = dfs(node.left), dfs(node.right)</span><br><span class="line">            subTree = left + <span class="string">&#x27;,&#x27;</span> + right + <span class="string">&#x27;,&#x27;</span> + <span class="built_in">str</span>(node.val)</span><br><span class="line">            <span class="keyword">if</span> d[subTree] == <span class="number">1</span>: res.append(node)</span><br><span class="line">            d[subTree] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> subTree</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="题目-04-补给覆盖"><a href="#题目-04-补给覆盖" class="headerlink" title="题目-04 补给覆盖"></a>题目-04 <a href="https://leetcode.cn/contest/hhrc2022/problems/wFtovi/">补给覆盖</a></h3><p>【后序遍历递归】对于每个root，一共有三种状态，状态0：没覆盖其他节点也没被覆盖；状态1：被覆盖了；状态2：覆盖其他节点。（空节点不需要覆盖别人也不需要被覆盖，默认状态1即可。）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSupplyStationNumber</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            left, right = dfs(node.left), dfs(node.right)</span><br><span class="line">            <span class="keyword">nonlocal</span> ans</span><br><span class="line">            <span class="keyword">if</span> left == <span class="number">0</span> <span class="keyword">or</span> right == <span class="number">0</span>:</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> left == <span class="number">2</span> <span class="keyword">or</span> right == <span class="number">2</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left == <span class="number">1</span> <span class="keyword">and</span> right == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> dfs(root) == <span class="number">0</span>: ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>复盘｜「天池 X LeetCode」在线编程专场选拔赛</title>
    <url>/2021/07/22/%E5%A4%8D%E7%9B%98%EF%BD%9C%E3%80%8C%E5%A4%A9%E6%B1%A0%20X%20LeetCode%E3%80%8D%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E4%B8%93%E5%9C%BA%E9%80%89%E6%8B%94%E8%B5%9B/</url>
    <content><![CDATA[<h1 id="复盘｜「天池-X-LeetCode」在线编程专场选拔赛"><a href="#复盘｜「天池-X-LeetCode」在线编程专场选拔赛" class="headerlink" title="复盘｜「天池 X LeetCode」在线编程专场选拔赛"></a>复盘｜「天池 X LeetCode」在线编程专场选拔赛</h1><h3 id="统计链表奇数节点"><a href="#统计链表奇数节点" class="headerlink" title="统计链表奇数节点"></a><a href="https://leetcode.cn/contest/tianchi2022/problems/yGdjWb/">统计链表奇数节点</a></h3><p>【一次遍历】遍历即可，小技巧是ans直接加0/1结果，省去if判断这一步。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numberEvenListNode</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            ans += head.val &amp; <span class="number">1</span></span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="光线反射"><a href="#光线反射" class="headerlink" title="光线反射"></a><a href="https://leetcode.cn/contest/tianchi2022/problems/8KXuKl/">光线反射</a></h3><p>【模拟】用DIRS数组存↑↓←→（对应0123四种状态）。由题意，碰到向左倾斜的镜面，←↑是一对，↓→是一对，可以通过异或操作来转换两种状态（状态 xor 2 即可，总共0123四种方向，0 xor 2=2，2 xor 2 = 0，1 xor 2 = 3，3 xor 2 = 1）；碰到向右倾斜的镜面，↓←是一对，↑→是一对，同理，状态 xor 3。初始x,y = (0,0)，d = 1即DIR = (1,0)，然后开始模拟。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLength</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="built_in">str</span>], DIRS = (<span class="params">(<span class="params">-<span class="number">1</span>, <span class="number">0</span></span>), (<span class="params"><span class="number">1</span>, <span class="number">0</span></span>), (<span class="params"><span class="number">0</span>, -<span class="number">1</span></span>), (<span class="params"><span class="number">0</span>, <span class="number">1</span></span>)</span>)</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n, m = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        ans = x = y = <span class="number">0</span></span><br><span class="line">        d = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">0</span> &lt;= x &lt; n <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; m:</span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> grid[x][y] == <span class="string">&#x27;L&#x27;</span>: d ^= <span class="number">2</span></span><br><span class="line">            <span class="keyword">elif</span> grid[x][y] == <span class="string">&#x27;R&#x27;</span>: d ^= <span class="number">3</span></span><br><span class="line">            x += DIRS[d][<span class="number">0</span>]</span><br><span class="line">            y += DIRS[d][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="整理书架"><a href="#整理书架" class="headerlink" title="整理书架"></a><a href="https://leetcode.cn/contest/tianchi2022/problems/ev2bru/">整理书架</a></h3><p>【单调栈】要求次数尽可能少，所以要把所有出现次数大于limit的元素，删除知道出现次数=limit。要求字典序最小，所以从左往右遍历如果找到更小数字就把前面更大的数去掉。用单调栈模拟，遍历的同时，要保证栈里的元素出现次数不超过limit，如果后面没有足够的元素，也不能让元素出现次数低于limit，如果遇到比栈顶小的元素，可以出栈。代码中，入栈时候要看后面有没有足够元素。如果没足够元素（cnt[x] = limit）就continue，如果栈顶比x大且栈顶 元素也够则可以出栈。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">arrangeBookshelf</span>(<span class="params">self, order: <span class="type">List</span>[<span class="built_in">int</span>], limit: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        left, st, cnt_st = Counter(order), [<span class="number">0</span>], Counter()</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> order:</span><br><span class="line">            <span class="keyword">if</span> cnt_st[x] == limit:</span><br><span class="line">                left[x] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">while</span> st[-<span class="number">1</span>] &gt; x <span class="keyword">and</span> left[st[-<span class="number">1</span>]] &gt; limit:</span><br><span class="line">                left[st[-<span class="number">1</span>]] -= <span class="number">1</span></span><br><span class="line">                cnt_st[st[-<span class="number">1</span>]] -= <span class="number">1</span></span><br><span class="line">                st.pop()</span><br><span class="line">            st.append(x)</span><br><span class="line">            cnt_st[x] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> st[<span class="number">1</span>:]</span><br></pre></td></tr></table></figure>

<h3 id="意外惊喜"><a href="#意外惊喜" class="headerlink" title="意外惊喜"></a><a href="https://leetcode.cn/contest/tianchi2022/problems/tRZfIV/">意外惊喜</a></h3><p>【贪心 + 分治 + 01背包】由于题中说每个礼物包里的礼物价值非严格递增，所以可证不存在选了两个数组但都没有选完的情况，之多只有一个数组没有选完，其余要么整个数组都选，要么都不选。枚举这个没选完的数组，其余的转为01背包（整个数组和当作一个物品的价值，数组长度当作物品体积）。为了优化时间复杂度，需要用分治来优化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">brilliantSurprise</span>(<span class="params">self, present: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], limit: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans, dp = <span class="number">0</span>, [<span class="number">0</span>] * (<span class="number">1</span> + limit)</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">a, tot</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> dp, ans</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(a) == <span class="number">1</span>:</span><br><span class="line">                sm = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(a[<span class="number">0</span>]):</span><br><span class="line">                    <span class="keyword">if</span> i &gt;= limit: <span class="keyword">break</span></span><br><span class="line">                    sm += x</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, dp[limit - (i + <span class="number">1</span>)] + sm)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">            tmp, m = dp.copy(), <span class="built_in">len</span>(a) // <span class="number">2</span></span><br><span class="line">            left, right = a[:m], a[m:]</span><br><span class="line">            <span class="keyword">for</span> i, row <span class="keyword">in</span> <span class="built_in">enumerate</span>(left):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(limit, <span class="built_in">len</span>(row) - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j], dp[j - <span class="built_in">len</span>(row)] + tot[i])</span><br><span class="line">            f(right, tot[m:])</span><br><span class="line">            </span><br><span class="line">            dp = tmp</span><br><span class="line">            <span class="keyword">for</span> i, row <span class="keyword">in</span> <span class="built_in">enumerate</span>(right, m):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(limit, <span class="built_in">len</span>(row) - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j], dp[j - <span class="built_in">len</span>(row)] + tot[i])</span><br><span class="line">            f(left, tot[:m])</span><br><span class="line">            </span><br><span class="line">        tot = [<span class="built_in">sum</span>(a) <span class="keyword">for</span> a <span class="keyword">in</span> present]</span><br><span class="line">        f(present, tot)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM总结(一) - 内存区域与内存管理</title>
    <url>/2021/08/26/JVM%E6%80%BB%E7%BB%93(%E4%B8%80)%20-%20%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="JVM总结-一-内存区域与内存管理"><a href="#JVM总结-一-内存区域与内存管理" class="headerlink" title="JVM总结(一) - 内存区域与内存管理"></a>JVM总结(一) - 内存区域与内存管理</h1><ul>
<li><a href="#%E4%B8%80jvm%E5%90%AF%E5%8A%A8%E4%BB%A5%E5%8F%8Ajvm%E4%BD%93%E7%B3%BB%E6%A6%82%E8%BF%B0">一、JVM启动以及JVM体系概述</a><ul>
<li><a href="#1jvm%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B">1、JVM启动流程</a></li>
<li><a href="#2jvm%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">2、JVM体系结构</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%80%BB%E4%BD%93%E6%A6%82%E6%8B%AC">二、运行时数据区总体概括</a><ul>
<li><a href="#1%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8">1、程序计数器</a></li>
<li><a href="#2java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88">2、Java虚拟机栈</a></li>
<li><a href="#3%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88">3、本地方法栈</a></li>
<li><a href="#4java%E5%A0%86">4、Java堆</a></li>
<li><a href="#5%E6%96%B9%E6%B3%95%E5%8C%BA">5、方法区</a></li>
<li><a href="#6%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0">6、运行时常量池</a></li>
<li><a href="#7%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98-%E4%B8%8D%E6%98%AF%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86">7、直接内存-不是运行时数据区域的一部分</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%85%B3">三、对象相关</a><ul>
<li><a href="#1%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B">1、对象的创建过程</a></li>
<li><a href="#2%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80">2、对象的内存布局</a></li>
<li><a href="#3%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D">3、对象的访问定位</a></li>
</ul>
</li>
</ul>
<hr>
<h2 id="一、JVM启动以及JVM体系概述"><a href="#一、JVM启动以及JVM体系概述" class="headerlink" title="一、JVM启动以及JVM体系概述"></a>一、JVM启动以及JVM体系概述</h2><p>概括: </p>
<ul>
<li>Java有<strong>Java编译器和Java虚拟机</strong>，编译器将Java源代码转换为<code>.class</code>文件，虚拟机加载并运行<code>.class</code>文件。</li>
<li>Java 的开发遵循“一次编写到处乱跑”理念，它运行在 VM（虚拟机）上。</li>
</ul>
<h3 id="1、JVM启动流程"><a href="#1、JVM启动流程" class="headerlink" title="1、JVM启动流程"></a>1、JVM启动流程</h3><p>JVM工作原理和特点主要是指操作系统装入JVM，是通过<code>jdk</code>中<code>java.exe</code>来完成,通过下面4步来完成JVM环境: </p>
<ul>
<li>创建JVM装载环境和配置；</li>
<li>装载<code>JVM.dll</code>；</li>
<li>初始化<code>JVM.dll</code>并挂界到<code>JNIENV</code>(JNI调用接口)实例；</li>
<li>调用<code>JNIEnv</code>实例装载并处理class类。</li>
</ul>
<p><img src="images/j1_jvm%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png" alt="jvm启动流程.png"></p>
<h3 id="2、JVM体系结构"><a href="#2、JVM体系结构" class="headerlink" title="2、JVM体系结构"></a>2、JVM体系结构</h3><p>JVM体系主要是两个JVM的内部体系结构，分为三个子系统和两大组件，分别是：</p>
<ul>
<li><strong>类装载器（ClassLoader）子系统、执行引擎子系统和GC子系统</strong>；</li>
<li>组件是<strong>内存运行数据区域</strong>和<strong>本地接口</strong>。</li>
</ul>
<p><strong>详细的结构: (<a href="https://zhuanlan.zhihu.com/p/28347393">图片来源以及详细解释</a>)</strong></p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/28347393">https://zhuanlan.zhihu.com/p/28347393</a></p>
</blockquote>
<p><img src="images/j3_%E8%AF%A6%E7%BB%86%E7%BB%93%E6%9E%84.png" alt="在这里插入图片描述"></p>
<h2 id="二、运行时数据区总体概括"><a href="#二、运行时数据区总体概括" class="headerlink" title="二、运行时数据区总体概括"></a>二、运行时数据区总体概括</h2><p><font color = green>运行时数据区:</p>
<ul>
<li>经过编译生成的字节码文件（class文件），由 <code>class loader</code>（类加载子系统）加载后交给执行引擎执行。</li>
<li>在执行引擎执行的过程中产生的数据会存储在一块内存区域。这块内存区域就是运行时区域。</li>
</ul>
<p>运行时数据区总体框架图: </p>
<p><img src="images/j2_%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="在这里插入图片描述"></p>
<p>总体概括</p>
<ul>
<li><p>堆:  存放Java 对象， <strong>线程之间共享</strong>的；</p>
</li>
<li><p>栈: 方法运行，每一个方法对应一个栈帧，每一个线程对应一个栈；每个栈由包括 <strong>操作数、局部变量表、指向运行时常量池的引用，方法返回地址、附加位区</strong>；所以是<strong>线程不共享</strong> (这个就是栈的宽度)(而栈的深度就是栈帧的个数)；</p>
</li>
<li><p>方法区 (静态区) : 被虚拟机加载的<strong>类信息、静态 (static) 变量，常量 (final) ，即时编译器编译后的代码等数据</strong>。运行常量池是方法区的一部分，class文件除了有类的版本、字段、接口、方法等描述信息之外，还有一项信息常量池保存缩译期生成的字面量和符号引用。 <strong>线程之间共享的。</strong></p>
</li>
<li><p>程序计数器: 指出某一个时候执行某一个指令、执行完毕之后要返回的位置，当执行的Java方法的时候，这里保存的当前执行的地址，如果执行的是本地方法，那么程序计数器为空。<strong>线程不共享</strong>。</p>
</li>
</ul>
<p><strong>划分线程共享和线程独占和线程共享的原因:</strong></p>
<p>先熟悉一下一个一般性的 Java 程序的工作过程。</p>
<ul>
<li><p>一个 Java 源程序文件，会被编译为字节码文件(以 class 为扩展名) ，每个java程序都需要运行在自己的JVM上；</p>
</li>
<li><p>然后告知 JVM 程序的运行入口，再被 JVM 通过字节码解释器加载运行。那么程序开始运行后，都是如何涉及到各内存区域的呢?</p>
</li>
<li><p>概括地说来，JVM初始运行的时候都会分配好 <code>Method Area</code> (方法区) 和<code>Heap</code> (堆) ，而JVM 每遇到一个线程，就为其分配一个 <code>Program Counter Register</code> (程序计数器) ，<code>VM Stack</code> (虚拟机栈) 和<code>Native Method Stack</code> (本地方法栈) ， 当线程终止时，三者(虚拟机栈，本地方法栈和程序计数器) 所占用的内存宝间也会被释放掉。这也是为什么我们把内存区域分为线程共享和非线程共享的原因，<strong>非线程共享的那三个区域的生命周周期与所属线程相同，而线程共享的区域与JAVA程序运行的生命周期相同，</strong>所以这也是系统垃圾回收的场所只发生在<strong>线程共享的区域</strong> (实际上对大部分虚拟机来说发生在Heap上) 的原因。</p>
</li>
</ul>
<h3 id="1、程序计数器"><a href="#1、程序计数器" class="headerlink" title="1、程序计数器"></a>1、程序计数器</h3><ul>
<li> 程序计数器是一块较小的内存区域，它可以看做是<strong>当前线程所执行的字节码的行号指示器；</strong></li>
<li> 程序计数器处于<strong>线程独占区</strong>(每一个线程都有一个独立的程序计数器)，各计数器不影响；</li>
<li> 如果线程正在执行的是一个Java方法，这个计数器记录的是<strong>正在执行的虚拟机的字节码指令的地址</strong>，如果线程正在执行的是一个本地Native方法，则计数器值为空；</li>
<li> 此内存区域是唯一一个在Java虚拟机规范没有规定任何OutOfMemoryError的区域;</li>
</ul>
<h3 id="2、Java虚拟机栈"><a href="#2、Java虚拟机栈" class="headerlink" title="2、Java虚拟机栈"></a>2、Java虚拟机栈</h3><ul>
<li>Java虚拟机栈描述的是<strong>Java方法执行的动态内存模型；</strong></li>
<li>栈帧: 每个方法执行都会创建一个栈帧，伴随着方法从创建到执行完成，<strong>用于存储局部变量表，操作数栈，动态链接，方法出口等；</strong></li>
<li>局部变量表 : <code>a.</code>存放编译期可知的各种基本数据类型，引用类型，returnAddress类型；<code>b.</code>局部变量表的内存空间在编译器完成分配，当进入一个方法时，这个方法需要在栈桢中分配多少内存是固定的，在方法运行期间不会改变局部变量表的大小；</li>
<li>也会有StackOverFlowError (线程请求的栈深度大于虚拟机允许的深度)，OutOfMemoryError(没有足够的内存) ;</li>
</ul>
<p><img src="images/j4_%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8.png" alt="在这里插入图片描述"><br><img src="images/j5_%E6%A0%88%E6%A1%A2.png"></p>
<blockquote>
<p><strong>局部变量表存放了编译期可知的各种基本数据类型 (boolean、byte、char、short、int、</strong><br><strong>float、long、double)、对象引用 〈reference 类型</strong>，它不等同于对象本身，可能是一个指向对<br>象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置) 和<br>TeturnAddress 类型〈指向了一条字节码指令的地址)。</p>
<p>其中 64 位长度的 long 和 double 类型的数据会占用 2 个局部变量空间 (Slot)，其余的数<br>据类型只占用 1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，<br>这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部<br>变量表的大小。</p>
<p>在 Java 虚拟机规范中，对这个区域规定了两种异常状况: 如果线程请求的栈深度大于虚<br>拟机所允许的深度，将抛出 StackOverowError 异常 ， 如果虚拟机栈可以动态扩展〈当前大<br>部分的 Java 虚拟机都可动态扩展，只不过 Java 虚拟机规范中也允许固定长度的虚拟机栈)，<br>如果扩展时无法申请到足够的内存，就会抛出 OutOftMemoryError 异常。</p>
</blockquote>
<h3 id="3、本地方法栈"><a href="#3、本地方法栈" class="headerlink" title="3、本地方法栈"></a>3、本地方法栈</h3><p>本地方法栈 (Native Method Stack) 与虚拟机栈所发挥的作用是非常相似的: </p>
<ul>
<li>它们之间的区别不过是<strong>虚拟机栈为虚拟机执行 Java 方法〈也就是字节码) 服务，而本地方法栈则为</strong></li>
</ul>
<p><strong>虚拟机使用到的 Native 方法服务。</strong></p>
<ul>
<li>在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机。(璧如Sun HotSpot 虚拟机直接就把本地方法栈和虚拟机栈合二为一)。</li>
<li>与虚拟机栈一样，本地方法栈区域也会抛出 StackOverflowError 和 OutOfMemoryError 异常。</li>
</ul>
<h3 id="4、Java堆"><a href="#4、Java堆" class="headerlink" title="4、Java堆"></a>4、Java堆</h3><ul>
<li>Java虚拟机所管理的内存中最大的一块区域，是被所有<strong>线程共享</strong>的一块区域；</li>
<li>几乎所有的对象实例都在这里分配内存(<strong>所有的对象实例以及数组</strong>)；</li>
<li>Java堆是垃圾收集器管理的主要区域，<strong>大部分收集器基于分代收集: 分为新生代和老生代</strong>，甚至更加的细分为<code>Eden</code>空间，<code>From Survivor</code>空间，<code>To Survivor</code>空间，这样分配的目的是为了更好的回收内存和分配内存；</li>
<li>Java堆可以处理物理上不连续，但是逻辑上连续的内存空间；现在的虚拟机可以通过Xms和<br>Xmx等来扩展大小；</li>
<li>如果堆中已经没有内存来分本实例，并且堆没法扩展，就会报出OutofMemoryError异常;</li>
</ul>
<p><img src="https://img-blog.csdn.net/20181018085014307?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p>
<h3 id="5、方法区"><a href="#5、方法区" class="headerlink" title="5、方法区"></a>5、方法区</h3><ul>
<li>是线程共享区;</li>
<li>存储的是虚拟机<strong>加载的类信息，常量，静态变量，即时编译器编译后的代码等数据</strong>；</li>
<li>其中类信息包括: <strong>类的版本，字段，方法，接口</strong>等；</li>
<li>方法区 <code>!=</code> 永久代，HotSpot使用永久代实现方法区，这样HotSpot的垃圾收集器可以像管理Java推</li>
</ul>
<p>一样来管理这块内存区域，省去专门为方法区编写内存管理代码的工作；</p>
<ul>
<li>根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError 异常。</li>
</ul>
<blockquote>
<p>JDK6时，String等常量信息至于方法区，JDK7时，已经移动到堆；</p>
</blockquote>
<blockquote>
<p>Java 虚拟机规范对方法区的限制非常宽松，除了和 Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，<strong>还可以选择不实现垃圾收集</strong>。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这区域的内存回收目标主要是针对常量池的回收和对类型的印载，一般来说，这个区域的回收“成绩”比较难以令人满意，尤其是类型的印载，条件相当苛刻，但是这部分区域的回收确实是必要的。在 Sun 公司的 BUG 列表中，曾出现过的若干个严重的 BUG 就是由于低版本的 HotSpot 虚拟机对此区域未完全回收而导致内存汇漏。</p>
</blockquote>
<blockquote>
<p> 关于元空间:  元空间的本质和永久代类似，都是对JVM规范中方法区的实现，不过元空间和永久代之间最大的差别在于: <font color = blue><strong>元空间并不在虚拟机中，而是使用本地内存</strong>。因此，默认情况下，元空间的大小仅受本地内存限制。</p>
</blockquote>
<h3 id="6、运行时常量池"><a href="#6、运行时常量池" class="headerlink" title="6、运行时常量池"></a>6、运行时常量池</h3><ul>
<li>用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区</li>
</ul>
<p>的运行时常量池中存放；</p>
<ul>
<li>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不</li>
</ul>
<p>要求常量一定只有编译器才能产生，运行期间也可能将新的常量放入池中，例如<code>intern()</code>。</p>
<ul>
<li>常量池无法再申请到内存时，也会抛出OutOfMemoryError异常;</li>
</ul>
<p>对<code>intern()</code>测试:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;abc&quot;</span>;  <span class="comment">//字节码常量</span></span><br><span class="line">        String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s1 == s3);</span><br><span class="line"></span><br><span class="line">        System.out.println(s1 == s3.intern()); <span class="comment">//true   运行时常量</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码的内存分配如下:  </p>
<p><img src="https://img-blog.csdn.net/20180909175633908?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h3 id="7、直接内存-不是运行时数据区域的一部分"><a href="#7、直接内存-不是运行时数据区域的一部分" class="headerlink" title="7、直接内存-不是运行时数据区域的一部分"></a>7、直接内存-不是运行时数据区域的一部分</h3><p>直接内存 (Direct Memory) 并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError 异常出现。</p>
<p>在JDK 1.4中新加入了NIO (New InputOutput) 类，引入了一种基于通道 (Channel)与缓冲区 (Buffer) 的 IO 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</p>
<p>显然，<strong>本机直接内存的分配不会受到 Java 堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存〈包括 RAM 以及SWAP 区或者分页文件) 大小以及处理器寻址空间的限制</strong>。服务器管理员在配置虚拟机参数时，会根据实际内存设置<code>-Xmx</code>等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制包括物理的和操作系统级的限制)，从而导致动态扩展时出现 OutOfMemoryError 异常。</p>
<h2 id="三、对象相关"><a href="#三、对象相关" class="headerlink" title="三、对象相关"></a>三、对象相关</h2><h3 id="1、对象的创建过程"><a href="#1、对象的创建过程" class="headerlink" title="1、对象的创建过程"></a>1、对象的创建过程</h3><h4 id="1-、对象的内存分配"><a href="#1-、对象的内存分配" class="headerlink" title="1)、对象的内存分配"></a>1)、对象的内存分配</h4><p><img src="images/j6_%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B.png" alt="这里写图片描述"></p>
<p>虚拟机在堆中分配内存有两种方式:  </p>
<p><strong>指针碰撞</strong></p>
<p>假设 Java 堆中内存是绝对规整的，<strong>所有用过的内存都放在一边，空闲的内存放在另一边</strong>，中间放着一个指针作为分界点的<strong>指示器</strong>，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为”指针碰撞”(<code>Bump the Pointer</code>)。</p>
<p><strong>空闲列表</strong></p>
<p>如果 Java 堆中的内存并不是规整的，<strong>已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的</strong>，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为”空闲列表”(Free List)。</p>
<p>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
<blockquote>
<p>因此，在使用 Serial、ParNew 等带 Compact 过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS 这种基于 Mark-Sweep 算法的收集器时，通常采用空闲列表。</p>
</blockquote>
<h4 id="2-、线程安全问题"><a href="#2-、线程安全问题" class="headerlink" title="2)、线程安全问题"></a>2)、线程安全问题</h4><p>除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，<strong>在并发情况下也并不是线程安全的</strong>，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。</p>
<p>解决这个问题有两种方案:</p>
<ul>
<li>一种是对分配内存空间的动作**进行同步处理(加锁)**一 实际上虚拟机采用 <code>CAS</code> 配上失败重试的方式保证更新操作的原子性；</li>
<li>另一种是<strong>把内存分配的动作按照线程划分在不同的空间之中进行</strong>，即每个线程在 Java堆中预先分配一小块内存，称为<strong>本地线程分配缓冲</strong>(Thread Local Allocation Buffer，TLAB)。 哪个线程要分配内存，就在哪个线程的TEAB 上分配； 只有 TEAB 用完并分配新的 TLAB 时，才需要同步锁定。虚拟机是否使用TEAB，可以通过<code>-XX:+/-UseTLAB</code> 参数来设定。            </li>
</ul>
<h4 id="3-、初始化对象"><a href="#3-、初始化对象" class="headerlink" title="3)、初始化对象"></a>3)、初始化对象</h4><p>内存分配完成后，虚拟机需要将分配到的内在空间都初始化为零值 (不包括对象头)，如果使用<code>TLAB</code>，这一工作过程也可以提前至 TLAB 分配时进行。这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<p>接下来，<strong>虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息</strong>。这些信息存放在对象的对象头 (Object Header) 之中。根据虚拟机当前的运行状态的不同。如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<h4 id="4-、调用对象的构造方法"><a href="#4-、调用对象的构造方法" class="headerlink" title="4)、调用对象的构造方法"></a>4)、调用对象的构造方法</h4><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚刚开始:</p>
<ul>
<li>即<code>&lt;init&gt;</code>方法还没有执行，所有的字段都还为零。</li>
<li>所以一般来说( 由字节码中是否跟随<code>invokespecial</code> 指令所决定)，执行 <code>new</code>s 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</li>
</ul>
<h3 id="2、对象的内存布局"><a href="#2、对象的内存布局" class="headerlink" title="2、对象的内存布局"></a>2、对象的内存布局</h3><p>对象在内存中存储的布局可以分为3块区域: <strong>对象头、实例数据和对其填充</strong>。</p>
<h4 id="1-、对象头-Header"><a href="#1-、对象头-Header" class="headerlink" title="1)、对象头(Header)"></a>1)、对象头(Header)</h4><ul>
<li>自身的运行数据(Mark Word):<ul>
<li>包括: 哈希值、GC分代年龄，锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳；</li>
</ul>
</li>
<li>类型指针: 通过这个指针来确定这个对象是哪个类的实例；</li>
</ul>
<h4 id="2-、实例数据-InstanceData"><a href="#2-、实例数据-InstanceData" class="headerlink" title="2)、实例数据(InstanceData)"></a>2)、实例数据(InstanceData)</h4><ul>
<li>实例数据是对象真正存储的有效信息；</li>
<li>也是程序代码中所定义的各种类型的字段内容；</li>
</ul>
<h4 id="3-、对齐填充-Paddings"><a href="#3-、对齐填充-Paddings" class="headerlink" title="3)、对齐填充(Paddings)"></a>3)、对齐填充(Paddings)</h4><ul>
<li>对齐填充并不是必然存在的，也没有特别的含义；</li>
<li>仅仅起着占位符的作用；</li>
</ul>
<h3 id="3、对象的访问定位"><a href="#3、对象的访问定位" class="headerlink" title="3、对象的访问定位"></a>3、对象的访问定位</h3><p>对象访问方式取决于虚拟机实现而定的。目前主流的访问方式有使用句柄和直接指针两种。</p>
<ul>
<li>句柄访问</li>
<li>直接指针</li>
</ul>
<h4 id="1-、句柄访问"><a href="#1-、句柄访问" class="headerlink" title="1)、句柄访问"></a>1)、句柄访问</h4><ul>
<li>如果使用句柄访问的话，那么 Java 堆中将会划分出一块内存来作为句柄池，<code>reference</code>中存储的就是对象的句柄地址；</li>
<li>而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</li>
</ul>
<p>如图:</p>
<p><img src="images/j7_%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE.png" alt="这里写图片描述"></p>
<h4 id="2-、直接指针"><a href="#2-、直接指针" class="headerlink" title="2)、直接指针"></a>2)、直接指针</h4><ul>
<li>如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息。</li>
<li>而<code>reference</code>中存储的直接就是<strong>对象地址</strong>。</li>
</ul>
<p><img src="images/j8_%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.png" alt="这里写图片描述"></p>
<h4 id="3-、各自的优势"><a href="#3-、各自的优势" class="headerlink" title="3)、各自的优势"></a>3)、各自的优势</h4><p>这两种对象访问方式各有优势。</p>
<p>使用句柄来访问的最大好处就是 <code>reference</code> 中<strong>存储的是稳定的句柄地址</strong>，在对象被移动垃圾收集时移动对象是非常普遍的行为) 时<strong>只会改变句柄中的实例数据指针，而 reference 本身不需要修改</strong>。</p>
<p>使用直接指针访问方式的最大好处就是<strong>速度更快</strong>，它节省了一次指针定位的时间开销，由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM Architecture</tag>
        <tag>Heap Memory</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM总结(二) - 垃圾收集器与内存分配策略</title>
    <url>/2021/09/05/JVM%E6%80%BB%E7%BB%93(%E4%BA%8C)%20-%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h1 id="JVM总结-二-垃圾收集器与内存分配策略"><a href="#JVM总结-二-垃圾收集器与内存分配策略" class="headerlink" title="JVM总结(二) - 垃圾收集器与内存分配策略"></a>JVM总结(二) - 垃圾收集器与内存分配策略</h1><ul>
<li><a href="#%E4%B8%80%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0">一、垃圾回收概述</a></li>
<li><a href="#%E4%BA%8C%E5%A6%82%E4%BD%95%E5%88%A4%E5%AE%9A%E5%AF%B9%E8%B1%A1%E4%B8%BA%E5%9E%83%E5%9C%BE%E5%AF%B9%E8%B1%A1">二、如何判定对象为垃圾对象</a><ul>
<li><a href="#1%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95">1、引用计数法</a></li>
<li><a href="#2%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95">2、可达性分析算法</a></li>
<li><a href="#3%E5%BC%95%E7%94%A8%E5%88%86%E7%B1%BB">3、引用分类</a></li>
<li><a href="#4%E7%94%9F%E5%AD%98%E8%BF%98%E6%98%AF%E6%AD%BB%E4%BA%A1-finalize%E6%96%B9%E6%B3%95">4、生存还是死亡-finalize()方法</a></li>
<li><a href="#5%E5%9B%9E%E6%94%B6%E6%96%B9%E6%B3%95%E5%8C%BA">5、回收方法区</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95">三、垃圾回收算法</a><ul>
<li><a href="#1%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95">1、标记清除算法</a></li>
<li><a href="#2%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95">2、复制算法</a></li>
<li><a href="#3%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95">3、标记整理算法</a></li>
<li><a href="#4%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95">4、分代收集算法</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8">四、垃圾收集器</a><ul>
<li><a href="#1%E5%90%84%E4%B8%AA%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E8%81%94%E7%B3%BB">1、各个垃圾收集器的联系</a></li>
<li><a href="#2serial%E6%94%B6%E9%9B%86%E5%99%A8">2、Serial收集器</a></li>
<li><a href="#3parnew%E6%94%B6%E9%9B%86%E5%99%A8">3、ParNew收集器</a></li>
<li><a href="#4parallel-scavenge%E6%94%B6%E9%9B%86%E5%99%A8">4、Parallel Scavenge收集器</a></li>
<li><a href="#5serial-old%E6%94%B6%E9%9B%86%E5%99%A8">5、Serial Old收集器</a></li>
<li><a href="#6paralell-old%E6%94%B6%E9%9B%86%E5%99%A8">6、Paralell Old收集器</a></li>
<li><a href="#7cms%E6%94%B6%E9%9B%86%E5%99%A8">7、CMS收集器</a></li>
<li><a href="#8g1%E6%94%B6%E9%9B%86%E5%99%A8">8、G1收集器</a></li>
<li><a href="#9%E5%90%84%E7%A7%8D%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E7%9A%84%E5%AF%B9%E6%AF%94">9、各种垃圾收集算法的对比</a></li>
</ul>
</li>
<li><a href="#%E5%85%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5">五、内存分配与回收策略</a><ul>
<li><a href="#1%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%85%88%E5%9C%A8eden%E5%88%86%E9%85%8D">1、对象优先在Eden分配</a></li>
<li><a href="#2%E5%A4%A7%E5%AF%B9%E8%B1%A1%E7%9B%B4%E6%8E%A5%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3">2、大对象直接进入老年代</a></li>
<li><a href="#3%E9%95%BF%E6%9C%9F%E5%AD%98%E6%B4%BB%E5%AF%B9%E8%B1%A1%E5%B0%86%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3">3、长期存活对象将进入老年代</a></li>
<li><a href="#4%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D">4、空间分配担保</a></li>
<li><a href="#5%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1%E5%B9%B4%E9%BE%84%E5%88%A4%E5%AE%9A">5、动态对象年龄判定</a></li>
<li><a href="#6%E5%85%B3%E4%BA%8E%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D">6、关于逃逸分析以及栈上分配</a></li>
</ul>
</li>
</ul>
<hr>
<h2 id="一、垃圾回收概述"><a href="#一、垃圾回收概述" class="headerlink" title="一、垃圾回收概述"></a>一、垃圾回收概述</h2><p>关于垃圾回收，主要探讨下面四个问题。</p>
<ul>
<li><p>1、回收区域</p>
<ul>
<li><strong>程序计数器、虚拟机栈和本地方法栈</strong>这三个区域属于<strong>线程私有</strong>的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收；</li>
<li>垃圾回收主要是针对 <strong>Java堆和方法区</strong>进行；</li>
</ul>
</li>
<li><p>2、如何判定对象为垃圾对象</p>
<ul>
<li>引用计数法；</li>
<li>可达性分析；</li>
</ul>
</li>
<li><p>3、如何回收  </p>
<ul>
<li>回收策略: <strong>标记清除法，复制算法，标记整理法，分代收集算法；</strong></li>
<li>垃圾回收器(垃圾收集器): <strong>Serial、Parnew、Cms、G1</strong>；</li>
</ul>
</li>
<li><p>4、 何时回收</p>
</li>
</ul>
<blockquote>
<p> 下面的章节对上面的四个方面展开探讨。</p>
</blockquote>
<hr>
<h2 id="二、如何判定对象为垃圾对象"><a href="#二、如何判定对象为垃圾对象" class="headerlink" title="二、如何判定对象为垃圾对象"></a>二、如何判定对象为垃圾对象</h2><h3 id="1、引用计数法"><a href="#1、引用计数法" class="headerlink" title="1、引用计数法"></a>1、引用计数法</h3><ul>
<li>在对象中添加一个引用计数器；</li>
<li>当有地方引用这个对象的时候，引用计数器的值就<code>+1</code>，当引用失效的时候，计数器的值就<code>-1</code>； </li>
<li>当某个对象的引用计数器的值为<code>0</code>的时候，就回收这个对象；</li>
<li>这种方法不常用；</li>
</ul>
<p>示例:</p>
<p><img src="images/j9_%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95.png" alt="在这里插入图片描述"></p>
<p>简单的代码验证:</p>
<p>注意要查看JVM的内容，要在运行的时候添加相关的参数: </p>
<p><img src="images/j11_%E6%94%B9IDE.png" alt="在这里插入图片描述"></p>
<p>下面进行下图的过程:<br>  <img src="images/j10_%E6%B5%8B%E8%AF%95.png" alt="在这里插入图片描述"></p>
<p>代码如下: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Clazz</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Object val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Clazz A = <span class="keyword">new</span> Clazz();</span><br><span class="line">        Clazz B = <span class="keyword">new</span> Clazz();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//内部相互引用</span></span><br><span class="line">        A.val = B;</span><br><span class="line">        B.val = A;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//断开外部的引用</span></span><br><span class="line">        A = <span class="keyword">null</span>;</span><br><span class="line">        B = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里可以回收，说明不是使用的引用计数法</span></span><br><span class="line">        System.gc(); <span class="comment">//通知垃圾回收器回收</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用的parallel 垃圾收集器　(没有使用引用计数法)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>看到运行结果 (可以发现还是进行了回收，所以不是用的引用计数法): </p>
<p><img src="images/j12_%E7%BB%93%E6%9E%9C.png" alt="在这里插入图片描述"></p>
<p>在构造函数中添加内存(创建一个20MB的字节数组)： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Clazz</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Object val;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Clazz</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span> * <span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">//20MB</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Clazz A = <span class="keyword">new</span> Clazz();</span><br><span class="line">        Clazz B = <span class="keyword">new</span> Clazz();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//内部相互引用</span></span><br><span class="line">        A.val = B;</span><br><span class="line">        B.val = A;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//断开外部的引用</span></span><br><span class="line">        A = <span class="keyword">null</span>;</span><br><span class="line">        B = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里可以回收，说明不是使用的引用计数法</span></span><br><span class="line">        System.gc(); <span class="comment">//通知垃圾回收器回收</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行效果: </p>
<p><img src="images/j13.png" alt="在这里插入图片描述"></p>
<h3 id="2、可达性分析算法"><a href="#2、可达性分析算法" class="headerlink" title="2、可达性分析算法"></a>2、可达性分析算法</h3><p>第二种判定垃圾对象的方法: 可达性分析法，这个可以解决上面引用计数法不能判定堆内部垃圾对象的问题；</p>
<p>可达性分析算法</p>
<ul>
<li>通过一系列的称为<code>&quot;GC Roots&quot;</code>的对象为起点，从这些节点开始向下搜索，搜索走过的路径称为引用链；</li>
<li>当一个对象到GC Roots没有任何引用链的时候，则说明这个对象是垃圾对象；</li>
</ul>
<p>可以作为GC Roots的对象包括一下几个方面:</p>
<ul>
<li>虚拟机栈(栈帧中的本地变量表)中的引用的对象；</li>
<li>方法区中类静态属性引用的对象；</li>
<li>方法区中常亮对象的引用；</li>
<li>本地方法栈中JNI(即一般说的Native方法)引用的对象；</li>
</ul>
<p>如图: 上面的四个对象存活，下面的三个对象为垃圾对象: </p>
<p><img src="images/j14%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90.png" alt="在这里插入图片描述"></p>
<h3 id="3、引用分类"><a href="#3、引用分类" class="headerlink" title="3、引用分类"></a>3、引用分类</h3><p>主要分类:</p>
<ul>
<li>强引用: <code>StrongReference</code>: 引用指向对象，类似<code>&quot;Object obj = new Object();&quot;</code>这类引用，<code>gc(Garbage Collection)</code>运行时不回收；</li>
<li>软引用: <code>SoftReference</code>: gc运行时<strong>可能</strong>回收(jvm内存不够(内存溢出异常))；</li>
<li>弱引用: <code>WeakReference </code>: 描述非必须对象，强度比软引用更加弱一些，被弱引用关联的对象只能生存到下一次垃圾回收之前，当垃圾回收器工作时，<strong>无论当前内存是否足够</strong>，都会回收掉这些被弱引用关联的对象(gc运行时回收)；</li>
<li>虚引用: <code>PhantomReference</code> 类似于无引用，主要跟踪对象被回收的状态，不能单独使用，必须与引用队列(ReferenceQueue)联合使用；</li>
</ul>
<p><strong>目的: 避免对象长期驻留在内存中，解决垃圾回收机制回收时机问题；</strong></p>
<p><em>弱引用举例: WeakHashMap : 键为弱引用，回收建后自动删除key-value对象</em>；</p>
<p>测试:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line"><span class="keyword">import</span> java.util.WeakHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 强与弱引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Refclassify</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;---------------测试强引用-----------------&quot;</span>);</span><br><span class="line">        <span class="comment">//强引用: 字符串常量池 (不能回收)</span></span><br><span class="line">        String str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="comment">//弱引用管理 str 对象</span></span><br><span class="line">        WeakReference&lt;String&gt;wr = <span class="keyword">new</span> WeakReference&lt;String&gt;(str);</span><br><span class="line">        System.out.println(<span class="string">&quot;GC运行前: &quot;</span> + wr.get());</span><br><span class="line">        str = <span class="keyword">null</span>; <span class="comment">// 断开引用</span></span><br><span class="line">        <span class="comment">//通知回收</span></span><br><span class="line">        System.gc();</span><br><span class="line">        System.runFinalization();</span><br><span class="line">        System.out.println(<span class="string">&quot;GC运行后: &quot;</span> + wr.get());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;---------------测试弱引用-----------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//注意这里是new String</span></span><br><span class="line">        String str2 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        WeakReference&lt;String&gt;wr2 = <span class="keyword">new</span> WeakReference&lt;String&gt;(str2);</span><br><span class="line">        System.out.println(<span class="string">&quot;GC运行前: &quot;</span> + wr2.get());</span><br><span class="line">        str2 = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.runFinalization();</span><br><span class="line">        System.out.println(<span class="string">&quot;GC运行后: &quot;</span> + wr2.get()); <span class="comment">//弱引用管理--&gt; 被回收</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-------------WeakHashMap----------------&quot;</span>);<span class="comment">//键为弱类型，GC运行被回收</span></span><br><span class="line">        WeakHashMap&lt;String,String&gt;map = <span class="keyword">new</span> WeakHashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;a1&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;b&quot;</span>,<span class="string">&quot;b1&quot;</span>);</span><br><span class="line">        <span class="comment">//下面两个会被回收   如果map中占用内存很大，希望运行后被回收，就可以使用这个 </span></span><br><span class="line">        map.put(<span class="keyword">new</span> String(<span class="string">&quot;c&quot;</span>),<span class="string">&quot;c1&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> String(<span class="string">&quot;d&quot;</span>),<span class="string">&quot;d1&quot;</span>);</span><br><span class="line">        System.out.println(map.size());</span><br><span class="line">        System.gc();</span><br><span class="line">        System.runFinalization();</span><br><span class="line">        System.out.println(map.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：<br><img src="images/j15.png" alt="在这里插入图片描述"></p>
<h3 id="4、生存还是死亡-finalize-方法"><a href="#4、生存还是死亡-finalize-方法" class="headerlink" title="4、生存还是死亡-finalize()方法"></a>4、生存还是死亡-finalize()方法</h3><p><code>finalize()</code>方法</p>
<ul>
<li><strong>finalize() 类似 C++ 的析构函数，用来做关闭外部资源等工作。</strong></li>
<li>但是 <code>try-finally</code> 等方式可以比<code>finalize()</code>做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。</li>
<li>当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。</li>
<li><strong>自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会调用 finalize() 方法</strong>。</li>
</ul>
<blockquote>
<p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程，如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。<br>如果这个对象被判定为有必要执行 finalize() 方法，那么这个对象将会放置在一个叫做F-Queue 的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。 这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在 finalize() 方法中执行缓慢，或者发生了死循环(更极端的情况)，将很可能会导致 F-Queue 队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。<strong>finalize()方法是对象逃脱死亡命运的最后一次机会</strong>，稍后 GC 将对 F-Queue 中的对象进行第二次小规模的标记，如果对象要在 finalize()中成功拯救自己一一<strong>只要重新与引用链上的任何一个对象建立关联即可，比如把自己 (this 关键字) 赋值给某个类变量或者对象的成员变量</strong>，那在第二次标记时它将被移除出“即将回收”的集合; 如果对象这时候还没有逃脱，那基本上它就真的被回收了。</p>
</blockquote>
<p>总结: </p>
<ul>
<li>对象可以在被GC时 自我拯救；</li>
<li>这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次；<br>测试:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此代码演示了两点:</span></span><br><span class="line"><span class="comment"> *   (1) 对象可以在被GC时 自我拯救;</span></span><br><span class="line"><span class="comment"> *   (2) 这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;finalize method executed !&quot;</span>);</span><br><span class="line"></span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>; <span class="comment">//最后的自救  --&gt; 把自己(this关键字)赋值给某个类变量或者对象的成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一次成功拯救自己</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>; <span class="comment">//没用的对象</span></span><br><span class="line">        System.gc();      <span class="comment">// 通知回收</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//在finalize()中拯救对象 --&gt; 因为finalize()方法优先级很低，所以暂停0.5秒以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;yes,I&#x27;m still alive !&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;no ,I&#x27;m dead !&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 下面的代码和上面的完全相同，但是这次却自救失败，</span></span><br><span class="line"><span class="comment">         * 因为任何一个对象的finalize()方法都只会被系统自动调用一次</span></span><br><span class="line"><span class="comment">         * 如果进行下一次回收，它的finalize()方法不会再次执行;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;yes,I&#x27;m still alive !&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;no ,I&#x27;m dead !&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果: </p>
<p><img src="images/j16.png" alt="在这里插入图片描述"></p>
<h3 id="5、回收方法区"><a href="#5、回收方法区" class="headerlink" title="5、回收方法区"></a>5、回收方法区</h3><p>很多人认为方法区 (或者 HotSpot 虚拟机中的永久代) 是没有垃圾收集的，但是并不是没有，只是在方法区中进行垃圾收集的“性价比”一般比较低 ，而在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收 70% ~ 95% 的空间，而永久代的垃圾收集效率远低于此。</p>
<p><strong>永久代的垃圾收集主要回收两部分内容 : 废弃常量和无用的类</strong>。回收废弃常量与回收Java 堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String 对象是叫做“abc”的，换句话说，就是没有任何 String 对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个“abc”常量就会被系统清理出常量地。常量池中的其他类(接口)、方法、字段的符号引用也与此类似。判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是”无用的类”:</p>
<ul>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 ClassLoader 已经被回收。</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以” 。而并不是和对象一样，不使用了就必然会回收。</p>
<p>是否对类进行回收，HotSpot 虚拟机提供了 <code>-Xnoclassgc</code> 参数进行控制，还可以使用 <code>-verbose:class</code> 以及 <code>-XX:HTraceClassLoading</code>、<code>-XX:HTraceClassUnLoading</code> 查看类加载和印载信息。</p>
<hr>
<h2 id="三、垃圾回收算法"><a href="#三、垃圾回收算法" class="headerlink" title="三、垃圾回收算法"></a>三、垃圾回收算法</h2><h3 id="1、标记清除算法"><a href="#1、标记清除算法" class="headerlink" title="1、标记清除算法"></a>1、标记清除算法</h3><ul>
<li>分为”标记”和”清除”两个阶段: 首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象；</li>
<li>主要的两个不足: <strong>(1)效率问题，标记和清除的效率都不高；(2) 空间问题，标记清除之后会产生大量的不连续的内存碎片</strong>，空间碎片太多可能导致以后在程序运行过程中需要分配较大对象时，无法找到足够的内存而不得不提前触发另一次垃圾收集动作；</li>
</ul>
<p>标记清除算法执行过程如下:</p>
<p><img src="images/j17.png" alt="在这里插入图片描述"></p>
<h3 id="2、复制算法"><a href="#2、复制算法" class="headerlink" title="2、复制算法"></a>2、复制算法</h3><p>为了解决效率问题，一种称为“复制”(Copying) 的收集算法出现了，它的工作流程如下:</p>
<ul>
<li>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块；</li>
<li>当这一块的内存用完了，就将还存活着的对象复制到另外一块上面；</li>
<li>然后再把已使用过的内存空间一次清理掉。</li>
</ul>
<p>这样使得每次都是对整个<strong>半区进行内存回收</strong>，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半，未免太高了一点。</p>
<p>两块的复制过程:</p>
<p><img src="images/j18%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="在这里插入图片描述"></p>
<p>现在的商业虚拟机都采用这种收集算法来回收新生代，IBM 公司的专门研究表明，新生代中的对象 98% 是“朝生夕死”的，所以并不需要按照 1 : 1 的比例来划分内存空间，<strong>而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivors</strong>。当回收时，将 Eden 和 Survivor 中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。<strong>HotSpot 虚拟机默认 Eden和 Survivor 的大小比例是 8 : 1</strong>，也就是每次新生代中可用内存空间为整个新生代容量的 **90%(80%+10%)<strong>，只有 10% 的内存会被“浪费”。当然，98% 的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10% 的对象存活，当 Survivor 空间不够用时，</strong>需要依赖其他内存 (这里指老年代) 进行分配担保 (HandIe Promotion7)**。</p>
<p><img src="images/j19.png" alt="pic"></p>
<blockquote>
<p> 拓展，关于新生代，老年代和持久代，具体看<a href="https://tech.meituan.com/jvm_optimize.html"><strong>这篇博客</strong></a>。</p>
<p> <img src="images/j20.png" alt="在这里插入图片描述"></p>
<ul>
<li>① 新生代（Young Generation）：大多数对象在新生代中被创建，其中很多对象的生命周期很短。每次新生代的垃圾回收（又称Minor GC）后只有少量对象存活，所以选用<strong>复制算法</strong>，只需要少量的复制成本就可以完成回收。新生代内分三个区：一个Eden区，两个Survivor区（一般而言），<strong>大部分对象在Eden区中生成</strong>。当Eden区满时，还存活的对象将被复制到两个Survivor区（中的一个）。当这个Survivor区满时，此区的存活且不满足“晋升”条件的对象将被复制到另外一个Survivor区。对象每经历一次Minor GC，年龄加1，达到“晋升年龄阈值”后，被放到老年代，这个过程也称为“晋升”。显然，“晋升年龄阈值”的大小直接影响着对象在新生代中的停留时间，在Serial和ParNew GC两种回收器中，“晋升年龄阈值”通过参数MaxTenuringThreshold设定，默认值为15。</li>
<li>② 老年代（Old Generation）：在新生代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代，该区域中对象存活率高。老年代的垃圾回收（又称Major GC）通常使用“标记-清理”或“标记-整理”算法。整堆包括新生代和老年代的垃圾回收称为Full GC（HotSpot VM里，除了CMS之外，其它能收集老年代的GC都会同时收集整个GC堆，包括新生代）。</li>
<li>③ 永久代（Perm Generation）：主要存放元数据，例如Class、Method的元信息，与垃圾回收要回收的Java对象关系不大。相对于新生代和年老代来说，该区域的划分对垃圾回收影响比较小。</li>
</ul>
</blockquote>
<h3 id="3、标记整理算法"><a href="#3、标记整理算法" class="headerlink" title="3、标记整理算法"></a>3、标记整理算法</h3><p>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费 <code>50%</code> 的空间，就需要有额扰的空间进行分配担保，以应对被使用的内存中所有对象都 100% 存活的极端情况，所以在老年代一般不能直接选用这种算法。</p>
<p>根据老年代的特点，有人提出于另外一种“标记 - 整理”(<code>Mark-Compact</code>) 算法，标记过程仍然与“标记 - 清除”算法一样，<strong>但后续步又不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</strong>。 <img src="images/j21.png" alt="在这里插入图片描述"></p>
<h3 id="4、分代收集算法"><a href="#4、分代收集算法" class="headerlink" title="4、分代收集算法"></a>4、分代收集算法</h3><p>当前商业虚拟机的垃圾收集都采用“分代收集”(Generational Collection) 算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。<strong>一般是把 Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法</strong>。</p>
<p>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记一清理”或者“标记一整理”算法来进行回收。  </p>
<hr>
<h2 id="四、垃圾收集器"><a href="#四、垃圾收集器" class="headerlink" title="四、垃圾收集器"></a>四、垃圾收集器</h2><h3 id="1、各个垃圾收集器的联系"><a href="#1、各个垃圾收集器的联系" class="headerlink" title="1、各个垃圾收集器的联系"></a>1、各个垃圾收集器的联系</h3><p>下图展示了7种垃圾收集器，如果有连线表示可以同时使用，上面是新生代，下面是老年代</p>
<p><img src="images/j22.png" alt="在这里插入图片描述"></p>
<p>注意，这些收集器都有下面的原则: </p>
<ul>
<li>单线程与多线程收集的不同：单线程指的是垃圾收集器只使用一个线程进行收集，而多线程使用多个线程；</li>
<li>串行与并发：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并发指的是垃圾收集器和用户程序同时执行。<strong>除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</strong></li>
</ul>
<p>**以下收集器图片均来自<a href="https://hellojz.me/2017/10/10/jvm/gc/">这篇博客</a>**。</p>
<h3 id="2、Serial收集器"><a href="#2、Serial收集器" class="headerlink" title="2、Serial收集器"></a>2、Serial收集器</h3><p>概括: </p>
<ul>
<li>是单线程且串行的收集器；</li>
<li>它的优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率；</li>
<li><strong>现在依然是虚拟机运行在 Client 模式下的默认新生代收集器；</strong>(因为在用户的桌面应用场景下，分配给虚拟机管理的内存一般来说不会很大。Serial 收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。) </li>
</ul>
<p><img src="images/j23.png" alt="在这里插入图片描述"></p>
<h3 id="3、ParNew收集器"><a href="#3、ParNew收集器" class="headerlink" title="3、ParNew收集器"></a>3、ParNew收集器</h3><p>概括</p>
<ul>
<li><p>它是 Serial 收集器的多线程版本；</p>
</li>
<li><p>是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作：</p>
<blockquote>
<p>在JDK1.5 时期，HotSpot 推出了 CMS 收集器（Concurrent Mark Sweep），它是 HotSpot 虚拟机中第一款真正意义上的并发收集器（收集线程和用户线程同时执行）。不幸的是，CMS 作为老年代的收集器，却无法与 JDK1.4.0 中已经存在的新生代收集器 Parallel Scavenge 配合工作，所以在 JDK1.5中使用 CMS 来收集老年代的时候，新生代只能选择 ParNew 或者 Serial 收集器中的一个。</p>
</blockquote>
</li>
<li><p>默认开启的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。</p>
</li>
<li><p>Parallel Scavenge 收集器以及后面提到的 G1 收集器都没有使用传统的 GC 收集器代码框架，而另外独立实现，其余集中收集器则共用了部分的框架代码。</p>
</li>
</ul>
<p><img src="images/j24.png" alt="在这里插入图片描述"></p>
<p>并发和并行在垃圾收集器中的概念: </p>
<blockquote>
<p>并发和并行。这两个名词都是并发编程中的概念，<strong>在谈论垃圾收集器的上下文语境中</strong>，它们可以解释如下:</p>
<ul>
<li>并行 (Parallel): 指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态；</li>
<li>并发(Concurrent) : 指用户线程与垃圾收集线程同时执行，(但不一定是并行的，可能会交替执行)，用户程序在继续运行，而垃圾收集程序运行于另一个CPU 上；</li>
</ul>
</blockquote>
<h3 id="4、Parallel-Scavenge收集器"><a href="#4、Parallel-Scavenge收集器" class="headerlink" title="4、Parallel Scavenge收集器"></a>4、Parallel Scavenge收集器</h3><p>概括：</p>
<ul>
<li>是新生代复制算法，多线程收集器、吞吐量优先的收集器；</li>
<li>吞吐量指 CPU 用于运行用户代码的时间占总时间的比值 ；**(吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间) )；**</li>
</ul>
<p>Parallel Scavenge 收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器……看上去和 ParNew 都一样，那它有什么特别之处呢?</p>
<p>Parallel Scavenge 收集器的特点是它的关注点与其他收集器不同，CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，**而 Parallel Scavenge 收集器的目标则是达到一个可控制的吞吐量 (Throughput)<strong>。所谓吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即</strong>吞吐量 = 运行用户代码时间 / (运行用户代码时间 +垃圾收集时间)**，例如，虚拟机总共运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是99%。</p>
<p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p>
<p><img src="images/j25.png" alt="在这里插入图片描述"></p>
<p>Parallel Scavenge 收集器提供了两个参数用于精确控制委吐量，分别是控制最大垃圾收集停顿时间的 <code>-XX:MaxGCPauseMillis</code> 参数以及直接设置吞吐量大小的<code> -XX:GCTimeRatio</code> 参数。</p>
<p><code>MaxGCPauseMillis</code> 参数允许的值是一个大于 0 的毫秒数，收集器将尽可能地保证内存回收花费的时间不超过设定值。不过大家不要认为如果把这个参数的值设置得稍小一点就能使得系统的垃圾收集速度变得更快，GC 停顿时间缩短是以牺牲吞吐量和新生代空间来换取的 : 系统把新生代调小一些，收集 300MB 新生代肯定比收集 500MB 快吧，这也直接导致垃圾收集发生得更频繁一些，原来 10 秒收集一次、每次停顿 100 毫秒，现在变成 5 秒收集一次、每次停顿 70 毫秒。停顿时间的确在下降，但吞吐量也降下来了。</p>
<p><strong><code>GCTimeRatio</code> 参数的值应当是一个大于 0 且小于 100 的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数</strong>。如果把此参数设置为 19，那允许的最大 GC 时间就占总时间的 5%（即 <code>1 / (1+19)</code>)，默认值为 99，就是允许最大 <code>1%</code> ( 即 <code>1/(1+99)</code>) 的垃圾收集时间。</p>
<p>由于与吞吐量关系密切，Parallel Scavenge 收集器也经常<strong>称为“吞吐量优先”收集器</strong>。除上述两个参数之外，Parallel Scavenge 收集器还有一个参数 <code>-XX:+UseAdaptiveSizePolicy</code>值得关注。这是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小 (-Xmn)、Eden 与 Survivor 区 的 比 例 (<code>-XX:SurvivorRatio</code>)、晋升老年代对象年龄(<code>-XX:PretenureSizeThreshold</code>) 等细节参数了，<strong>虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大吞吐量，这种调节方式成为GC自适应的调节策略。</strong></p>
<p><img src="images/j26.png" alt="在这里插入图片描述"></p>
<h3 id="5、Serial-Old收集器"><a href="#5、Serial-Old收集器" class="headerlink" title="5、Serial Old收集器"></a>5、Serial Old收集器</h3><p>概括: </p>
<ul>
<li><p>Serial Old是<strong>Serial 收集器的老年代版本</strong>，它同样是一个<strong>单线程收集器</strong>，使用”标记整理算法”；</p>
</li>
<li><p>这个收集器的主要意义也是在于给Client模式下的虚拟机使用；</p>
</li>
<li><p>在Server模式下，还有两个用途: (1) 在JDK1.5版本之前和Parallel Scavenge 收集器搭配使用；(2) 作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用；</p>
</li>
</ul>
<p><img src="images/j27.png" alt="在这里插入图片描述"></p>
<h3 id="6、Paralell-Old收集器"><a href="#6、Paralell-Old收集器" class="headerlink" title="6、Paralell Old收集器"></a>6、Paralell Old收集器</h3><p>概括: </p>
<ul>
<li>Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和 ”标记-整理“ 算法；</li>
<li>在注重<strong>吞吐量以及 CPU 资源敏感</strong>的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器；</li>
</ul>
<p><img src="images/j28.png" alt="在这里插入图片描述"></p>
<h3 id="7、CMS收集器"><a href="#7、CMS收集器" class="headerlink" title="7、CMS收集器"></a>7、CMS收集器</h3><p>概括: </p>
<ul>
<li><p>CMS（Concurrent Mark Sweep），Mark Sweep 即是 标记 - 清除 算法。</font>主要优点：并发收集、低停顿，也称之为并发低停顿收集器（Concurrent Low Pause Collection）；</p>
</li>
<li><p>整个过程分为四个步骤: </p>
<ul>
<li><strong>① 初始标记(CMS initial Mark) (标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿</strong>；</li>
<li>**② 并发标记(CMS concurrent mark)(时间最长)**；</li>
<li>**③重新标记(CMS remark)(需要停顿)**；</li>
<li>**④并发清除(CMS concurrent sweep)**；</li>
</ul>
</li>
<li><p>可以注意到上面只有②和④过程是并发的，因为这两个也是最占时间的，所以这就是CMS的优点；</p>
</li>
<li><p>缺点：</p>
<ul>
<li>①吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高(对CPU资源非常敏感)。</li>
<li>②无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li>
<li>③标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li>
</ul>
</li>
<li><p>为了解决上面的由于标记清除算法产生的空间碎片的问题:  </p>
<ul>
<li><p>CMS 提供了一个开关参数<code>-XX:+UseCMSCompactAtFullCollection</code>（默认开启），用于在 CMS 收集器顶不住要进行 Full GC 时开启内存碎片的合并整理过程，内存整理的过程是无法并发的。</p>
</li>
<li><p>参数<code> -XX:CMSFullGCsBeforeCompaction</code> 用于设置执行多少次不压缩的 Full GC后，跟着来以此带压缩的，（默认值为0）。</p>
</li>
</ul>
</li>
</ul>
<p><img src="images/j29.png" alt="在这里插入图片描述"></p>
<h3 id="8、G1收集器"><a href="#8、G1收集器" class="headerlink" title="8、G1收集器"></a>8、G1收集器</h3><p>参考: <a href="http://blog.jobbole.com/109170/"><strong>文章一</strong></a>、<a href="https://tech.meituan.com/g1.html"><strong>文章二</strong></a></p>
<p>G1收集器运作步骤</p>
<ul>
<li><p>初始标记；</p>
</li>
<li><p>并发标记；</p>
</li>
<li><p>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 <code>Remembered Set Logs</code> 里面，最终标记阶段需要把 <code>Remembered Set Logs</code> 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行；</p>
</li>
<li><p>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率；</p>
</li>
</ul>
<p><img src="images/j30.png" alt="在这里插入图片描述"></p>
<p>G1收集器的特点: </p>
<p>G1 是一款面向<strong>服务端应用</strong>的垃圾收集器。HotSpot 开发团队赋予它的使命是(在比较长期的) 未来可以替换掉 JDK 1.5 中发布的 CMS 收集器。与其他 GC 收集器相比，G1 具备如下特点。</p>
<ul>
<li><p><strong>并行与并发</strong> ， G1 能充分利用多 CPU、多核环境下的硬件优势，使用多个 CPU (CPU或者 CPU 核心) 来缩短 Stop-The-World 停顿的时间，部分其他收集器原本需要停顿Java 线程执行的 GC 动作，GI1 收集器仍然可以通过并发的方式让 Java 程序继续执行。</p>
</li>
<li><p><strong>分代收集</strong> : 与其他收集器一样，分代概念在 G1 中依然得以保留。虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、效过多次 GC 的旧对象以获取更好的收集效果。</p>
</li>
<li><p><strong>空间整合</strong>: 与 CMS 的“标记一清理”算法不同，<strong>G1 从整体来看是基于“标记一整理”算法实现的收集器，从局部(两个 Region 之间) 上来看是基于“复制”算法实现的</strong>，但无论如何，这两种算法都意味着 G1 运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。</p>
</li>
<li><p><strong>可预测的停顿</strong> : 这是 G1 相对于 CMS 的另一大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N 毫秒，这几乎已经是实时 Java (RTSJ) 的垃圾收集器的特征了。</p>
</li>
</ul>
<p>G1的设计原则就是简单可行的性能调优，其次，<strong>G1将新生代，老年代的物理空间划分取消了</strong>。这样我们再也不用单独的空间对每个代进行设置了，不用担心每个代内存是否足够。</p>
<p><img src="images/j31.png" alt="在这里插入图片描述"></p>
<p>取而代之的是，G1算法将堆划分为若干个区域（Region），它仍然属于分代收集器。不过，这些区域的一部分包含新生代，新生代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间。老年代也分成很多区域，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。这就意味着，<strong>在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有cms内存碎片问题的存在了</strong>。</p>
<p><img src="images/j32.png" alt="在这里插入图片描述"></p>
<p>在G1中，还有一种特殊的区域，叫Humongous区域。 <strong>如果一个对象占用的空间超过了分区容量50%以上，G1收集器就认为这是一个巨型对象</strong>。这些巨型对象，默认直接会被分配在<strong>年老代</strong>，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动Full GC。(<strong>在java 8中，持久代也移动到了普通的堆内存空间中，改为元空间</strong>。)</p>
<p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p>
<h3 id="9、各种垃圾收集算法的对比"><a href="#9、各种垃圾收集算法的对比" class="headerlink" title="9、各种垃圾收集算法的对比"></a>9、各种垃圾收集算法的对比</h3><p><img src="images/j33.png" alt="在这里插入图片描述"></p>
<p>使用垃圾收集器常用的相关参数: </p>
<p><img src="images/j34.png" alt="在这里插入图片描述"></p>
<p>默认在Server模式下使用 <code>Paraller</code>收集器:</p>
<p><img src="images/j35.png" alt="在这里插入图片描述"></p>
<p>参数设置(设置成使用<code>Serial</code>)</p>
<p><img src="images/j36.png" alt="在这里插入图片描述"></p>
<p><img src="images/j37.png" alt="在这里插入图片描述"></p>
<hr>
<h2 id="五、内存分配与回收策略"><a href="#五、内存分配与回收策略" class="headerlink" title="五、内存分配与回收策略"></a>五、内存分配与回收策略</h2><p>Java技术体系中所说的自动内存管理归结为解决了两个问题: </p>
<ul>
<li>给对象分配内存；</li>
<li>回收分配给对象的内存；</li>
</ul>
<p>回收内存就是前面所讲的回收算法以及垃圾收集器，而<strong>对象分配内存</strong>，大方向讲，就是在堆上分配(但也可能经过JIT编译后被拆散为标量类型并间接的栈上分配)，对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程有限在TLAB上分配。<br>下面是几条普遍的<strong>内存分配规则</strong>: </p>
<ul>
<li>对象优先在Eden分配；</li>
<li>大对象直接进入老年代；</li>
<li>长期存活对象将进入老年代；</li>
<li> 空间分配担保；</li>
<li>动态对象年龄判定；</li>
</ul>
<p>下面分配看这几个分配规则。</p>
<h3 id="1、对象优先在Eden分配"><a href="#1、对象优先在Eden分配" class="headerlink" title="1、对象优先在Eden分配"></a>1、对象优先在Eden分配</h3><p>先看一个测试代码: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAllocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>];  <span class="comment">// 2MB</span></span><br><span class="line">        <span class="keyword">byte</span>[] b2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">byte</span>[] b3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">byte</span>[] b4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>先配置运行参数:<br><img src="images/j38.png" alt="在这里插入图片描述"></p>
<p>设置和对应内存的关系:</p>
<p><img src="images/j39.png" alt="在这里插入图片描述"></p>
<p>运行结果以及分析: </p>
<p><img src="images/j40.png" alt="在这里插入图片描述"></p>
<p>概括来说: </p>
<ul>
<li><p>一般直接分配到Eden区域，但是如果Eden区域不够，就进行Minor GC和分配担保； </p>
</li>
<li><p>所以原来的6MB(<code>b1、b2、b3</code>)进入了分配担保区(老年代中)，然后新的<code>b4</code>继续放入Eden区域；</p>
</li>
</ul>
<p><strong>另外，注意Minor GC和Full GC的区别</strong></p>
<ul>
<li><p>新生代 GC (<code>Minor GC</code>) : 指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，<strong>一般回收速度度也比较快</strong>。</p>
</li>
<li><p>老年代 GC (<code>Major GC / Full GC</code>) : 指发生在<strong>老年代的 GC</strong>，出现了 Major GC，经常会伴随至少一次的 Minor GC (但非绝对的，在 Parallel Scavenge 收集器的收集策略里就有直接进行 Major GC 的策略选择过程)。<strong>Major GC 的过度一般会比 Minor GC 慢 10 倍以上</strong>。</p>
</li>
</ul>
<h3 id="2、大对象直接进入老年代"><a href="#2、大对象直接进入老年代" class="headerlink" title="2、大对象直接进入老年代"></a>2、大对象直接进入老年代</h3><p>概括 </p>
<ul>
<li>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</li>
<li>大的对象不能一直放在新生代的Eden区域，因为这个区域是经常需要GC的部分，所以会降低效率，所以大的对象要放到老年代；</li>
<li>有一个默认的大小，当对象的大小超过这个值的时候，会进入老年代，也可以通过<br> <code>-XX:PretenureSizeThreshold</code>来设置这个值；<strong>大于此值的对象直接在老年代分配</strong>，避免在 Eden 区和 Survivor 区之间的大量内存复制。</li>
</ul>
<p>在上面的例子的运行参数(堆大小为20MB)的环境下测试:</p>
<p><img src="images/j41.png" alt="在这里插入图片描述"></p>
<p>再看</p>
<p><img src="https://img-blog.csdn.net/20181019140829981?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p>
<p>通过参数来修改这个默认值: </p>
<p><img src="images/j42.png" alt="在这里插入图片描述"></p>
<p>则此时7MB也会进入老年代: </p>
<p><img src="images/j43.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>注意 : PretenureSizeThreshold 参数只对 Serial 和 ParNew 两款收集器有效，<code>Parallel Scavenge</code>收集器不认识这个参数，Parallel Scavenge 收集器一般并不需要设置。如果过到必须使用此参数的场合，可以考虑 ParNew 加 CMS 的收集器组合。</p>
</blockquote>
<h3 id="3、长期存活对象将进入老年代"><a href="#3、长期存活对象将进入老年代" class="headerlink" title="3、长期存活对象将进入老年代"></a>3、长期存活对象将进入老年代</h3><ul>
<li>为对象定义<strong>年龄计数器</strong>，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</li>
<li><code>-XX:MaxTenuringThreshold</code> 用来设置年龄的阈值(到了这个年龄就进入老年代)。</li>
<li>例子和上面差不多，只有设置参数不同，这里不重复做了。</li>
</ul>
<h3 id="4、空间分配担保"><a href="#4、空间分配担保" class="headerlink" title="4、空间分配担保"></a>4、空间分配担保</h3><ul>
<li>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。</li>
<li>如果不成立的话虚拟机会查看<code>HandlePromotionFailure</code>(<code>-XX:+HandlePromotionFailure</code>(默认是开启的)) 设置值是否允许担保失败；</li>
<li>如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC(尽管有风险)；</li>
<li>如果小于，或者 <code>HandlePromotionFailure</code> 设置不允许冒险，那么就要进行一次 Full GC。</li>
</ul>
<h3 id="5、动态对象年龄判定"><a href="#5、动态对象年龄判定" class="headerlink" title="5、动态对象年龄判定"></a>5、动态对象年龄判定</h3><ul>
<li>虚拟机并不是永远地要求对象的年龄必须达到 <code>MaxTenuringThreshold</code> 才能晋升老年代；</li>
<li>如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 <code>MaxTenuringThreshold</code> 中要求的年龄。</li>
</ul>
<hr>
<h3 id="6、关于逃逸分析以及栈上分配"><a href="#6、关于逃逸分析以及栈上分配" class="headerlink" title="6、关于逃逸分析以及栈上分配"></a>6、关于逃逸分析以及栈上分配</h3><p>堆的分配已经不是唯一</p>
<ul>
<li>逃逸分析：分析对象的作用域；</li>
<li>**如果对象的作用域只是在方法体内(没有发生逃逸)**，就可以不需要在堆上分配内存，而是可以在栈上分配内存；</li>
</ul>
<p>看几个逃逸和不逃逸的例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackAllocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> StackAllocation instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**方法返回 StackAllocation对象，发生逃逸*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StackAllocation <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance == <span class="keyword">null</span> ? <span class="keyword">new</span> StackAllocation() : instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**为成员属性赋值，也发生了逃逸*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.instance = <span class="keyword">new</span> StackAllocation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**引用成员变量，也发生了逃逸*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StackAllocation s = getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**对象的作用域仅在方法中有效,没有发生逃逸*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StackAllocation s = <span class="keyword">new</span> StackAllocation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Garbage Collection Overview</tag>
        <tag>Object Identification</tag>
      </tags>
  </entry>
  <entry>
    <title>Java虚拟机性能监控工具</title>
    <url>/2021/08/19/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="Java虚拟机性能监控工具"><a href="#Java虚拟机性能监控工具" class="headerlink" title="Java虚拟机性能监控工具"></a>Java虚拟机性能监控工具</h1><ul>
<li>一、JDK的命令行工具</li>
<li>二、JDK的可视化工具</li>
<li>三、性能调优</li>
</ul>
<hr>
<h2 id="一、JDK的命令行工具"><a href="#一、JDK的命令行工具" class="headerlink" title="一、JDK的命令行工具"></a>一、JDK的命令行工具</h2><p>主要有以下几种: </p>
<ul>
<li>jps (<code>Java Process Status Tool</code>): 虚拟机进程状态工具；</li>
<li>jstat (<code>JVM Statistics Monitoring Tool</code>):  虚拟机统计信息监视工具；</li>
<li>jinfo (<code>Configuration Info for Java</code>):  Java配置信息工具；</li>
<li>jmap (<code>Memory Map for Java</code>):  Java内存映像工具；</li>
<li>jhat (<code>JVM Heap Dump Browser</code>):  虚拟机堆转存储快照工具；</li>
<li>jstack (<code>Stack Trace for Java</code>): Java堆栈跟踪工具； </li>
</ul>
<p>下面一个个来总结: </p>
<h3 id="1、jps-虚拟机进程状态工具"><a href="#1、jps-虚拟机进程状态工具" class="headerlink" title="1、jps : 虚拟机进程状态工具"></a>1、jps : 虚拟机进程状态工具</h3><ul>
<li>jps（JVM Process Status Tool，虚拟机进程监控工具），这个命令可以列出正在运行的虚拟机进程，并显示虚拟机执行主类名称，以及这些进程的本地虚拟机唯一ID。</li>
<li>这个 ID 被称为<strong>本地虚拟机唯一 ID</strong>（Local Virtual Machine Identifier，简写为LVMID）。如果你在 linux 的一台服务器上使用 jps 得到的 LVMID 其实就是和 ps 命令得到的 PID 是一样的。</li>
</ul>
<p>命令格式: </p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">jps [options] [hostid]</span><br></pre></td></tr></table></figure>
<p>jps工具主要选项：</p>
<ul>
<li>-q，只输出LVMID，省略主类的名称；</li>
<li>-m，输出虚拟机进程启动时传给主类main()函数的参数；</li>
<li>-l，输出主类的全名，如果进程执行的是Jar包，输出Jar路径；</li>
<li>-v，输出虚拟机进程启动时JVM参数；</li>
</ul>
<h3 id="2、jstat-虚拟机统计信息监视工具"><a href="#2、jstat-虚拟机统计信息监视工具" class="headerlink" title="2、jstat : 虚拟机统计信息监视工具"></a>2、jstat : 虚拟机统计信息监视工具</h3><ul>
<li>jstat（JVM Statistics Monitoring Tool，虚拟机统计信息监视工具），这个命令用于监视虚拟机各种运行状态信息。</li>
<li>它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据，虽然没有GUI图形界面，只是提供了纯文本控制台环境的服务器上，但它是运行期间定位虚拟机性能问题的首选工具。</li>
</ul>
<p> 命令格式: </p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">jstat [option vmid [interval [s | ms] [count ] ] ]</span><br></pre></td></tr></table></figure>
<p>option代表着用户希望查询的虚拟机信息，主要分为3类: 类装载、垃圾收集、运行期编译状况，具体可以参照下表:<br><img src="images/tool1.png" alt="在这里插入图片描述"></p>
<p>示例: </p>
<p><img src="images/tool2.png" alt="在这里插入图片描述"></p>
<p><strong>更多jstat的详细讲解可以参考<a href="https://blog.csdn.net/zhaozheng7758/article/details/8623549">这篇博客</a>。</strong></p>
<h3 id="3、jinfo-：Java配置信息工具"><a href="#3、jinfo-：Java配置信息工具" class="headerlink" title="3、jinfo ：Java配置信息工具"></a>3、jinfo ：Java配置信息工具</h3><ul>
<li>实时地查看和调整虚拟机各项参数。</li>
</ul>
<p>查看14838是否使用CMS收集器: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jinfo -flag UseConcMarkSweepGC <span class="number">14836</span></span><br></pre></td></tr></table></figure>
<p>查看2788的MaxPerm大小可以用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jinfo -flag MaxPermSize <span class="number">2788</span></span><br></pre></td></tr></table></figure>

<h3 id="4、jmap-Java内存映像工具"><a href="#4、jmap-Java内存映像工具" class="headerlink" title="4、jmap : Java内存映像工具"></a>4、jmap : Java内存映像工具</h3><ul>
<li>jmap（Memory Map for Java，内存映像工具），用于生成堆转存的快照，一般是 heapdump 或者 dump 文件。如果不使用 jmap 命令，可以使用 -XX:+HeapDumpOnOutOfMemoryError 参数，当虚拟机发生内存溢出的时候可以产生快照。或者使用kill -3 pid也可以产生。</li>
<li>jmap 的作用并不仅仅是为了获取 dump 文件，它可以查询 finalize 执行队列，java 堆和永久代的详细信息，如空间使用率，当前用的哪种收集器。</li>
</ul>
<p>格式: </p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">jmap [option] vmid</span><br></pre></td></tr></table></figure>
<p>生成某个pid的存储快照示例:<br><img src="images/tool3.png" alt="在这里插入图片描述"><br><img src="images/tool4.png" alt="在这里插入图片描述"></p>
<h3 id="5、jhat-虚拟机堆转存储快照工具"><a href="#5、jhat-虚拟机堆转存储快照工具" class="headerlink" title="5、jhat :  虚拟机堆转存储快照工具"></a>5、jhat :  虚拟机堆转存储快照工具</h3><ul>
<li>jhat（虚拟机堆转储快照分析工具），这个工具是用来分析 jmap dump 出来的文件。 由于这个工具功能比较简陋，运行起来也比较耗时，所以这个工具不推荐使用，推荐使用MAT。</li>
</ul>
<p>分析示例: </p>
<p><img src="images/tool5.png" alt="在这里插入图片描述"></p>
<h3 id="6、jstack-：-Java堆栈跟踪工具"><a href="#6、jstack-：-Java堆栈跟踪工具" class="headerlink" title="6、jstack ： Java堆栈跟踪工具"></a>6、jstack ： Java堆栈跟踪工具</h3><ul>
<li>jstack（Java Stack Trace，Java堆栈跟踪工具），这个命令用于查看虚拟机当前时刻的线程快照（一般是threaddump 或者 javacore文件）。<font color = green>线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。</li>
<li><font color = blue>生成线程快照的主要目的是：定位线程出现长时间停顿的原因，入线程间死锁、死循环、请求外部资源导致的长时间等待都是导致线程长时间停顿的常见原因。</li>
<li>线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情。</li>
</ul>
<p>命令格式：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">jstack [option] vmid</span><br></pre></td></tr></table></figure>

<p>使用：查看进程8024 的堆栈信息</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">jstack 8024</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="二、-JDK的可视化工具"><a href="#二、-JDK的可视化工具" class="headerlink" title="二、 JDK的可视化工具"></a>二、 JDK的可视化工具</h2><ul>
<li>Jconsole : Java监视与管理控制台</li>
<li>VisualVM: 多合一故障处理工具</li>
</ul>
<p>下面具体看这个两个工具: </p>
<h3 id="1、-Jconsole-Java监视与管理控制台"><a href="#1、-Jconsole-Java监视与管理控制台" class="headerlink" title="1、 Jconsole : Java监视与管理控制台"></a>1、 Jconsole : Java监视与管理控制台</h3><ul>
<li>JConsole可以监视<strong>JVM 内存的使用情况、线程堆栈跟踪、已装入的类和 VM 信息以及 CE MBean。</strong></li>
<li>JConsole一个 Java GUI 监视工具，可以以图表化的形式显示各种数据。并可通过远程连接监视远程的服务器VM。</li>
<li>用 Java 写的 GUI 程序，用来监控 VM，并可监控远程的 VM，非常易用，而且功能非常强。命令行里打 Jconsole，选则进程就可以了。</li>
<li>可以监控内存和线程，以及检测是否出现死锁；</li>
</ul>
<h3 id="2、VisualVM-：多合一故障处理工具"><a href="#2、VisualVM-：多合一故障处理工具" class="headerlink" title="2、VisualVM ：多合一故障处理工具"></a>2、VisualVM ：多合一故障处理工具</h3><ul>
<li>VisualVm 同 Jconsole 都是一个基于图形化界面的、可以查看本地及远程的 JAVA GUI 监控工具，VisualVm 同 Jconsole 的使用方式一样，<font color= red>直接在命令行打入JVisualVm 即可启动</font>，VisualVm 界面更美观一些，数据更实时。</li>
</ul>
<hr>
<h3 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h3><p>性能调优: </p>
<ul>
<li>知识</li>
<li>工具</li>
<li>数据</li>
<li>经验</li>
</ul>
<p><strong>关于性能调优更多的可以看看这篇<a href="https://tech.meituan.com/jvm_optimize.html">JVM性能调优案例</a>。</strong></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM Performance Monitoring</tag>
        <tag>Heap Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8 Lambda表达式总结</title>
    <url>/2021/08/01/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="Lambda表达式总结"><a href="#Lambda表达式总结" class="headerlink" title="Lambda表达式总结"></a>Lambda表达式总结</h1><ul>
<li><a href="#%E4%B8%80%E4%BD%BF%E7%94%A8%E8%8C%83%E4%BE%8B%E4%BB%A5%E5%8F%8A%E4%BE%8B%E5%AD%90">一、使用范例以及例子</a><ul>
<li><a href="#1%E5%8E%9F%E5%A7%8B%E6%96%B9%E6%B3%95">1、原始方法</a></li>
<li><a href="#2%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F%E4%B8%80-%E4%BD%BF%E7%94%A8%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E6%9D%A5%E4%BC%98%E5%8C%96">2、优化方式一-使用策略模式来优化</a></li>
<li><a href="#3%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F%E4%BA%8C-%E4%BD%BF%E7%94%A8%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E4%BC%98%E5%8C%96">3、优化方式二-使用匿名内部类优化</a></li>
<li><a href="#4%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F%E4%B8%89-%E4%BD%BF%E7%94%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F">4、优化方式三-使用Lambda表达式</a></li>
<li><a href="#5%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F%E5%9B%9B-%E4%BD%BF%E7%94%A8stream-api">5、优化方式四-使用Stream-API</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8Clambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95">二、<code>Lambda</code>表达式基础语法</a></li>
<li><a href="#%E4%B8%89%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3">三、函数式接口</a></li>
<li><a href="#%E5%9B%9Blambda%E7%BB%83%E4%B9%A0">四、<code>Lambda</code>练习</a><ul>
<li><a href="#1%E7%BB%83%E4%B9%A0%E4%B8%80-employee%E7%B1%BB%E4%B8%AD%E5%85%88%E6%8C%89%E5%B9%B4%E9%BE%84%E6%AF%94%E5%B9%B4%E9%BE%84%E7%9B%B8%E5%90%8C%E6%8C%89%E7%85%A7%E5%A7%93%E5%90%8D%E6%AF%94-%E9%83%BD%E6%98%AF%E5%8D%87%E5%BA%8F">1、练习一-<code>Employee</code>类中先按年龄比，年龄相同按照姓名比-都是升序</a></li>
<li><a href="#2%E7%BB%83%E4%B9%A0%E4%BA%8C-%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AA%E5%B8%A6%E4%B8%A4%E4%B8%AA%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%B9%B6%E4%B8%94%E5%AF%B9%E4%B8%A4%E4%B8%AAlong%E5%9E%8B%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97">2、练习二-声明一个带两个泛型的接口，并且对两个<code>Long</code>型数值计算</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94java8%E5%9B%9B%E5%A4%A7%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3">五、<code>Java8</code>四大内置函数式接口</a></li>
<li><a href="#%E5%85%AD%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E5%92%8C%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8">六、方法引用和构造器引用</a><ul>
<li><a href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8">1、方法引用</a></li>
<li><a href="#%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8">2、构造器引用</a></li>
</ul>
</li>
</ul>
<hr>
<h2 id="一、使用范例以及例子"><a href="#一、使用范例以及例子" class="headerlink" title="一、使用范例以及例子"></a>一、使用范例以及例子</h2><p>使用匿名内部类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator&lt;Integer&gt;com = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;  <span class="comment">//降序排列</span></span><br><span class="line">        <span class="keyword">return</span> Integer.compare(o2,o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用<code>Lambda</code>表达式: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; com = (x, y) -&gt; Integer.compare(y, x);</span><br></pre></td></tr></table></figure>

<p><strong>下面给出一个例子来引入<code>Lambda</code>表达式。</strong></p>
<p>给出一个<code>Employee</code>类，有<code>name、age、salary</code>三个属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, salary=&quot;</span> + salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后我们需要通过限制查询数据: </p>
<ul>
<li>比如查询年龄<code>&gt;25</code>岁的所有员工的信息；</li>
<li>再如查询工资<code>&gt;4000</code>的员工信息；</li>
</ul>
<p>首先给出一个<code>List</code>集合类模拟数据库表: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将数组转换成集合的</span></span><br><span class="line">List&lt;Employee&gt; employees = Arrays.asList(</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="string">&quot;张三&quot;</span>,<span class="number">23</span>,<span class="number">3333.33</span>),</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="string">&quot;李四&quot;</span>,<span class="number">24</span>,<span class="number">4444.44</span>),</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="string">&quot;王五&quot;</span>,<span class="number">25</span>,<span class="number">5555.55</span>),</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="string">&quot;赵六&quot;</span>,<span class="number">26</span>,<span class="number">6666.66</span>),</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="string">&quot;田七&quot;</span>,<span class="number">27</span>,<span class="number">7777.77</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="1、原始方法"><a href="#1、原始方法" class="headerlink" title="1、原始方法"></a>1、原始方法</h3><p>然后我们写分别查询出<font color =red>年龄大于<code>25</code>岁的员工信息和工资大于<code>4000</code></font>的员工信息，发现<code>findEmployeesByAge</code>和<code>findEmployeesBySalary</code>两个方法代码非常的相似，<font color =red>只有查询条件不同，所以这个方法是不太可取的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//年龄</span></span><br><span class="line">    List&lt;Employee&gt; list = findEmployeesByAge(employees);</span><br><span class="line">    <span class="keyword">for</span>(Employee emp : list)&#123;</span><br><span class="line">        System.out.println(emp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//工资</span></span><br><span class="line">    System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line">    List&lt;Employee&gt; list2 = findEmployeesBySalary(employees);</span><br><span class="line">    <span class="keyword">for</span>(Employee emp : list2)&#123;</span><br><span class="line">        System.out.println(emp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//原始方法 : 查询出年龄大于25岁的(这个是最原始的方法)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">findEmployeesByAge</span><span class="params">(List&lt;Employee&gt;list)</span></span>&#123;</span><br><span class="line">    List&lt;Employee&gt;emps = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Employee emp : list)&#123;</span><br><span class="line">        <span class="keyword">if</span>(emp.getAge() &gt; <span class="number">25</span>)&#123;</span><br><span class="line">            emps.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> emps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//原始方法 : 查询出工资大于4000的(这个是最原始的方法)</span></span><br><span class="line"><span class="comment">//和上面的方法唯一的差别只有年龄和工资的改动，代码冗余</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">findEmployeesBySalary</span><span class="params">(List&lt;Employee&gt;list)</span></span>&#123;</span><br><span class="line">    List&lt;Employee&gt;emps = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Employee emp : list)&#123;</span><br><span class="line">        <span class="keyword">if</span>(emp.getSalary() &gt; <span class="number">4000</span>)&#123;</span><br><span class="line">            emps.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> emps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2、优化方式一-使用策略模式来优化"><a href="#2、优化方式一-使用策略模式来优化" class="headerlink" title="2、优化方式一-使用策略模式来优化"></a>2、优化方式一-使用策略模式来优化</h3><p>策略模式需要行为算法族，于是我们创建查询行为的接口<code>MyPredicate&lt;T&gt;</code>: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyPredicate</span> &lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并创建相关的实现类代表不同的算法行为: (分别是年龄<code> &gt; 25</code>和工资<code>&gt; 4000</code>的 ): </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterEmployeeByAge</span> <span class="keyword">implements</span> <span class="title">MyPredicate</span>&lt;<span class="title">Employee</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  employee.getAge() &gt; <span class="number">25</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterEmployeeBySalary</span> <span class="keyword">implements</span> <span class="title">MyPredicate</span>&lt;<span class="title">Employee</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> employee.getSalary()  &gt;= <span class="number">4000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color = red>这时我们可以只需要创建通用的方法: 具体的调用只需要传入具体的实现类(接口作为参数)</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">filterEmployees</span><span class="params">(List&lt;Employee&gt;list,MyPredicate&lt;Employee&gt;mp)</span></span>&#123;</span><br><span class="line">    List&lt;Employee&gt;emps = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Employee emp : list)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mp.test(emp))&#123;  <span class="comment">//调用相应的过滤器</span></span><br><span class="line">            emps.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> emps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color =red>测试的时候就传入两个不同的类，来指定查询的行为</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优化方式一 :  使用策略设计模式进行优化  下面的方法只要写一个</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Employee&gt; list = filterEmployees(<span class="keyword">this</span>.employees, <span class="keyword">new</span> FilterEmployeeByAge());</span><br><span class="line">    <span class="keyword">for</span>(Employee emp : list)&#123;</span><br><span class="line">        System.out.println(emp);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line">    List&lt;Employee&gt; list2 = filterEmployees(<span class="keyword">this</span>.employees, <span class="keyword">new</span> FilterEmployeeBySalary());</span><br><span class="line">    <span class="keyword">for</span>(Employee emp : list2)&#123;</span><br><span class="line">        System.out.println(emp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、优化方式二-使用匿名内部类优化"><a href="#3、优化方式二-使用匿名内部类优化" class="headerlink" title="3、优化方式二-使用匿名内部类优化"></a>3、优化方式二-使用匿名内部类优化</h3><p><font color =red>这样的好处在于不需要创建接口的具体的实现类，(但是还是需要<code>MyPredicate</code>接口和<code>filterEmployees()</code>方法): </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优化方式二 ： 使用匿名内部类  这样的好处是不要创建一个额外的 策略类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Employee&gt; list = filterEmployees(<span class="keyword">this</span>.employees, <span class="keyword">new</span> MyPredicate&lt;Employee&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> employee.getSalary() &gt; <span class="number">4000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (Employee emp:list) &#123;</span><br><span class="line">        System.out.println(emp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、优化方式三-使用Lambda表达式"><a href="#4、优化方式三-使用Lambda表达式" class="headerlink" title="4、优化方式三-使用Lambda表达式"></a>4、<font color = green>优化方式三-使用Lambda表达式</h3><p><font color = red>省去匿名内部类的没用的代码，增强可读性:(注意还是需要那个<code>filterEmployees()</code>方法和<code>MyPredicate</code>接口)</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Employee&gt; list = filterEmployees(<span class="keyword">this</span>.employees, (e) -&gt; e.getSalary() &gt; <span class="number">4000</span>);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5、优化方式四-使用Stream-API"><a href="#5、优化方式四-使用Stream-API" class="headerlink" title="5、优化方式四-使用Stream-API"></a>5、<font color = green>优化方式四-使用Stream-API</h3><p><font color = red>使用<code>StreamAPI</code>完全不需要其他的代码，包括不需要<code>filterEmployees()</code>方法，代码很简洁:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">    employees.stream().filter( (e) -&gt; e.getSalary() &lt; <span class="number">4000</span> ).limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">&quot;------------------&quot;</span>);</span><br><span class="line">    employees.stream().map(Employee::getName).forEach(System.out::println); <span class="comment">//打印所有的名字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="二、Lambda表达式基础语法"><a href="#二、Lambda表达式基础语法" class="headerlink" title="二、Lambda表达式基础语法"></a>二、Lambda表达式基础语法</h2><p><strong>关于箭头操作符:</strong> </p>
<ul>
<li><code>Java8</code>中引入了一个新的操作符，<code>&quot;-&gt;&quot;</code>，该操作符称为箭头操作符或者<code>Lambda</code>操作符，箭头操作符将<code>Lambda</code>表达式拆分成两部分；</li>
<li>左侧:  <code>Lambda</code>表达式的<font color = blue>参数列表</font>，对应的是<font color = red>接口中抽象方法的参数列表</font>；</li>
<li>右侧:  <code>Lambda</code>表达式中所需要执行的功能(<font color =blue><code>Lambda</code>体</font>)，对应的是<font color = red>对抽象方法的实现；(函数式接口(只能有一个抽象方法))</li>
<li><code>Lambda</code>表达式的实质是　<font color =red>对接口的实现</font>；</li>
</ul>
<p><strong>语法格式:</strong></p>
<p>(一)、接口中的抽象方法 : 无参数，无返回值；</p>
<p>例如: <code>Runnable</code>接口中的<code>run</code>方法: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/*final */</span><span class="keyword">int</span> num = <span class="number">2</span>; <span class="comment">//jdk1.7之前必须定义为final的下面的匿名内部类中才能访问</span></span><br><span class="line"></span><br><span class="line">    Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello world!&quot;</span> + num); <span class="comment">//本质还是不能对num操作(只是jdk自己为我们设置成了final的)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    r.run();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;----------使用Lambda输出-----------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Runnable r1 = () -&gt; System.out.println(<span class="string">&quot;Hello world!&quot;</span> + num);</span><br><span class="line">    r1.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color =red>(二)、接口中的抽象方法 : 一个参数且无返回值；  (若只有一个参数，那么小括号可以省略不写)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//  Consumer&lt;String&gt;con = (x) -&gt; System.out.println(x);</span></span><br><span class="line">    Consumer&lt;String&gt;con = x -&gt; System.out.println(x);</span><br><span class="line">    con.accept(<span class="string">&quot;Lambda牛逼!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color =red>(三)、两个参数，有返回值，并且有多条语句 ：　<strong>要用大括号括起来，而且要写上<code>return</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">     Comparator&lt;Integer&gt;com = (x,y) -&gt; &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;函数式接口&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> Integer.compare(y,x); <span class="comment">//降序</span></span><br><span class="line">     &#125;;</span><br><span class="line">     </span><br><span class="line">     Integer[] nums = &#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">5</span>&#125;;</span><br><span class="line">     Arrays.sort(nums,com);</span><br><span class="line">     System.out.println(Arrays.toString(nums));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">函数式接口</span><br><span class="line">函数式接口</span><br><span class="line">函数式接口</span><br><span class="line">函数式接口</span><br><span class="line">函数式接口</span><br><span class="line">函数式接口</span><br><span class="line">函数式接口</span><br><span class="line">函数式接口</span><br><span class="line">函数式接口</span><br><span class="line">[<span class="number">8</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p><font color =red>(四)、两个参数，有返回值，但是只有一条语句:　<strong>大括号省略，<code>return</code>省略</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">     Comparator&lt;Integer&gt;com = (x,y) -&gt; Integer.compare(x,y);<span class="comment">//升序</span></span><br><span class="line">     Integer[] nums = &#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">5</span>&#125;;</span><br><span class="line">     Arrays.sort(nums,com);</span><br><span class="line">     System.out.println(Arrays.toString(nums));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>输出: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure>

<p> <font color =red>(五)、 <code>Lambda</code>表达式的参数列表的数据类型 可以省略不写，因为JVM编译器通过上下文推断出数据类型，即”类型推断”， <code>(Integer x,Integer y ) -&gt; Integer.compare(x,y)</code>可以简写成<code>(x,y) -&gt; Integer.compare(x,y)</code>；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">上联: 左右遇一括号省</span><br><span class="line">下联: 左侧推断类型省</span><br><span class="line">横批: 能省则省</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="三、函数式接口"><a href="#三、函数式接口" class="headerlink" title="三、函数式接口"></a>三、函数式接口</h2><ul>
<li><font color =red>若接口中只有一个抽象方法的接口称为函数式接口；</li>
<li><font color =red>可以使用注解<code>@FunctionlInterface</code>来标识，可以检查是否是函数式接口；</li>
</ul>
<p> 例子: 对一个进行<code>+-*/</code>的运算：　</p>
<p>函数式接口: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span> <span class="comment">//函数式接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getValue</span><span class="params">(Integer num)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通用函数: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">operation</span><span class="params">(Integer num,MyFunction mf)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mf.getValue(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">     Integer res = operation(<span class="number">200</span>, (x) -&gt; x * x);</span><br><span class="line">     System.out.println(res);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="四、Lambda练习"><a href="#四、Lambda练习" class="headerlink" title="四、Lambda练习"></a>四、Lambda练习</h2><h3 id="1、练习一-Employee类中先按年龄比，年龄相同按照姓名比-都是升序"><a href="#1、练习一-Employee类中先按年龄比，年龄相同按照姓名比-都是升序" class="headerlink" title="1、练习一-Employee类中先按年龄比，年龄相同按照姓名比-都是升序"></a>1、练习一-<code>Employee</code>类中先按年龄比，年龄相同按照姓名比-都是升序</h3><p>先给出集合，模拟数据库表: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Employee&gt; employees = Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> Employee(<span class="string">&quot;田七&quot;</span>,<span class="number">27</span>,<span class="number">7777.77</span>),</span><br><span class="line">        <span class="keyword">new</span> Employee(<span class="string">&quot;王五&quot;</span>,<span class="number">24</span>,<span class="number">5555.55</span>),</span><br><span class="line">        <span class="keyword">new</span> Employee(<span class="string">&quot;张三&quot;</span>,<span class="number">23</span>,<span class="number">3333.33</span>),</span><br><span class="line">        <span class="keyword">new</span> Employee(<span class="string">&quot;李四&quot;</span>,<span class="number">24</span>,<span class="number">4444.44</span>),</span><br><span class="line">        <span class="keyword">new</span> Employee(<span class="string">&quot;赵六&quot;</span>,<span class="number">26</span>,<span class="number">6666.66</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">   Collections.sort(employees,(x,y) -&gt;&#123;</span><br><span class="line">       <span class="keyword">if</span>(x.getAge() == y.getAge())&#123;</span><br><span class="line">           <span class="keyword">return</span> x.getName().compareTo(y.getName());</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> Integer.compare(x.getAge(),y.getAge());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (Employee emp: employees) &#123;</span><br><span class="line">       System.out.println(emp);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">name=<span class="string">&#x27;张三&#x27;</span>, age=<span class="number">23</span>, salary=<span class="number">3333.33</span></span><br><span class="line">name=<span class="string">&#x27;李四&#x27;</span>, age=<span class="number">24</span>, salary=<span class="number">4444.44</span></span><br><span class="line">name=<span class="string">&#x27;王五&#x27;</span>, age=<span class="number">24</span>, salary=<span class="number">5555.55</span></span><br><span class="line">name=<span class="string">&#x27;赵六&#x27;</span>, age=<span class="number">26</span>, salary=<span class="number">6666.66</span></span><br><span class="line">name=<span class="string">&#x27;田七&#x27;</span>, age=<span class="number">27</span>, salary=<span class="number">7777.77</span></span><br></pre></td></tr></table></figure>
<h3 id="2、练习二-声明一个带两个泛型的接口，并且对两个Long型数值计算"><a href="#2、练习二-声明一个带两个泛型的接口，并且对两个Long型数值计算" class="headerlink" title="2、练习二-声明一个带两个泛型的接口，并且对两个Long型数值计算"></a>2、练习二-声明一个带两个泛型的接口，并且对两个<code>Long</code>型数值计算</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyCalFunction</span>&lt;<span class="title">T</span>,<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">getValue</span><span class="params">(T t1,T t2)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应函数和测试: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    op(<span class="number">200L</span>,<span class="number">200L</span>,(x,y) -&gt; x + y);</span><br><span class="line">    op(<span class="number">200L</span>,<span class="number">200L</span>,(x,y) -&gt; x * y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">op</span><span class="params">(Long l1,Long l2,MyCalFunction&lt;Long,Long&gt;mc)</span></span>&#123;<span class="comment">//需求: 对于两个long型运算进行处理</span></span><br><span class="line">    System.out.println(mc.getValue(l1, l2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多的例子: (取自<code>&lt;&lt;</code>Java8<code>实战&gt;&gt;</code>)<br><img src="images/lambda1.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>根据上述语法规则，以下哪个不是有效的Lambda表达式？<br>(1)  () -&gt; {}<br>(2)  () -&gt; “Raoul”<br>(3)  () -&gt; {return “Mario”;}<br>(4)  (Integer i) -&gt; return “Alan” + i;<br>(5)  (String s) -&gt; {“IronMan”;}<br>答案：只有4和 5是无效的Lambda。</p>
<p>(1) 这个Lambda没有参数，并返回void。 它类似于主体为空的方法：public void run() {}。<br>(2) 这个Lambda没有参数，并返回String作为表达式。<br>(3) 这个Lambda没有参数，并返回String（利用显式返回语句）。</p>
<p>(4) return是一个控制流语句。要使此Lambda有效，需要使花括号，如下所示：<code>(Integer i) -&gt; &#123;return &quot;Alan&quot; + i;&#125;</code>。</p>
<p>(5)“Iron Man”是一个表达式，不是一个语句。要使此Lambda有效，你可以去除花括号和分号，如下所示：<code>(String s) -&gt; &quot;Iron Man&quot;</code>。或者如果你喜欢，可以使用显式返回语句，如下所示：<code>(String s)-&gt;&#123;return &quot;IronMan&quot;;&#125;</code>。</p>
</blockquote>
<p>(注意类型可以省略(类型推导)。</p>
<p>下面是一些使用示例:<img src="images/lambda3.png" alt="在这里插入图片描述"></p>
<p>上图的<code>Apple</code>类: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String color;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">(String color, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="五、Java8四大内置函数式接口"><a href="#五、Java8四大内置函数式接口" class="headerlink" title="五、Java8四大内置函数式接口"></a>五、Java8四大内置函数式接口</h2><p>我们发现，如果使用<code>Lambda</code>还要自己写一个接口的话太麻烦，所以<code>Java</code>自己提供了一些接口: </p>
<ul>
<li><code>Consumer&lt; T &gt;con</code> 消费性 接口:  <code>void accept(T t)</code>；</li>
<li><code>Supplier&lt; T &gt;sup</code>供给型接口 :  <code>T get()</code>；</li>
<li> <code>Function&lt; T , R &gt;fun </code> 函数式接口 :   <code>R apply (T t)</code>；</li>
<li> <code>Predicate&lt; T &gt;</code>： 断言形接口 : <code>boolean test(T t)</code>；</li>
</ul>
<h3 id="1、Consumer-lt-T-gt-con消费性接口-void-accept-T-t"><a href="#1、Consumer-lt-T-gt-con消费性接口-void-accept-T-t" class="headerlink" title="1、Consumer&lt; T &gt;con消费性接口-void accept(T t)"></a>1、<code>Consumer&lt; T &gt;con</code>消费性接口-<code>void accept(T t)</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    apply(<span class="number">1000</span>,(num) -&gt; System.out.println(<span class="string">&quot;消费了&quot;</span> + num + <span class="string">&quot;元!&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> num,Consumer&lt;Double&gt;con)</span></span>&#123;</span><br><span class="line">    con.accept(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2、Supplier-lt-T-gt-sup供给型接口-T-get"><a href="#2、Supplier-lt-T-gt-sup供给型接口-T-get" class="headerlink" title="2、Supplier&lt; T &gt;sup供给型接口-T get()"></a>2、<code>Supplier&lt; T &gt;sup</code>供给型接口-<code>T get()</code></h3><p>例子: 产生指定个数的整数，并放入集合中；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = getNumList(<span class="number">10</span>, () -&gt; (<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>));</span><br><span class="line">    System.out.println(res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需求，产生指定个数的整数，并放入集合中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">getNumList</span><span class="params">(<span class="keyword">int</span> num, Supplier&lt;Integer&gt;sup)</span></span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt;list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">        Integer e = sup.get();</span><br><span class="line">        list.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、Function-lt-T-R-gt-fun函数式接口-R-apply-T-t"><a href="#3、Function-lt-T-R-gt-fun函数式接口-R-apply-T-t" class="headerlink" title="3、Function&lt; T, R &gt;fun函数式接口- R apply (T t)"></a>3、<code>Function&lt; T, R &gt;fun</code>函数式接口-<code> R apply (T t)</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String newStr = strHandler(<span class="string">&quot;abc&quot;</span>, (str) -&gt; str.toUpperCase());</span><br><span class="line">    System.out.println(newStr);</span><br><span class="line">    newStr = strHandler(<span class="string">&quot;   abc  &quot;</span>, (str) -&gt; str.trim());</span><br><span class="line">    System.out.println(newStr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">strHandler</span><span class="params">(String str, Function&lt;String,String&gt;fun)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fun.apply(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、Predicate-lt-T-gt-断言形接口-boolean-test-T-t"><a href="#4、Predicate-lt-T-gt-断言形接口-boolean-test-T-t" class="headerlink" title="4、Predicate&lt; T &gt;断言形接口-boolean test(T t)"></a>4、<code>Predicate&lt; T &gt;</code>断言形接口-<code>boolean test(T t)</code></h3><p>判断一些字符串数组判断长度<code>&gt;2</code>的字符串: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;atguiu&quot;</span>, <span class="string">&quot;lambda&quot;</span>, <span class="string">&quot;ok&quot;</span>, <span class="string">&quot;www&quot;</span>, <span class="string">&quot;z&quot;</span>);</span><br><span class="line">    List&lt;String&gt; res = filterStr(list, (str) -&gt; str.length() &gt; <span class="number">2</span>);</span><br><span class="line">    System.out.println(res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需求</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">filterStr</span><span class="params">(List&lt;String&gt;list, Predicate&lt;String&gt;pre)</span></span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt;res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String str : list)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.test(str))&#123;</span><br><span class="line">            res.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="六、方法引用和构造器引用"><a href="#六、方法引用和构造器引用" class="headerlink" title="六、方法引用和构造器引用"></a>六、方法引用和构造器引用</h2><h3 id="1、方法引用"><a href="#1、方法引用" class="headerlink" title="1、方法引用"></a>1、方法引用</h3><p>使用前提: <strong><code>Lambda</code>体中调用方法的参数列表和返回值类型，要和函数式接口中抽象方法的参数列表和返回值类型保持一致；</strong></font></p>
<h4 id="1-、语法格式-一-对象-实例方法名"><a href="#1-、语法格式-一-对象-实例方法名" class="headerlink" title="1)、语法格式(一) 对象::实例方法名"></a>1)、语法格式(一) 对象::实例方法名</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//普通写法</span></span><br><span class="line">     PrintStream ps = System.out;</span><br><span class="line">     Consumer&lt;String&gt;con = (x) -&gt; ps.println(x);</span><br><span class="line">     con.accept(<span class="string">&quot;hello !&quot;</span>);</span><br><span class="line"></span><br><span class="line">     System.out.println(<span class="string">&quot;----------------------&quot;</span>);</span><br><span class="line">	<span class="comment">//简写</span></span><br><span class="line">     Consumer&lt;String&gt;con1 = ps::println;</span><br><span class="line">     con1.accept(<span class="string">&quot;hello ! &quot;</span>);</span><br><span class="line"></span><br><span class="line">     System.out.println(<span class="string">&quot;----------------------&quot;</span>);</span><br><span class="line">	<span class="comment">//更简单的写法</span></span><br><span class="line">     Consumer&lt;String&gt;con2 = System.out::println;</span><br><span class="line">     con2.accept(<span class="string">&quot;hello ! &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意，这样写的前提: <code>Consumer</code>中的<code>accept()</code>方法和<code>println()</code>方法的参数列表和返回类型要完全一致:</strong><br><img src="images/lambda4.png" alt="这里写图片描述"><br><img src="images/lambda5.png" alt="这里写图片描述"></p>
<p>再看一个例子:<br>三种写法的效果是一样的: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLambda</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// method 1</span></span><br><span class="line">        Consumer&lt;String&gt; consumer = s -&gt; System.out.println(s);</span><br><span class="line">        useConsumer(consumer,<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//method 2</span></span><br><span class="line">        useConsumer(s -&gt; System.out.println(s),<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//method3   method reference (方法引用)</span></span><br><span class="line">        useConsumer(System.out::println,<span class="string">&quot;123&quot;</span>); <span class="comment">//因为println和 accept 是同样的只有一个入参，没有返回值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">useConsumer</span><span class="params">(Consumer&lt;T&gt; consumer,T t)</span></span>&#123;</span><br><span class="line">        consumer.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看一个例子: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//都是输出 字符 &#x27;l&#x27;</span></span><br><span class="line">    BiFunction&lt;String,Integer,Character&gt; bf = String::charAt; <span class="comment">//这里第一个必须传入　String</span></span><br><span class="line">    Character c = bf.apply(<span class="string">&quot;hello,&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    System.out.println(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意这里使用的是Function 接口</span></span><br><span class="line">    String str = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    Function&lt;Integer,Character&gt; f = str::charAt; <span class="comment">//这里不需要String</span></span><br><span class="line">    Character c2 = f.apply(<span class="number">2</span>);</span><br><span class="line">    System.out.println(c2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再看一个例子: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Employee emp = <span class="keyword">new</span> Employee(<span class="string">&quot;zx&quot;</span>,<span class="number">23</span>,<span class="number">5555</span>);</span><br><span class="line"></span><br><span class="line">    Supplier&lt;String&gt;sup = () -&gt; emp.getName();</span><br><span class="line">    System.out.println(sup.get());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//简写</span></span><br><span class="line">    Supplier&lt;String&gt;sup2 = emp::getName;</span><br><span class="line">    System.out.println(sup2.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="images/lambda6.png" alt="这里写图片描述"></p>
<p><img src="images/lambda7.png" alt="这里写图片描述"></p>
<h4 id="2-、语法格式-二-类名-静态方法"><a href="#2-、语法格式-二-类名-静态方法" class="headerlink" title="2)、语法格式(二)  类名::静态方法"></a>2)、语法格式(二)  类名::静态方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">     Comparator&lt;Integer&gt;com = (x,y) -&gt; Integer.compare(x,y);</span><br><span class="line"></span><br><span class="line">     Comparator&lt;Integer&gt;com2 = Integer::compare;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Integer</code>类中的</p>
<p><img src="images/lambda8.png" alt="这里写图片描述"></p>
<p><code>Comparator</code>接口中的方法: </p>
<p><img src="images/lambda9.png" alt="这里写图片描述"></p>
<h4 id="3-、语法格式-三-类-实例方法名"><a href="#3-、语法格式-三-类-实例方法名" class="headerlink" title="3)、语法格式(三) 类::实例方法名"></a>3)、语法格式(三) 类::实例方法名</font></h4><p>使用注意: <strong>若Lambda参数列表中的第一个参数是实例方法的第一个调用者，而第二个参数是实例方法的参数时，可以使用<code>ClassName :: method</code>。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BiPredicate&lt;String,String&gt;bp = (x,y) -&gt; x.equals(y);</span><br><span class="line"></span><br><span class="line">    BiPredicate&lt;String,String&gt;bp2 = String::equals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="images/lambda10.png" alt="这里写图片描述"></p>
<p><img src="images/lambda11.png" alt="这里写图片描述"></p>
<h3 id="2-、构造器引用"><a href="#2-、构造器引用" class="headerlink" title="2)、构造器引用"></a>2)、构造器引用</h3><p><strong>需要调用构造器的参数列表，要与函数式接口中的抽象方法的参数列表保持一致；</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Supplier&lt;Employee&gt;sup = () -&gt; <span class="keyword">new</span> Employee();</span><br><span class="line"></span><br><span class="line">    Supplier&lt;Employee&gt;sup2 = Employee::<span class="keyword">new</span>; <span class="comment">//调用的是默认的</span></span><br><span class="line">    System.out.println(sup2.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">name=<span class="string">&#x27;null&#x27;</span>, age=<span class="number">0</span>, salary=<span class="number">0.0</span></span><br></pre></td></tr></table></figure>

<p><img src="images/images12.png" alt="这里写图片描述"></p>
<p><img src="images/lambda12.png" alt="这里写图片描述"></p>
<p>再看构造器一个参数的: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Function&lt;String,Employee&gt;fun = Employee::<span class="keyword">new</span>;</span><br><span class="line">    System.out.println(fun.apply(<span class="string">&quot;zx&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">name=<span class="string">&#x27;zx&#x27;</span>, age=<span class="number">0</span>, salary=<span class="number">0.0</span></span><br></pre></td></tr></table></figure>

<p><img src="images/lambda13.png" alt="这里写图片描述"></p>
<p><img src="images/lambda14.png" alt="这里写图片描述"></p>
<p>如果想要匹配多个的，(两个的可以使用<code>BiFunction</code>)，下面看一个三个的:<br>例如想匹配这个: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComplexApple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ComplexApple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//匹配这个构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ComplexApple</span><span class="params">(String name, <span class="keyword">int</span> weight, String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>自己建一个接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreeFunction</span>&lt;<span class="title">A</span>,<span class="title">B</span>,<span class="title">C</span>,<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(A a,B b,C c)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreeFunction&lt;String,Integer,String,ComplexApple&gt; tf = ComplexApple::<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">        ComplexApple apple = tf.apply(<span class="string">&quot;蓝色&quot;</span>, <span class="number">12</span>, <span class="string">&quot;好苹果&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Lambda Expression</tag>
        <tag>Stream API</tag>
        <tag>Lazy Initialization</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8 Stream</title>
    <url>/2021/08/10/Stream/</url>
    <content><![CDATA[<h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><ul>
<li>一、引入流</li>
<li>二、使用流</li>
<li>三、Optional取代null</li>
<li>四、用流收集数据(collect)</li>
</ul>
<h2 id="一、引入流"><a href="#一、引入流" class="headerlink" title="一、引入流"></a>一、引入流</h2><h3 id="1、一个案例引入"><a href="#1、一个案例引入" class="headerlink" title="1、一个案例引入"></a>1、一个案例引入</h3><p>看一个使用<code>Stream</code>(Java8)和不使用<code>Stream</code>(Java7)代码量的区别。</p>
<p>这里需要筛选出一份菜单中<strong>卡路里&lt;400</strong>的菜的名字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_01_Java7AndJava8Compare</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 返回 热量&lt;400 的菜肴 的 名称, 返回结果按照从低到高排序， Java7的写法</span></span><br><span class="line">        System.out.println(java7());</span><br><span class="line">        System.out.println(java8());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> List&lt;String&gt; <span class="title">java7</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Dish&gt; lowCaloricDishes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Dish d : Dish.menu) &#123;</span><br><span class="line">            <span class="keyword">if</span> (d.getCalories() &lt; <span class="number">400</span>) &#123;</span><br><span class="line">                lowCaloricDishes.add(d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(lowCaloricDishes, <span class="keyword">new</span> Comparator&lt;Dish&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Dish d1, Dish d2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(d1.getCalories(), d2.getCalories());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;String&gt; lowCaloricDishesName = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Dish d : lowCaloricDishes) &#123;</span><br><span class="line">            lowCaloricDishesName.add(d.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lowCaloricDishesName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> List&lt;String&gt; <span class="title">java8</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; lowCaloricDishesName =</span><br><span class="line">                Dish.menu.stream()</span><br><span class="line">                        .filter(d -&gt; d.getCalories() &lt; <span class="number">400</span>)</span><br><span class="line">                        .sorted(Comparator.comparing(Dish::getCalories))</span><br><span class="line">                        .map(Dish::getName)</span><br><span class="line">                        .collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> lowCaloricDishesName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、流简介"><a href="#2、流简介" class="headerlink" title="2、流简介"></a>2、流简介</h3><ul>
<li>流简短的定义: 是数据渠道，用于操作数据源(集合，数组等)所生成的元素序列；<ul>
<li>元素序列 — 就像集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序<br>值。因为集合是数据结构，所以它的主要目的是以特定的时间/ 空间复杂度存储和访问元<br>素（如ArrayList 与 LinkedList） 。但<strong>流的目的在于表达计算</strong>，比如你前面见到的<br><code>filter、 sorted和 map</code>。<strong>集合讲的是数据，流讲的是计算</strong>。</li>
<li>源 — 流会使用一个提供数据的源，如集合、数组或输入/输出资源；</li>
<li>数据处理操作 — 流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中<br>的常用操作，如<code>filter、 map、 reduce、 find、 match、 sort</code>等；</li>
</ul>
</li>
<li>流的重要的特点<ul>
<li>流水线 — 很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大<br>的流水线；流水线的操作可以看作对数据源进行数据库式查询；</li>
<li>内部迭代 — 与使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的；</li>
<li><strong>①<code>Stream</code>自己不会存储元素；② <code>Stream</code>不会改变原对象，相反，他们会返回一个持有结果的新<code>Stream</code>；③Stream操作是延迟执行的，这意味着他们会等到需要结果的时候才执行</strong>；</li>
</ul>
</li>
</ul>
<p><img src="images/stream1.png"></p>
<h3 id="3、流与集合"><a href="#3、流与集合" class="headerlink" title="3、流与集合"></a>3、流与集合</h3><h4 id="1-、只能遍历一次"><a href="#1-、只能遍历一次" class="headerlink" title="1)、只能遍历一次"></a>1)、只能遍历一次</h4><p>请注意，<strong>和迭代器类似，流只能遍历一次</strong></p>
<ul>
<li>遍历完之后，我们就说这个流已经被消费掉了；</li>
<li>你可以从原始数据源那里再获得一个新的流来重新遍历一遍，就像迭代器一样（这里假设它是集<br>合之类的可重复的源，如果是I/O通道就没戏了）；</li>
</ul>
<h4 id="2-、外部迭代与内部迭代"><a href="#2-、外部迭代与内部迭代" class="headerlink" title="2)、外部迭代与内部迭代"></a>2)、外部迭代与内部迭代</h4><ul>
<li>使用<code>Collection</code>接口需要用户去做迭代（比如用<code>for-each</code>） ，这称为外部迭代；</li>
<li>相反， Streams库使用内部迭代；</li>
</ul>
<p>外部迭代和内部迭代的区别:</p>
<p><img src="images/stream2.png"></p>
<h3 id="4、流操作"><a href="#4、流操作" class="headerlink" title="4、流操作"></a>4、流操作</h3><p>主要分为两类操作: 中间操作和终端操作。</p>
<p><img src="images/stream3.png"></p>
<h4 id="1-、中间操作"><a href="#1-、中间操作" class="headerlink" title="1)、中间操作"></a>1)、中间操作</h4><p>中间操作就是产生的结果(仍然是一个流)。</p>
<p>诸如<code>filter</code>或<code> sorted</code>等中间操作会返回另一个流。这让多个操作可以连接起来形成一个查询。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 除非流水线上触发一个终端操作，否则中间操作不会执行任何处理</span></span><br><span class="line"><span class="comment">// 流的延迟性质。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_02_StreamDelayFeature</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; names =</span><br><span class="line">                Dish.menu.stream()</span><br><span class="line">                        .filter(d -&gt; &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;filtering&quot;</span> + d.getName());</span><br><span class="line">                            <span class="keyword">return</span> d.getCalories() &gt; <span class="number">300</span>;</span><br><span class="line">                        &#125;)</span><br><span class="line">                        .map(d -&gt; &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;mapping&quot;</span> + d.getName());</span><br><span class="line">                            <span class="keyword">return</span> d.getName();</span><br><span class="line">                        &#125;)</span><br><span class="line">                        .limit(<span class="number">3</span>)</span><br><span class="line">                        .collect(Collectors.toList());</span><br><span class="line">        System.out.println(names);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        // 终端操作</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;-------Terminal Operation------&quot;);</span></span><br><span class="line"><span class="comment">//        Dish.menu.stream().forEach(System.out::println);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看运行结果，可以发现<code>Stream</code>是有延迟的性质。</p>
<p><img src="images/stream4.png"></p>
<h4 id="2-、终止操作"><a href="#2-、终止操作" class="headerlink" title="2)、终止操作"></a>2)、终止操作</h4><p>终止操作会从流的流水线生成结果。其结果是任何不是流的值，比如List、 Integer，甚至 void。</p>
<h4 id="3-、流的使用步骤"><a href="#3-、流的使用步骤" class="headerlink" title="3)、流的使用步骤"></a>3)、流的使用步骤</h4><p>流的流水线背后的理念类似于构建器模式。</p>
<p>三个基本步骤: </p>
<ul>
<li>创建Stream : 需要一个数据源(如：集合，数组)，获取一个流；</li>
<li>中间操作: 一个中间操作链，对数据源的数据进行处理；</li>
<li>终止操作(终端操作): 一个终止操作，执行中间操作链，并产生结果；</li>
</ul>
<h2 id="二、使用流"><a href="#二、使用流" class="headerlink" title="二、使用流"></a>二、使用流</h2><h3 id="1、构建流"><a href="#1、构建流" class="headerlink" title="1、构建流"></a>1、构建流</h3><p>构建的流的方式有:</p>
<ul>
<li><p>从Collection中构建；</p>
</li>
<li><p>从值<code>value</code>(<code>Stream.of()</code>)中构建；</p>
</li>
<li><p>从数组中构建(<code>Arrays.stream()</code>)；</p>
</li>
<li><p>从文件中构建；</p>
</li>
<li><p>由函数生成: 创建无限流；</p>
</li>
</ul>
<p>创建的几种方法的示例代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 创建流的几种方法 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_03_CreateStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        PrintStream out = System.out;</span><br><span class="line"></span><br><span class="line">        out.println(<span class="string">&quot;--------fromCollection--------&quot;</span>);</span><br><span class="line">        fromCollection().forEach(x -&gt; out.print(x + <span class="string">&quot; &quot;</span>)); <span class="comment">// 从Collection中创建Stream</span></span><br><span class="line">        out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;-------fromValues---------&quot;</span>);</span><br><span class="line">        fromValues().forEach(x -&gt; out.print(x + <span class="string">&quot; &quot;</span>)); <span class="comment">// 从Collection中创建Stream</span></span><br><span class="line">        out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;--------fromArrays--------&quot;</span>);</span><br><span class="line">        fromArrays().forEach(x -&gt; out.print(x + <span class="string">&quot; &quot;</span>)); <span class="comment">// 从Collection中创建Stream</span></span><br><span class="line">        out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;--------fromFile--------&quot;</span>);</span><br><span class="line">        fromFile().forEach(out::println); <span class="comment">// 从函数中创建</span></span><br><span class="line">        out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;--------fromIterate--------&quot;</span>);</span><br><span class="line">        fromIterate().forEach(x -&gt; out.print(x + <span class="string">&quot; &quot;</span>)); <span class="comment">// 从函数中创建</span></span><br><span class="line">        out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;--------fromGenerate--------&quot;</span>);</span><br><span class="line">        fromGenerate().forEach(x -&gt; out.print(x + <span class="string">&quot; &quot;</span>)); <span class="comment">// 从函数中创建</span></span><br><span class="line">        out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;--------fromCustom--------&quot;</span>);</span><br><span class="line">        fromCustom().forEach(x -&gt; out.print(x + <span class="string">&quot; &quot;</span>));</span><br><span class="line">        out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;----------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Stream&lt;String&gt; <span class="title">fromCollection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> list.stream();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Stream&lt;String&gt; <span class="title">fromValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.of(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Stream&lt;String&gt; <span class="title">fromArrays</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String[] str = &#123;<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Stream&lt;String&gt; <span class="title">fromFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Path path = Paths.get(<span class="string">&quot;/home/zxzxin/Main.java&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; stream = Files.lines(path);</span><br><span class="line">        <span class="keyword">return</span> stream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Stream <span class="title">fromIterate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>).limit(<span class="number">5</span>); <span class="comment">// 函数创建的无限流</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Stream&lt;Double&gt; <span class="title">fromGenerate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.generate(Math::random).limit(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Custom的流  (CusSupplier)</span></span><br><span class="line">    <span class="keyword">static</span> Stream&lt;Custom&gt;fromCustom()&#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.generate(<span class="keyword">new</span> CusSupplier()).limit(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CusSupplier</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Custom</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Custom <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            index = random.nextInt(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Custom(index, <span class="string">&quot;name-&quot;</span> + index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Custom</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Custom</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Obj&#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                    <span class="string">&quot;, id=&quot;</span> + id +</span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">--------fromCollection--------</span><br><span class="line">aa bb cc </span><br><span class="line">-------fromValues---------</span><br><span class="line">aa bb cc </span><br><span class="line">--------fromArrays--------</span><br><span class="line">aa bb cc </span><br><span class="line">--------fromFile--------</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line">        PrintStream out = System.out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------fromIterate--------</span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> </span><br><span class="line">--------fromGenerate--------</span><br><span class="line"><span class="number">0.18018050075496417</span> <span class="number">0.948721748467966</span> <span class="number">0.37983036182518304</span> <span class="number">0.679145483357325</span> <span class="number">0.21520045208568783</span> </span><br><span class="line">--------fromCustom--------</span><br><span class="line">Obj&#123;name=<span class="string">&#x27;name-73&#x27;</span>, id=<span class="number">73</span>&#125; Obj&#123;name=<span class="string">&#x27;name-84&#x27;</span>, id=<span class="number">84</span>&#125; Obj&#123;name=<span class="string">&#x27;name-14&#x27;</span>, id=<span class="number">14</span>&#125; Obj&#123;name=<span class="string">&#x27;name-79&#x27;</span>, id=<span class="number">79</span>&#125; Obj&#123;name=<span class="string">&#x27;name-51&#x27;</span>, id=<span class="number">51</span>&#125; </span><br><span class="line">----------------</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2、filter、limit、skip、map、flatMap"><a href="#2、filter、limit、skip、map、flatMap" class="headerlink" title="2、filter、limit、skip、map、flatMap"></a>2、filter、limit、skip、map、flatMap</h3><ul>
<li>filter : 该操作会接受一个谓词（一个返回boolean的函数）(<code>Predicate</code>)作为参数，并返回一个包括所有符合谓词的元素的流；</li>
<li>limit : 流支持<code>limit(n)</code>方法，该方法会返回一个不超过给定长度的流；</li>
<li>skip : 流还支持<code>skip(n)</code>方法，返回一个扔掉了前n 个元素的流；</li>
<li>map : 流支持map方法，它会接受一个函数(<code>Function</code>)作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素（使用映射一词，是因为它和转换类似，但其中的细微差别在于它是“创建一个新版本”而不是去“修改”）；</li>
<li>flatMap (<strong>扁平化</strong>): <code>flatmap()</code>方法让你<strong>把一个流中的每个值都换成另一个流，然后把所有的流连接</strong><br><strong>起来成为一个流</strong>；</li>
</ul>
<p>测试代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_04_StreamOperations1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> PrintStream out;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        out = System.out;</span><br><span class="line">        out.println( <span class="string">&quot;-------filterTest---------&quot;</span>);</span><br><span class="line">        filterTest();</span><br><span class="line">        out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;-------limitTest---------&quot;</span>);</span><br><span class="line">        limitTest();</span><br><span class="line">        out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;-------skipTest---------&quot;</span>);</span><br><span class="line">        skipTest();</span><br><span class="line">        out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;-------mapTest---------&quot;</span>);</span><br><span class="line">        mapTest();</span><br><span class="line">        out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;-------flatMapTest---------&quot;</span>);</span><br><span class="line">        flatMapTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filterTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 山选出偶数且没有重复</span></span><br><span class="line">        numbers.stream()</span><br><span class="line">                .filter(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                .distinct() <span class="comment">// 去重</span></span><br><span class="line">                .forEach(x -&gt; out.print(x + <span class="string">&quot; &quot;</span>));</span><br><span class="line">        out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">limitTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">        numbers.stream().</span><br><span class="line">                limit(<span class="number">3</span>). <span class="comment">// 取前3个</span></span><br><span class="line">                forEach(x -&gt; out.print(x + <span class="string">&quot; &quot;</span>));</span><br><span class="line">        out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">skipTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">        numbers.stream().</span><br><span class="line">                skip(<span class="number">3</span>). <span class="comment">// 跳过前3个</span></span><br><span class="line">                forEach(x -&gt; out.print(x + <span class="string">&quot; &quot;</span>));</span><br><span class="line">        out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map里面需要的是 Function</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mapTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 例子1</span></span><br><span class="line">        List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">        numbers.stream().</span><br><span class="line">                map(i -&gt; i * <span class="number">2</span>). <span class="comment">// 跳过前3个</span></span><br><span class="line">                collect(Collectors.toList()).</span><br><span class="line">                forEach(x -&gt; out.print(x + <span class="string">&quot; &quot;</span>));</span><br><span class="line">        out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 例子2</span></span><br><span class="line">        List&lt;String&gt; words = Arrays.asList(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;cccc&quot;</span>, <span class="string">&quot;ddddd&quot;</span>); <span class="comment">// 长度分别为 2, 3, 4, 5</span></span><br><span class="line">        words.stream()</span><br><span class="line">                .map(String::length)</span><br><span class="line">                .collect(Collectors.toList())</span><br><span class="line">                .forEach(x -&gt; out.print(x + <span class="string">&quot; &quot;</span>));</span><br><span class="line">        out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 words去重输出字符</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">flatMapTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String[] words = &#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">// &#123;h, e, l, l, o&#125;, &#123;w, o, r, l, d&#125;</span></span><br><span class="line">        Stream&lt;String[]&gt; stream = Arrays.stream(words).map(x -&gt; x.split(<span class="string">&quot;&quot;</span>));</span><br><span class="line">        Stream&lt;String&gt; stringStream = stream.flatMap(s -&gt; Arrays.stream(s));</span><br><span class="line">        stringStream.distinct().forEach(x -&gt; out.print(x + <span class="string">&quot; &quot;</span>));</span><br><span class="line">        out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">-------filterTest---------</span><br><span class="line"><span class="number">2</span> <span class="number">4</span> </span><br><span class="line"></span><br><span class="line">-------limitTest---------</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span> </span><br><span class="line"></span><br><span class="line">-------skipTest---------</span><br><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="number">2</span> <span class="number">4</span> </span><br><span class="line"></span><br><span class="line">-------mapTest---------</span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">2</span> <span class="number">6</span> <span class="number">6</span> <span class="number">4</span> <span class="number">8</span> </span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br><span class="line"></span><br><span class="line">-------flatMapTest---------</span><br><span class="line">H e l o W r d </span><br></pre></td></tr></table></figure>

<h3 id="3、match、find、reduce"><a href="#3、match、find、reduce" class="headerlink" title="3、match、find、reduce"></a>3、match、find、reduce</h3><ul>
<li>match：查看元素是否匹配(返回boolean)，包括<code>allMatch(), anyMatch()、noneMatch()</code>；</li>
<li>find : <ul>
<li> <code>isPresent()</code>将在Optional包含值的时候返回true, 否则返回false；</li>
<li> <code>ifPresent(Consumer&lt;T&gt; block)</code>会在值存在的时候执行给定的代码块；</li>
<li><code>T get()</code>会在值存在时返回值，否则抛出一个NoSuchElement异常；</li>
<li><code>T orElse(T other)</code>会在值存在时返回值，否则返回一个默认值；</li>
<li><code>Optional&lt;T&gt; of(T value)</code>  : 通过value构造一个Optional；</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_05_StreamOperations2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> PrintStream out;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        out = System.out;</span><br><span class="line">        out.println(<span class="string">&quot;-------matchTest---------&quot;</span>);</span><br><span class="line">        matchTest();</span><br><span class="line">        out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;-------findTest---------&quot;</span>);</span><br><span class="line">        findTest();</span><br><span class="line">        out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;-------reduceTest---------&quot;</span>);</span><br><span class="line">        reduceTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">matchTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; arr = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">        out.println(arr.stream().allMatch(i -&gt; i &gt; <span class="number">10</span>));</span><br><span class="line">        out.println(arr.stream().anyMatch(i -&gt; i &gt; <span class="number">6</span>));</span><br><span class="line">        out.println(arr.stream().noneMatch(i -&gt; i &lt; <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; arr = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">        Optional&lt;Integer&gt; any = arr.stream().filter(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>).findAny();</span><br><span class="line">        out.println(any.get());</span><br><span class="line">        Optional&lt;Integer&gt; first = arr.stream().filter(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>).findFirst();</span><br><span class="line">        first.ifPresent(out::println);</span><br><span class="line">        out.println(first.get()); <span class="comment">//没有就抛出 NoSuchElementException</span></span><br><span class="line">        out.println(first.orElse(-<span class="number">1</span>)); <span class="comment">// 如果first为空就输出-1</span></span><br><span class="line">        System.out.println(first.filter(i -&gt; i == <span class="number">2</span>).get()); <span class="comment">// Optional还会产生一个stream</span></span><br><span class="line">        System.out.println(find(arr, -<span class="number">1</span>, i -&gt; i &gt; <span class="number">10</span>)); <span class="comment">// 自己写的一个防止空指针的，而Optional中有一个已经存在的</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(List&lt;Integer&gt; values, <span class="keyword">int</span> defaultValue, Predicate&lt;Integer&gt; predicate)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> val : values)&#123;</span><br><span class="line">            <span class="keyword">if</span>(predicate.test(val))</span><br><span class="line">                <span class="keyword">return</span> val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> defaultValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reduce 也是一个terminal的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reduceTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; arr = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">        System.out.println(arr.stream().reduce(<span class="number">0</span>, (a, b) -&gt; a + b)); <span class="comment">//计算数组的和 ,有初始值就是Integer</span></span><br><span class="line">        arr.stream().reduce((a, b) -&gt; a + b).ifPresent(out::println); <span class="comment">// 没有初始值就是 Optional</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提取所有的偶数相乘</span></span><br><span class="line">        <span class="keyword">int</span> res = arr.stream().filter(x -&gt; x%<span class="number">2</span> == <span class="number">0</span>).reduce(<span class="number">1</span>, (a, b) -&gt; a*b);</span><br><span class="line">        Optional.of(res).ifPresent(out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-------matchTest---------</span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">-------findTest---------</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">-------reduceTest---------</span><br><span class="line"><span class="number">28</span></span><br><span class="line"><span class="number">28</span></span><br><span class="line"><span class="number">48</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4、数值流"><a href="#4、数值流" class="headerlink" title="4、数值流"></a>4、数值流</h3><p>Java 8引入了三个原始类型特化流接口来解决这个问题：<code>IntStream、 DoubleStream和LongStream</code>，分别将流中的元素特化为<code>int、 long和 double</code>，从而避免了暗含的装箱成本。这些特化的原因并不在于流的复杂性，而是装箱造成的复杂性——即类似int和 Integer之间的效率差异。</p>
<p>映射方法:</p>
<ul>
<li>映射到数值流<ul>
<li>将流转换为特化版本的常用方法是mapToInt、 mapToDouble和 mapToLong；</li>
<li>例如mapToInt返回一个IntStream（而不是一个<code>Stream&lt;Integer&gt;</code>）；</li>
</ul>
</li>
<li> 转换回对象流</li>
<li>使用<code>boxed()</code>方法；</li>
<li>用处: 例如，IntStream上的操作只能产生原始整数。</li>
</ul>
<p>例子(勾股数):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_06_NumericStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------example1---------&quot;</span>);</span><br><span class="line">        example1();</span><br><span class="line">        System.out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;-------example2---------&quot;</span>);</span><br><span class="line">        example2();</span><br><span class="line">        System.out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;-------example3---------&quot;</span>);</span><br><span class="line">        example3();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">example1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; arr = Arrays.asList(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        Stream&lt;Integer&gt; integerStream = arr.stream().filter(i -&gt; i.intValue() &gt; <span class="number">3</span>);</span><br><span class="line">        Integer res = integerStream.reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line"></span><br><span class="line">        IntStream intStream = arr.stream().mapToInt(i -&gt; i.intValue());</span><br><span class="line">        <span class="keyword">int</span> res2 = intStream.filter(i -&gt; i &gt; <span class="number">3</span>).sum();</span><br><span class="line"></span><br><span class="line">        System.out.println(res + <span class="string">&quot; &quot;</span> + res2); <span class="comment">// 一样的，但是转换成IntStream效率更高</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 产生 a = 5 勾股数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">example2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">        Stream&lt;<span class="keyword">int</span>[]&gt; triples1 = IntStream.rangeClosed(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">                .filter(b -&gt; Math.sqrt(a * a + b * b) % <span class="number">1</span> == <span class="number">0</span>)</span><br><span class="line">                .boxed()</span><br><span class="line">                .map(b -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a, b, (<span class="keyword">int</span>) Math.sqrt(a * a + b * b)&#125;);</span><br><span class="line"></span><br><span class="line">        triples1.forEach(t -&gt;</span><br><span class="line">                System.out.println(t[<span class="number">0</span>] + <span class="string">&quot;, &quot;</span> + t[<span class="number">1</span>] + <span class="string">&quot;, &quot;</span> + t[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 产生100以内的所有勾股数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">example3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Stream&lt;<span class="keyword">int</span>[]&gt; triples2 =</span><br><span class="line">                IntStream.rangeClosed(<span class="number">1</span>, <span class="number">100</span>).boxed()</span><br><span class="line">                        .flatMap(a -&gt; IntStream.rangeClosed(a, <span class="number">100</span>) <span class="comment">// a也是100内随机产生的</span></span><br><span class="line">                                .filter(b -&gt; Math.sqrt(a*a + b*b) % <span class="number">1</span> == <span class="number">0</span>)</span><br><span class="line">                                .mapToObj(b -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a, b, (<span class="keyword">int</span>)Math.sqrt(a * a + b * b)&#125;)</span><br><span class="line">                        );</span><br><span class="line">        triples2.limit(<span class="number">10</span>).</span><br><span class="line">                forEach(t -&gt;</span><br><span class="line">                System.out.println(t[<span class="number">0</span>] + <span class="string">&quot;, &quot;</span> + t[<span class="number">1</span>] + <span class="string">&quot;, &quot;</span> + t[<span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-------example1---------</span><br><span class="line"><span class="number">9</span> <span class="number">9</span></span><br><span class="line"></span><br><span class="line">-------example2---------</span><br><span class="line"><span class="number">5</span>, <span class="number">12</span>, <span class="number">13</span></span><br><span class="line"></span><br><span class="line">-------example3---------</span><br><span class="line"><span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span></span><br><span class="line"><span class="number">5</span>, <span class="number">12</span>, <span class="number">13</span></span><br><span class="line"><span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span></span><br><span class="line"><span class="number">7</span>, <span class="number">24</span>, <span class="number">25</span></span><br><span class="line"><span class="number">8</span>, <span class="number">15</span>, <span class="number">17</span></span><br><span class="line"><span class="number">9</span>, <span class="number">12</span>, <span class="number">15</span></span><br><span class="line"><span class="number">9</span>, <span class="number">40</span>, <span class="number">41</span></span><br><span class="line"><span class="number">10</span>, <span class="number">24</span>, <span class="number">26</span></span><br><span class="line"><span class="number">11</span>, <span class="number">60</span>, <span class="number">61</span></span><br><span class="line"><span class="number">12</span>, <span class="number">16</span>, <span class="number">20</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="三、Optional取代null"><a href="#三、Optional取代null" class="headerlink" title="三、Optional取代null"></a>三、Optional取代null</h2>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Stream API</tag>
        <tag>Optional</tag>
      </tags>
  </entry>
  <entry>
    <title>Http协议</title>
    <url>/2021/11/05/Http%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a>Http协议</h1><ul>
<li><a href="#%E4%B8%80web%E5%92%8C%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80">一、Web和网络基础</a></li>
</ul>
<h2 id="一、Web和网络基础"><a href="#一、Web和网络基础" class="headerlink" title="一、Web和网络基础"></a>一、Web和网络基础</h2><h3 id="1、使用HTTP协议访问Web"><a href="#1、使用HTTP协议访问Web" class="headerlink" title="1、使用HTTP协议访问Web"></a>1、使用HTTP协议访问Web</h3><ul>
<li>客户端: 通过发送请求获取服务器资源的 Web 浏览器等，都可称为客户端（ client ）。</li>
<li>Web 使用一种名为 HTTP （ <code>HyperText Transfer Protocol</code> ，超文本传输协议）的协议作为规范，完成从客户端到服务器端等一系列运作流程。而协议是指规则的约定。Web是建立在Http协议上通信的；</li>
</ul>
<p><img src="images/http/1_%E5%AE%A2%E6%88%B7%E7%AB%AF.png"></p>
<h3 id="2、TCP-IP"><a href="#2、TCP-IP" class="headerlink" title="2、TCP/IP"></a>2、TCP/IP</h3><p>TCP/IP 协议族按层次分别分为以下 4 层：应用层、传输层、网络层和数据链路层；</p>
<ul>
<li>应用层: TCP/IP 协议族内预存了各类通用的应用服务。比如， FTP （ File Transfer Protocol ，文件传输协议）和 DNS （ Domain Name System ，域名系统）服务就是其中两类。<strong>HTTP 协议也处于该层</strong>。</li>
<li>传输层: 传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。在传输层有两个性质不同的协议： TCP （ Transmission Control Protocol ，传输控制协议）和 UDP （ User Data Protocol ，用户数据报协议）；</li>
<li>网络层: 网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。</li>
<li>数据链路层: 用来处理连接网络的硬件部分。</li>
</ul>
<p>通信传输流:</p>
<p><img src="images/http/2_.png"></p>
<p>传输过程:</p>
<p>利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。</p>
<p><strong>发送端从应用层往下走，接收端则往应用层往上走</strong>。</p>
<p>我们用 HTTP 举例来说明，首先作为发送端的客户端在应用层（ HTTP 协议）发出一个想看某个 Web 页面的HTTP 请求。</p>
<p>接着，为了传输方便，<strong>在传输层（ TCP 协议）把从应用层处收到的数据（ HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层</strong>。</p>
<p><strong>在网络层（ IP 协议），增加作为通信目的地的 MAC 地址后转发给链路层</strong>。这样一来，发往网络的通信请求就准备齐全了。</p>
<p>接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP请求。</p>
<p><img src="images/http/3_.png"></p>
<p>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。<br>这种把数据信息包装起来的做法称为<strong>封装（ encapsulate ）</strong>。</p>
<h3 id="3、IP、TCP和DNS"><a href="#3、IP、TCP和DNS" class="headerlink" title="3、IP、TCP和DNS"></a>3、IP、TCP和DNS</h3><h4 id="1-、IP-负责传输"><a href="#1-、IP-负责传输" class="headerlink" title="1)、IP(负责传输)"></a>1)、IP(负责传输)</h4><p>按层次分， <strong>IP （ Internet Protocol ）网际协议位于网络层</strong>。几乎所有使用网络的系统都会用到 IP 协议。 </p>
<p>可能有人会把 “IP” 和 “IP 地址 ” 搞混， “IP” 其实是一种协议的名称。</p>
<ul>
<li>IP 协议的作用是把<strong>各种数据包传送给对方</strong>。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是 <strong>IP 地址和 MAC地址</strong>（ Media Access Control Address ）。</li>
<li><strong>IP 地址指明了节点被分配到的地址， MAC 地址是指网卡所属的固定地址</strong>。 IP 地址可以和 MAC 地址进行配对。 IP 地址可变换，但 MAC地址基本上不会更改。</li>
</ul>
<p>使用 ARP 协议凭借 MAC 地址进行通信</p>
<ul>
<li>IP 间的通信依赖 MAC 地址。在网络上，通信的双方在同一局域网（ LAN ）内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，<strong>会利用下一站中转设备的 MAC地址来搜索下一个中转目标。这时，会采用 ARP 协议（ Address Resolution Protocol ）</strong>。 </li>
<li>ARP 是一种用以解析地址的协议，<strong>根据通信方的 IP 地址就可以反查出对应的 MAC 地址</strong>。没有人能够全面掌握互联网中的传输状况，在到达通信目标前的中转过程中，那些计算机和路由器等网络设备只能获悉很粗略的传输路线。这种机制称为路由选择（ routing ）。</li>
</ul>
<blockquote>
<p>路由选择：有点像快递公司的送货过程。想要寄快递的人，只要将自己的货物送到集散中心，就可以知道快递公司是否肯收件发货，该快递公司的集散中心检查货物的送达地址，明确下站该送往哪个区域的集散中心。接着，那个区域的集散中心自会判断是否能送到对方的家中。</p>
</blockquote>
<p><img src="images/http/4_.png"></p>
<h4 id="2-、TCP协议-确保可靠性"><a href="#2-、TCP协议-确保可靠性" class="headerlink" title="2)、TCP协议(确保可靠性)"></a>2)、TCP协议(确保可靠性)</h4><p>按层次分， TCP 位于传输层，提供可靠的字节流服务。</p>
<ul>
<li>所谓的字节流服务（ Byte Stream Service ）是指，为了方便传输，<strong>将大块数据分割成以报文段（ segment ）为单位的数据包</strong>进行管理；</li>
<li>而可靠的传输服务是指，能够把数据准确可靠地传给对方。一言以蔽之，TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方。确保数据能到达目标；</li>
</ul>
<p>为了准确无误地将数据送达目标处， TCP 协议采用了<strong>三次握手（ three-way handshaking ）策略</strong>。</p>
<ul>
<li>用 TCP 协议把数据包送出去后， TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。</li>
<li>握手过程中使用了 TCP 的标志（ flag ） —— SYN （ synchronize ） 和ACK （ acknowledgement ）。发送端首先发送一个带 <strong>SYN</strong> 标志的数据包给对方。接收端收到后，回传一个带有 <strong>SYN/ACK</strong> 标志的数据包以示传达确认信息。最后，发送端再回传一个带 <strong>ACK</strong> 标志的数据包，代表 “ 握手 ” 结束。</li>
</ul>
<p>若在握手过程中某个阶段莫名中断， TCP 协议会再次以相同的顺序发送相同的数据包。</p>
<p><img src="images/http/5_.png"></p>
<h4 id="3-、DNS-负责域名解析"><a href="#3-、DNS-负责域名解析" class="headerlink" title="3)、DNS(负责域名解析)"></a>3)、DNS(负责域名解析)</h4><p>DNS （ Domain Name System ）服务是和 HTTP 协议一样位于应用层的协议。它提供<strong>域名到 IP 地址之间</strong>的解析服务。</p>
<p>用户通常使用<strong>主机名或域名</strong>来访问对方的计算机，而不是直接通过 IP地址访问。因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯。</p>
<p>为了解决上述的问题， DNS 服务应运而生。 DNS 协议提供<strong>通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务</strong>。</p>
<p><img src="images/http/6_DNS.png"></p>
<h3 id="4-、各种协议与Http协议的关系"><a href="#4-、各种协议与Http协议的关系" class="headerlink" title="4)、各种协议与Http协议的关系"></a>4)、各种协议与Http协议的关系</h3><p><img src="images/http/7_.png"><img src="images/http/8_.png"></p>
<h3 id="5、URI和URL"><a href="#5、URI和URL" class="headerlink" title="5、URI和URL"></a>5、URI和URL</h3><p>与 URI （统一资源标识符）相比，我们更熟悉 URL （ UniformResource Locator ，统一资源定位符）。</p>
<p>URL 正是使用 Web 浏览器等访问 Web 页面时需要输入的网页地址。</p>
<h4 id="1-、URI-统一资源标识符"><a href="#1-、URI-统一资源标识符" class="headerlink" title="1)、URI(统一资源标识符)"></a>1)、URI(统一资源标识符)</h4><p>URI 是 Uniform Resource Identifier 的缩写。 </p>
<blockquote>
<p>Uniform</p>
<p>规定统一的格式可方便处理多种不同类型的资源，而不用根据上下文环境来识别资源指定的访问方式。另外，加入新增的协议方案（如http: 或 ftp: ）也更容易。</p>
<p>Resource</p>
<p>资源的定义是 “ 可标识的任何东西 ” 。除了文档文件、图像或服务（例如当天的天气预报）等能够区别于其他类型的，全都可作为资源。另外，资源不仅可以是单一的，也可以是多数的集合体。</p>
<p>Identifier</p>
<p>表示可标识的对象。也称为标识符。</p>
</blockquote>
<p> <strong>URI 就是由某个协议方案表示的资源的定位标识符</strong>。协议方案是指访问资源所使用的协议类型名称。采用 HTTP 协议时，协议方案就是 http 。除此之外，还有 <code>ftp 、mailto 、 telnet 、 file</code> 等。标准的 URI 协议方案有 30 种左右。</p>
<p><strong>URI 用字符串标识某一互联网资源，而 URL 表示资源的地点（互联网上所处的位置）。可见 URL 是 URI 的子集</strong>。<br>“ RFC3986：统一资源标识符（ URI ）通用语法 “ 中列举了几种 URI 例子，如下所示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ftp:<span class="comment">//ftp.is.co.za/rfc/rfc1808.txt</span></span><br><span class="line">http:<span class="comment">//www.ietf.org/rfc/rfc2396.txt</span></span><br><span class="line">ldap:<span class="comment">//[2001:db8::7]/c=GB?objectClass?one</span></span><br><span class="line">mailto:John.Doe@example.com</span><br><span class="line">news:comp.infosystems.www.servers.unix</span><br><span class="line">tel:+<span class="number">1</span><span class="number">-816</span><span class="number">-555</span><span class="number">-1212</span></span><br><span class="line">telnet:<span class="comment">//192.0.2.16:80/</span></span><br><span class="line">urn:oasis:names:specification:docbook:dtd:xml:<span class="number">4.1</span><span class="number">.2</span></span><br></pre></td></tr></table></figure>

<h4 id="2-、URI格式"><a href="#2-、URI格式" class="headerlink" title="2)、URI格式"></a>2)、URI格式</h4><p>表示指定的 URI ，要使用涵盖全部必要信息的绝对 URI 、绝对 URL 以及相对 URL 。相对 URL ，是指从浏览器中基本 URI 处指定的 URL ，形如<code> /image/logo.gif</code> 。</p>
<p>绝对 URI 的格式如下:</p>
<p><img src="images/http/9_.png"></p>
<p>使用 <code>http: </code>或<code>https:</code>等协议方案名获取访问资源时要指定协议类型。不区分字母大小写，最后附一个冒号（<code> :</code> ）。也可使用 data: 或 javascript: 这类指定数据或脚本程序的方案名。</p>
<ul>
<li>登录信息（认证）: 指定用户名和密码作为从服务器端获取资源时必要的登录信息（身份认证）。此项是可选项。</li>
<li>服务器地址 : <strong>使用绝对 URI 必须指定待访问的服务器地址</strong>。地址可以是类似<code>baidu.com</code> 这种 DNS 可解析的名称，或是 192.168.1.1 这类 IPv4 地址名，还可以是 <code>[0:0:0:0:0:0:0:1]</code> 这样用方括号括起来的 IPv6 地址名。</li>
<li>服务器端口号 : <strong>指定服务器连接的网络端口号</strong>。此项也是可选项，若用户省略则自动使用默认端口号。</li>
<li>带层次的文件路径 : 指定服务器上的文件路径来定位特指的资源。这与 UNIX 系统的文件目录结构相似。</li>
<li>查询字符串 : 针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数。此项可选。</li>
<li>片段标识符 : 使用片段标识符通常可标记出已获取资源中的子资源（文档内的某个位置）。但在 RFC 中并没有明确规定其使用方法。该项也为可选项。</li>
</ul>
]]></content>
      <categories>
        <category>Computer Network</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>Instrction Arrangement以及关键路径详解</title>
    <url>/2022/02/17/Instrction%20Arrangement%E4%BB%A5%E5%8F%8A%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="Instrction-Arrangement以及关键路径详解"><a href="#Instrction-Arrangement以及关键路径详解" class="headerlink" title="Instrction Arrangement以及关键路径详解"></a>Instrction Arrangement以及关键路径详解</h2><ul>
<li><a href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E8%AF%A6%E8%A7%A3">关键路径详解</a></li>
<li><a href="#hdu4109-instrction-arrangement%E9%A2%98%E8%A7%A3">Hdu4109-Instrction Arrangement题解</a></li>
</ul>
<hr>
<h3 id="关键路径详解"><a href="#关键路径详解" class="headerlink" title="关键路径详解"></a><font color  = red id = "1">关键路径详解</h3><h5 id="AOE网"><a href="#AOE网" class="headerlink" title="AOE网"></a><code>AOE</code>网</h5><p><font color = purple>概念: </p>
<ul>
<li>在一个表示工程的带权有向图中，<font color = red>用顶点表示事件，用有向边表示活动</fonT>，边上的权值表示活动的持续时间，称这样的有向图叫做边表示活动的网，简称<code>AOE</code>(<code>Activity On Edge</code>)网。AOE网中没有入边的顶点称为始点（或源点），没有出边的顶点称为终点（或汇点）。</li>
</ul>
<p>如下图的 <code>V...</code>表示事件，<code>a...</code>表示活动。<br><img src="images/g1.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>对比<code>AOV</code> (<code>Activity On Vertex Network</code>)网: 用顶点表示活动，用弧表示活动间的优先关系的有向图。</p>
</blockquote>
<ul>
<li><code>AOE</code>网可用来估算工程的完成时间，对于<code>AOE</code>网，有两个关键的问题:<ul>
<li>① 完成整个工程至少需要多少时间？</li>
<li>② 哪些活动是影响工程进度的关键？（或者说，为缩短完成工程所需要的时间，应该加快哪些活动 ?）</li>
</ul>
</li>
</ul>
<p><font color = purple>性质:</p>
<ul>
<li><p>只有在某顶点所代表的事件发生后，从该顶点出发的各活动才能开始；</p>
</li>
<li><p>只有在进入某顶点的各活动都结束，该顶点所代表的事件才能发生。</p>
</li>
</ul>
<h5 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h5><ul>
<li><p>在<code>AOE</code>网中，从始点到终点具有<font color = red>最大路径长度（该路径上的各个活动所持续的时间之和）的路径称为关键路径</font> (<code>ee[ai]=le[ai]</code>(<font color = blue>活动最早开始时间和最晚开始时间相等（没有一点商量的余地）</font>))，在关键路径上的活动叫关键活动。</p>
</li>
<li><p>由于<code>AOE</code>网中的某些活动能够同时进行，故完成整个工程所必须花费的时间应该为<font color = red>始点到终点的最大路径长度。关键路径长度是整个工程所需的最短工期。</font></p>
</li>
</ul>
<h5 id="关键路径相关的四个量"><a href="#关键路径相关的四个量" class="headerlink" title="关键路径相关的四个量"></a>关键路径相关的四个量</h5><ul>
<li>事件的最早发生时间<code>ev</code>(<code>earliest time of vertex</code>): 即顶点<code>Vk</code>的最早发生时间。</li>
<li>事件的最晚发生时间<code>lv</code>(<code>latest time of vertex</code>)  : 即顶点<code>Vk</code>的最晚发生时间。(<font color = green>也就是每个顶点对应的事件最晚需要开始的时间，超出此时间将会延误整个工期。</font>)</li>
<li>活动的最早开工时间<code>ee</code>(<code>earliest time of edge</code>): 即边<code>ak</code>的最早发生时间。</li>
<li>活动的最晚开工时间<code>le</code>(<code>latest time of edge</code>): 即弧<code>ak</code>的最晚发生时间。(<font color = green>也就是不推迟工期的最晚开工时间。</font>)</li>
</ul>
<p><font color = blue>只要求出了这四个量。然后根据活动最早开工时间<code>ee[ak]</code>和活动最晚开工时间<code>le[ak]</code>相等判断<code>ak</code>是否是关键活动(确定关键路径)。</font></p>
<h5 id="四个量的求解"><a href="#四个量的求解" class="headerlink" title="四个量的求解"></a>四个量的求解</h5><p><font color = purple><strong>①事件的最早发生时间<code>ev</code></strong></p>
<ul>
<li><code>ev[k]</code>是指从始点开始到顶点<code>vk</code>的<font color = blue>最大路径长度</font>。这个长度决定了所有从顶点<code>vk</code>发出的活动能够开工的最早时间。</li>
<li>要想求得当前的<code>ev[k]</code>，必须保证之前经过的顶点也是最大的路径，所以这是一个动态规划问题，转移方程<code>ev[k] = max&#123;ev[j] + lev&lt;Vj, Vk&gt; &#125;</code>（其中<code>Vj</code>就是<code>Vk</code>的所有前一个事件(顶点)）。</li>
<li>要想求出上面的<code>ev</code>数组，由于<code>Vk</code>发生之前要发生<code>Vj</code>，所以我们可以使用拓扑排序来辅助这一过程，也就是说， 求事件的最早发生时间<code>ev</code>的过程，就是从头至尾找拓扑序列，然后顺便维护<code>ev</code>数组的过程。</li>
</ul>
<p><img src="images/g2.png" alt="在这里插入图片描述"></p>
<p>看一个求解的例子:<br><img src="images/g3.png" alt="在这里插入图片描述"></p>
<ul>
<li><code>V0</code>最早发生时间是<code>0</code>时刻，即<code>ev[0] = 0</code>；</li>
<li><code>V1</code>最早发生时间是当<code>a0</code>完成后，也就是<code>ev[1] = 0 + a0 = 6</code>；</li>
<li>同<code>V1</code>，<code>V2 = 4、V3 = 5</code>；</li>
<li><code>V4</code>和前四个不同，前面有两条路径<code>V0 ~ V1 ~ V4</code>、<code>V0 ~ V2 ~ V4</code>到达<code>V4</code>，但是更长的一条是第一条<code>V0 ~ V1 ~ V4</code>，所以取更大<code>max</code>的，即<code>ev[4] = 7</code>；</li>
<li>后面的<code>V7</code>、<code>V8</code>和<code>V4</code>同理。</li>
</ul>
<p> <font color = purple><strong>②事件的最晚发生时间<code>lv</code></strong></p>
<ul>
<li><code>lv[k]</code>是指在不推迟整个工期的前提下,事件<code>vk</code>允许的最晚发生时间。</li>
<li>和<code>ev</code>相反，求<code>lv</code>数组是从<font color = blue>终点</font>开始求，<code>lv[n-1] = ev[n-1]</code>，然后对于前面的顶点，也是采用动态规划的方式，<code>lv[k] = min&#123; lv[j] - len&lt;Vk, Vj&gt;&#125;</code>；</li>
</ul>
<p><img src="images/g4.png" alt="在这里插入图片描述"><br><img src="images/g5.png" alt="在这里插入图片描述"><br><font color = purple><strong>③活动的最早发生时间<code>ee</code></strong></p>
<p>这个最简单：　</p>
<ul>
<li>因为活动<code>ai</code>是由弧<code>&lt;vk , vj&gt;</code>表示，则活动<code>ai</code>的最早开始时间应等于事件<code>vk</code>的最早发生时间。因此，有：<code>ee[i]=ev[k]</code></li>
</ul>
<p><font color = purple><strong>④活动的最早发生时间<code>le</code></strong></p>
<ul>
<li>活动<code>ai</code>的最晚开始时间是指，在不推迟整个工期的前提下， <code>ai</code>必须开始的最晚时间。</li>
<li>若<code>ai</code>由弧<code>&lt;vk，vj&gt;</code>表示，则<code>ai</code>的最晚开始时间要保证事件<code>vj</code>的最迟发生时间不拖后。因此，有：<code>le[ai]=lv[j]-len&lt;vk,vj&gt;</code>；</li>
</ul>
<p><img src="images/g6.png" alt="在这里插入图片描述"></p>
<h5 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h5><p>这里是按照上面的图(索引从<code>0</code>开始)，也可以按照索引从<code>1</code>开始: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CriticalPathMethod2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] in;     <span class="comment">// 入度</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] ev, lv; <span class="comment">// 事件(顶点)的最早，最晚时间</span></span><br><span class="line">        <span class="keyword">public</span> ArrayList&lt;Edge&gt; g[];</span><br><span class="line">        <span class="keyword">public</span> Stack&lt;Integer&gt;vStack; <span class="comment">//存拓扑排序的顶点</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.n = n;</span><br><span class="line">            in = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            g = <span class="keyword">new</span> ArrayList[n];</span><br><span class="line">            ev = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            lv = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            vStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                g[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                ev[i] = <span class="number">0</span>;</span><br><span class="line">                lv[i] = <span class="number">0</span>;</span><br><span class="line">                in[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> to;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> w;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.to = to;</span><br><span class="line">            <span class="keyword">this</span>.w = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**求事件的最早发生时间ev的过程，就是从头至尾找拓扑序列的过程。**/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortedTopology</span><span class="params">(Graph G)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(G.in[i] == <span class="number">0</span>)</span><br><span class="line">                queue.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> curNode = queue.poll();</span><br><span class="line">            G.vStack.push(curNode);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.g[curNode].size(); i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> to = G.g[curNode].get(i).to;</span><br><span class="line">                <span class="keyword">int</span> w = G.g[curNode].get(i).w;</span><br><span class="line">                <span class="keyword">if</span>(--G.in[to] == <span class="number">0</span>)</span><br><span class="line">                    queue.add(to);</span><br><span class="line">                <span class="comment">//ev事件最早发生: ve[to] = max&#123;ev[curNode] + len&lt;V[curNode],V[to]&gt;)&#125;</span></span><br><span class="line">                <span class="keyword">if</span>(G.ev[curNode] + w &gt; G.ev[to])  <span class="comment">// 更新的不是curNode，而是to</span></span><br><span class="line">                    G.ev[to] = G.ev[curNode] + w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;ev(事件最早)数组: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.n; i++)</span><br><span class="line">            System.out.print(G.ev[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">criticalPath</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.n; i++)</span><br><span class="line">            G.lv[i] = G.ev[G.n-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(!G.vStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> curNode = G.vStack.pop();</span><br><span class="line">            <span class="comment">//lv[curNode] = min&#123;lv[to] - len&lt;V[curNode],V[to]&gt;&#125;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.g[curNode].size(); i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> to = G.g[curNode].get(i).to;</span><br><span class="line">                <span class="keyword">int</span> w = G.g[curNode].get(i).w;</span><br><span class="line">                <span class="keyword">if</span>(G.lv[to] - w &lt; G.lv[curNode]) <span class="comment">//注意更新的不是 to 而是 curNode</span></span><br><span class="line">                    G.lv[curNode] = G.lv[to] - w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;lv(事件最迟)数组: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.n; i++)</span><br><span class="line">            System.out.print(G.lv[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求解活动最早、最晚发生时间</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ee, le; <span class="comment">//活动(边)最早、晚发生时间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;关键活动(边): &lt;左端点,右端点&gt;: 权值&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.n; v++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.g[v].size(); i++)&#123;</span><br><span class="line">                ee = G.ev[v];       <span class="comment">// 活动ai 由&lt;Vk, Vj&gt;组成，则ai(ee) = ev[k] --&gt; 活动最早发生就是前面的事件最早发生</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> to = G.g[v].get(i).to;</span><br><span class="line">                <span class="keyword">int</span> w = G.g[v].get(i).w;</span><br><span class="line"></span><br><span class="line">                le = G.lv[to] - w;  <span class="comment">// 活动ai 由&lt;Vk, Vj&gt;组成，则ai(le) = lv[j] - len&lt;Vk, Vj&gt;</span></span><br><span class="line">                <span class="keyword">if</span>(ee == le)   <span class="comment">//关键活动</span></span><br><span class="line">                    System.out.format(<span class="string">&quot;&lt;V%d,V%d&gt;: %d\n&quot;</span>, v, to, w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line">        <span class="keyword">int</span> n = cin.nextInt();</span><br><span class="line">        <span class="keyword">int</span> m = cin.nextInt();</span><br><span class="line"></span><br><span class="line">        Graph G = <span class="keyword">new</span> Graph(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> from = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> to = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> w = cin.nextInt();</span><br><span class="line">            G.g[from].add(<span class="keyword">new</span> Edge(to, w));</span><br><span class="line">            G.in[to]++;</span><br><span class="line">        &#125;</span><br><span class="line">        sortedTopology(G); <span class="comment">//拓扑排序求 G.ev : 每个顶点(事件)的最早发生时间</span></span><br><span class="line">        criticalPath(G); <span class="comment">// 求解关键路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上图的测试结果:<br><img src="images/g7.png" alt="在这里插入图片描述"></p>
<hr>
<h3 id="Hdu4109-Instrction-Arrangement题解"><a href="#Hdu4109-Instrction-Arrangement题解" class="headerlink" title="Hdu4109-Instrction Arrangement题解"></a><font color  = red id = "2">Hdu4109-Instrction Arrangement题解</h3><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4109">题目链接</a></h4><h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>给你<code>n</code>和<code>m</code>代表编号<code>0 ~ n-1</code>个任务(顶点)，和<code>m</code>条关系(边)，每条关系由<code>X、Y、Z</code>，代表想要完成<code>Y</code>必须先完成<code>X</code>并花费<code>Z</code>个时间、<code>CPU</code>可以同时完成多个任务处理，一次花费一个单位时间。问完成<code>0 ~ n-1</code>个任务需要多少时间。</p>
<p><img src="images/g8.png" alt="在这里插入图片描述"></p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><ul>
<li>这个比关键路径更加简单，其实就是求一个<code>ev</code>数组的最大值；</li>
<li>也就是求这个图(<font color = red>可能不连通，但是我们求一个最大值即可</font>)这些连通分量的最长路径长度的最大值.</li>
<li>所以我们只需要通过拓扑排序求出<code>ev</code>数组即可。</li>
<li>值得注意的是，因为这里不是<font color = red>“时刻”</font>，所以起点不是<code>0</code>，而是<code>1</code>；<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] in;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] ev;</span><br><span class="line">        <span class="keyword">public</span> ArrayList&lt;Edge&gt; g[];</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.n = n;</span><br><span class="line">            in = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            g = <span class="keyword">new</span> ArrayList[n];</span><br><span class="line">            ev = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                in[i] = <span class="number">0</span>;</span><br><span class="line">                g[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                ev[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> to;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> w;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.to = to;</span><br><span class="line">            <span class="keyword">this</span>.w = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**求事件的最早发生时间ev的过程，就是从头至尾找拓扑序列的过程。**/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortedTopology</span><span class="params">(Graph G)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(G.in[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.add(i);</span><br><span class="line">                G.ev[i] = <span class="number">1</span>; <span class="comment">// this is important   不是时间，而是CPU的花费，所以初始化不是0而是1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> curNode = queue.poll();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.g[curNode].size(); i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> to = G.g[curNode].get(i).to;</span><br><span class="line">                <span class="keyword">int</span> w = G.g[curNode].get(i).w;</span><br><span class="line">                <span class="keyword">if</span>(--G.in[to] == <span class="number">0</span>)</span><br><span class="line">                    queue.add(to);</span><br><span class="line">                <span class="comment">//ev事件最早发生: ve[to] = max&#123;ev[curNode] + len&lt;V[curNode],V[to]&gt;)&#125;</span></span><br><span class="line">                <span class="keyword">if</span>(G.ev[curNode] + w &gt; G.ev[to])  <span class="comment">// 更新的不是curNode，而是to</span></span><br><span class="line">                    G.ev[to] = G.ev[curNode] + w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line">        <span class="keyword">while</span>(cin.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> m = cin.nextInt();</span><br><span class="line">            Graph G = <span class="keyword">new</span> Graph(n);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> from = cin.nextInt();</span><br><span class="line">                <span class="keyword">int</span> to = cin.nextInt();</span><br><span class="line">                <span class="keyword">int</span> w = cin.nextInt();</span><br><span class="line">                G.g[from].add(<span class="keyword">new</span> Edge(to, w));</span><br><span class="line">                G.in[to]++;</span><br><span class="line">            &#125;</span><br><span class="line">            sortedTopology(G);</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.n; i++)</span><br><span class="line">                res = Math.max(res, G.ev[i]);</span><br><span class="line">            System.out.println(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Graph</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言基础知识总结(一)</title>
    <url>/2021/10/01/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93(%E4%B8%80)/</url>
    <content><![CDATA[<h2 id="C语言基础知识总结-一"><a href="#C语言基础知识总结-一" class="headerlink" title="C语言基础知识总结(一)"></a>C语言基础知识总结(一)</h2><ul>
<li><a href="#%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C">编译、运行</a><ul>
<li><a href="#%E7%BC%96%E8%AF%91%E6%A0%BC%E5%BC%8F">编译格式</a></li>
<li><a href="#c%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B">C语言编译过程</a></li>
<li><a href="#cpu%E5%AF%84%E5%AD%98%E5%99%A8">CPU、寄存器</a></li>
<li><a href="#%E5%85%B3%E4%BA%8Evs%E7%9A%84c4996%E9%94%99%E8%AF%AF">关于VS的C4996错误</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E5%88%B6%E5%8E%9F%E5%8F%8D%E8%A1%A5%E7%A0%81">进制，原、反、补码</a><ul>
<li><a href="#%E8%BF%9B%E5%88%B6%E7%9B%B8%E5%85%B3">进制相关</a></li>
<li><a href="#%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81">原码、反码、补码</a></li>
<li><a href="#%E5%8E%9F%E7%A0%81%E5%92%8C%E8%A1%A5%E7%A0%81%E4%BA%92%E6%8D%A2">原码和补码互换</a></li>
<li><a href="#%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB">有符号和无符号的区别</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%96%E5%80%BC%E5%88%86%E6%9E%90">数据类型取值分析</a></li>
<li><a href="#%E8%B6%8A%E7%95%8C%E9%97%AE%E9%A2%98">越界问题</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BF%90%E7%AE%97%E7%AC%A6%E7%AD%89%E5%9F%BA%E7%A1%80">数据类型、运算符等基础</a><ul>
<li><a href="#c%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">C语言数据类型</a></li>
<li><a href="#sizeof%E5%85%B3%E9%94%AE%E5%AD%97">sizeof关键字</a></li>
<li><a href="#char%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-char%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%B0%B1%E6%98%AF%E4%B8%80%E4%B8%AA1%E5%AD%97%E8%8A%82%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%95%B4%E5%9E%8B">char数据类型-char的本质就是一个1字节大小的整型</a></li>
<li><a href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8D%E5%87%86%E7%A1%AE%E7%B1%BB%E5%9E%8B%E9%99%90%E5%AE%9A%E7%AC%A6">浮点数不准确、类型限定符</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E9%97%AE%E9%A2%98">字符的输入问题</a></li>
<li><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%85%88%E7%BA%A7">运算符以及优先级</a></li>
<li><a href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">类型转换</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E7%BB%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0">数组、字符串、函数</a><ul>
<li><a href="#%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F">数组初始化的几种方式</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2">字符数组与字符串</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%87%BA%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E4%B8%80%E7%B3%BB%E5%88%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98">字符串输出乱码问题以及一系列字符串要注意的问题</a></li>
<li><a href="#%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90">随机数生成</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0">字符串相关函数</a></li>
<li><a href="#%E5%87%BD%E6%95%B0">函数</a></li>
</ul>
</li>
</ul>
<hr>
<h3 id="编译、运行"><a href="#编译、运行" class="headerlink" title="编译、运行"></a>编译、运行</h3><h5 id="编译格式"><a href="#编译格式" class="headerlink" title="编译格式"></a>编译格式</h5><p> <code>gcc -o main main.cpp</code>生成<code>main</code>可执行文件，可以有两种运行方式: </p>
<ul>
<li>当前目录运行<code>./main</code>；</li>
<li><font color = red>绝对路径运行</font>，例如<code>/home/zxzxin/C/main</code>，要注意的是绝对路 径没有<code>.</code>，因为<code>.</code>代表的是当前路径，也就是说我们只需要<font color = blue>写上完整路径即可；</font> </li>
</ul>
<p> 编译命令格式 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc [-option] ... &lt;filename&gt;   //c语言编译</span><br><span class="line">g++ [-option] ... &lt;filename&gt;   //c++编译</span><br></pre></td></tr></table></figure>
<ul>
<li>gcc、g++编译常用选项说明：</li>
</ul>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-o file</td>
<td>指定生成的输出文件名为file</td>
</tr>
<tr>
<td>-E</td>
<td>只进行预处理</td>
</tr>
<tr>
<td>-S(大写)</td>
<td>只进行预处理和编译</td>
</tr>
<tr>
<td>-c(小写)</td>
<td>只进行预处理、编译和汇编</td>
</tr>
</tbody></table>
<ul>
<li>注意下面的两种方式生成可执行文件的效果是一样的: </li>
</ul>
<p><img src="images/c1.png" alt="在这里插入图片描述"><br><strong>平台问题:</strong><br>① Linux编译后的可执行程序只能在Linux运行，Windows编译后的程序只能在Windows下运行；<br>②64位的Linux编译后的程序只能在64位Linux下运行，32位Linux编译后的程序只能在32位的Linux运行；<br>③<font color = blue>64位的Windows编译后的程序只能在64位Windows下运行，32位Windows编译后的程序<font color = red>可以</font>在64位的Windows运行；</font></p>
<p><strong>可以在程序中嵌套<code>Linux</code>的命令，会在可执行文件的对应目录执行相应的命令；</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before\n&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;ls -alh&quot;</span>); <span class="comment">// system内放置 linux的命令  甚至也可以在&quot;&quot;内放 ./a.out这种，也可以调用</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行: </p>
<p><img src="images/c2.png" alt="在这里插入图片描述"></p>
<ul>
<li><code>#include&lt; &gt;</code> 与 <code>#include &quot;&quot;</code>的区别：<br>①<code>&lt; &gt;</code> 表示系统直接按系统指定的目录检索；<br>② <code>&quot;&quot;</code> 表示系统先在 <code>&quot;&quot;</code> 指定的路径(没写路径代表当前路径)查找头文件，如果找不到，再按系统指定的目录检索；</li>
</ul>
<h5 id="C语言编译过程"><a href="#C语言编译过程" class="headerlink" title="C语言编译过程"></a>C语言编译过程</h5><p>C代码编译成可执行程序经过4步：</p>
<ul>
<li>1）预处理：宏定义展开、头文件展开、条件编译等，同时将代码中的注释删除，这里并不会检查语法；</li>
<li>2）编译：检查语法，将预处理后文件编译生成汇编文件； </li>
<li>3）汇编：将汇编文件生成目标文件(二进制文件)；</li>
<li>4）链接：C语言写的程序是需要依赖各种库的，所以编译之后还需要把库链接到最终的可执行程序中去；</li>
</ul>
<p><img src="images/c3.png" alt="在这里插入图片描述"></p>
<p><img src="images/c4.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20181106195818281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><font color = red>然而一般编译的时候都是使用的一步编译</font>。 (但是这样还是经过：<font color = red>预处理、编译、汇编、链接的过程。)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc hello.c -o hello</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Linux</code>下查找程序所依赖的动态库</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ldd hello</span><br></pre></td></tr></table></figure>
<h5 id="CPU、寄存器"><a href="#CPU、寄存器" class="headerlink" title="CPU、寄存器"></a>CPU、寄存器</h5><ul>
<li>寄存器是CPU内部最基本的存储单元；</li>
<li>CPU对外是通过总线(地址、控制、数据)来和外部设备交互的，总线的宽度是8位，同时CPU的寄存器也是8位，那么这个CPU就叫8位CPU</li>
<li>CPU计算时，先预先把要用的数据从硬盘读到内存，然后再把即将要用的数据读到寄存器。于是<code> CPU&lt;---&gt;寄存器&lt;---&gt;内存</code>，这就是它们之间的信息交换，看下面的图片说明:  </li>
</ul>
<p><font color = red> 寄存器、缓存、内存三者关系: </p>
<p><img src="images/c5.png" alt="在这里插入图片描述"></p>
<h5 id="关于VS的C4996错误"><a href="#关于VS的C4996错误" class="headerlink" title="关于VS的C4996错误"></a>关于VS的C4996错误</h5><ul>
<li>由于微软在VS2013中不建议再使用C的传统库函数scanf,strcpy,sprintf等，所以直接使用这些库函数会提示C4996错误。VS建议采用带<code>_s</code>的函数，如<code>scanf_s</code>、<code>strcpy_s</code>，但这些并不是标准C函数。</li>
<li>要想继续使用此函数，需要在源文件中添加以下两个指令中的一个就可以避免这个错误提示：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS     <span class="comment">//这个宏定义最好要放到.c文件的第一行</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable:4996)	<span class="comment">//或者使用这个</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="进制，原、反、补码"><a href="#进制，原、反、补码" class="headerlink" title="进制，原、反、补码"></a>进制，原、反、补码</h3><h5 id="进制相关"><a href="#进制相关" class="headerlink" title="进制相关"></a>进制相关</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">123</span>;		<span class="comment">//十进制方式赋</span></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0123</span>;		<span class="comment">//八进制方式赋值， 以数字0开</span></span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0xABC</span>;	<span class="comment">//十六进制方式赋值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果在printf中输出一个十进制数那么用%d，八进制用%o，十六进制是%x</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;十进制：%d\n&quot;</span>,a );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;八进制：%o\n&quot;</span>, b);	<span class="comment">// %o,为字母o,不是数字</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;十六进制：%x\n&quot;</span>, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">十进制：<span class="number">123</span></span><br><span class="line">八进制：<span class="number">123</span></span><br><span class="line">十六进制：abc</span><br></pre></td></tr></table></figure>

<h5 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h5><h6 id="原码"><a href="#原码" class="headerlink" title="原码"></a><font color = green>原码</h6><p>一个数的原码(原始的二进制码)有如下特点：</p>
<ul>
<li>最高位做为符号位，0表示正,为1表示负；</li>
<li>其它数值部分就是数值本身绝对值的二进制数；</li>
<li><font color = blue>负数的原码是在其绝对值(相反数)的基础上，最高位变为1；</li>
</ul>
<p>例如：(以一个字节(8bit)来看)　<br>|十进制数|原码|<br>|–|–|<br>|+15|0000 1111|<br>|-15|1000 1111|<br>|+0|0000 0000|<br>|-0|1000 0000|</p>
<p><font color = red>原码存储导致2个问题：</p>
<ul>
<li>0有两种存储方式；</li>
<li>正数和负数相加，结果不正确（<font color = blue>计算机只会加不会减</font>）；</li>
</ul>
<p>例如:<br>以<font color = blue>原码</font>来算不同符号的数: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="number">-1</span> = <span class="number">1</span> + <span class="number">-1</span></span><br><span class="line">  <span class="number">1</span>： <span class="number">0000</span> <span class="number">0001</span></span><br><span class="line"> <span class="number">-1</span>： <span class="number">1000</span> <span class="number">0001</span></span><br><span class="line">      <span class="number">1000</span> <span class="number">0010</span> = <span class="number">-2</span>   <span class="comment">//答案错误</span></span><br></pre></td></tr></table></figure>

<h6 id="反码"><a href="#反码" class="headerlink" title="反码"></a><font color = green>反码</h6><ul>
<li>正数的原码和反码是一样；</li>
<li>对于负数，先求原码，<font color = red>在原码基础上，符号位不变，其它位取反（0为1， 1变0）；</li>
</ul>
<p>例如：(以一个字节(8bit)来看)　</p>
<table>
<thead>
<tr>
<th>十进制数</th>
<th>原码</th>
<th>反码</th>
</tr>
</thead>
<tbody><tr>
<td>+15</td>
<td>0000 1111</td>
<td>0000 1111</td>
</tr>
<tr>
<td>-15</td>
<td>1000 1111</td>
<td>1111 0000</td>
</tr>
<tr>
<td>+0</td>
<td>0000 0000</td>
<td>0000 0000</td>
</tr>
<tr>
<td>-0</td>
<td>1000 0000</td>
<td>1111 1111</td>
</tr>
</tbody></table>
<p>反码计算两个符号不同的数:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="number">-1</span> = <span class="number">1</span> + <span class="number">-1</span></span><br><span class="line"> <span class="number">1</span>：<span class="number">0000</span> <span class="number">0001</span></span><br><span class="line"><span class="number">-1</span>：<span class="number">1111</span> <span class="number">1110</span></span><br><span class="line">    <span class="number">1111</span> <span class="number">1111</span> = <span class="number">-0</span>   <span class="comment">//答案是对的</span></span><br></pre></td></tr></table></figure>

<p><font color = blue>但是反码还是没有解决</font><font color = red>0有两种存储方式</font>的问题。 </p>
<h6 id="补码"><a href="#补码" class="headerlink" title="补码"></a><font color = green>补码</h6><p><font color = red>综上，计算机存储数字以补码方式存储（为了解决负数的存储）； </p>
<p>补码特点: </p>
<ul>
<li>对于正数，原码、反码、补码相同；</li>
<li>对于负数，其补码为它的反码加1；</li>
</ul>
<p>例如：(以一个字节(8bit)来看)　</p>
<table>
<thead>
<tr>
<th>十进制数</th>
<th>原码</th>
<th>反码</th>
<th>补码</th>
</tr>
</thead>
<tbody><tr>
<td>+15</td>
<td>0000 1111</td>
<td>0000 1111</td>
<td>0000 1111</td>
</tr>
<tr>
<td>-15</td>
<td>1000 1111</td>
<td>1111 0000</td>
<td>1111 0001</td>
</tr>
<tr>
<td>+0</td>
<td>0000 0000</td>
<td>0000 0000</td>
<td>0000 0000</td>
</tr>
<tr>
<td>-0</td>
<td>1000 0000</td>
<td>1111 1111</td>
<td>0000 0000</td>
</tr>
</tbody></table>
<p>补码计算: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="number">-1</span> = <span class="number">1</span> + <span class="number">-1</span></span><br><span class="line"> <span class="number">1</span>：<span class="number">0000</span> <span class="number">0001</span></span><br><span class="line"><span class="number">-1</span>：<span class="number">1111</span> <span class="number">1111</span></span><br><span class="line">   <span class="number">10000</span> <span class="number">0000</span>（最高位丢弃） = <span class="number">0000</span> <span class="number">0000</span>  <span class="comment">//注意1字节，所以丢弃最高位</span></span><br></pre></td></tr></table></figure>

<p><font color = red>记得一个原则: </p>
<ul>
<li>十进制数  –&gt;  站在用户的角度  –&gt; 原码；</li>
<li>二进制、八进制、十六进制   –&gt;  站在计算机角度  –&gt; 补码；</li>
</ul>
<h5 id="原码和补码互换"><a href="#原码和补码互换" class="headerlink" title="原码和补码互换"></a>原码和补码互换</h5><p><font color = purple>原码求补码：</p>
<ul>
<li>①. 先求原码: 最高位符号位，其它位就是二进制；</li>
<li>②. 在①基础上，符号位不变，其它位取反；</li>
<li>③. 在②基础上加1；</li>
</ul>
<p><font color = purple>补码求原码：</p>
<ul>
<li>①.  先得到补码；</li>
<li>②.  求补码的反码，符号位不变，其它位取反；</li>
<li>③.   在②基础上加1(<font color = blue>注意不要人为的相乘相反是减)</li>
</ul>
<p><font color  =red>综上，在计算机系统中，数值一律用补码来存储，主要原因是：</p>
<ul>
<li>统一了零的编码；</li>
<li>将符号位和其它位统一处理；</li>
<li>将减法运算转变为加法运算；</li>
<li>两个用补码表示的数相加时，如果最高位(符号位)有进位，则进位被舍弃；</li>
</ul>
<p>相关案例计算转换: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a = <span class="number">0x81</span>; <span class="comment">// 计算机的角度(补码)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>,a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> b = <span class="number">0xe5</span>;<span class="comment">//计算机的角度(补码)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %d\n&quot;</span>,b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> c = <span class="number">0x6f</span>; <span class="comment">//计算机的角度(补码)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c = %d\n&quot;</span>,c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> d = <span class="number">-123</span>; <span class="comment">//人类的角度 --&gt; 看成原码</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d = %x\n&quot;</span>,d);<span class="comment">//输出16进制(计算机的角度)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a = <span class="number">-127</span></span><br><span class="line">b = <span class="number">-27</span></span><br><span class="line">c = <span class="number">111</span></span><br><span class="line">d = ffffff85</span><br></pre></td></tr></table></figure>
<p><font color = red>对于上面程序的分析:</font> </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二进制、八进制、十六进制，站在计算机角度，补码</span></span><br><span class="line"><span class="comment">//0x81转为为二进制位1000 0001，最高位为1，说明是负数</span></span><br><span class="line"><span class="keyword">char</span> a = <span class="number">0x81</span>;</span><br><span class="line">补码：<span class="number">1000</span> <span class="number">0001</span></span><br><span class="line">反码：<span class="number">1111</span> <span class="number">1110</span></span><br><span class="line">原码：<span class="number">1111</span> <span class="number">1111</span> = <span class="number">-127</span> </span><br><span class="line"><span class="comment">//10进制数，站在用户的角度，原码</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a); <span class="comment">//-127</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制、八进制、十六进制，站在计算机角度，补码</span></span><br><span class="line"><span class="comment">//0xe5二进制为1110 0101，最高位为1，说明是负数，它是负数的补码</span></span><br><span class="line"><span class="keyword">char</span> b = <span class="number">0xe5</span>;</span><br><span class="line">补码：<span class="number">1110</span> <span class="number">0101</span></span><br><span class="line">反码：<span class="number">1001</span> <span class="number">1010</span></span><br><span class="line">原码：<span class="number">1001</span> <span class="number">1011</span> = <span class="number">-27</span></span><br><span class="line"><span class="comment">//10进制数，站在用户的角度，原码</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b);<span class="comment">// -27</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">0x6f</span>的二级制为<span class="number">0110</span> <span class="number">1111</span>，最高位为<span class="number">0</span>，它是正数</span><br><span class="line"><span class="keyword">char</span> c = <span class="number">0x6f</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, c);<span class="comment">// 111 原码、反码、补码都相同</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//10进制数，站在用户的角度，原码</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">-123</span>;<span class="comment">//注意这个是十进制，所以直接就是原码</span></span><br><span class="line">原码：<span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0111</span> <span class="number">1011</span></span><br><span class="line">反码：<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1000</span> <span class="number">0100</span></span><br><span class="line">补码：<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1000</span> <span class="number">0101</span></span><br><span class="line">	   f     f   f    f     f   f    <span class="number">8</span>     <span class="number">5</span></span><br><span class="line">%x，默认以<span class="number">4</span>个字节(<span class="number">32</span>位)大小打印</span><br><span class="line"><span class="comment">//二进制、八进制、十六进制，站在计算机角度，补码</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, a);<span class="comment">// 16进制打印 ffffff85</span></span><br></pre></td></tr></table></figure>

<h5 id="有符号和无符号的区别"><a href="#有符号和无符号的区别" class="headerlink" title="有符号和无符号的区别"></a>有符号和无符号的区别</h5><ul>
<li> 有符号，最高位是符号位，如果是1代表为负数，如果为0代表为正数；</li>
<li>无符号，最高位不是符号位，是数的一部分，无符号不可能是负数；</li>
</ul>
<p>测试: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1000 0000 0000 0000 0000 0000 0111 1011</span></span><br><span class="line">    <span class="comment">// 8000007b</span></span><br><span class="line">    <span class="comment">// %d按照有符号数来打印  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">0x8000007b</span>);</span><br><span class="line">    <span class="comment">// %u按照无符号数打印</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, <span class="number">0x8000007b</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// signed 和 unsigned</span></span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> b = <span class="number">-10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意输出结果　以%d 为准，%d表示按照有符号数来输出    </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> c = <span class="number">0x8000007b</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c[有符号] = %d\n&quot;</span>,c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c[无符号] = %u\n&quot;</span>,c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">-2147483525</span></span><br><span class="line"><span class="number">2147483771</span></span><br><span class="line">c[有符号] = <span class="number">-2147483525</span></span><br><span class="line">c[无符号] = <span class="number">2147483771</span></span><br></pre></td></tr></table></figure>
<p>分析: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0111</span> <span class="number">1011</span>   <span class="comment">//二进制</span></span><br><span class="line"><span class="number">8000007b</span>   <span class="comment">//16进制  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//有符号   ---&gt;   %d, 默认以有符号的方式打印</span></span><br><span class="line">补码：<span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0111</span> <span class="number">1011</span></span><br><span class="line">反码：<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1000</span> <span class="number">0100</span></span><br><span class="line">原码：<span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1000</span> <span class="number">0101</span></span><br><span class="line">     - <span class="number">7</span>   f    f    f    f    f    <span class="number">8</span>    <span class="number">5</span> = <span class="number">-2147483525</span></span><br><span class="line">										     <span class="number">-2147483525</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">0x8000007b</span>); <span class="comment">//-2147483525</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//无符号(最高位看做是数的一部分)  ---&gt;    %u, 以无符号的方式打印</span></span><br><span class="line"><span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0111</span> <span class="number">1011</span></span><br><span class="line"><span class="number">8000007b</span> = <span class="number">2147483771</span></span><br><span class="line">		   <span class="number">2147483771</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, <span class="number">0x8000007b</span>); <span class="comment">//2147483771</span></span><br></pre></td></tr></table></figure>

<h5 id="数据类型取值分析"><a href="#数据类型取值分析" class="headerlink" title="数据类型取值分析"></a>数据类型取值分析</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">数据类型范围（站在<span class="number">10</span>进制角度，原码）：</span><br><span class="line"><span class="keyword">char</span> <span class="number">1</span>个字节（<span class="number">8</span>位，<span class="number">8b</span>it）</span><br><span class="line">有符号的范围：</span><br><span class="line">正数：</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> ~ <span class="number">0111</span> <span class="number">1111</span></span><br><span class="line"><span class="number">0</span>             <span class="number">127</span></span><br><span class="line"></span><br><span class="line">负数：</span><br><span class="line"><span class="number">1000</span> <span class="number">0000</span> ~ <span class="number">1111</span> <span class="number">1111</span></span><br><span class="line"><span class="number">-0</span> ~ <span class="number">-127</span></span><br><span class="line"></span><br><span class="line">注意这里比较特使：</span><br><span class="line"><span class="number">-0</span> 当做 <span class="number">-128</span>使用</span><br><span class="line"><span class="number">-128</span>：</span><br><span class="line">原码：  <span class="number">1</span> <span class="number">1000</span> <span class="number">0000</span> </span><br><span class="line">反码：  <span class="number">1</span> <span class="number">0111</span> <span class="number">1111</span></span><br><span class="line">补码：  <span class="number">1</span> <span class="number">1000</span> <span class="number">0000</span></span><br><span class="line">这个很特别: <span class="number">-128</span>的原码和补码是一样的，发现和<span class="number">0</span> (<span class="number">1000</span> <span class="number">0000</span>)也是一样的。</span><br><span class="line"></span><br><span class="line">无符号范围：</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> ~ <span class="number">1111</span> <span class="number">1111</span></span><br><span class="line"><span class="number">0</span> ~ <span class="number">255</span></span><br></pre></td></tr></table></figure>
<p>综上，char:</p>
<ul>
<li>有符号：-128 ~ 127；</li>
<li>无符号：0 ~ 255；<h5 id="越界问题"><a href="#越界问题" class="headerlink" title="越界问题"></a>越界问题</h5>赋值或者运算，记得不要越界，下面展示了越界的情况: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//有符号越界</span></span><br><span class="line">    <span class="keyword">char</span> a = <span class="number">127</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>,a);  <span class="comment">//-127</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//无符号越界</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> b = <span class="number">255</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %u\n&quot;</span>,b);  <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
输出: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">-127</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
分析: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a = <span class="number">127</span> + <span class="number">2</span>;</span><br><span class="line"><span class="number">129</span>转换为二进制：<span class="number">1000</span> <span class="number">0001</span>，这是负数补码(计算机角度)</span><br><span class="line">补码：<span class="number">1000</span> <span class="number">0001</span> </span><br><span class="line">反码：<span class="number">1111</span> <span class="number">1110</span></span><br><span class="line">原码：<span class="number">1111</span> <span class="number">1111</span>(最高位是符号位) = <span class="number">-127</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);<span class="comment">//-127</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> b = <span class="number">255</span> + <span class="number">2</span>; </span><br><span class="line"><span class="number">257</span>转化为二进制 ：<span class="number">0001</span> <span class="number">0000</span> <span class="number">0001</span> （只取后<span class="number">8</span>位）</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, b);<span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="数据类型、运算符等基础"><a href="#数据类型、运算符等基础" class="headerlink" title="数据类型、运算符等基础"></a>数据类型、运算符等基础</h3><h5 id="C语言数据类型"><a href="#C语言数据类型" class="headerlink" title="C语言数据类型"></a>C语言数据类型</h5><ul>
<li><p>数据类型的作用：编译器预算对象（变量）分配的内存空间大小。</p>
<p><img src="images/c6.png" alt="在这里插入图片描述"> </p>
</li>
</ul>
<p><strong>变量特点:</strong></p>
<ul>
<li><p><font color = red>变量在编译时为其分配相应的内存空间；</font></p>
</li>
<li><p><font color = red>可以通过其名字和地址访问相应内存；</p>
<p><img src="images/c7.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<p><strong>声明和定义的区别:</strong></p>
<ul>
<li><p><font color = blue>声明变量不需要建立存储空间，如：<code>extern int a</code>; (使用<code>extern</code>关键字)</p>
</li>
<li><p>定义变量需要建立存储空间，如：<code>int b</code>;</p>
</li>
<li><p>从广义的角度来讲声明中包含着定义，即定义是声明的一个特例，所以并非所有的声明都是定义：<br> ① <code>int b</code> 它既是声明，同时又是定义；<br> ②对于<code>extern int b</code>来讲它只是声明不是定义；</p>
</li>
<li><p><font color = blue>一般的情况下，把建立存储空间的声明称之为“定义”，而把不需要建立存储空间的声明称之为“声明”。</p>
</li>
</ul>
<h5 id="sizeof关键字"><a href="#sizeof关键字" class="headerlink" title="sizeof关键字"></a>sizeof关键字</h5><ul>
<li><code>sizeof</code>不是函数，所以不需要包含任何头文件，它的功能是<font color = red>计算一个数据类型的大小，单位为字节；</li>
<li><code>sizeof</code>的返回值为<code>size_t</code>；</li>
<li><code>size_t</code>类型在32位操作系统下是<code>unsigned int</code>，是一个无符号的整数；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">//数据类型的作用: 告诉编译器，分配此类型的变量需要多大的空间</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(char) = %u\n&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(a) = %d\n&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">long</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(long) = %u\n&quot;</span>,len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) = <span class="number">1</span></span><br><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span>(a) = <span class="number">4</span></span><br><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">long</span>) = <span class="number">8</span></span><br></pre></td></tr></table></figure>
<h5 id="char数据类型-char的本质就是一个1字节大小的整型"><a href="#char数据类型-char的本质就是一个1字节大小的整型" class="headerlink" title="char数据类型-char的本质就是一个1字节大小的整型"></a>char数据类型-char的本质就是一个1字节大小的整型</h5><ul>
<li><font color = red>内存中没有字符，只有数字；</li>
<li>一个数字，对应一个字符，这种规则就是<code>ascii</code>；</li>
<li>使用字符或数字给字符变量赋值是等价的；</li>
<li><font color = red>字符类型本质就是1个字节大小的整形；</li>
<li>字符变量实际上并不是把该字符本身放到变量的内存单元中去，而是将该字符对应的 ASCII 编码放到变量的存储单元中。</li>
</ul>
<p>测试: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch[c] = %c, ch[d] = %d\n&quot;</span>,ch, ch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> ch2 = <span class="number">97</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch2[c] = %c\n&quot;</span>, ch2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch2 - 32 = %c\n&quot;</span>,ch2 - <span class="number">32</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ch[c] = a, ch[d] = <span class="number">97</span></span><br><span class="line">ch2[c] = a</span><br><span class="line">ch2 - <span class="number">32</span> = A</span><br></pre></td></tr></table></figure>
<p><font color = blue>以及注意转义字符: </p>
<p><img src="images/c8.png" alt="在这里插入图片描述"></p>
<p>转义字符简单测试: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">&#x27;\r&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;abcdddd%cefg\n&quot;</span>,ch);</span><br><span class="line"></span><br><span class="line">    ch = <span class="string">&#x27;\b&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;12%c345\n&quot;</span>,ch);</span><br><span class="line"></span><br><span class="line">    ch = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ch); <span class="comment">// 打印&#x27; &#x27;的对应数字</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8进制转义字符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="string">&#x27;\123&#x27;</span>); <span class="comment">//8进制123 --&gt;　对应10进制83</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="string">&#x27;\x23&#x27;</span>); <span class="comment">//16进制23 --&gt; 对应10进制35</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// &#x27;\0&#x27;和0等价</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">efgdddd</span><br><span class="line"><span class="number">1345</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">83</span></span><br><span class="line"><span class="number">35</span></span><br><span class="line"><span class="number">0</span>,<span class="number">0</span></span><br></pre></td></tr></table></figure>
<h5 id="浮点数不准确、类型限定符"><a href="#浮点数不准确、类型限定符" class="headerlink" title="浮点数不准确、类型限定符"></a>浮点数不准确、类型限定符</h5><ul>
<li>浮点数不准确:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">float</span> a = <span class="number">100.9</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %f\n&quot;</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a = <span class="number">100.900002</span></span><br></pre></td></tr></table></figure>
<p>原因还是计算机按照<code>二进制</code>存储。</p>
<ul>
<li>类型限定符:</li>
</ul>
<p><img src="images/c9.png" alt="在这里插入图片描述"></p>
<h5 id="字符的输入问题"><a href="#字符的输入问题" class="headerlink" title="字符的输入问题"></a>字符的输入问题</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> ch1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入字符:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;ch1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch1 = %c\n&quot;</span>,ch1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> ch2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入字符:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;ch2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch2 = %c\n&quot;</span>,ch2);</span><br><span class="line">    <span class="comment">//输出ch2的ascii码</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch2[d] = %d\n&quot;</span>,ch2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出演示: </p>
<p><img src="images/c10.png" alt="在这里插入图片描述"></p>
<p>这个程序要特别注意: </p>
<ul>
<li>当我们输入完一个字符时，按下回车，会直接结束程序；</li>
<li>因为第二个字符在按下回车的时候已经输入完成了，也就是<code>ch2 = &#39;\n&#39;</code>；而<code>&#39;\n&#39;</code>的<code>ascii</code>码为10；</li>
</ul>
<p><img src="images/c11.png" alt="在这里插入图片描述"></p>
<p>处理上面的问题，可以使用另一个字符变量过滤掉<code>\n</code>，也可以使用<code>getchar()</code>来过滤一个字符: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> ch1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入字符:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;ch1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch1 = %c\n&quot;</span>,ch1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了处理上面的问题，可以自己用scanf处理这个回车</span></span><br><span class="line">    <span class="keyword">char</span> tmp;</span><br><span class="line">    <span class="comment">//scanf(&quot;%c&quot;,&amp;tmp); //或者使用下面的方法输入一个字符</span></span><br><span class="line">    <span class="comment">// tmp = getchar(); //或者也可以直接调用getchar()即可</span></span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> ch2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入字符:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;ch2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch2 = %c\n&quot;</span>,ch2);</span><br><span class="line">    <span class="comment">//输出ch2的ascii码</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch2[d] = %d\n&quot;</span>,ch2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="运算符以及优先级"><a href="#运算符以及优先级" class="headerlink" title="运算符以及优先级"></a>运算符以及优先级</h5><p><strong><font color  = red>运算符优先级: </font></strong></p>
<p><img src="images/c12.png" alt="在这里插入图片描述"></p>
<p><img src="images/c13.png" alt="在这里插入图片描述"></p>
<blockquote>
<ul>
<li> 另外，注意 逻辑判断中的  <font color = red>短路原则。</font></li>
</ul>
</blockquote>
<h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><ul>
<li>隐式转换: 编译器内部自动转换；</li>
<li>强制类型转换：把表达式的运算结果强制转换成所需的数据类型。</li>
<li>浮点型打印说明: 不要以为指定了打印的类型就会自动转换，必须要强制转换；</li>
<li>转换原则: <font color = red>数据类型小的往大的转换；<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------------隐式转换-----------\n&quot;</span>);</span><br><span class="line">    <span class="comment">//隐式转换</span></span><br><span class="line">    <span class="keyword">double</span> a;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//编译器内部自动转换，在第10行自动转换，其他地方b还是int</span></span><br><span class="line">    a = b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %lf\n&quot;</span>,a);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------------强制类型转换-----------\n&quot;</span>);</span><br><span class="line">    <span class="comment">//强制类型转换</span></span><br><span class="line">    <span class="keyword">double</span> c = (<span class="keyword">double</span>)<span class="number">1</span>/<span class="number">2</span>; <span class="comment">//强制将1转换成double</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c = %lf\n&quot;</span>,c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(int) = %u\n&quot;</span>,(<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------------浮点型打印说明-----------\n&quot;</span>);</span><br><span class="line">    <span class="comment">//浮点型打印说明</span></span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">11</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d[wrong] = %lf\n&quot;</span>,d); <span class="comment">//以为指定了%lf就会转换成浮点数，其实是错的</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d[right] = %lf\n&quot;</span>,(<span class="keyword">double</span>)d); <span class="comment">// 正确的打印是要强制类型转换的</span></span><br><span class="line">    <span class="keyword">double</span> e = <span class="number">88.14</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;e[wrong] = %d\n&quot;</span>,e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;e[right] = %d\n&quot;</span>,<span class="built_in"><span class="keyword">int</span></span>(e));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-------------转换原则----------\n&quot;</span>);</span><br><span class="line">    <span class="comment">//转换原则: 数据类型　小的往大的　转换</span></span><br><span class="line">    <span class="keyword">int</span> g = <span class="number">129</span>;</span><br><span class="line">    <span class="keyword">char</span> h = <span class="number">111</span>;</span><br><span class="line">    <span class="comment">//g = (int)h; // 这个是可以转换的</span></span><br><span class="line">    <span class="comment">//printf(&quot;g = %d\n&quot;,g);</span></span><br><span class="line">    h = (<span class="keyword">char</span>)g; <span class="comment">//这个转换是出错的，h会变成一个负数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;h = %d\n&quot;</span>,h);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
输出：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">------------隐式转换-----------</span><br><span class="line">a = <span class="number">10.000000</span></span><br><span class="line">------------强制类型转换-----------</span><br><span class="line">c = <span class="number">0.500000</span></span><br><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) = <span class="number">4</span></span><br><span class="line">------------浮点型打印说明-----------</span><br><span class="line">d[wrong] = <span class="number">0.000000</span></span><br><span class="line">d[right] = <span class="number">11.000000</span></span><br><span class="line">e[wrong] = <span class="number">1519177328</span></span><br><span class="line">e[right] = <span class="number">88</span></span><br><span class="line">-------------转换原则----------</span><br><span class="line">h = <span class="number">-127</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="数组、字符串、函数"><a href="#数组、字符串、函数" class="headerlink" title="数组、字符串、函数"></a>数组、字符串、函数</h3><h5 id="数组初始化的几种方式"><a href="#数组初始化的几种方式" class="headerlink" title="数组初始化的几种方式"></a>数组初始化的几种方式</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr1[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; <span class="comment">//数组的定义需要&#123;&#125;，只有在定义的时候才能初始化</span></span><br><span class="line">    <span class="keyword">int</span> arr2[<span class="number">5</span>];</span><br><span class="line">    <span class="comment">//arr2 = &#123;1,2,3,4,5&#125;; //err 这个是错误的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组全部元素初始化为 某个值</span></span><br><span class="line">    <span class="keyword">int</span> arr3[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果定义的同时 初始化，第一个[]内可以不写内容</span></span><br><span class="line">    <span class="keyword">int</span> arr4[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; <span class="comment">//编译器会根据用户初始化的元素来确定数组的大小</span></span><br><span class="line">    <span class="comment">//int arr4[]; //err //必须初始化的时候才能省略</span></span><br><span class="line">    <span class="keyword">int</span> arr5[][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;; <span class="comment">//第一个可以省略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>数组的名字代表着数组的首地址，以及使用<code>sizeof</code>来求数组长度的方法；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------------一维数组------------\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">//1. 数组名是数组首元素地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arr = %p, &amp;arr[0] = %p\n&quot;</span>, arr, &amp;arr[<span class="number">0</span>]); <span class="comment">//两个是一样的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 测试数组总的字节大小 : sizeof(数组名) 10 * 4 = 40</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(arr) = %u\n&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(arr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 得到数组长度 数组总大小/每个元素大小 (常用)</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>(arr)/<span class="built_in"><span class="keyword">sizeof</span></span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;len(arr) = %d\n&quot;</span>,len);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------------二维数组------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> arr2[<span class="number">5</span>][<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// 1. 数组名是常量，不能修改</span></span><br><span class="line">    <span class="comment">// a = 10; //err</span></span><br><span class="line">    <span class="comment">//2. sizeof(数组名),测数组的总大小 5*int[10] = 5*4*10</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(arr2) = %u\n&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(arr2));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 求行数</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in"><span class="keyword">sizeof</span></span>(arr2)/<span class="built_in"><span class="keyword">sizeof</span></span>(arr2[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;行数 = %d\n&quot;</span>,n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 求列数</span></span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in"><span class="keyword">sizeof</span></span>(arr2[<span class="number">0</span>])/<span class="built_in"><span class="keyword">sizeof</span></span>(arr2[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;列数 = %d\n&quot;</span>,m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 总个数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;总个数 = %d\n&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(arr2)/<span class="built_in"><span class="keyword">sizeof</span></span>(arr2[<span class="number">0</span>][<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">------------一维数组------------</span><br><span class="line">arr = <span class="number">0x7ffc86eac190</span>, &amp;arr[<span class="number">0</span>] = <span class="number">0x7ffc86eac190</span></span><br><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span>(arr) = <span class="number">40</span></span><br><span class="line"><span class="built_in">len</span>(arr) = <span class="number">10</span></span><br><span class="line">------------二维数组------------</span><br><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span>(arr2) = <span class="number">200</span></span><br><span class="line">行数 = <span class="number">5</span></span><br><span class="line">列数 = <span class="number">10</span></span><br><span class="line">总个数 = <span class="number">50</span></span><br></pre></td></tr></table></figure>
<p><font color = red>可以看出<code>arr</code>和<code>arr[0]</code>的地址是一样的。 </p>
<h5 id="字符数组与字符串"><a href="#字符数组与字符串" class="headerlink" title="字符数组与字符串"></a>字符数组与字符串</h5><ul>
<li>C语言中没有字符串这种数据类型，可以通过<code>char</code>的数组来替代；</li>
<li>字符串一定是一个<code>char</code>的数组，但<code>char</code>的数组未必是字符串；</li>
<li>数字<code>0</code>(和字符<code>‘\0’</code>等价)结尾的<code>char</code>数组就是一个字符串，但如果<code>char</code>数组没有以数字<code>0</code>结尾，那么就不是一个字符串，只是普通字符数组，所以字符串是一种特殊的<code>char</code>的数组。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. c语言没有字符串类型，用字符数组模拟</span></span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 字符串一定是字符数组，字符数组不一定是字符串</span></span><br><span class="line">    <span class="comment">// 3. 如果字符数组以&#x27;\0&#x27;(0)结尾，就是字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> str2[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;<span class="comment">//字符数组 --&gt; 注意这里[]内没有指定数字</span></span><br><span class="line">    <span class="keyword">char</span> str3[<span class="number">10</span>] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;; <span class="comment">//字符串</span></span><br><span class="line">	<span class="keyword">char</span> str4[<span class="number">10</span>] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="number">0</span>&#125;;    <span class="comment">//字符串</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="字符串输出乱码问题以及一系列字符串要注意的问题"><a href="#字符串输出乱码问题以及一系列字符串要注意的问题" class="headerlink" title="字符串输出乱码问题以及一系列字符串要注意的问题"></a>字符串输出乱码问题以及一系列字符串要注意的问题</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 字符数组打印乱码问题</span></span><br><span class="line">    <span class="keyword">char</span> a1[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;; <span class="comment">//字符数组</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a1 = %s\n&quot;</span>,a1); <span class="comment">//这个是乱码，因为字符数组后面没有&#x27;\0&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 正确的字符串</span></span><br><span class="line">    <span class="keyword">char</span> a2[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">    <span class="comment">//char a2[] = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, 0&#125;; // 0也可以</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 遇到&#x27;\0&#x27;提前截断</span></span><br><span class="line">    <span class="keyword">char</span> a3[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a3 = %s\n&quot;</span>, a3);<span class="comment">//&quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 前3个字符赋值为a, b, c, 后面自动赋值为0</span></span><br><span class="line">    <span class="keyword">char</span> a4[<span class="number">10</span>] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a4 = %s\n&quot;</span>, a4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 常用的初始化方法  --&gt; 使用字符串初始化，在字符串结尾自动加结束符数字0</span></span><br><span class="line">    <span class="comment">//    这个结束符，用户看不到（隐藏），但是是存在的</span></span><br><span class="line">    <span class="keyword">char</span> a5[<span class="number">10</span>] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a5 = %s\n&quot;</span>, a5);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 使用sizeof()测试隐藏的那个&#x27;\0&#x27;</span></span><br><span class="line">    <span class="keyword">char</span> a6[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(a6) = %d\n&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(a6));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. \0 后面最好别跟数字，不然有可能变成转义字符 例如\012 就是&#x27;\n&#x27;</span></span><br><span class="line">    <span class="keyword">char</span> a7[] = <span class="string">&quot;\012abc&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a7 = %s\n&quot;</span>, a7);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. 最多写9个字符，留一个位置放结束符</span></span><br><span class="line">    <span class="keyword">char</span> a8[<span class="number">10</span>] = <span class="string">&quot;123456789&quot;</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 9. sizeof()测数据类型大小，不会因为结束符提前结束  sizeof(&quot;123\045&quot;) = 5</span></span><br><span class="line">    <span class="keyword">char</span> a9[] = <span class="string">&quot;abc\0de&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(a9));  <span class="comment">// 7 --&gt; a b c \0 d e \0  不要忘记最后还有一个\0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 10. scanf(&quot;%s&quot;, a); //a没有&amp;，原因数组名是首元素地址，本来就是地址</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果: </p>
<p><img src="images/c14.png" alt="在这里插入图片描述"></p>
<h5 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 先设置种子，种子设置一次即可</span></span><br><span class="line">	<span class="comment">// 2. 如果srand()参数一样，随机数就一样</span></span><br><span class="line">	<span class="comment">//srand(100);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于希望产生的随机数不同，所以要使用系统时间作为随机数  </span></span><br><span class="line">    <span class="built_in">srand</span>( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>) ); <span class="comment">// 返回的是time_t类型 相当于long，单位为毫秒，注意强制转换一下</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the rand number is = %d\n&quot;</span>, <span class="built_in">rand</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="字符串相关函数"><a href="#字符串相关函数" class="headerlink" title="字符串相关函数"></a>字符串相关函数</h5><h6 id="输入函数"><a href="#输入函数" class="headerlink" title="输入函数"></a>输入函数</h6><p>① <code>gets(str)</code>与<code>scanf(“%s”,str)</code>的区别：</p>
<ul>
<li><code>gets(str)</code>允许输入的字符串含有空格；</li>
<li><code>scanf(“%s”,str)</code>不允许含有空格；</li>
</ul>
<blockquote>
<ul>
<li>注意：由于<code>scanf()</code>和<code>gets()</code>无法知道字符串s大小，必须遇到换行符或读到文件结尾为止才接收输入，因此容易导致字符数组越界(缓冲区溢出)的情况。</li>
</ul>
</blockquote>
<p>② <code>fgets函数</code>相关：
　　</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> size, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><font color = red>功能</font>：从stream指定的文件内读入字符，保存到s所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了size - 1个字符为止，最后会自动加上字符 ‘\0’ 作为字符串结束；</p>
</li>
<li><p><font color =red>参数 </font>:<br>  <font color = blue>s</font>：字符串；<br>  <font color = blue>size</font>：指定最大读取字符串的长度（size - 1）(大于这个长度就舍弃)；<br>  <font color = blue>stream</font>：文件指针，如果读键盘输入的字符串，固定写为stdin；</p>
</li>
<li><p>返回值：<br>  <font color = blue>成功</font>：成功读取的字符串；<br>  <font color = blue>读到文件尾或出错</font>： NULL；</p>
</li>
<li><p>注意，<code>fgets()</code>在读取一个用户通过键盘输入的字符串的时候，<font color = red>同时把用户输入的回车(‘\n’)也做为字符串的一部分</font>。通过scanf和gets输入一个字符串的时候，不包含结尾的“\n”，但通过fgets结尾多了“\n”。</p>
</li>
<li><p>fgets()函数是安全的，不存在缓冲区溢出的问题。</p>
</li>
</ul>
<p>简单测试：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. scanf()输入字符串 不做越界检查，此函数不安全</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. gets(已抛弃，不安全) </span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// gets(buf);  //不安全 已废弃</span></span><br><span class="line">    <span class="comment">// printf(&quot;buf = %s\n&quot;, buf);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. fgets(安全，可以指定大小)</span></span><br><span class="line">    <span class="built_in">fgets</span>(buf,<span class="built_in"><span class="keyword">sizeof</span></span>(buf),stdin);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf = &#x27;%s&#x27;\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 测试读入了　最后的换行</span></span><br><span class="line">    <span class="built_in">fgets</span>(buf,<span class="built_in"><span class="keyword">sizeof</span></span>(buf),stdin); <span class="comment">// 注意虽然这里从键盘读入，但是如果缓冲区还有内容就不会读这里的</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf2 = &#x27;%s&#x27;\n&quot;</span>, buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入输出结果: </p>
<p><img src="images/c15.png" alt="在这里插入图片描述"></p>
<h6 id="输出函数"><a href="#输出函数" class="headerlink" title="输出函数"></a>输出函数</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br><span class="line">功能：标准设备输出s字符串，在输出完成后自动输出一个<span class="string">&#x27;\n&#x27;</span>。</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * str, FILE * stream)</span></span>;  <span class="comment">//文件操作</span></span><br><span class="line">功能： 将str所指定的字符串写入到stream指定的文件中， 字符串结束符 <span class="string">&#x27;\0&#x27;</span>  不写入文件。 </span><br></pre></td></tr></table></figure>

<p>简单测试: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line">    <span class="built_in">puts</span>(str); <span class="comment">//会自动加上一个 &#x27;\n&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fputs</span>(str,stdout); <span class="comment">// 不会自动加上 &#x27;\n&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出: </p>
<p><img src="images/c16.png" alt="在这里插入图片描述"></p>
<h6 id="sizeof-和strlen-的区别"><a href="#sizeof-和strlen-的区别" class="headerlink" title="sizeof()和strlen()的区别"></a>sizeof()和strlen()的区别</h6><p>注意: </p>
<ul>
<li> <code>strlen()</code> 从首元素开始，到结束符为止的长度，结束符不算(遇到’\0’结束)；</li>
<li>而<code>sizeof()</code>则不管遇不遇到<code>&#39;\0&#39;</code>都会计算整个数据类型大小；<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// strlen 从首元素开始，到结束符为止的长度，结束符不算(遇到&#x27;\0&#x27;结束)</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;strlen(buf) = %d\n&quot;</span>, len);   <span class="comment">//5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(buf) = %d\n&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(buf)); <span class="comment">// 6 这个还包括 &#x27;\0&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf2[] = <span class="string">&quot;\0hello&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;strlen(buf2) = %d\n&quot;</span>, <span class="built_in">strlen</span>(buf2)); <span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(buf2) = %d\n&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(buf2)); <span class="comment">// 7  注意不要忘记最后还有一个 &#x27;\0&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf3[<span class="number">100</span>] = <span class="string">&quot;zxzxin&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;strlen(buf3) = %d\n&quot;</span>, <span class="built_in">strlen</span>(buf3)); <span class="comment">//6</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(buf3) = %d\n&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(buf3));  <span class="comment">//100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="字符串拷贝strcpy-和strncpy"><a href="#字符串拷贝strcpy-和strncpy" class="headerlink" title="字符串拷贝strcpy()和strncpy()"></a>字符串拷贝strcpy()和strncpy()</h6>注意两者区别: </li>
<li><code>char *strcpy(char *dest, const char *src) </code>：把src所指向的字符串复制到dest所指向的空间中，’\0’也会拷贝过去。(如果参数dest所指的内存空间不够大，可能会造成缓冲溢出的错误情况。)</li>
<li><code>char *strncpy(char *dest, const char *src, size_t n)</code>：把src指向字符串的前n个字符复制到dest所指向的空间中，<font color=  red>是否拷贝结束符看指定的长度是否包含’\0’。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//strcpy:  把src所指向的字符串复制到dest所指向的空间中，&#x27;\0&#x27;也会拷贝过去</span></span><br><span class="line">    <span class="keyword">char</span> src[] = <span class="string">&quot;hello world!&quot;</span>; </span><br><span class="line">    <span class="keyword">char</span> dest[<span class="number">100</span>] = <span class="string">&quot;aaaaaaaaaaaaaaaaaaaaaaa&quot;</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(dest,src);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dest = %s\n&quot;</span>, dest);<span class="comment">// hello world!  不会输出后面的aaaa， 因为&#x27;\0&#x27;也拷贝在后面了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// strncpy : 把src指向字符串的前n个字符复制到dest所指向的空间中，是否拷贝结束符看指定的长度是否包含&#x27;\0&#x27;。</span></span><br><span class="line">    <span class="keyword">char</span> dest2[<span class="number">100</span>] = <span class="string">&quot;aaaaaaaaaaaaaaaaaaaaaaa&quot;</span>;</span><br><span class="line">    <span class="built_in">strncpy</span>(dest2, src, <span class="built_in">strlen</span>(src));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dest2 = %s\n&quot;</span>, dest2); <span class="comment">//hello world!aaaaaaaaaaa</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//但是如果拷贝的长度大于strlen(src)</span></span><br><span class="line">    <span class="keyword">char</span> dest3[<span class="number">100</span>] = <span class="string">&quot;aaaaaaaaaaaaaaaaaaaaaaa&quot;</span>;</span><br><span class="line">    <span class="built_in">strncpy</span>(dest3, src, <span class="built_in">strlen</span>(src)+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dest3 = %s\n&quot;</span>, dest3); <span class="comment">//hello world!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
输出：</li>
</ul>
<p><img src="images/c17.png" alt="在这里插入图片描述"></p>
<h6 id="strcat-、strncat-、-strcmp-、strncmp"><a href="#strcat-、strncat-、-strcmp-、strncmp" class="headerlink" title="strcat()、strncat()、 strcmp()、strncmp()"></a>strcat()、strncat()、 strcmp()、strncmp()</h6><ul>
<li><code>char *strcat(char *dest, const char *src);</code>: 将src字符串连接到dest的尾部，<code>‘\0’</code>也会追加过去；</li>
<li><code>char *strncat(char *dest, const char *src, size_t n);</code>: 将src字符串前n个字符连接到dest的尾部，<code>‘\0’</code>也会追加过去；</li>
<li><code>int strcmp(const char *s1, const char *s2);</code>: 比较 s1 和 s2 的大小，比较的是字符ASCII码大小；</li>
<li><code>int strncmp(const char *s1, const char *s2, size_t n);</code>：比较 s1 和 s2 前n个字符的大小，比较的是字符ASCII码大小；</li>
</ul>
<p>测试:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s1[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> s2[] = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="built_in">strcmp</span>(s1, s2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;flag = %d\n&quot;</span>,flag);<span class="comment">// &lt;0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> s3[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> s4[] = <span class="string">&quot;Abcd&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> flag2 = <span class="built_in">strncmp</span>(s3, s4, <span class="number">3</span>); <span class="comment">//指定比较前3个字符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;flag2 = %d\n&quot;</span>,flag2);<span class="comment">// &gt;0s</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-------------strcat和strncat------------\n&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> src[] = <span class="string">&quot; hello mike&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> dst[<span class="number">100</span>] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="comment">//把src的内容追加到dst的后面</span></span><br><span class="line">    <span class="comment">//strcat(dst, src); //dst = &quot;abc  hello mike&quot;</span></span><br><span class="line">    <span class="built_in">strncat</span>(dst, src, <span class="built_in">strlen</span>(<span class="string">&quot; hello&quot;</span>)); <span class="comment">//指定长度追加 dst = &quot;abc  hello&quot;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dst = %s\n&quot;</span>, dst);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">flag = <span class="number">-100</span></span><br><span class="line">flag2 = <span class="number">32</span></span><br><span class="line">-------------strcat和strncat------------</span><br><span class="line">dst = abc hello</span><br></pre></td></tr></table></figure>
<h6 id="sprintf-、sscanf"><a href="#sprintf-、sscanf" class="headerlink" title="sprintf()、sscanf()"></a>sprintf()、sscanf()</h6><ul>
<li><code>int sprintf(char *str, const char *format, ...);</code>: 根据参数format字符串来转换并格式化数据，然后将结果输出到str指定的空间中，直到出现字符串结束符 ‘\0’  为止。</li>
<li><code>int sscanf(const char *str, const char *format, ...);</code>: 从str指定的字符串读取数据，并根据参数format字符串来转换并格式化数据。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------------sprintf-------------------\n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">10</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> dest[<span class="number">30</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(dest,<span class="string">&quot;n = %d, ch = %c, buf = %s\n&quot;</span>, n, ch, buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dest: %s&quot;</span>, dest);  <span class="comment">// 注意这里没有加上 &#x27;\n&#x27; 但是之前里面有</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------------sscanf-------------------\n&quot;</span>);</span><br><span class="line">    <span class="comment">// sscanf和spirnf相反  这里从dest中读取</span></span><br><span class="line">    <span class="keyword">int</span> n2;</span><br><span class="line">    <span class="keyword">char</span> ch2;</span><br><span class="line">    <span class="keyword">char</span> buf2[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">sscanf</span>(dest, <span class="string">&quot;n = %d, ch = %c, buf = %s\n&quot;</span>, &amp;n2, &amp;ch2, &amp;buf2); <span class="comment">//记得加上 &amp;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n2 = %d\n&quot;</span>, n2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch2 = %c\n&quot;</span>, ch2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf2 = %s\n&quot;</span>, buf2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-----------字符串提取注意的地方--------------\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 从字符串中提取 内容最好按照空格进行分割 ，不然有可能提取不出来</span></span><br><span class="line">    <span class="comment">// 1. 按照空格分割 --&gt; 正确</span></span><br><span class="line">    <span class="keyword">char</span> buf3[] = <span class="string">&quot;aaa bbb ccc&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">10</span>],b[<span class="number">10</span>],c[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">sscanf</span>(buf3, <span class="string">&quot;%s %s %s&quot;</span>, a,b,c); <span class="comment">//注意没有&amp;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %s, b = %s, c = %s\n&quot;</span>, a, b, c);</span><br><span class="line">    <span class="comment">// 2. 按照逗号分割 --&gt; 错误</span></span><br><span class="line">    <span class="keyword">char</span> buf4[] = <span class="string">&quot;aaa,bbb,ccc&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> a2[<span class="number">10</span>],b2[<span class="number">10</span>],c2[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">sscanf</span>(buf4, <span class="string">&quot;%s,%s,%s&quot;</span>, a2,b2,c2); <span class="comment">//注意没有&amp;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a2 = %s, b2 = %s, c2 = %s\n&quot;</span>, a2, b2, c2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
结果: </li>
</ul>
<p><img src="images/c18.png" alt="在这里插入图片描述"></p>
<h6 id="strchr-、strstr-、strtok"><a href="#strchr-、strstr-、strtok" class="headerlink" title="strchr()、strstr()、strtok()"></a>strchr()、strstr()、strtok()</h6><ul>
<li><code>char *strchr(const char *s, char c);</code>: 在字符串s中查找字母c出现的位置；</li>
<li><code>char *strstr(const char *haystack, const char *needle);</code>: 在字符串haystack中查找字符串needle出现的位置；</li>
<li><code>char *strtok(char *str, const char *delim);</code><br>①来将字符串分割成一个个片段。当strtok()在参数s的字符串中发现参数delim中包含的分割字符时, 则会将该字符改为\0 字符，当连续出现多个时只替换第一个为\0；<br>②在第一次调用时：strtok()必需给予参数s字符串；<br>③<font color =red>往后的调用则将参数s设置成NULL</font>，每次调用成功则返回指向被分割出片段的指针；<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-------------strchr------------\n&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> str1[] = <span class="string">&quot;aaabbbccc&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="built_in">strchr</span>(str1, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = %s\n&quot;</span>, p);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-------------strstr------------\n&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> str2[] = <span class="string">&quot;ddddabcd123abcd333abcd&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> *p2 = <span class="built_in">strstr</span>(str2, <span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p2 = %s\n&quot;</span>, p2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-------------strtok------------\n&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> str3[<span class="number">100</span>] = <span class="string">&quot;adc*fvcv*ebcy*hghbdfg*casdert&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> *s = <span class="built_in">strtok</span>(str3, <span class="string">&quot;*&quot;</span>);   <span class="comment">//将&quot;*&quot;分割的子串取出</span></span><br><span class="line">    <span class="keyword">while</span> (s != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);</span><br><span class="line">        s = <span class="built_in">strtok</span>(<span class="literal">NULL</span>, <span class="string">&quot;*&quot;</span>);<span class="comment">//往后的调用则将参数s设置成NULL，每次调用成功则返回指向被分割出片段的指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
输出:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">-------------strchr------------</span><br><span class="line">p = bbbccc</span><br><span class="line">-------------strstr------------</span><br><span class="line">p2 = abcd123abcd333abcd</span><br><span class="line">-------------strtok------------</span><br><span class="line">adc</span><br><span class="line">fvcv</span><br><span class="line">ebcy</span><br><span class="line">hghbdfg</span><br><span class="line">casdert</span><br></pre></td></tr></table></figure>
<h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><ul>
<li>函数内部，包括()内部的形参变量，只有在调用时分配空间，调用完毕自动释放；</li>
<li><code>return</code>和<code>exit()</code>函数区别，只要一调用 <code>exit()</code>函数(不管在什么地方)，整个程序就结束，但是只有在<code>main</code>函数中调用<code>return</code>才会结束程序；</li>
<li>声明函数加不加 <code>extern</code>关键字都一样，<font color = red>  声明函数可以不指定形参名称，只指定形参形参类型，但是定义不可以。</li>
<li>头文件一般是放函数声明；</li>
</ul>
<p>看下面两张图解释<code>.h</code>文件的作用: </p>
<p><img src="images/c19.png" alt="在这里插入图片描述"></p>
<p>解决办法: </p>
<p><img src="images/c20.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>多个文件中(同一项目)，不能出现同名函数(static除外)。<font color =red>这就是为什么 <code>.h</code>文件只放函数的声明，不放函数的定义；</p>
</li>
<li><p>防止头文件重复包含: 当一个项目比较大时，往往都是分文件，这时候有可能不小心把同一个头文件 <code>include</code> 多次，或者头文件嵌套包含。</p>
</li>
</ul>
<p><font color = blue>防止办法:<br>①<code>#ifndef</code> 方式；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SOMEFILE_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SOMEFILE_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明语句</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>②<code>#pragma once</code> 方式。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>Compilation</tag>
        <tag>C Language</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言基础知识总结(一)</title>
    <url>/2021/10/26/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93(%E4%B8%80)/</url>
    <content><![CDATA[<h2 id="C-基础知识总结-一"><a href="#C-基础知识总结-一" class="headerlink" title="C++基础知识总结(一)"></a>C++基础知识总结(一)</h2><ul>
<li><a href="#c%E5%AF%B9c%E8%AF%AD%E8%A8%80%E7%9A%84%E6%8F%90%E9%AB%98">C++对C语言的提高</a><ul>
<li><a href="#%E5%91%BD%E4%BB%A4%E7%A9%BA%E9%97%B4%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8">命令空间简单使用</a></li>
<li><a href="#const%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8A%A0%E5%BC%BA"><code>const</code>关键字的加强</a></li>
<li><a href="#%E5%BC%95%E7%94%A8-%E9%87%8D%E7%82%B9">引用-重点</a></li>
<li><a href="#%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8">指针引用</a></li>
<li><a href="#%E6%B2%A1%E6%9C%89%E5%BC%95%E7%94%A8%E6%8C%87%E9%92%88">没有引用指针</a></li>
<li><a href="#const%E5%BC%95%E7%94%A8"><code>const</code>引用</a></li>
<li><a href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%BF%90%E7%AE%97%E7%AC%A6">默认参数函数重载作用域运算符</a></li>
<li><a href="#newdelete%E7%9A%84%E4%BD%BF%E7%94%A8"><code>new</code>、<code>delete</code>的使用</a></li>
</ul>
</li>
<li><a href="#c%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80">C++面向对象基础</a><ul>
<li><a href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E6%A1%88%E4%BE%8B">一个简单案例</a></li>
<li><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0">构造函数和析构函数</a></li>
<li><a href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D">深拷贝和浅拷贝</a></li>
<li><a href="#%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88">指向对象成员函数的指针</a></li>
<li><a href="#%E5%B8%B8%E5%AF%B9%E8%B1%A1">常对象</a></li>
<li><a href="#%E5%B8%B8%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98-%E5%B8%B8%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E5%B8%B8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">常对象成员-常数据成员&amp;常成员函数</a></li>
<li><a href="#%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E6%8C%87%E9%92%88">指向对象的常指针</a></li>
<li><a href="#%E6%8C%87%E5%90%91%E5%B8%B8%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8C%87%E9%92%88">指向常变量、对象的指针</a></li>
<li><a href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98">静态成员</a></li>
<li><a href="#%E5%8F%8B%E5%85%83">友元</a></li>
</ul>
</li>
<li><a href="#c%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6">C++重载运算符</a><ul>
<li><a href="#%E9%87%8D%E8%BD%BD%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6">重载基本运算符</a></li>
<li><a href="#%E9%87%8D%E8%BD%BD%E5%8F%B7%E6%93%8D%E4%BD%9C%E7%AC%A6">重载<code>=</code>号操作符</a></li>
<li><a href="#%E9%87%8D%E8%BD%BD%E6%B5%81%E6%8F%92%E5%85%A5%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E6%B5%81%E6%8F%90%E5%8F%96%E8%BF%90%E7%AE%97%E7%AC%A6">重载流插入运算符和流提取运算符</a></li>
<li><a href="#%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B-%E7%9F%A9%E9%98%B5%E5%8A%A0%E6%B3%95%E4%BB%A5%E5%8F%8A%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA">综合案例-矩阵加法以及输入输出</a></li>
</ul>
</li>
<li><a href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%B1%BB%E6%A8%A1%E6%9D%BF">函数模板、类模板</a><ul>
<li><a href="#%E6%A1%88%E4%BE%8B-%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E7%9A%84vector%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%AD%E7%9A%84push-back">案例-简单实现的Vector类模板中的<code>push_back</code></a></li>
</ul>
</li>
<li><a href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C">文件操作</a><ul>
<li><a href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81">输入输出流</a></li>
<li><a href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99">文件读写</a></li>
</ul>
</li>
</ul>
<hr>
<h3 id="C-对C语言的提高"><a href="#C-对C语言的提高" class="headerlink" title="C++对C语言的提高"></a><font color = red id = "1">C++对C语言的提高</h3><h5 id="命令空间简单使用"><a href="#命令空间简单使用" class="headerlink" title="命令空间简单使用"></a>命令空间简单使用</h5><p>引用命令空间的三种方式: </p>
<ul>
<li><p>直接指定标识符。例如<code>std::cout&lt;&lt;&quot;hello&quot;&lt;&lt;std::endl;</code>；<br>   使用<code>using</code>关键字。例如<code>using    std::cout;    </code>；</p>
</li>
<li><p>导入整个命令空间。例如<code>using namespace std; </code>导入<code>std</code>命名空间；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个命令空间</span></span><br><span class="line"><span class="keyword">namespace</span> space1&#123; </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//using namespace std;</span></span><br><span class="line"><span class="comment">//只导入其中的cout和endl</span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;hello&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> space1;<span class="comment">//直接导入命令空间</span></span><br><span class="line">    cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="const关键字的加强"><a href="#const关键字的加强" class="headerlink" title="const关键字的加强"></a><code>const</code>关键字的加强</h5></li>
<li><p><code>C</code>语言中的<code>const</code>是一个冒牌货，即使用来修饰变量的值不能修改，但是还是可以通过指针指向这个变量，然后修改指针指向的内存来修改这个变量的值；</p>
</li>
<li><p>注意<code>const</code>和<code>#define</code>的区别: ①<code>#define</code>只是在预编译时进行字符置换，例如<code>#define PI 3.14</code>，这里的<code>PI</code>不是变量，没有类型，不占用存储单元。②而<code>const float PI = 3. 14</code>定义了常变量<code>PI</code>，它具有变量的属性，有数据类型，占用存储单元，只是在程序运行期间变量的值是固定的，不能改变(<font color=  red>真正的不能改变</font>)；</p>
</li>
</ul>
<p>测试: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//a此时是一个真正的常量 : 不能通过指针修改(C语言中的const是一个冒牌货)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//如果对一个常量取地址，编译器会临时开辟一个空间temp,让这个指针指向temp</span></span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *)&amp;a; <span class="comment">//注意要强制转换一下</span></span><br><span class="line">    *p = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, *p = %d\n&quot;</span>, a, *p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以使用const定义的&quot;常量&quot;来定义数组(C语言中不能这样)</span></span><br><span class="line">    <span class="keyword">int</span> arr[a]; <span class="comment">//ok</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出(可以看到<code>a</code>没有改变(<code>C</code>语言中会变)): </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; 100, *p &#x3D; 200</span><br></pre></td></tr></table></figure>
<h5 id="引用-重点"><a href="#引用-重点" class="headerlink" title="引用-重点"></a>引用-重点</h5><ul>
<li>变量名，本身是一段内存的引用，即别名(<code>alias</code>). 引用可以看作一个已定义变量的别名；</li>
<li>对变量声明一个引用，<font color = red>并不另外开辟内存单元</font>，例如<code>int &amp;b = a</code>，则<code>b</code>和<code>a</code>都代表同一个内存单元(使用<code>sizeof()</code>测<code>a</code>、<code>b</code>大小是相同的)。<font color= red>引用与被引用的变量有相同的地址</font>；</li>
<li>在声明一个引用时，<font color = red>必须同时初始化</font>(和常量有点类似)，即声明它代表哪一个变量；</li>
<li>当声明一个变量的引用后，改引用一直与其代表的变量相联系，<font color = red>不能再作为其他变量的别名</font>。</li>
<li><code>&amp;</code>符号前有数据类型时，是引用。其他都是代表取地址；</li>
<li>引用所占用的大小跟指针是相等的，引用可能是一个”常指针”(<code>int *const p</code>)；</li>
<li>对引用的初始化，可以是一个变量名，也可以是另一个引用。如<code>int a = 3; int &amp;b = a; int &amp;c = b；</code>此时，整形变量<code>a</code>有两个别名<code>b</code>、<code>c</code>；</li>
<li>不能建立<code>void</code>类型的引用(但是有<code>void *</code>类型指针(万能指针))。不能建立引用的数组(可以有指针数组)；</li>
</ul>
<p>使用经典的<code>swap</code>问题来看引用作为形参的简单使用: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//值传递(不行)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swap1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针(也是值传递)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span>&#123;   </span><br><span class="line">    <span class="keyword">int</span> t = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用(引用传递)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swap3</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>, b = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">swap1</span>(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d\n&quot;</span>, a , b);</span><br><span class="line">    <span class="built_in">swap2</span>(&amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d\n&quot;</span>, a , b);</span><br><span class="line">    <span class="built_in">swap3</span>(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d\n&quot;</span>, a , b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a = <span class="number">100</span>, b = <span class="number">200</span></span><br><span class="line">a = <span class="number">200</span>, b = <span class="number">100</span></span><br><span class="line">a = <span class="number">100</span>, b = <span class="number">200</span></span><br></pre></td></tr></table></figure>

<h5 id="指针引用"><a href="#指针引用" class="headerlink" title="指针引用"></a>指针引用</h5><p>可以建立指针变量的引用，如: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"><span class="keyword">int</span>* &amp;ref = p; <span class="comment">//ref是一个指向 “整形变量的指针变量” 的引用，初始化为p</span></span><br></pre></td></tr></table></figure>
<p>下面看一个使用指针引用的例子，对比使用<font color = blue>二级指针</font>和使用<font color= blue>指针引用</font>的区别: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过二级指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getMem</span><span class="params">(Student **temp)</span></span>&#123; </span><br><span class="line">    Student *p = (Student *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Student));</span><br><span class="line">    p-&gt;age = <span class="number">13</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(p-&gt;name, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    *temp = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getMem2</span><span class="params">(Student* &amp;p)</span></span>&#123; <span class="comment">//将Student*看成一个类型 </span></span><br><span class="line">    p = (Student *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Student));</span><br><span class="line">    p-&gt;age = <span class="number">14</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(p-&gt;name, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free1</span><span class="params">(Student **temp)</span></span>&#123; </span><br><span class="line">    Student *p = *temp;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>)&#123; </span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        *temp = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过指向指针的引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free2</span><span class="params">(Student* &amp;p)</span></span>&#123; <span class="comment">//指向指针的引用</span></span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>)&#123; </span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Student *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">getMem</span>(&amp;p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;age = %d, name = %s\n&quot;</span>, p-&gt;age, p-&gt;name); </span><br><span class="line">    <span class="built_in">free1</span>(&amp;p);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getMem2</span>(p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;age = %d, name = %s\n&quot;</span>, p-&gt;age, p-&gt;name);</span><br><span class="line">    <span class="built_in">free2</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">age = <span class="number">13</span>, name = zhangsan</span><br><span class="line">------------------</span><br><span class="line">age = <span class="number">14</span>, name = lisi</span><br></pre></td></tr></table></figure>

<h5 id="没有引用指针"><a href="#没有引用指针" class="headerlink" title="没有引用指针"></a>没有引用指针</h5><ul>
<li>由于引用不是一种独立的数据类型，所以不能建立指向引用类型的指针变量。 </li>
<li>但是，可以将<font color= blue>变量的引用的地址</font>赋值给一个指针，此时指针指向的是<font color= blue>原来的变量</font>。</li>
</ul>
<p>例如: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = a;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;b;  <span class="comment">//指针变量p指向变量a的引用b,相当于指向a,合法</span></span><br></pre></td></tr></table></figure>
<p>上面代码和下面一行代码相同: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure>
<p>输出<code>*p</code>的值，就是<code>b</code>的值，即<code>a</code>的值。<br>不能定义指向引用类型的指针变量，不能写成: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; *p = &amp;a; <span class="comment">//企图定义指向引用类型的指针变量，错误</span></span><br></pre></td></tr></table></figure>

<h5 id="const引用"><a href="#const引用" class="headerlink" title="const引用"></a><code>const</code>引用</h5><ul>
<li>如果想对一个常量进行引用，必须是一个<code>const</code>引用；</li>
<li><font color=  red>可以对一个变量进行 常引用(此时引用不可修改，但是原变量可以修改)。这个特征一般是用在函数形参修饰上，不希望改变原来的实参的值；</font></li>
<li>可以用常量或表达式对引用进行初始化，但此时必须用<code>const</code>作声明(<font color=  blue>内部是使用一个<code>temp</code>临时变量转换</font>)；</li>
</ul>
<p>测试:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">//对一个常量进行引用</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//int&amp; ref1 = a; //err</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;ref1 = a; <span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以对一个变量进行 常引用(此时引用不可修改，但是原变量可以修改)</span></span><br><span class="line">    <span class="comment">//这个特征一般是用在函数形参修饰上，有时候不希望改变原来的实参的值</span></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>&amp; ref2 = b;</span><br><span class="line">    <span class="comment">//ref2 = 20; //err</span></span><br><span class="line">    b = <span class="number">20</span>; <span class="comment">// ok</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %d, ref2 = %d\n&quot;</span>, b, ref2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对表达式做引用</span></span><br><span class="line">    <span class="comment">// 内部系统处理 int temp = c+10; const int&amp; ref3 = temp;</span></span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>&amp; ref3 = c + <span class="number">10</span>; <span class="comment">//合法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//也可以对不同类型进行转换</span></span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>&amp; ref4 = d; <span class="comment">// int temp = d; const int&amp; ref4 = temp</span></span><br><span class="line">    cout&lt;&lt;d&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ref4&lt;&lt;endl;<span class="comment">//b = 3.14,ref4 = 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">b = <span class="number">20</span>, ref2 = <span class="number">20</span></span><br><span class="line"><span class="number">3.14</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h5 id="默认参数、函数重载、作用域运算符"><a href="#默认参数、函数重载、作用域运算符" class="headerlink" title="默认参数、函数重载、作用域运算符"></a>默认参数、函数重载、作用域运算符</h5><ul>
<li>如果全局和局部有相同名字变量，使用<code>::</code>运算符来操作全局变量；<br>   默认参数要注意：<font color = red>    如果默认参数出现，那么右边的都必须有默认参数，也就是只有参数列表后面部分的参数才可以提供默认参数值</font>；</li>
<li>函数重载规则: ①函数名相同。②参数个数不同,参数的类型不同,参数顺序不同,均可构成重载。 ③<font color=  red>返回值类型不同则不可以构成重载。 </li>
<li>一个函数，不能既作重载，又作默认参数的函数。</li>
</ul>
<p>简单使用:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">20</span>, <span class="keyword">int</span> c = <span class="number">30</span>)</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// 作用域运算符 ::</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a2 = %d\n&quot;</span>, ::a); <span class="comment">//全局的a</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">fun</span>(<span class="number">10</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">fun</span>(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">fun</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="new、delete的使用"><a href="#new、delete的使用" class="headerlink" title="new、delete的使用"></a><code>new</code>、<code>delete</code>的使用</h5><ul>
<li><code>C</code>语言中使用<code>malloc</code>函数必须指定开辟空间的大小，即<code>malloc(size)</code>，且<code>malloc</code>函数只能从用户处知道应开辟空间的大小而不知道数据的类型，因此无法使其返回的指针指向具体的数据类型。其返回值一律为<code>void *</code>，使用时必须强制转换；</li>
<li><code>C++</code>中提供了<code>new</code>和<code>delete</code><font color= red>运算符</font>来替代<code>malloc</code>和<code>free</code>函数；</li>
<li>差别: <code>malloc</code>不会调用类的构造函数,而<code>new</code>会调用类的构造函数。②<code>free</code>不会调用类的析构函数，而<code>delete</code>会调用类的析构函数；(析构函数释放的是对象内部的内存，而<code>delete</code>释放的是对象，而<code>delete</code>也出发析构，所以都可以释放)</li>
</ul>
<p>例如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>； <span class="comment">//开辟一个存放整数的空间，返回一个指向整形数据的指针</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">100</span>); <span class="comment">//开辟一个存放整数的空间，并指定初始值为100</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>]; <span class="comment">// 开辟一个存放字符数组的空间，size = 10</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">float</span> *p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">float</span></span>(<span class="number">3.14</span>); <span class="comment">//将返回的指向实型数据的指针赋给指针变量p</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">delete</span> []p; <span class="comment">//释放对数组空间的操作(加方括号)</span></span><br></pre></td></tr></table></figure>
<p>简单测试：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// new 和 delete 使用</span></span><br><span class="line">    <span class="keyword">int</span> *p1 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p1 = %d\n&quot;</span>, *p1);</span><br><span class="line">    <span class="keyword">delete</span> p1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *p2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        p2[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p2[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> []p2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*p1 = <span class="number">10</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </span><br></pre></td></tr></table></figure>

<hr>
<h3 id="C-面向对象基础"><a href="#C-面向对象基础" class="headerlink" title="C++面向对象基础"></a><font color = red id = "2">C++面向对象基础</h3><h5 id="一个简单案例"><a href="#一个简单案例" class="headerlink" title="一个简单案例"></a>一个简单案例</h5><blockquote>
<p>题目，判断两个圆是否相交。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//点(坐标类)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setXY</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">getPointDis</span><span class="params">(Point &amp;thr)</span></span>; <span class="comment">//计算两点距离</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//圆类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setR</span><span class="params">(<span class="keyword">int</span> r)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setXY</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isInterSection</span><span class="params">(Circle &amp;thr)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        Point p0; <span class="comment">//圆心</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Point::setXY</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; </span><br><span class="line">    <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">    <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Point::getPointDis</span><span class="params">(Point &amp;thr)</span></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> dx = x - thr.x;</span><br><span class="line">    <span class="keyword">int</span> dy = y - thr.y;</span><br><span class="line">    <span class="keyword">double</span> dis = <span class="built_in">sqrt</span>(dx*dx + dy*dy);</span><br><span class="line">    <span class="keyword">return</span> dis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Circle::setR</span><span class="params">(<span class="keyword">int</span> r)</span></span>&#123; </span><br><span class="line">    <span class="keyword">this</span>-&gt;r = r; <span class="comment">//注意不能写成this.r (this是一个指针,每个对象都可以通过this指针来访问自己的地址)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Circle::setXY</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123; </span><br><span class="line">    p0.<span class="built_in">setXY</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Circle::isInterSection</span><span class="params">(Circle &amp;thr)</span></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> R = r + thr.r; <span class="comment">//两个圆的半径之和</span></span><br><span class="line">    <span class="keyword">double</span> dis = p0.<span class="built_in">getPointDis</span>(thr.p0); <span class="comment">//两个圆心的距离</span></span><br><span class="line">    <span class="keyword">if</span>(dis &lt;= R)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    Circle c1,c2;</span><br><span class="line">    c1.<span class="built_in">setR</span>(<span class="number">1</span>);</span><br><span class="line">    c1.<span class="built_in">setXY</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    c2.<span class="built_in">setR</span>(<span class="number">3</span>);</span><br><span class="line">    c2.<span class="built_in">setXY</span>(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    Circle *pc1 = &amp;c1; <span class="comment">//定义指向对象的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pc1-&gt;<span class="built_in">isInterSection</span>(c2))<span class="comment">//通过指针的方式调用</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;两圆相交!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;两圆不相交!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">两圆相交!</span><br></pre></td></tr></table></figure>
<h5 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h5><ul>
<li>如果用户没有定义默认的，系统会提供一个默认构造函数，但是如果用户已经定义了构造函数，系统就不会提供默认的构造函数；</li>
<li>系统也会提供一个默认的<font  color = blue>拷贝构造函数</font>，默认是浅拷贝，形如<code>Clazz c1(c2)</code>的使用，将<code>c1</code>拷贝给<code>c2</code>；</li>
<li><code>C++</code>有一个参数初始化列表的特性，注意不能用在数组上；</li>
<li>构造函数也可以是带有默认参数；</li>
<li>析构函数被调用的情况:① 如果用<code>new</code>运算符动态的建立了一个对象，当用<code>delete</code>运算符释放该对象时，先调用该对象的析构函数。②<code>static</code>局部对象在函数调用结束之后对象并不是放，因此也不调用析构函数。只有在调用<code>exit</code>或者<code>main</code>函数结束的时候才会调用<code>static</code>的析构函数。</li>
<li>构造函数和析构函数的顺序: ①<font color = red>先构造的后析构，后构造的先析构；</li>
</ul>
<p>拷贝构造函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clazz</span>&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Clazz</span>()&#123; </span><br><span class="line">            x = <span class="number">0</span>;</span><br><span class="line">            y = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Clazz</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123; </span><br><span class="line">            <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">            <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">printXY</span><span class="params">()</span></span>&#123; </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, x, y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//显示的拷贝构造函数  如果不写，默认也有这个</span></span><br><span class="line">        <span class="built_in">Clazz</span>(<span class="keyword">const</span> Clazz &amp;thr)&#123; </span><br><span class="line">            x = thr.x;</span><br><span class="line">            y = thr.y;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Clazz <span class="title">c1</span><span class="params">(<span class="number">100</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Clazz <span class="title">c2</span><span class="params">(c1)</span></span>; <span class="comment">//拷贝</span></span><br><span class="line">    c2.<span class="built_in">printXY</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数是对象初始化的时候调用</span></span><br><span class="line">    Clazz c3 = c1; <span class="comment">// 调用的依然是c3的拷贝构造函数</span></span><br><span class="line">    c3.<span class="built_in">printXY</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Clazz c4; <span class="comment">//调用的是无参构造器</span></span><br><span class="line">    c4 = c1; <span class="comment">//不是调用拷贝构造函数，而是重载操作符</span></span><br><span class="line">    c4.<span class="built_in">printXY</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>构造函数中的<font color = blue>参数初始化列表</font>: </p>
<ul>
<li>注意构造对象成员的 顺序跟初始化列表的顺序无关；</li>
<li>而是跟成员对象的定义顺序有关；<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Box</span>(); <span class="comment">//默认的无参</span></span><br><span class="line">        <span class="comment">//参数初始化表</span></span><br><span class="line">        <span class="built_in">Box</span>(<span class="keyword">int</span> l, <span class="keyword">int</span> w, <span class="keyword">int</span> h):<span class="built_in">l</span>(l),<span class="built_in">w</span>(w),<span class="built_in">h</span>(h)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, <span class="string">&quot;zhangsan&quot;</span>); <span class="comment">//默认</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Box</span>(<span class="keyword">int</span> l, <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">const</span> <span class="keyword">char</span> *name):<span class="built_in">l</span>(l),<span class="built_in">w</span>(w),<span class="built_in">h</span>(h)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name,name); <span class="comment">//字符串不能那样初始化</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">volume</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> l,w,h;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Box::<span class="built_in">Box</span>()</span><br><span class="line">&#123; </span><br><span class="line">    l = <span class="number">10</span>;</span><br><span class="line">    w = <span class="number">10</span>;</span><br><span class="line">    h = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Box::volume</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> l*w*h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Box b1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b1.<span class="built_in">volume</span>());</span><br><span class="line">    <span class="function">Box <span class="title">b2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b2.<span class="built_in">volume</span>());</span><br><span class="line">    <span class="function">Box <span class="title">b3</span><span class="params">(<span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="string">&quot;lisi&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b3.<span class="built_in">volume</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
输出: </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1000</span></span><br><span class="line"><span class="number">8000</span></span><br><span class="line"><span class="number">27000</span></span><br></pre></td></tr></table></figure>

<h5 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h5><ul>
<li>深拷贝是有必要的，因为析构函数释放内存的时候，如果使用浅拷贝拷贝了一个对象，释放两个对象指向得到同一个内存两次，就会产生错误。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Teacher</span>(<span class="keyword">int</span> id, <span class="keyword">const</span> <span class="keyword">char</span>* name)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;id = id;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="built_in">strlen</span>(name);</span><br><span class="line">            <span class="keyword">this</span>-&gt;name = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(len+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//显式的提供一个拷贝构造函数，完成深拷贝动作</span></span><br><span class="line">        <span class="comment">// 防止在析构函数中 释放堆区空间两次</span></span><br><span class="line">        <span class="built_in">Teacher</span>(<span class="keyword">const</span> Teacher &amp;thr)&#123; </span><br><span class="line">            id = thr.id;</span><br><span class="line">            <span class="comment">//深拷贝  </span></span><br><span class="line">            <span class="keyword">int</span> len = <span class="built_in">strlen</span>(thr.name);</span><br><span class="line">            name = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(len + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">strcpy</span>(name, thr.name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//必须要显式的提供深拷贝构造函数，不然会释放两次</span></span><br><span class="line">        ~<span class="built_in">Teacher</span>()&#123; </span><br><span class="line">            <span class="keyword">if</span>(name != <span class="literal">NULL</span>)&#123; </span><br><span class="line">                <span class="built_in">free</span>(name);</span><br><span class="line">                name = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123; </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;id: %d, name = %s\n&quot;</span>, id, name);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">char</span> *name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="function">Teacher <span class="title">t1</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;zhangsan&quot;</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">print</span>(); </span><br><span class="line">    <span class="function">Teacher <span class="title">t2</span><span class="params">(t1)</span></span>;</span><br><span class="line">    t2.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="指向对象成员函数的指针"><a href="#指向对象成员函数的指针" class="headerlink" title="指向对象成员函数的指针"></a>指向对象成员函数的指针</h5><ul>
<li>注意: 定义指向对象成员函数的指针变量的方法和定义<a href="https://blog.csdn.net/zxzxzx0119/article/details/84001021#t3"><strong>指向普通函数的指针变量</strong></a>不同，定义指向成员函数的指针变量的方法: <code>void (Time:: *p)();</code>(对比普通的: <code>void (*p)();</code>) : 定义<code>p</code>为指向<code>Time</code>类中公共成员函数的指针变量；</li>
<li>可以使用上面的<code>p</code>指针指向一个公用成员函数，只需把公用成员函数的入口地址赋给一个公用成员函数的指针即可，如<code>p = &amp;Time::get_time</code>;</li>
</ul>
<p>简单测试: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span>&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Time</span>(<span class="keyword">int</span> h, <span class="keyword">int</span> m, <span class="keyword">int</span> s):<span class="built_in">hour</span>(h),<span class="built_in">minute</span>(m),<span class="built_in">sec</span>(s)&#123; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">get_time</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> hour;</span><br><span class="line">        <span class="keyword">int</span> minute;</span><br><span class="line">        <span class="keyword">int</span> sec;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Time::get_time</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d:%d:%d\n&quot;</span>, hour, minute, sec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="function">Time <span class="title">t1</span><span class="params">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">30</span>)</span></span>; <span class="comment">//10:10:30</span></span><br><span class="line">    Time *p = &amp;t1; <span class="comment">//定义指向对象的指针</span></span><br><span class="line">    p-&gt;<span class="built_in">get_time</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (Time::*p2)(); <span class="comment">//定义指向Time类公共成员函数的指针变量</span></span><br><span class="line">    p2 = &amp;Time::get_time;</span><br><span class="line">    (t1.*p2)(); <span class="comment">// 调用对象t1中p2所指向的成员函数(即t1.get_time())</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span>:<span class="number">10</span>:<span class="number">30</span></span><br><span class="line"><span class="number">10</span>:<span class="number">10</span>:<span class="number">30</span></span><br></pre></td></tr></table></figure>
<h5 id="常对象"><a href="#常对象" class="headerlink" title="常对象"></a><font color = green>常对象</h5><ul>
<li>可以在定义对象时加上关键字<code>const</code>，指定对象为常对象。<font color= red>常对象必须要有初值，凡是希望保护数据成员不被改变的对象，都可以声明为常对象。</font></li>
<li>基本语法: <code>类名 const 对象名 [(实参表)]</code> 或者<code>const 类名 对象名 [(实参表)]</code>，举例: <code>Time const t(10, 10, 30)</code>和<code>const Time t(10, 10, 30)</code>；</li>
<li>如果一个对象被声明为常对象，则通过改对象<font color = red>只能调用它的常成员函数，不能调用对象的普通成员函数；例如<code>void get_time() const</code> </font>(常成员函数)；</li>
<li><font color= blue>常成员函数可以访问常对象中的数据成员，但不允许修改常对象中数据成员的值；</font></li>
</ul>
<h5 id="常对象成员-常数据成员-amp-常成员函数"><a href="#常对象成员-常数据成员-amp-常成员函数" class="headerlink" title="常对象成员-常数据成员&amp;常成员函数"></a><font color = green>常对象成员-常数据成员&amp;常成员函数</h5><p>①<font color = purple>常数据成员</p>
<ul>
<li>只能通过构造函数的<font color=  red>参数初始化表</font>对常数据成员进行初始化，任何其他函数都不能对常数据赋值；</li>
<li>因为常数据成员不能被赋值；</li>
</ul>
<p>②<font color = purple>常成员函数</p>
<ul>
<li>常成员函数声明: 例如<code>void get_time() const</code>，<font color= red>常成员函数只能引用本类中的数据成员，不能修改它们</font>；</li>
<li>注意: 如果定义了一个常对象，只能调用其中的<code>const</code>成员函数，不能调用非<code>const</code>成员函数(不论这些函数是否会修改对象中的数据)；</li>
<li>常成员函数不能调用另一个非<code>const</code>成员函数；</li>
</ul>
<table>
<thead>
<tr>
<th>数据成员</th>
<th>非<code>const</code>成员函数</th>
<th><code>const</code>成员函数</th>
</tr>
</thead>
<tbody><tr>
<td>非<code>const</code>数据成员</td>
<td>可以引用，可以改变值</td>
<td>可以引用，不可改变值</td>
</tr>
<tr>
<td><code>const</code>数据成员</td>
<td>可以引用，不可改变值</td>
<td>可以引用，不可改变值</td>
</tr>
<tr>
<td><code>const</code>对象</td>
<td>不允许</td>
<td>可以引用，不可改变值</td>
</tr>
</tbody></table>
<h5 id="指向对象的常指针"><a href="#指向对象的常指针" class="headerlink" title="指向对象的常指针"></a><font color = green>指向对象的常指针</h5><ul>
<li>基本语法<code>Time * const p = &amp;t1</code>和基本的常指针差不多；</li>
<li>只能指向同一个对象不能改变指针的指向；</li>
<li>意义是作为函数的形参，不允许在函数执行过程中改变指针变量，使其始终指向原来的对象；<h5 id="指向常变量、对象的指针"><a href="#指向常变量、对象的指针" class="headerlink" title="指向常变量、对象的指针"></a><font color = green>指向常变量、对象的指针</h5>①<font color = purple>指向常变量的指针</li>
<li>如果一个变量已经被声明为常变量，只能用指向常变量的指针变量指向它，而不能用非<code>const</code>指针指向它；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> c[] = <span class="string">&quot;boy&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p1 = c; <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">char</span> *p2 = c; <span class="comment">// err</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>const</code>指针除了可以指向<code>const</code>变量，<font color = blue>还可以指向非<code>const</code>变量，此时不能通过指针来改变变量的值；</li>
<li>如果函数的形参是指向非<code>const</code>变量的指针变量，实参只能使用指向非<code>const</code>变量的指针；更多形参和实参指针变量关系看下表；</li>
</ul>
<table>
<thead>
<tr>
<th><font color= blue>形参</th>
<th><font color= blue>实参</th>
<th><font color= blue>合法否</th>
<th><font color= blue>改变指针所指向的变量的值</th>
</tr>
</thead>
<tbody><tr>
<td>指向非<code>const</code>变量的指针</td>
<td>非<code>const</code>变量的地址</td>
<td>合法</td>
<td>可以</td>
</tr>
<tr>
<td>指向非<code>const</code>变量的指针</td>
<td><code>const</code>变量的地址</td>
<td>不合法</td>
<td></td>
</tr>
<tr>
<td>指向<code>const</code>变量的指针</td>
<td><code>const</code>变量的地址</td>
<td>合法</td>
<td>不可以</td>
</tr>
<tr>
<td>指向<code>const</code>变量的指针</td>
<td>非<code>const</code>变量的地址</td>
<td>合法</td>
<td>不可以</td>
</tr>
</tbody></table>
<p>②<font color = purple>指向常对象的指针</p>
<ul>
<li>和指向常变量的指针类似，只能用<font color = red>指向常对象的指针变量</font>指向它，不能用指向非<code>const</code>对象的指针指向它；</li>
<li>如果定义了一个指向常对象的指针变量，并指向了一个<font color=  red>非<code>const</code>对象</font>，则不能通过改指针变量来改变变量的值；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Time <span class="title">t1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="keyword">const</span> Time *p = &amp;t1;</span><br><span class="line">(*p).hour = <span class="number">20</span>;  <span class="comment">//err</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用意义也是在形参上，希望调用函数的时候对象的值不被改变，就把形参指定为指向常对象的指针变量；</li>
</ul>
<h5 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h5><p>①<font color = purple>静态数据成员</p>
<ul>
<li>静态数据成员在内存中只占一份空间(不是每一个对象都为它保留一份空间)，静态数据成员的值对所有对象都是一样的，如果改变它的值，在其他对象中也会改变；</li>
<li><font color = red>静态数据成员只能在类体外进行初始化。如<code>int Box::height = 10;</code>，只在类体中声明静态数据成员时加上<code>static</code>，不必在初始化语句中加<code>static</code>。</li>
<li>不能在参数初始化列表中对静态数据成员进行初始化；</li>
</ul>
<p>②<font color = purple>静态成员函数</p>
<ul>
<li><p><font color = red>静态成员函数和普通函数最大的区别就在静态成员函数没有<code>this</code>指针，决定了静态成员函数与不能访问本类中的非静态成员。</font>所以静态成员函数的作用就是用来访问静态数据成员；</p>
</li>
<li><p>但是普通成员函数(非静态)可以引用类中的静态数据成员；</p>
<h5 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h5><p>① <font color = purple>将普通函数声明为友元函数</p>
</li>
<li><p>这样这个普通函数就可以访问声明了友元函数的那个类的私有成员；</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Time</span>(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line">        <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Time&amp;)</span></span>; </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> hour;</span><br><span class="line">        <span class="keyword">int</span> minute;</span><br><span class="line">        <span class="keyword">int</span> sec;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Time::<span class="built_in">Time</span>(<span class="keyword">int</span> h, <span class="keyword">int</span> m, <span class="keyword">int</span> s)&#123; </span><br><span class="line">    hour = h;</span><br><span class="line">    minute = m;</span><br><span class="line">    sec = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通的友元函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(Time&amp; t)</span></span>&#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d:%d:%d\n&quot;</span>, t.hour, t.minute, t.sec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="function">Time <span class="title">t</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="built_in">display</span>(t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span>:<span class="number">10</span>:<span class="number">30</span></span><br></pre></td></tr></table></figure>

<p>② <font color = purple>将别的类中的成员函数声明为友元函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>;</span> <span class="comment">//对Date类声明</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span>&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Time</span>(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(Date &amp;)</span></span>; <span class="comment">//要访问Date类的成员</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> hour;</span><br><span class="line">        <span class="keyword">int</span> minute;</span><br><span class="line">        <span class="keyword">int</span> sec;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Time::<span class="built_in">Time</span>(<span class="keyword">int</span> h, <span class="keyword">int</span> m, <span class="keyword">int</span> s)&#123; </span><br><span class="line">    hour = h;</span><br><span class="line">    minute = m;</span><br><span class="line">    sec = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Date</span>(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line">        <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Time::display</span><span class="params">(Date &amp;)</span></span>; <span class="comment">//声明Time类中的display函数为本类的友元函数</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> month;</span><br><span class="line">        <span class="keyword">int</span> day;</span><br><span class="line">        <span class="keyword">int</span> year;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Date::<span class="built_in">Date</span>(<span class="keyword">int</span> m, <span class="keyword">int</span> d, <span class="keyword">int</span> y)&#123; </span><br><span class="line">    month = m;</span><br><span class="line">    day = d;</span><br><span class="line">    year = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Time::display</span><span class="params">(Date &amp;d)</span></span>&#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d/%d/%d\n&quot;</span>,d.month, d.day, d.year);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d:%d:%d\n&quot;</span>, hour, minute, sec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Time <span class="title">t</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Date <span class="title">d</span><span class="params">(<span class="number">12</span>,<span class="number">25</span>,<span class="number">2018</span>)</span></span>;</span><br><span class="line">    t.<span class="built_in">display</span>(d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>③ <font color = purple>友元类</p>
<ul>
<li>在<code>A</code>类中声明<code>B</code>类是自己的友元类，这样<code>B</code>类就可以访问<code>A</code>的所有私有成员了。</li>
<li>但是要注意友元的关系是单向的而不是双向的。且友元的关系不能传递；</li>
</ul>
<hr>
<h3 id="C-重载运算符"><a href="#C-重载运算符" class="headerlink" title="C++重载运算符"></a><font color = red id = "3">C++重载运算符</h3><h5 id="重载基本运算符"><a href="#重载基本运算符" class="headerlink" title="重载基本运算符"></a>重载基本运算符</h5><p><font color = purple><strong>案例一: 重载<code>+</code>号来计算复数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Complex</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b):<span class="built_in">a</span>(a),<span class="built_in">b</span>(b)&#123; &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 方法一.使用成员函数</span></span><br><span class="line">        <span class="comment">//不能写成返回&amp; （引用)因为temp是局部的 ,函数调用完毕就会释放 </span></span><br><span class="line">        Complex <span class="keyword">operator</span>+ (<span class="keyword">const</span> Complex &amp;thr)&#123;</span><br><span class="line">            <span class="function">Complex <span class="title">temp</span><span class="params">(a + thr.a, b + thr.b)</span></span>;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//　方法二.使用友元函数</span></span><br><span class="line">        <span class="comment">//friend Complex operator+ (const Complex &amp;c1, const Complex &amp;c2);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123; </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d,%di)\n&quot;</span>,a,b);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> a; <span class="comment">//实部</span></span><br><span class="line">        <span class="keyword">int</span> b; <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Complex operator+ (const Complex &amp;c1, const Complex &amp;c2)&#123; //注意也不能返回局部的引用 </span></span><br><span class="line"><span class="comment">//    return Complex(c1.a + c2.a, c1.b + c2.b);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">3</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">    Complex c3 = c1 + c2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面的显示调用也是和上面等同的，但是一般不会这么写</span></span><br><span class="line">    <span class="comment">//Complex c3 = c1.operator+(c2); //成员函数 </span></span><br><span class="line">    <span class="comment">//Complex c3 = operator+(c1, c2); //友元函数</span></span><br><span class="line">    c3.<span class="built_in">printC</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(<span class="number">4</span>,<span class="number">6</span>i)</span><br></pre></td></tr></table></figure>

<p><font color = purple><strong>案例二: 重载双目运算符</strong></p>
<ul>
<li>注意这个要返回的是引用，因为运算符支持连续的相加操作；</li>
<li>在成员函数中返回 <code>this</code>指针指向的内容，在友元函数中可以返回第一个参数的引用(不是局部变量的，所以可以返回)；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重载 += 运算符</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Complex</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b):<span class="built_in">a</span>(a), <span class="built_in">b</span>(b)&#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法一:使用成员函数 </span></span><br><span class="line">        <span class="comment">// 注意这里和上一个不同，这里要返回引用</span></span><br><span class="line">        <span class="comment">//Complex&amp; operator+= (const Complex &amp;thr)&#123; </span></span><br><span class="line">        <span class="comment">//    this-&gt;a += thr.a;</span></span><br><span class="line">        <span class="comment">//    this-&gt;b += thr.b;</span></span><br><span class="line">        <span class="comment">//    return *this; //注意这里返回this指针指向的内容</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法二: 使用友元函数</span></span><br><span class="line">        <span class="keyword">friend</span> Complex&amp; <span class="keyword">operator</span>+= (Complex&amp; c1, <span class="keyword">const</span> Complex&amp; c2);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123; </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d,%di)\n&quot;</span>, a, b);   </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//也要返回引用 因为要支持连续操作 类似(c1 += c2) += c3</span></span><br><span class="line">Complex&amp; <span class="keyword">operator</span>+= (Complex&amp; c1, <span class="keyword">const</span> Complex&amp; c2)&#123; </span><br><span class="line">    c1.a += c2.a;</span><br><span class="line">    c1.b += c2.b;</span><br><span class="line">    <span class="keyword">return</span> c1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">3</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">    (c1 += c2) += c2;</span><br><span class="line">    c1.<span class="built_in">printC</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><font color = purple><strong>案例三: 重载单目运算符</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Complex</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b):<span class="built_in">a</span>(a),<span class="built_in">b</span>(b)&#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重载 前置++</span></span><br><span class="line">        Complex <span class="keyword">operator</span>++ ()&#123; </span><br><span class="line">            a++;</span><br><span class="line">            b++;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载后置++  需要使用一个占位符</span></span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">const</span> Complex <span class="keyword">operator</span>++ (Complex&amp; c1, <span class="keyword">int</span>);</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123; </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d,%di)\n&quot;</span>, a, b);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">int</span> b;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置++</span></span><br><span class="line"><span class="keyword">const</span> Complex <span class="keyword">operator</span>++ (Complex&amp; c1, <span class="keyword">int</span>)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="function">Complex <span class="title">temp</span><span class="params">(c1.a, c1.b)</span></span>;</span><br><span class="line">    c1.a++;</span><br><span class="line">    c1.b++;</span><br><span class="line">    <span class="keyword">return</span> temp; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="function">Complex <span class="title">c</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    c++;</span><br><span class="line">    c.<span class="built_in">printC</span>();</span><br><span class="line">    ++c;</span><br><span class="line">    c.<span class="built_in">printC</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(<span class="number">2</span>,<span class="number">3</span>i)</span><br><span class="line">(<span class="number">3</span>,<span class="number">4</span>i)</span><br></pre></td></tr></table></figure>


<h5 id="重载-号操作符"><a href="#重载-号操作符" class="headerlink" title="重载=号操作符"></a>重载<code>=</code>号操作符</h5><ul>
<li>这个重点是在当类中有指针的时候，就要注意堆中分配空间的问题，如果不是在初始化的时候使用的<code>=</code>操作符，就是代表的赋值，其中的指针不能使用浅拷贝；</li>
<li>需要我们重写<code>=</code>操作符，实现深拷贝。(就是不能让两个对象同时指向堆中的同一块内存，因为释放内存的时候不能释放两次)；<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Student</span>() &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;id = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">this</span>-&gt;name = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Student</span>(<span class="keyword">int</span> id, <span class="keyword">const</span> <span class="keyword">char</span> *name)&#123; </span><br><span class="line">            <span class="keyword">this</span>-&gt;id = id;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> len = <span class="built_in">strlen</span>(name);</span><br><span class="line">            <span class="keyword">this</span>-&gt;name = <span class="keyword">new</span> <span class="keyword">char</span>[len+<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Student</span>(<span class="keyword">const</span> Student&amp; thr)&#123;  <span class="comment">// 拷贝构造</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;id = thr.id;</span><br><span class="line">            <span class="comment">//深拷贝</span></span><br><span class="line">            <span class="keyword">int</span> len = <span class="built_in">strlen</span>(thr.name);</span><br><span class="line">            <span class="keyword">this</span>-&gt;name = <span class="keyword">new</span> <span class="keyword">char</span>[len+<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, thr.name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重载=号，防止 s2 = s1的时候内部的name直接指向堆中的同一个内容，析构时发生错误</span></span><br><span class="line">        Student&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Student&amp; thr)&#123; </span><br><span class="line">            <span class="comment">//1. 防止自身赋值</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;thr) <span class="comment">//&amp;是取地址 </span></span><br><span class="line">                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">            <span class="comment">//2. 将自身的空间回收</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;name != <span class="literal">NULL</span>)&#123; </span><br><span class="line">                <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;name;</span><br><span class="line">                <span class="keyword">this</span>-&gt;name = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">this</span>-&gt;id = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3. 执行深拷贝</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;id = thr.id;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="built_in">strlen</span>(thr.name);</span><br><span class="line">            <span class="keyword">this</span>-&gt;name = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, thr.name);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4. 返回本身的对象</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">Student</span>()&#123; </span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;name != <span class="literal">NULL</span>)&#123; </span><br><span class="line">                <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;name;</span><br><span class="line">                <span class="keyword">this</span>-&gt;name = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">this</span>-&gt;id = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">printS</span><span class="params">()</span></span>&#123; </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, name);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">char</span> *name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">s1</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;zhangsan&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Student <span class="title">s2</span><span class="params">(s1)</span></span>; <span class="comment">//拷贝构造</span></span><br><span class="line">    Student s3 = s1; <span class="comment">//这个调用的还是拷贝构造函数，不是=操作符，初始化的都是拷贝构造函数</span></span><br><span class="line">    s1.<span class="built_in">printS</span>();</span><br><span class="line">    s2.<span class="built_in">printS</span>();</span><br><span class="line">    s3.<span class="built_in">printS</span>();</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//但是这样就是调用的等号操作符</span></span><br><span class="line">    Student s4;</span><br><span class="line">    s4 = s1; <span class="comment">//不是初始化的时候</span></span><br><span class="line">    s4.<span class="built_in">printS</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="重载流插入运算符和流提取运算符"><a href="#重载流插入运算符和流提取运算符" class="headerlink" title="重载流插入运算符和流提取运算符"></a>重载流插入运算符和流提取运算符</h5><ul>
<li>重载流插入运算符的基本格式: <code>istream&amp; operator&gt;&gt; (istream&amp;, 自定义类&amp;);</code> ，也就是返回值和第一个参数必须是<code>istream&amp;</code>类型；</li>
<li>重载流提取运算符的基本格式: <code>ostream&amp; operator&lt;&lt; (istream&amp;, 自定义类&amp;);</code>，也就是返回值和第一个参数必须是<code>ostream&amp;</code>类型；</li>
<li><font color = red>注意: 重载这两个运算符的时候，只能将他们作为友元函数，不能作为成员函数。避免修改 <code>c++</code>的标准库。</font></li>
</ul>
<p>案例: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp;, Complex&amp;);</span><br><span class="line">        <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt; (istream&amp;, Complex&amp;);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp; os, Complex&amp; c)</span><br><span class="line">&#123; </span><br><span class="line">    os&lt;&lt;<span class="string">&quot;(&quot;</span>&lt;&lt;c.a&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;c.b&lt;&lt;<span class="string">&quot;i)&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> os;<span class="comment">//返回stream对象就可以连续向输出流插入信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt; (istream&amp; is, Complex&amp; c)</span><br><span class="line">&#123; </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a:&quot;</span>;</span><br><span class="line">    is&gt;&gt;c.a;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;b:&quot;</span>;</span><br><span class="line">    is&gt;&gt;c.b;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Complex c;</span><br><span class="line">    cin&gt;&gt;c;</span><br><span class="line">    cout&lt;&lt;c;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="综合案例-矩阵加法以及输入输出"><a href="#综合案例-矩阵加法以及输入输出" class="headerlink" title="综合案例-矩阵加法以及输入输出"></a>综合案例-矩阵加法以及输入输出</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span>&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Matrix</span>();</span><br><span class="line">        <span class="keyword">friend</span> Matrix <span class="keyword">operator</span>+(Matrix&amp;, Matrix&amp;);</span><br><span class="line">        <span class="comment">//千万注意: 只能将&quot;&lt;&lt;&quot;和&quot;&gt;&gt;&quot;定义为友元函数，不能作为成员函数</span></span><br><span class="line">        <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp;, Matrix&amp;);</span><br><span class="line">        <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp;, Matrix&amp;); </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> mat[N][M];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Matrix::<span class="built_in">Matrix</span>()&#123; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++)&#123; </span><br><span class="line">            mat[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意返回局部变量对象，不能返回引用</span></span><br><span class="line">Matrix <span class="keyword">operator</span>+ (Matrix&amp; a, Matrix&amp; b)&#123; </span><br><span class="line">    Matrix c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++)&#123; </span><br><span class="line">            c.mat[i][j] = a.mat[i][j] + b.mat[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, Matrix&amp; m)&#123; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++)&#123; </span><br><span class="line">            os&lt;&lt;m.mat[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        os&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; is, Matrix&amp; m)&#123; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++)&#123; </span><br><span class="line">            is&gt;&gt;m.mat[i][j];</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Matrix matrix1,matrix2;</span><br><span class="line">    cin&gt;&gt;matrix1;</span><br><span class="line">    cin&gt;&gt;matrix2;</span><br><span class="line">    Matrix matrix3 = matrix1 + matrix2;</span><br><span class="line">    cout&lt;&lt;matrix3&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:<br><img src="images/cpp1.png" alt="在这里插入图片描述"></p>
<hr>
<h3 id="函数模板、类模板"><a href="#函数模板、类模板" class="headerlink" title="函数模板、类模板"></a><font color = red id = "4">函数模板、类模板</h3><ul>
<li>函数模板基本语法: <code>template &lt;typename T&gt;</code>；</li>
<li>类模板基本语法: <code>template &lt;class T&gt;</code>，注意函数声明在外面的时候也要在函数的上面写上这个语句；</li>
<li>函数模板实际上是建立一个通用函数， 其函数类型和形参类型不具体制定， 用 一个虚拟的类型来代表。 这 个通用函数就成为函数模板；</li>
<li>注意:  ①函数模板不允许自动类型转化；②普通函数能够自动进行类型转化；</li>
<li>&lt;函数模板和普通函数在一起调用规则：① 函数模板可以想普通函数那样可以被重载；②<code>C++</code>编 译器优先考虑普通函数；</li>
<li>类模板中的 <code>static</code>关 键字: ①从 类模板实例化的每一个模板类有自己的类模板数据成员， 该 模板的所有对象共享一 个 <code>statci</code>数 据成员②每 个模板类有自己类模板的<code>static</code>数据成员的副本；</li>
</ul>
<p>测试程序: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap1</span><span class="params">(T&amp; a, T&amp; b)</span></span>&#123;</span><br><span class="line">    T t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">R</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Complex</span>(T a, R b):<span class="built_in">a</span>(a),<span class="built_in">b</span>(b)&#123; &#125;</span><br><span class="line">        <span class="comment">//方法一: 下面的printC函数是在类内实现</span></span><br><span class="line">        <span class="comment">//void printC()</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">        <span class="comment">//    cout&lt;&lt;&quot;(&quot;&lt;&lt;a&lt;&lt;&quot;,&quot;&lt;&lt;b&lt;&lt;&quot;i)&quot;&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方法二: 在类外实现要声明</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法三: 重载+友元函数 最好作为内部，外部有点麻烦</span></span><br><span class="line">        <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp; os, Complex&lt;T,R&gt;&amp; c)&#123; </span><br><span class="line">            os&lt;&lt;<span class="string">&quot;(&quot;</span>&lt;&lt;c.a&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;c.b&lt;&lt;<span class="string">&quot;i)&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> os;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T a;</span><br><span class="line">        R b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在类外实现,必须要加上函数模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">R</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Complex&lt;T,R&gt;::<span class="built_in">printC</span>()</span><br><span class="line">&#123; </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;(&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;b&lt;&lt;<span class="string">&quot;i)&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    swap1&lt;<span class="keyword">int</span>&gt;(a,b);<span class="comment">//显示的调用</span></span><br><span class="line">    <span class="comment">//自动类型推导</span></span><br><span class="line">    <span class="comment">//swap1(a, b);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d,b = %d\n&quot;</span>, a, b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-------类模板-------\n&quot;</span>);</span><br><span class="line">    Complex&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt;<span class="built_in">c1</span>(<span class="number">2.2</span>, <span class="number">3.3</span>);</span><br><span class="line">    c1.<span class="built_in">printC</span>();</span><br><span class="line"></span><br><span class="line">    Complex&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt;<span class="built_in">c2</span>(<span class="number">4</span>, <span class="number">5.5</span>);</span><br><span class="line">    cout&lt;&lt;c2&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a = <span class="number">20</span>,b = <span class="number">10</span></span><br><span class="line">-------类模板-------</span><br><span class="line">(<span class="number">2.2</span>,<span class="number">3.3</span>i)</span><br><span class="line">(<span class="number">4</span>,<span class="number">5.5</span>i)</span><br></pre></td></tr></table></figure>
<h5 id="案例-简单实现的Vector类模板中的push-back"><a href="#案例-简单实现的Vector类模板中的push-back" class="headerlink" title="案例-简单实现的Vector类模板中的push_back"></a>案例-简单实现的Vector类模板中的<code>push_back</code></h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span>&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">MyArray</span>(<span class="keyword">int</span> capacity)&#123; <span class="comment">//构造函数</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">            <span class="keyword">this</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">this</span>-&gt;p = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;capacity];</span><br><span class="line">        &#125;</span><br><span class="line">        MyArray&lt;T&gt;(<span class="keyword">const</span> MyArray&lt;T&gt;&amp; thr)&#123; <span class="comment">//拷贝构造</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;size = thr.size;</span><br><span class="line">            <span class="keyword">this</span>-&gt;capacity = thr.capacity;</span><br><span class="line">            <span class="keyword">this</span>-&gt;p = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;capacity];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;size; i++)&#123;  </span><br><span class="line">                <span class="keyword">this</span>-&gt;p[i] = thr.p[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重载=号</span></span><br><span class="line">        MyArray&lt;T&gt;&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> MyArray&lt;T&gt;&amp; thr)&#123; </span><br><span class="line">             <span class="comment">//1. 防止自身赋值</span></span><br><span class="line">             <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;thr)&#123; </span><br><span class="line">                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//2. 删除原来的</span></span><br><span class="line">            <span class="keyword">if</span>(p != <span class="literal">NULL</span>)&#123; </span><br><span class="line">                <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;p;</span><br><span class="line">                <span class="keyword">this</span>-&gt;p = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>-&gt;size = thr.size;</span><br><span class="line">            <span class="keyword">this</span>-&gt;capacity = thr.capacity;</span><br><span class="line">            <span class="keyword">this</span>-&gt;p = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;capacity];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;size; i++)&#123; </span><br><span class="line">                <span class="keyword">this</span>-&gt;p[i] = thr.p[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//重载[]运算符: 提取元素</span></span><br><span class="line">        T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;p[index];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">pushBack</span><span class="params">(T&amp; ele)</span></span>&#123; </span><br><span class="line">            <span class="keyword">if</span>(size == capacity)&#123; </span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 调用的是 = 号运算符，如果成员是指针，要注意深拷贝问题</span></span><br><span class="line">            p[size++] = ele;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//搞定插入常量(右值)的引用问题(C++11特性)</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">pushBack</span><span class="params">(T&amp;&amp; ele)</span></span>&#123; </span><br><span class="line">            <span class="keyword">if</span>(size == capacity)&#123; </span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 调用的是 = 号运算符，如果成员是指针，要注意深拷贝问题</span></span><br><span class="line">            p[size++] = ele;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~<span class="built_in">MyArray</span>()&#123; </span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;p != <span class="literal">NULL</span>)&#123; </span><br><span class="line">                <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;size;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> capacity;<span class="comment">//容量</span></span><br><span class="line">        <span class="keyword">int</span> size; <span class="comment">//当前数组元素</span></span><br><span class="line">        T *p; <span class="comment">//数组首地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    MyArray&lt;<span class="keyword">int</span>&gt;<span class="built_in">array</span>(<span class="number">20</span>); </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    array.<span class="built_in">pushBack</span>(a);</span><br><span class="line">    array.<span class="built_in">pushBack</span>(b);</span><br><span class="line"></span><br><span class="line">    array.<span class="built_in">pushBack</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.<span class="built_in">getSize</span>(); i++)&#123; </span><br><span class="line">        cout&lt;&lt;array[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a><font color = red id = "5">文件操作</h3><h4 id="输入输出流"><a href="#输入输出流" class="headerlink" title="输入输出流"></a>输入输出流</h4><p><code>C++</code>输入输出包含以下三个方面的内容：</p>
<ul>
<li>对 系统指定的标准设备的输入和输出。 即从键盘输入数据，输出到显示器屏幕。这种输入输出称为标准的输入输出，简称<font color  = blue>标准 I /O。</li>
<li>以外存磁盘文件为对象进行输入和输出， 即从磁盘文件输入数据， 数据输出到磁盘文件。 以外存文件为对象的输入输出称为文件的输入输出，简称<font color  = blue>文件 I /O。</li>
<li>对 内存中指定的空间进行输入和输出。通常指定一个字符数组作为存储空间( 实际上可以利用该空间存储任何信息) 。 这种输入和输出称为字符串输入输出，简称<font color  = blue>串 I /O。 </li>
</ul>
<p>缓冲区的概念: </p>
<ul>
<li>要注意；</li>
<li>读和写是站在应用程序的角度来看的；<br><img src="images/cpp2.png" alt="在这里插入图片描述"></li>
</ul>
<p>标准输入流对象 <code>cin</code>， 重点函数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cin.<span class="built_in">get</span>() <span class="comment">// 一次只能读取一个字符</span></span><br><span class="line">cin.<span class="built_in">get</span>(一个参数) <span class="comment">// 读 一个字符</span></span><br><span class="line">cin.<span class="built_in">get</span>(两个参数) <span class="comment">// 可以读字符串</span></span><br><span class="line">cin.<span class="built_in">getline</span>()</span><br><span class="line">cin.<span class="built_in">ignore</span>()</span><br><span class="line">cin.<span class="built_in">peek</span>()</span><br><span class="line">cin.<span class="built_in">putback</span>()</span><br></pre></td></tr></table></figure>

<p>测试<code>cin.get()</code>、<code>cin.getline()</code>的简单使用: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="comment">//while( (ch = cin.get()) != EOF)</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; ch &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//char ch;  cin.get(ch); //same as above</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    cin.<span class="built_in">get</span>(buf, <span class="number">256</span>); <span class="comment">//　两个参数,从缓冲区读取一个字符串指定长度</span></span><br><span class="line">    cout &lt;&lt; buf;</span><br><span class="line">    cin.<span class="built_in">get</span>(buf, <span class="number">256</span>, <span class="string">&#x27;\n&#x27;</span>); <span class="comment">//三个参数,指定终止的字符</span></span><br><span class="line">    cout &lt;&lt; buf;</span><br><span class="line">    cin.<span class="built_in">getline</span>(buf, <span class="number">256</span>);  <span class="comment">//读取一行数据，不读换行符</span></span><br><span class="line">    cout &lt;&lt; buf;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试<code>cin.ignore()</code>使用: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    cin.<span class="built_in">get</span>(ch);    <span class="comment">//从缓冲区要数据 阻塞</span></span><br><span class="line">    cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">    cin.<span class="built_in">ignore</span>(<span class="number">1</span>); <span class="comment">//忽略当前字符 从缓冲区取走了</span></span><br><span class="line">    cin.<span class="built_in">get</span>(ch);</span><br><span class="line">    cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果:<br><img src="images/cpp3.png" alt="在这里插入图片描述"></p>
<p>测试<code>cin.peek()</code>函数的使用: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入数组或者字符串:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    ch = cin.<span class="built_in">peek</span>(); <span class="comment">//偷窥一下缓冲区，并不会取走, 返回第一个字符</span></span><br><span class="line">    <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> number;</span><br><span class="line">        cin &gt;&gt; number; <span class="comment">// 从缓冲区读取这个数字</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;您输入的是数字:&quot;</span> &lt;&lt; number &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        cin &gt;&gt; buf; <span class="comment">// 从缓冲区读取这个字符串</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;您输入的是字符串:&quot;</span> &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：　<br><img src="images/cpp4.png" alt="在这里插入图片描述"></p>
<p>测试<code>cin.putback()</code>函数的使用: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入字符串或者数字:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    cin.<span class="built_in">get</span>(ch); <span class="comment">//从缓冲区取走一个字符</span></span><br><span class="line">    <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        cin.<span class="built_in">putback</span>(ch); <span class="comment">//ch放回到缓冲区</span></span><br><span class="line">        <span class="keyword">int</span> number;</span><br><span class="line">        cin &gt;&gt; number;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;您输入的是数字:&quot;</span> &lt;&lt; number &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cin.<span class="built_in">putback</span>(ch);<span class="comment">// 将字符放回缓冲区</span></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        cin &gt;&gt; buf;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;您输入的是字符串: &quot;</span> &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果和测试<code>cin.peek()</code>函数的一样。</p>
<p>标准输出流对象 <code>cout</code>，重点函数: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout.<span class="built_in">flush</span>() <span class="comment">// 刷新缓冲区</span></span><br><span class="line">cout.<span class="built_in">put</span>() <span class="comment">// 向缓冲区写字符</span></span><br><span class="line">cout.<span class="built_in">write</span>() <span class="comment">// 二进制流的输出</span></span><br><span class="line">cout.<span class="built_in">width</span>() <span class="comment">// 输出格式控制</span></span><br><span class="line">cout.<span class="built_in">fill</span>()</span><br><span class="line">cout.<span class="built_in">setf</span>(标记)</span><br></pre></td></tr></table></figure>
<p><code>cout</code>比较简单不做案例演示。</p>
<h4 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h4><p>输入输出是以系统指定的标准设备（输入设备为键盘，输出设备为显示器）为对象的。 在实际应用中，常以磁盘文件作为对象。即从磁盘文件读取数据，将数据输出到磁盘文件。 和 文件有关系的输入输出类主要在 <code>fstream.h</code> 这 个头文件中被定义，在这个头文件中主要被定义了三个类， 由这三个类控制对文件的各种输入输出操作 ， 他们分别是 <code>ifstream</code>、 <code>ofstream</code>。</p>
<p><img src="images/cpp5.png" alt="在这里插入图片描述"><br>由于文件设备并不像显示器屏幕与键盘那样是标准默认设备，所以它在 <code>fstream.h</code> 头 文件中<br>是没有像 <code>cout</code> 那 样预先定义的全局对象，所以我们必须自己定义一个该类的对象。 <code>ifstream</code> 类 ，它是从 <code>istream</code> 类 派生的，用来支持从磁盘文件的输入。<code>ofstream</code> 类 ，它是从<code>ostream</code>类 派生的，用来支持向磁盘文件的输出。<br><code>fstream</code> 类 ，它是从<code>iostream</code>类 派生的，用来支持对磁盘文件的输入输出。</p>
<p>所谓打开( <code>open</code>)文 件是一种形象的说法，如同打开房门就可以进入房间活动一样。 打<br>开 文件是指在文件读写之前做必要的准备工作，包括：</p>
<ul>
<li>为文件流对象和指定的磁盘文件建立关联，以便使文件流 向指定的磁盘文件。</li>
<li> 指定文件的工作方式，如，该文件是作为输入文件还是输出文件，是 <code>ASCII</code> 文件还是二进制文件等。</li>
</ul>
<p>以上工作可以通过两种不同的方法实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span> <span class="comment">//文件读写的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* srcName = <span class="string">&quot;src.txt&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* destName = <span class="string">&quot;dest.txt&quot;</span>;</span><br><span class="line">    <span class="function">ifstream <span class="title">is</span><span class="params">(srcName, ios::in)</span></span>; <span class="comment">//只读方式打开</span></span><br><span class="line">    <span class="function">ofstream <span class="title">os</span><span class="params">(destName, ios::out | ios::app)</span></span>; <span class="comment">// app表示是追加</span></span><br><span class="line">    <span class="keyword">if</span>(!is)&#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;打开文件失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>(is.<span class="built_in">get</span>(ch))&#123; </span><br><span class="line">        cout &lt;&lt; ch;</span><br><span class="line">        os.<span class="built_in">put</span>(ch); <span class="comment">// 输出到os指向的文件</span></span><br><span class="line">    &#125;</span><br><span class="line">    is.<span class="built_in">close</span>();</span><br><span class="line">    os.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>演示结果:<br><img src="images/cpp6.png" alt="在这里插入图片描述"></p>
<p>测试按照二进制方式写入和读取: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="built_in">Person</span>()&#123; &#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">int</span> age, <span class="keyword">int</span> id):<span class="built_in">age</span>(age), <span class="built_in">id</span>(id)&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age: &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;, id: &quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Person p1(10, 20), p2(30, 40);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *destFile = <span class="string">&quot;dest.txt&quot;</span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">os</span><span class="params">(destFile, ios::out | ios::binary)</span></span>; <span class="comment">// 二进制方式写入</span></span><br><span class="line">    os.<span class="built_in">write</span>((<span class="keyword">char</span>*)&amp;p1, <span class="built_in"><span class="keyword">sizeof</span></span>(Person));</span><br><span class="line">    os.<span class="built_in">write</span>((<span class="keyword">char</span>*)&amp;p2, <span class="built_in"><span class="keyword">sizeof</span></span>(Person));</span><br><span class="line">    os.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *destFile = <span class="string">&quot;dest.txt&quot;</span>;</span><br><span class="line">    <span class="function">ifstream <span class="title">is</span><span class="params">(destFile, ios::in | ios::binary)</span></span>;</span><br><span class="line">    Person p1, p2;</span><br><span class="line">    is.<span class="built_in">read</span>((<span class="keyword">char</span>*)&amp;p1, <span class="built_in"><span class="keyword">sizeof</span></span>(Person));</span><br><span class="line">    is.<span class="built_in">read</span>((<span class="keyword">char</span>*)&amp;p2, <span class="built_in"><span class="keyword">sizeof</span></span>(Person));</span><br><span class="line">    p1.<span class="built_in">show</span>();</span><br><span class="line">    p2.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C Language</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Instrction Arrangement以及关键路径详解</title>
    <url>/2022/02/25/Ordering%20Tasks%20_%20LeetCode%20-%20207.%20Course%20Schedule%20(%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F)/</url>
    <content><![CDATA[<h2 id="Ordering-Tasks-LeetCode-207-Course-Schedule-拓扑排序"><a href="#Ordering-Tasks-LeetCode-207-Course-Schedule-拓扑排序" class="headerlink" title="Ordering Tasks | LeetCode - 207. Course Schedule (拓扑排序)"></a>Ordering Tasks | LeetCode - 207. Course Schedule (拓扑排序)</h2><ul>
<li><a href="#1">Uva - 10305. Ordering Tasks</a></li>
<li><a href="#2">LeetCode - 207. Course Schedule</a></li>
</ul>
<hr>
<h3 id="Uva-10305-Ordering-Tasks"><a href="#Uva-10305-Ordering-Tasks" class="headerlink" title="Uva - 10305. Ordering Tasks"></a><font color = red id = "1">Uva - 10305. Ordering Tasks</h3><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1246">题目链接</a></h4><blockquote>
<p><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1246">https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1246</a></p>
</blockquote>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p><img src="images/to1.png"></p>
<p>给你<code>n、m</code>，<code>n</code>代表点的个数，<code>m</code>代表边的条数，然后下面给出<code>m</code>条边，都是有向的(有向图)，要你建出一个图，并且找出一种序列，这种序列即拓扑序列 。</p>
<blockquote>
<p>拓扑排序  是对有向无环图（<code>DAG</code>)进行的一种操作，这种操作是将<code>DAG</code>中的所有顶点排成一个线性序列，使得图中的任意一对顶点<code>u,v</code>满足如下条件：若边<code>(u,v) ∈ E(G)</code>，则<code>u</code>在最终的线性序列中出现在<code>v</code>的前面;<br>拓扑排序的应用常常和<code>AOV</code>网相联系，在一个大型的工程中，某些项目不是独立于其他项目的，这意味着这种非独立的项目的完成必须依赖与其它项目的完成而完成，不妨记为<code>u,v</code>，则若边<code>(u,v)∈E(G)</code>，代表着必须在项目<code>u</code>完成后，<code>v</code>才能完成。</p>
</blockquote>
<p> <strong>所以如果存在有向环，则不存在拓扑排序</strong>，反之则存在。</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>拓扑排序可以使用<code>BFS</code>或者<code>DFS</code>来求解。</p>
<p><font color = purple><strong>①<code>BFS</code></strong></font></p>
<p>拓扑排序使用<code>BFS</code>解题的过程: </p>
<ul>
<li>找出入度为<code>0</code>的结点并加入队列；</li>
<li>在队列中弹出一个结点，并访问，<strong>并把它的相邻结点的入度<code>-1</code>，如果减一之后入度为<code>0</code>，则也进队列；</strong></li>
<li>直到队列为空，访问完毕 ；</li>
</ul>
<p>通过上述过程即可以得到图的拓扑序列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;Integer&gt; G[];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] in;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n , m;</span><br><span class="line">    <span class="keyword">static</span> PrintStream out;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortedTopology</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt;queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[i] == <span class="number">0</span>)</span><br><span class="line">                queue.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>; <span class="comment">// for output</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                out.print(cur);</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                out.print(<span class="string">&quot; &quot;</span> + cur);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[cur].size(); i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> to = G[cur].get(i);</span><br><span class="line">                <span class="keyword">if</span>(--in[to] == <span class="number">0</span>)</span><br><span class="line">                    queue.add(to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line">        out = System.out;</span><br><span class="line">        <span class="keyword">while</span>(cin.hasNext())&#123;</span><br><span class="line">            n = cin.nextInt();</span><br><span class="line">            m = cin.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            in = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">            G = <span class="keyword">new</span> ArrayList[n + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">                G[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> from = cin.nextInt();</span><br><span class="line">                <span class="keyword">int</span> to = cin.nextInt();</span><br><span class="line">                G[from].add(to);</span><br><span class="line">                in[to]++;</span><br><span class="line">            &#125;</span><br><span class="line">            sortedTopology();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color = purple><strong>②<code>DFS</code></strong></font><br>使用<code>DFS</code>求解拓扑排序的过程:</p>
<ul>
<li>这里的<code>vis</code>需要表示三个状态，即: <code>vis[i] = 0</code>表示还从未访问过、<code>vis[i] = 1</code>表示已经访问过、<code>vis[i] = 2</code>表示正在访问；</li>
<li>只需要通过上述的设置，即可以判断是否能得到拓扑排序(或者说是否有环)；</li>
<li>然后我们还需要记录拓扑序列，因为递归不断进行到深层，所以我们需要用栈来记录拓扑序列，这里用一个数组<font color = red>从后往前</font>存即可；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;Integer&gt; G[];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] vis;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n , m;</span><br><span class="line">    <span class="keyword">static</span> PrintStream out;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] res;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> p;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123; </span><br><span class="line">        vis[cur] = <span class="number">2</span>; <span class="comment">// now is visiting </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> to : G[cur])&#123;  </span><br><span class="line">            <span class="keyword">if</span>(vis[to] == <span class="number">2</span> || (vis[to] == <span class="number">0</span> &amp;&amp; !dfs(to))) <span class="comment">// exist directed cycle </span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[cur] = <span class="number">1</span>; <span class="comment">// now is visited</span></span><br><span class="line">        res[p--] = cur;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line">        out = System.out;</span><br><span class="line">        <span class="keyword">while</span>(cin.hasNext())&#123;</span><br><span class="line">            n = cin.nextInt();</span><br><span class="line">            m = cin.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            G = <span class="keyword">new</span> ArrayList[n + <span class="number">1</span>];</span><br><span class="line">            vis = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">                G[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> from = cin.nextInt();</span><br><span class="line">                <span class="keyword">int</span> to = cin.nextInt();</span><br><span class="line">                G[from].add(to);</span><br><span class="line">            &#125; </span><br><span class="line">            p = n - <span class="number">1</span>;  <span class="comment">// back to front</span></span><br><span class="line">            res = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">boolean</span> ok = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; </span><br><span class="line">                <span class="keyword">if</span>(vis[i] == <span class="number">0</span>)</span><br><span class="line">                    dfs(i);</span><br><span class="line">            &#125;       </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n-<span class="number">1</span>; i++)</span><br><span class="line">                out.print(res[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            out.println(res[n-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="LeetCode-207-Course-Schedule"><a href="#LeetCode-207-Course-Schedule" class="headerlink" title="LeetCode - 207. Course Schedule"></a><font color = red id = "2">LeetCode - 207. Course Schedule</h3><h4 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a><a href="https://leetcode.com/problems/course-schedule/">题目链接</a></h4><blockquote>
<p><a href="https://leetcode.com/problems/course-schedule/">https://leetcode.com/problems/course-schedule/</a></p>
</blockquote>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><img src="images/to2.png" alt="在这里插入图片描述"></p>
<h4 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h4><p>和上一个题目差不多，这个题目更加简单，只需要你判断能不能得到拓扑序列。</p>
<p><font color = purple><strong>①<code>BFS</code></strong></font></p>
<ul>
<li>总体过程和上一题差不多；</li>
<li>这里增加一个<code>vis</code>数组，当我们进行完<code>BFS</code>过程之后，如果还有点没有被访问到<code>vis[i] = false</code>，则说明不能得到拓扑序列(有环)；</li>
</ul>
<p><img src="images/to3.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// topological sorting should be used on directed acyclic graph </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = numCourses;</span><br><span class="line">        ArrayList&lt;Integer&gt; G[] = <span class="keyword">new</span> ArrayList[n];</span><br><span class="line">        <span class="keyword">int</span>[] in = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">boolean</span>[] vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            G[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; i++)&#123; </span><br><span class="line">            <span class="keyword">int</span> to = prerequisites[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> from = prerequisites[i][<span class="number">1</span>];</span><br><span class="line">            G[from].add(to);</span><br><span class="line">            in[to]++;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt;queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span>(in[i] == <span class="number">0</span>)</span><br><span class="line">                queue.add(i);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123; </span><br><span class="line">            Integer cur = queue.poll();</span><br><span class="line">            vis[cur] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[cur].size(); i++)&#123; </span><br><span class="line">                <span class="keyword">int</span> to = G[cur].get(i);</span><br><span class="line">                <span class="keyword">if</span>(--in[to] == <span class="number">0</span>)</span><br><span class="line">                    queue.add(to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span>(!vis[i]) <span class="comment">// 有些点没有访问到</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        PrintStream out = System.out;</span><br><span class="line">        <span class="keyword">int</span> numCourses = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] prerequisites = &#123; </span><br><span class="line">             &#123;<span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">             &#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        out.println(<span class="keyword">new</span> Solution().</span><br><span class="line">            canFinish(numCourses, prerequisites)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color = purple><strong>②<code>DFS</code></strong></font></p>
<p>这个和上面的<code>DFS</code>也是一样的，区别就是这里不需要记录拓扑序列了。</p>
<p><img src="images/to4.png" alt="在这里插入图片描述"></p>
<p><code>DFS</code>访问顺序以及记录的拓扑序列(<code>res</code>)如下: </p>
<p>可以看到访问的顺序和结果的顺序正好相反: </p>
<table>
<thead>
<tr>
<th><font color = red><strong>vertex</strong></th>
<th><font color = red><strong>visiting</strong>( <code>vis = 2</code>)</th>
<th><font color = red><strong>visited</strong>(<code>vis = 1</code>)</th>
<th><code>res</code></th>
</tr>
</thead>
<tbody><tr>
<td><font color = purple><strong>0</strong></td>
<td><strong>{0}</strong></td>
<td><strong>{}</strong></td>
<td><strong>{}</strong></td>
</tr>
<tr>
<td><font color = purple><strong>1</strong></td>
<td><strong>{0, 1}</strong></td>
<td><strong>{}</strong></td>
<td><strong>{}</strong></td>
</tr>
<tr>
<td><font color = purple><strong>0</strong></td>
<td><strong>{0</strong>}</td>
<td><strong>{1}</strong></td>
<td><strong>{1}</strong></td>
</tr>
<tr>
<td><font color = purple><strong>7</strong></td>
<td><strong>{0, 7}</strong></td>
<td><strong>{1}</strong></td>
<td><strong>{1}</strong></td>
</tr>
<tr>
<td><font color = purple><strong>0</strong></td>
<td><strong>{0}</strong></td>
<td><strong>{1, 7}</strong></td>
<td>{<strong>7, 1}</strong></td>
</tr>
<tr>
<td><font color = purple><strong>-</strong></td>
<td><strong>{}</strong></td>
<td><strong>{1, 7, 0}</strong></td>
<td><strong>{0, 7, 1}</strong></td>
</tr>
<tr>
<td><font color = purple><strong>2</strong></td>
<td><strong>{2}</strong></td>
<td><strong>{1, 7, 0}</strong></td>
<td><strong>{0, 7, 1}</strong></td>
</tr>
<tr>
<td><font color = purple><strong>-</strong></td>
<td><strong>{}</strong></td>
<td><strong>{1, 7, 0, 2}</strong></td>
<td><strong>{2, 0, 7, 1}</strong></td>
</tr>
<tr>
<td><font color = purple><strong>3</strong></td>
<td><strong>{3}</strong></td>
<td><strong>{1, 7, 0, 2}</strong></td>
<td><strong>{2, 0, 7, 1}</strong></td>
</tr>
<tr>
<td><font color = purple><strong>-</strong></td>
<td><strong>{}</strong></td>
<td><strong>{1, 7, 0, 2, 3}</strong></td>
<td><strong>{3, 2, 0, 7, 1}</strong></td>
</tr>
<tr>
<td><font color = purple><strong>4</strong></td>
<td><strong>{4}</strong></td>
<td><strong>{1, 7, 0, 2, 3}</strong></td>
<td><strong>{3, 2, 0, 7, 1}</strong></td>
</tr>
<tr>
<td><font color = purple><strong>6</strong></td>
<td><strong>{4, 6}</strong></td>
<td><strong>{1, 7, 0, 2, 3}</strong></td>
<td><strong>{3, 2, 0, 7, 1}</strong></td>
</tr>
<tr>
<td><font color = purple><strong>4</strong></td>
<td><strong>{4}</strong></td>
<td><strong>{1, 7, 0, 2, 3, 6}</strong></td>
<td><strong>{6, 3, 2, 0, 7, 1}</strong></td>
</tr>
<tr>
<td><font color = purple><strong>-</strong></td>
<td><strong>{}</strong></td>
<td><strong>{1, 7, 0, 2, 3, 6, 4}</strong></td>
<td><strong>{4, 6, 3, 2, 0, 7, 1}</strong></td>
</tr>
<tr>
<td><font color = purple><strong>5</strong></td>
<td><strong>{5}</strong></td>
<td><strong>{1, 7, 0, 2, 3, 6, 4}</strong></td>
<td><strong>{4, 6, 3, 2, 0, 7, 1}</strong></td>
</tr>
<tr>
<td><font color = purple><strong>-</strong></td>
<td><strong>{}</strong></td>
<td><strong>{1, 7, 0, 2, 3, 6, 4, 5}</strong></td>
<td><strong>{5, 4, 6, 3, 2, 0, 7, 1}</strong></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; G[];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] vis; <span class="comment">// 0: not visited, 1 : visited, 2 : visiting</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// topological sorting should be used on directed acyclic graph </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = numCourses;</span><br><span class="line">        G = <span class="keyword">new</span> ArrayList[n];</span><br><span class="line">        vis = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            G[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; i++)&#123; </span><br><span class="line">            <span class="keyword">int</span> to = prerequisites[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> from = prerequisites[i][<span class="number">1</span>];</span><br><span class="line">            G[from].add(to);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span>(!dfs(i))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123; </span><br><span class="line">        vis[cur] = <span class="number">2</span>; <span class="comment">// visiting </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> to : G[cur])&#123; </span><br><span class="line">            <span class="keyword">if</span>((vis[to] == <span class="number">2</span>) || (vis[to] == <span class="number">0</span> &amp;&amp; !dfs(to)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[cur] = <span class="number">1</span>; <span class="comment">// visited</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        PrintStream out = System.out;</span><br><span class="line">        <span class="keyword">int</span> numCourses = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] prerequisites = &#123; </span><br><span class="line">             &#123;<span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">             &#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        out.println(<span class="keyword">new</span> Solution().</span><br><span class="line">            canFinish(numCourses, prerequisites)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>另外<code>DFS</code>函数也可以这样写:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(vis[cur] == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(vis[cur] == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    vis[cur] = <span class="number">2</span>; <span class="comment">// visiting </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> to : G[cur])&#123; </span><br><span class="line">        <span class="keyword">if</span>(!dfs(to))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[cur] = <span class="number">1</span>; <span class="comment">// visited</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Graph</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>乘法快速幂相关总结  &amp; LeetCode - 50. Pow(x, n)</title>
    <url>/2022/04/26/%E4%B9%98%E6%B3%95%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93%20%20&amp;%20LeetCode%20-%2050.%20Pow(x,%20n)/</url>
    <content><![CDATA[<h2 id="乘法快速幂相关总结-amp-LeetCode-50-Pow-x-n"><a href="#乘法快速幂相关总结-amp-LeetCode-50-Pow-x-n" class="headerlink" title="乘法快速幂相关总结  &amp; LeetCode - 50. Pow(x, n)"></a>乘法快速幂相关总结  &amp; LeetCode - 50. Pow(x, n)</h2><ul>
<li>递归计算<font color = red> (a <sup>n</sup>) % mod</li>
<li>非递归计算  <font color = red>(a <sup>n</sup>) % mod</li>
<li>计算<font color = red> ( a * b ) % mod</li>
<li>配合<font color = red> ( a * b ) % mod</font>和乘法快速幂</li>
<li>XYNUOJ - 1872. 次方求模题解</li>
<li>LeetCode - 50. Pow(x, n)题解</li>
</ul>
<hr>
<h3 id="递归计算-a-n-mod"><a href="#递归计算-a-n-mod" class="headerlink" title="递归计算 (a n) % mod"></a>递归计算 (a <sup>n</sup>) % mod</h3><p>递归计算其实是更容易理解的: </p>
<ul>
<li>为了求<font color = red>a<sup>n</sup></font>，我们先递归去求出<font color = red>a<sup>n/2</sup></font>，得到结果记录为<code>halfRes</code>；</li>
<li>然后如果<code>n</code>为偶数，很好办，再乘以一个<code>halfRes</code>就可以了(再取模一下)，也就是可以返回<code>halfRes*halfRes</code>；</li>
<li>但是如果<code>n</code>为奇数的话，就需要再乘以一个<code>a</code>，然后再返回；</li>
</ul>
<p><img src="images/m14.png" alt="幂分解"><br><img src="images/m26.png" alt="在这里插入图片描述"></p>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">pow_mod</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> n, <span class="keyword">long</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)      <span class="comment">// a^0 = 1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 先求一半的 --&gt; 你先给我求出 a ^ (n/2) 的结果给我</span></span><br><span class="line">    <span class="keyword">long</span> halfRes = pow_mod(a, n &gt;&gt; <span class="number">1</span>, mod); <span class="comment">// n &gt;&gt; 1 --&gt; n/2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> res = halfRes * halfRes % mod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) != <span class="number">0</span>)       <span class="comment">// odd num</span></span><br><span class="line">        res = res * a % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="非递归计算-a-n-mod"><a href="#非递归计算-a-n-mod" class="headerlink" title="非递归计算  (a n) % mod"></a>非递归计算 <font color = red> (a <sup>n</sup>) % mod</h3><p><img src="https://img-blog.csdn.net/201809222010339?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br><img src="images/m13.png" alt="在这里插入图片描述"><img src="images/m18.png" alt="在这里插入图片描述"><br>假设一个整数是<code>10</code>，如何最快的求解<code>10</code>的<code>75</code>次方。</p>
<ul>
<li>① <code>75</code>的二进制形式为<code>1001011</code>；</li>
<li>②<code>10</code>的<code>75</code>次方  = **10<sup>64</sup> × 10<sup>8</sup> × 10<sup>2</sup> × 10<sup>1</sup>**；</li>
<li>在这个过程中，我们先求出<strong>10<sup>1</sup><strong>，然后根据</strong>10<sup>1</sup><strong>求出</strong>10<sup>2</sup><strong>，再根据</strong>10<sup>2</sup><strong>求出</strong>10<sup>4</sup><strong>。。。。，最后根据</strong>10<sup>32</sup><strong>求出</strong>10<sup>64</sup><strong>，</strong>即<code>75</code>的二进制数形式总共有多少位，我们就使用了多少次乘法；</strong></li>
<li>③ 在步骤②进行的过程中，把应该累乘的值相乘即可，比如**10<sup>64</sup><strong>、</strong>10<sup>8</sup><strong>、</strong>10<sup>2</sup><strong>、</strong>10<sup>1</sup><strong>应该累乘，因为<code>64、8、2、1</code>对应到<code>75</code>的二进制数中，相应位上是<code>1</code>；而</strong>10<sup>32</sup><strong>、</strong>10<sup>16</sup>**、10<sup>4</sup>不应该累乘，因为<code>32、16、 4</code>对应到<code>75</code>的二进制数中，相应位是<code>0</code>；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">pow_mod2</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> n, <span class="keyword">long</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) != <span class="number">0</span>) <span class="comment">// 二进制最低位 是 1 --&gt; (n&amp;1) != 0  --&gt;  乘上 x ^ (2^i)   (i从0开始)</span></span><br><span class="line">            res = res * a % mod;</span><br><span class="line">        a = a * a % mod;  <span class="comment">// a = a^2</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;          <span class="comment">// n -&gt; n/2      往右边移一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>a ^ 11</code>来模拟一下计算过程: </p>
<p><img src="images/m17.png" alt="在这里插入图片描述"></p>
<h3 id="计算-a-b-mod"><a href="#计算-a-b-mod" class="headerlink" title="计算 ( a * b ) % mod"></a>计算 <font color = red>( a * b ) % mod</h3><p><img src="images/m16.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算 (a * b) % mod</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">mul_mod</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> b, <span class="keyword">long</span> mod)</span></span>&#123;</span><br><span class="line">       <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(b &gt; <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>( (b&amp;<span class="number">1</span>) != <span class="number">0</span>)  <span class="comment">// 二进制最低位是1 --&gt; 加上 a的 2^i 倍, 快速幂是乘上a的2^i ）</span></span><br><span class="line">               res  = ( res + a) % mod;</span><br><span class="line">           a = (a &lt;&lt; <span class="number">1</span>) % mod;    <span class="comment">// a = a * 2    a随着b中二进制位数而扩大 每次 扩大两倍。</span></span><br><span class="line">           b &gt;&gt;= <span class="number">1</span>;               <span class="comment">// b -&gt; b/2     右移  去掉最后一位 因为当前最后一位我们用完了，</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="配合-a-b-mod和乘法快速幂"><a href="#配合-a-b-mod和乘法快速幂" class="headerlink" title="配合 ( a * b ) % mod和乘法快速幂"></a>配合<font color = red> ( a * b ) % mod</font>和乘法快速幂</h3><p>可以使用非递归的乘法快速幂和上面的<code> (a*b) % mod</code> 来计算快速幂，差别不大: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算 (a * b) % mod</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">mul_mod</span><span class="params">(<span class="keyword">long</span> a,<span class="keyword">long</span> b,<span class="keyword">long</span> mod)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>( (b&amp;<span class="number">1</span>) != <span class="number">0</span>)  <span class="comment">// 二进制最低位是1 --&gt; 加上 a的 2^i 倍, 快速幂是乘上a的2^i ）</span></span><br><span class="line">            res  = ( res + a) % mod;</span><br><span class="line">        a = (a &lt;&lt; <span class="number">1</span>) % mod;    <span class="comment">// a = a * 2    a随着b中二进制位数而扩大 每次 扩大两倍。</span></span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;               <span class="comment">// b -&gt; b/2     右移  去掉最后一位 因为当前最后一位我们用完了，</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归 计算 (a^n) % mod   配合 mul</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">pow_mod3</span><span class="params">(<span class="keyword">long</span> a,<span class="keyword">long</span> n,<span class="keyword">long</span> mod)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>( (n&amp;<span class="number">1</span>) != <span class="number">0</span> ) <span class="comment">// 二进制最低位 是 1 --&gt; (n&amp;1) != 0  --&gt;  乘上 x ^ (2^i)   (i从0开始)</span></span><br><span class="line">            res = mul_mod(res,a,mod) % mod;</span><br><span class="line">        a = mul_mod(a,a,mod) % mod;  <span class="comment">// a = a^2</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;          <span class="comment">// n -&gt; n/2      往右边移一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="XYNUOJ-1872-次方求模题解"><a href="#XYNUOJ-1872-次方求模题解" class="headerlink" title="XYNUOJ - 1872. 次方求模题解"></a>XYNUOJ - 1872. 次方求模题解</h3><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="http://xyoj.xynu.edu.cn/problem.php?id=1872">题目链接</a></h4><blockquote>
<p><a href="http://xyoj.xynu.edu.cn/problem.php?id=1872">http://xyoj.xynu.edu.cn/problem.php?id=1872</a></p>
</blockquote>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><img src="images/m12.png" alt="在这里插入图片描述"></p>
<p>完全的模板题，三种方法都可以通过: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目链接:  http://xyoj.xynu.edu.cn/problem.php?id=1872&amp;csrf=mmofuzhUWGip3c6WlmhiFY6bLxeVHZta</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;  <span class="comment">//提交时改成Main</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归 计算 (a^n) % mod</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">pow_mod</span><span class="params">(<span class="keyword">long</span> a,<span class="keyword">long</span> n,<span class="keyword">long</span> mod)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)      <span class="comment">// a^0 = 1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 先求一半的 --&gt; 你先给我求出 a ^ (n/2) 的结果给我</span></span><br><span class="line">        <span class="keyword">long</span> halfRes = pow_mod(a, n &gt;&gt; <span class="number">1</span>, mod); <span class="comment">// n &gt;&gt; 1 --&gt; n/2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> res = halfRes * halfRes % mod;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( (n&amp;<span class="number">1</span>) != <span class="number">0</span>)       <span class="comment">// odd num</span></span><br><span class="line">            res = res * a % mod;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非递归 计算 (a^n) % mod</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">pow_mod2</span><span class="params">(<span class="keyword">long</span> a,<span class="keyword">long</span> n,<span class="keyword">long</span> mod)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>( (n&amp;<span class="number">1</span>) != <span class="number">0</span> ) <span class="comment">// 二进制最低位 是 1 --&gt; (n&amp;1) != 0  --&gt;  乘上 x ^ (2^i)   (i从0开始)</span></span><br><span class="line">                res = res * a % mod;</span><br><span class="line">            a = a * a % mod;  <span class="comment">// a = a^2</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;          <span class="comment">// n -&gt; n/2      往右边移一位</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 (a * b) % mod</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">mul_mod</span><span class="params">(<span class="keyword">long</span> a,<span class="keyword">long</span> b,<span class="keyword">long</span> mod)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(b &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (b&amp;<span class="number">1</span>) != <span class="number">0</span>)  <span class="comment">// 二进制最低位是1 --&gt; 加上 a的 2^i 倍, 快速幂是乘上a的2^i ）</span></span><br><span class="line">                res  = ( res + a) % mod;</span><br><span class="line">            a = (a &lt;&lt; <span class="number">1</span>) % mod;    <span class="comment">// a = a * 2    a随着b中二进制位数而扩大 每次 扩大两倍。</span></span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;               <span class="comment">// b -&gt; b/2     右移  去掉最后一位 因为当前最后一位我们用完了，</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非递归 计算 (a^n) % mod   配合 mul</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">pow_mod3</span><span class="params">(<span class="keyword">long</span> a,<span class="keyword">long</span> n,<span class="keyword">long</span> mod)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>( (n&amp;<span class="number">1</span>) != <span class="number">0</span> ) <span class="comment">// 二进制最低位 是 1 --&gt; (n&amp;1) != 0  --&gt;  乘上 x ^ (2^i)   (i从0开始)</span></span><br><span class="line">                res = mul_mod(res,a,mod) % mod;</span><br><span class="line">            a = mul_mod(a,a,mod) % mod;  <span class="comment">// a = a^2</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;          <span class="comment">// n -&gt; n/2      往右边移一位</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line">        <span class="keyword">int</span> T = cin.nextInt();</span><br><span class="line">        <span class="keyword">while</span>(T-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> n = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> mod = cin.nextInt();</span><br><span class="line"><span class="comment">//            System.out.println(pow_mod(a,n,mod));</span></span><br><span class="line"><span class="comment">//            System.out.println(pow_mod2(a,n,mod));</span></span><br><span class="line">            System.out.println(pow_mod3(a,n,mod));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="LeetCode-50-Pow-x-n-题解"><a href="#LeetCode-50-Pow-x-n-题解" class="headerlink" title="LeetCode - 50. Pow(x, n)题解"></a>LeetCode - 50. Pow(x, n)题解</h3><h4 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a><a href="https://leetcode.com/problems/powx-n/description/">题目链接</a></h4><blockquote>
<p><a href="https://leetcode.com/problems/powx-n/description/">https://leetcode.com/problems/powx-n/description/</a></p>
</blockquote>
<h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p><img src="images/m15.png"></p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>这个题目和普通的求幂不同的是: </p>
<ul>
<li><strong>其中<code>x</code>(底数)是<code>double</code>类型的，且<code>n</code>是范围是<code>Integer</code>范围的(可正可负) :</strong> </li>
<li><strong>要注意的就是当<code>n</code>为负数的时候，我们可以转换成求<code> 1.0 / pow(x,-n)</code>；</strong></li>
<li><font color = red>还一个很重要的地方就是当<code>n = Integer.MIN_VALUE</code>的时候要特殊处理，因为整形范围是-2<sup>31</sup>到2<sup>31</sup>-1，所以或者我们使用<code>long</code>来存转换的数，或者特殊判断一下；</font><h5 id="递归求解"><a href="#递归求解" class="headerlink" title="递归求解:"></a>递归求解:</h5>两种写法意思一样，第二种写法更加简洁: <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> pow(x, n);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == Integer.MIN_VALUE) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1.0</span> / (pow(x, -(Integer.MIN_VALUE + <span class="number">1</span>)) * x); <span class="comment">// MAX_VALUE = -(Integer.MIN_VALUE + 1)</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span> / pow(x, -n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> half = pow(x, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> half * half;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> x * half * half;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == Integer.MIN_VALUE) &#123;</span><br><span class="line">                <span class="comment">// return 1.0 / (myPow(x,-(Integer.MIN_VALUE+1)) * x);</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1.0</span> / (myPow(x, Integer.MAX_VALUE) * x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span> / myPow(x, -n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> half = myPow(x, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> half * half;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> x * half * half;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="非递归求解"><a href="#非递归求解" class="headerlink" title="非递归求解:"></a>非递归求解:</h5><p><font color = red>三种写法的意思都是一样，只不过处理<code>Integer.MIN_VALUE</code>的方式不同而已。</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == Integer.MIN_VALUE) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1.0</span> / (myPow(x, Integer.MAX_VALUE) * x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1.0</span> / myPow(x, -n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">                res *= x;</span><br><span class="line">            x = x * x;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            n = -(<span class="number">1</span> + n);  <span class="comment">// for Integer.MIN_VALUE   </span></span><br><span class="line">            res *= x;  <span class="comment">// x is 1/x   because n is -(n+1) so should do this </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">                res *= x;</span><br><span class="line">            x = x * x;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> abs = Math.abs((<span class="keyword">long</span>) n); <span class="comment">// also for Integer.MIN_VALUE</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span> (abs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((abs &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">                res *= x;</span><br><span class="line">            x = x * x;</span><br><span class="line">            abs &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span> / res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找的总结(6种变形)</title>
    <url>/2021/12/15/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E6%80%BB%E7%BB%93(6%E7%A7%8D%E5%8F%98%E5%BD%A2)/</url>
    <content><![CDATA[<h2 id="二分查找的总结"><a href="#二分查找的总结" class="headerlink" title="二分查找的总结"></a>二分查找的总结</h2><ul>
<li><p><a href="#%E6%99%AE%E9%80%9A%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">普通的二分查找</a></p>
</li>
<li><p><a href="#%E6%99%AE%E9%80%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%86%99%E6%B3%95">普通二分查找的另一种写法</a></p>
</li>
<li><p><a href="#%E7%AC%AC%E4%B8%80%E4%B8%AAkey%E7%9A%84%E4%B8%8D%E5%AD%98%E5%9C%A8%E8%BF%94%E5%9B%9E-1">第一个<code>=key</code>的，不存在返回<code>-1</code></a></p>
</li>
<li><p><a href="#%E7%AC%AC%E4%B8%80%E4%B8%AAkey%E7%9A%84">第一个<code>&gt;=key</code>的</a></p>
</li>
<li><p><a href="#%E7%AC%AC%E4%B8%80%E4%B8%AAkey%E7%9A%84">第一个<code>&gt;key</code>的</a></p>
</li>
<li><p><a href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%9A%84%E6%80%BB%E7%BB%93">第一个<code>...</code>的总结</a></p>
</li>
<li><p><a href="#%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AAkey%E7%9A%84%E4%B8%8D%E5%AD%98%E5%9C%A8%E8%BF%94%E5%9B%9E-1">最后一个<code>=</code>key的，不存在返回<code>-1</code></a></p>
</li>
<li><p><a href="#%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AAkey%E7%9A%84">最后一个<code>&lt;=key</code>的</a> </p>
</li>
<li><p><a href="#%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AAkey%E7%9A%84">最后一个<code>&lt;key</code> 的</a></p>
</li>
<li><p><a href="#%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E7%9A%84%E6%80%BB%E7%BB%93">最后一个<code>...</code>的总结</a></p>
</li>
<li><p><a href="#%E5%AE%8C%E6%95%B4%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">完整测试代码</a></p>
</li>
</ul>
<hr>
<h3 id="普通的二分查找"><a href="#普通的二分查找" class="headerlink" title="普通的二分查找"></a>普通的二分查找</h3><p>最普通的写法: </p>
<ul>
<li>范围在<code>[L,R]</code>闭区间中，<code>L = 0</code>、<code>R = arr.length - 1</code>；</li>
<li>注意循环条件为 <code>L &lt;= R</code> ，而不是<code>L &lt; R</code>；</li>
</ul>
<p><img src="images/bs1.png" alt="这里写图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bs1</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>,R = arr.length - <span class="number">1</span>; <span class="comment">//在[L,R]范围内寻找key</span></span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>( L &lt;= R)&#123;</span><br><span class="line">        mid = L + (R - L) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] == key)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &gt; key)</span><br><span class="line">            R = mid - <span class="number">1</span>;<span class="comment">// key 在 [L,mid-1]内</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="普通二分查找的另一种写法"><a href="#普通二分查找的另一种写法" class="headerlink" title="普通二分查找的另一种写法"></a>普通二分查找的另一种写法</h3><p>首先说明，这个和上面的二分查找是完全一样的，只不过我们定义的区间不同而已: </p>
<ul>
<li><p>上面的二分查找是在<code>[L,R]</code>的闭区间中查找，而这个二分查找是在<code>[L,R</code><font color =red>)</font>的左闭右开区间查找；</p>
</li>
<li><p>所以<font color =red>此时的循环条件是<code>L &lt; R</code> ，因为<code>R</code>本来是一个不可到达的地方，我们定义为了开区间，所以<code>R</code>是一个不会考虑的数，所以我们循环条件是<code>L  &lt; R</code>；</p>
</li>
<li><p>同理，当<code>arr[mid] &gt; key</code>的时候，不是<code>R = mid -  1</code>，因为我们定义的是开区间，所以<code>R = mid</code> ，因为不会考虑<code>arr[mid]</code>这个数；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//和上面的完全一样，只是一开始R不是arr.length-1 而是arr.length</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bs2</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>, R = arr.length; <span class="comment">//注意这里R = arr.length 所以在[L,R)开区间中找</span></span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>( L &lt; R)&#123; <span class="comment">//注意这里 不是 L &lt;= R</span></span><br><span class="line">        mid = L + (R - L)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] == key)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &gt; key)</span><br><span class="line">            R = mid; <span class="comment">// 在[L,mid)中找</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color =red>上面的两种方式一般还是第一种方式用的多一点。</font></p>
<hr>
<h3 id="第一个-key的，不存在返回-1"><a href="#第一个-key的，不存在返回-1" class="headerlink" title="第一个=key的，不存在返回-1"></a>第一个<code>=key</code>的，不存在返回<code>-1</code></h3><p>这个和之前的不同是: </p>
<ul>
<li><p><strong>数组中可能有重复的<code>key</code>，我们要找的是第一个<code>key</code>的位置；</strong></p>
</li>
<li><p>和普通二分查找法不同的是在我们要<code>R = mid - 1</code>前的判断条件不是<code>arr[mid] &gt; key</code>，而是<code>arr[mid] &gt;= key</code>；</p>
</li>
<li><p>为什么是上面那样，<strong>其实直观上理解，我们要找的是第一个，那我们去左边找的时候不仅仅<code>arr[mid] &gt; key</code>就去左边找，等于我也要去找，因为我要最左边的等于的；</strong></p>
</li>
<li><p>最后我们要判断<code>L</code>是否越界(<code>L</code> 有可能等于<code>arr.length</code>)，而且最后<code>arr[L]</code>是否等于要找的<code>key</code>；</p>
</li>
<li><p>如果<code>arr[L]</code>不等于<code>key</code>，说明没有这个元素，返回<code>-1</code>；</p>
</li>
</ul>
<p><strong>举个例子:</strong> </p>
<p><img src="images/bs2.png" alt="这里写图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**查找第一个与key相等的元素的下标，　如果不存在返回-1　*/</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">firstEqual</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> L = <span class="number">0</span>, R = arr.length - <span class="number">1</span>; <span class="comment">//在[L,R]查找第一个&gt;=key的</span></span><br><span class="line">       <span class="keyword">int</span> mid;</span><br><span class="line">       <span class="keyword">while</span>( L &lt;= R)&#123;</span><br><span class="line">           mid = L + (R - L)/<span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span>(arr[mid] &gt;= key)</span><br><span class="line">               R = mid - <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               L = mid + <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(L &lt; arr.length &amp;&amp; arr[L] == key)</span><br><span class="line">           <span class="keyword">return</span> L;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="第一个-gt-key的"><a href="#第一个-gt-key的" class="headerlink" title="第一个&gt;=key的"></a>第一个<code>&gt;=key</code>的</h3><p>这个和上面那个寻找第一个等于<code>key</code>的唯一的区别就是: </p>
<ul>
<li><p>最后我们不需要判断(<code> L &lt; arr.length &amp;&amp; arr[L] == key</code>)，因为如果不存在<code>key</code>的话，我们返回第一个<code>&gt; key</code>的元素即可；</p>
</li>
<li><p><strong>注意这里没有判断越界(<code>L  &lt; arr.length </code>)，因为如果整个数组都比<code>key</code>要小，就会返回<code>arr.length</code>的大小；</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**查找第一个大于等于key的元素的下标*/</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">firstLargeEqual</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> L = <span class="number">0</span>, R = arr.length - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> mid;</span><br><span class="line">       <span class="keyword">while</span>( L &lt;= R)&#123;</span><br><span class="line">           mid = L + (R - L) / <span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span>(arr[mid] &gt;= key)</span><br><span class="line">               R = mid - <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               L = mid + <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> L;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="第一个-gt-key的-1"><a href="#第一个-gt-key的-1" class="headerlink" title="第一个&gt;key的"></a>第一个<code>&gt;key</code>的</h3><p>这个和上两个的不同在于: </p>
<ul>
<li><p><font color = red><code>if(arr[mid] &gt;= key) </code>改成了<code> if(arr[mid]  &gt; key)</code></font>，因为我们不是要寻找 <code>= key</code>的；</p>
</li>
<li><p><strong>看似和普通二分法很像，但是我们在循环中没有判断<code>if(arr[mid] == key)</code>就返回<code>mid</code>(因为要寻找的不是等于<code>key</code>的)，而是在最后返回了<code>L</code> ；</strong></p>
</li>
</ul>
<p>举个例子: </p>
<p><img src="images/bs3.png" alt="这里写图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**查找第一个大于key的元素的下标 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">firstLarge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>,R = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(L &lt;= R)&#123;</span><br><span class="line">        mid = L + (R - L) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &gt; key)</span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="第一个-的总结"><a href="#第一个-的总结" class="headerlink" title="第一个...的总结"></a><font color  =red>第一个<code>...</code>的总结</h3><p>上面写了三个第一个<code>.....</code>的程序，可以发现一些共同点 ，也可以总结一下它们微妙的区别: </p>
<ul>
<li><p><strong>最后返回的都是<code>L</code>；</strong></p>
</li>
<li><p>如果是寻找第一个等于<code>key</code>的，是<code>if( arr[mid]  &gt;= key) R = mid -  1</code>，且最后要判断<code>L </code>的合法以及是否存在<code>key</code>；</p>
</li>
<li><p>如果是寻找第一个大于等于<code>key</code>的，也是<code>if(arr[mid] &gt;= key) R = mid - 1</code>，但是最后直接返回<code>L</code>；</p>
</li>
<li><p>如果是寻找第一个大于<code>key</code>的，则判断条件是<code>if(arr[mid]  &gt; key) R = mid - 1</code>，最后返回<code>L</code> ；</p>
</li>
</ul>
<hr>
<h3 id="最后一个-key的，不存在返回-1"><a href="#最后一个-key的，不存在返回-1" class="headerlink" title="最后一个=key的，不存在返回-1"></a>最后一个<code>=</code>key的，不存在返回<code>-1</code></h3><p>和寻找第一个 <code>= key</code>的很类似，不过是方向的不同而已: </p>
<ul>
<li><p>数组中有可能有重复的<code>key</code>，我们要查找的是最后一个 <code>= key</code>的位置，不存在返回<code>-1</code>；</p>
</li>
<li><p>为了更加的直观的理解，和寻找第一个…的形成对比，这里是当<code>arr[mid] &lt;= key</code>的时候，我们要去右边查找(<code>L = mid + 1</code>)，<strong>同样是直观的理解，因为我们是要去找到最后一个 <code>=  key</code>的，所以不仅仅是<code>arr[mid]  &lt; key</code>要去左边寻找，等于<code>key</code>的时候也要去左边寻找；</strong></p>
</li>
<li><p><font color  = red>和第一个….不同的是，我们返回的都是<code>R</code>；</p>
</li>
<li><p>同时我们也要判断<code>R</code>的下标的合法性，以及最后的<code>arr[R]</code>是否等于<code>key</code>，如果不等于就返回<code>-1</code>；</p>
</li>
</ul>
<p>举个例子: </p>
<p><img src="images/bs4.png" alt="这里写图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**查找最后一个与key相等的元素的下标，　如果没有返回-1*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lastEqual</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>, R = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>( L &lt;= R)&#123;</span><br><span class="line">        mid = L + (R - L)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &lt;= key)</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(R &gt;= <span class="number">0</span> &amp;&amp; arr[R] == key)</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="最后一个-lt-key的"><a href="#最后一个-lt-key的" class="headerlink" title="最后一个&lt;=key的"></a>最后一个<code>&lt;=key</code>的</h3><p>这个和上面那个寻找最后一个等于<code>key</code>的唯一的区别就是: </p>
<ul>
<li><p>最后我们不需要判断 (<code>R &gt;= 0 &amp;&amp; arr[R] == key</code>)，<strong>因为如果不存在<code>key</code>的话，我们返回最后一个  <code>&lt; key</code>的元素即可；</strong></p>
</li>
<li><p><strong>注意这里没有判断越界(<code>R &gt;=  0 </code>)，因为如果整个数组都比<code>key</code>要大，数组最左边的更左边一个(也就是<code>-1</code>)；</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**查找最后一个小于等于key的元素的下标 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lastSmallEqual</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>, R = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>( L &lt;= R)&#123;</span><br><span class="line">        mid = L + (R - L) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &lt;= key)</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="最后一个-lt-key-的"><a href="#最后一个-lt-key-的" class="headerlink" title="最后一个&lt;key 的"></a>最后一个<code>&lt;key</code> 的</h3><p>这个和上面两个不同的是: </p>
<ul>
<li><p><font color = red>和上面的程序唯一不同的就是<code>arr[mid] &lt;= key</code>改成了 <code>arr[mid]  &lt; key</code>，因为我们要寻找的不是<code> = key</code>的；</font></p>
</li>
<li><p>注意这三个最后一个的都是先对<code>L</code>的操作<code>L = mid + 1</code>，然后在<code>else</code> 中进行对<code>R</code>的操作；</p>
</li>
</ul>
<p><img src="images/bs5.png" alt="这里写图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**查找最后一个小于key的元素的下标*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lastSmall</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>, R = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(L &lt;= R)&#123;</span><br><span class="line">        mid = L + (R - L) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &lt; key)</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="最后一个-的总结"><a href="#最后一个-的总结" class="headerlink" title="最后一个...的总结"></a><font color  =red>最后一个<code>...</code>的总结</h3><p>上面三个都是求最后一个<code>.....</code>的，也进行一下总结: </p>
<ul>
<li><p><strong>最后返回的都是<code>R</code>；</strong></p>
</li>
<li><p><strong>第一个<code>if</code>判断条件(不管是<code>arr[mid] &lt;= key</code>还是<code>arr[mid] &lt; key</code>) ，都是<code>L</code>的操作，也就是去右边寻找；</strong></p>
</li>
<li><p>如果是寻找最后一个 等于<code> key</code>的， <code> if(arr[mid] &lt;= key) L = mid + 1;</code> 不过最后要判断<code>R</code>的合法性以及是否存在<code>key</code>；</p>
</li>
<li><p>如果是寻找最后一个 小于等于 <code>key</code>的，也是<code>if(arr[mid] &lt;= key) L = mid + 1</code>；不过最后直接返回<code>R</code>；</p>
</li>
<li><p>如果是寻找最后一个 小于 <code>key</code>的，则判断条件是  <code> if(arr[mid] &lt; key) L = mid + 1</code> ，最后返回<code>R</code>；</p>
</li>
</ul>
<hr>
<h3 id="完整测试代码"><a href="#完整测试代码" class="headerlink" title="完整测试代码"></a>完整测试代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最普通的二分搜索法</span></span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bs1</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>,R = arr.length - <span class="number">1</span>; <span class="comment">//在[L,R]范围内寻找key</span></span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>( L &lt;= R)&#123;</span><br><span class="line">            mid = L + (R - L) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid] == key)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &gt; key)</span><br><span class="line">                R = mid - <span class="number">1</span>;<span class="comment">// key 在 [L,mid-1]内</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//和上面的完全一样，只是一开始R不是arr.length-1 而是arr.length</span></span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bs2</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>, R = arr.length; <span class="comment">//注意这里R = arr.length 所以在[L,R)开区间中找</span></span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>( L &lt; R)&#123; <span class="comment">//注意这里 不是 L &lt;= R</span></span><br><span class="line">            mid = L + (R - L)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid] == key)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &gt; key)</span><br><span class="line">                R = mid; <span class="comment">// 在[L,mid)中找</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**查找第一个与key相等的元素的下标，　如果不存在返回-1　*/</span></span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">firstEqual</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>, R = arr.length - <span class="number">1</span>; <span class="comment">//在[L,R]查找第一个&gt;=key的</span></span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>( L &lt;= R)&#123;</span><br><span class="line">            mid = L + (R - L)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &gt;= key)</span><br><span class="line">                R = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(L &lt; arr.length &amp;&amp; arr[L] == key)</span><br><span class="line">            <span class="keyword">return</span> L;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**查找第一个大于等于key的元素的下标*/</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">firstLargeEqual</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>, R = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>( L &lt;= R)&#123;</span><br><span class="line">            mid = L + (R - L) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &gt;= key)</span><br><span class="line">                R = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**查找第一个大于key的元素的下标 */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">firstLarge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>,R = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(L &lt;= R)&#123;</span><br><span class="line">            mid = L + (R - L) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &gt; key)</span><br><span class="line">                R = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**查找最后一个与key相等的元素的下标，　如果没有返回-1*/</span></span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lastEqual</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>, R = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>( L &lt;= R)&#123;</span><br><span class="line">            mid = L + (R - L)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &lt;= key)</span><br><span class="line">                L = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(R &gt;= <span class="number">0</span> &amp;&amp; arr[R] == key)</span><br><span class="line">            <span class="keyword">return</span> R;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**查找最后一个小于等于key的元素的下标 */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lastSmallEqual</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>, R = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>( L &lt;= R)&#123;</span><br><span class="line">            mid = L + (R - L) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &lt;= key)</span><br><span class="line">                L = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**查找最后一个小于key的元素的下标*/</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lastSmall</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>, R = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(L &lt;= R)&#123;</span><br><span class="line">            mid = L + (R - L) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &lt; key)</span><br><span class="line">                L = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------general-----------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(bs1(arr,<span class="number">3</span>));<span class="comment">//1</span></span><br><span class="line">        System.out.println(bs2(arr,<span class="number">3</span>));<span class="comment">//1</span></span><br><span class="line">        System.out.println(bs2(arr,<span class="number">6</span>));<span class="comment">//5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------first------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个 =  的</span></span><br><span class="line">        System.out.println(firstEqual(arr,<span class="number">6</span>));<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个　&gt;= 的</span></span><br><span class="line">        System.out.println(firstLargeEqual(arr,<span class="number">5</span>));<span class="comment">//3</span></span><br><span class="line">        System.out.println(firstLargeEqual(arr,<span class="number">6</span>));<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个 &gt; 的</span></span><br><span class="line">        System.out.println(firstLarge(arr,<span class="number">6</span>));<span class="comment">//9</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------last------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后一个 =  的</span></span><br><span class="line">        System.out.println(lastEqual(arr,<span class="number">6</span>));<span class="comment">//8</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后一个 &lt;= 的</span></span><br><span class="line">        System.out.println(lastSmallEqual(arr,<span class="number">7</span>));<span class="comment">//8</span></span><br><span class="line">        System.out.println(lastSmallEqual(arr,<span class="number">6</span>));<span class="comment">//8</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后一个 &lt; 的</span></span><br><span class="line">        System.out.println(lastSmall(arr,<span class="number">6</span>));<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>效果:<br><img src="images/bs6.png" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>BinarySearch</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路dijkstra模板</title>
    <url>/2022/03/09/%E6%9C%80%E7%9F%AD%E8%B7%AFdijkstra%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>﻿## 最短路dijkstra模板</p>
<ul>
<li><code>dijkstra</code>算法总结</li>
<li>常用模板解决</li>
<li>其他写法</li>
</ul>
<hr>
<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1874">题目链接</a></h4><blockquote>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1874">http://acm.hdu.edu.cn/showproblem.php?pid=1874</a></p>
</blockquote>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><img src="images/path1.png"></p>
<h3 id="dijkstra算法总结"><a href="#dijkstra算法总结" class="headerlink" title="dijkstra算法总结"></a><code>dijkstra</code>算法总结</h3><p>总结一下<code>dijkstra</code>算法大致的流程: </p>
<ul>
<li>一开始有一个<code>dist[]</code>数组(也可以是<code>map</code>)来保存从<code>start</code>(起点)到每个点的最短路径(一开始的话，如果<code>start</code>和某个点没有边，就为<code>INF</code>(或者为<code>null</code>)，如果有连线的话就是边的权值)；</li>
<li>然后每次从<code>dist</code>数组中取出一个<code>dist[i]</code>最小的<code>i</code>(不能取已经用过的顶点(<code>vis</code>数组标记))，也就是<strong>start距离某个结点</strong>最近的一个；</li>
<li>取出这个结点之后，用这个结点更新和<strong>它相连的边的<code>dist</code>数组</strong>；</li>
<li>直到把所有的<code>dist</code>数组都更新一遍；</li>
</ul>
<p><img src="images/path2.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>注意: <font color = red><code>dijkstra</code>为什么不能有负权边? 因为如果有的话，我们找最小的那个结构的时候，没准它还能通过松弛变得更短，例如上面我们一开始选出<code>0~2</code>这条边的时候，试想如果<code>2~1</code>的那条边权值为<code>-4</code>，那一开始我们找的<code>0~2</code>这条边就是错的，所以不能有负权边。</font></p>
</blockquote>
<hr>
<h3 id="常用模板解决"><a href="#常用模板解决" class="headerlink" title="常用模板解决"></a>常用模板解决</h3><p><strong>推荐的写法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span>[] vis;</span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;Edge&gt; G[];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Edge</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> to;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> w;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.to = to;</span><br><span class="line">            <span class="keyword">this</span>.w = w;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Edge o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> w - o.w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] dijkstra(<span class="keyword">int</span> start) &#123;</span><br><span class="line">        PriorityQueue&lt;Edge&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] dis = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) dis[i] = Integer.MAX_VALUE; <span class="comment">//初始标记（不是-1(因为是求最小的)）</span></span><br><span class="line">        dis[start] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//        G.vis[start] = true;  //第一个访问 start, 不能将start标记为true</span></span><br><span class="line">        pq.add(<span class="keyword">new</span> Edge(start, <span class="number">0</span>)); <span class="comment">//将第一条边加入 pq, 自环边</span></span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            Edge curEdge = pq.poll();</span><br><span class="line">            <span class="keyword">int</span> to = curEdge.to;</span><br><span class="line">            <span class="keyword">if</span> (vis[to])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            vis[to] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[to].size(); i++) &#123; <span class="comment">//更新相邻的边</span></span><br><span class="line">                <span class="keyword">int</span> nxtNode = G[to].get(i).to;</span><br><span class="line">                <span class="keyword">int</span> nxtW = G[to].get(i).w;</span><br><span class="line">                <span class="keyword">if</span> (!vis[nxtNode] &amp;&amp; dis[nxtNode] &gt; dis[to] + nxtW) &#123;</span><br><span class="line">                    dis[nxtNode] = dis[to] + nxtW;</span><br><span class="line">                    pq.add(<span class="keyword">new</span> Edge(nxtNode, dis[nxtNode])); <span class="comment">//将这个新的dis[nxtNode]加入优先队列，没准它是下一个(很小)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line">        <span class="keyword">while</span> (cin.hasNext()) &#123;</span><br><span class="line">            n = cin.nextInt();</span><br><span class="line">            m = cin.nextInt();</span><br><span class="line">            G = <span class="keyword">new</span> ArrayList[n]; <span class="comment">// 0~n-1</span></span><br><span class="line">            vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                G[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                vis[i] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> from = cin.nextInt();</span><br><span class="line">                <span class="keyword">int</span> to = cin.nextInt();</span><br><span class="line">                <span class="keyword">int</span> w = cin.nextInt();</span><br><span class="line">                G[from].add(<span class="keyword">new</span> Edge(to, w));</span><br><span class="line">                G[to].add(<span class="keyword">new</span> Edge(from, w));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> s = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> e = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span>[] dis = dijkstra(s);</span><br><span class="line">            System.out.println(dis[e] == Integer.MAX_VALUE ? -<span class="number">1</span> : dis[e]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他写法"><a href="#其他写法" class="headerlink" title="其他写法"></a>其他写法</h3><p>没有使用堆优化，也就是说找出当前最小的<code>dist</code>所在的结构的时候，遍历了一遍当前的<code>dist</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> ArrayList&lt;Edge&gt;edges;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            edges = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> weight;</span><br><span class="line">        <span class="keyword">public</span> Node from;</span><br><span class="line">        <span class="keyword">public</span> Node to;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">( Node from, Node to,<span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.from = from;</span><br><span class="line">            <span class="keyword">this</span>.to = to;</span><br><span class="line">            <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> HashMap&lt;Integer,Node&gt;nodes;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            nodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有使用堆优化的 O(n^2)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Node,Integer&gt; <span class="title">dijkstra</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        HashMap&lt;Node,Integer&gt;dist = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        dist.put(head,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(Edge edge : head.edges)&#123;</span><br><span class="line">            dist.put(edge.to,edge.weight);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashSet&lt;Node&gt;set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Node minNode = getMinAndUnSelect(dist,set); minNode != <span class="keyword">null</span> ; minNode = getMinAndUnSelect(dist,set))&#123;</span><br><span class="line">            <span class="keyword">int</span> distance = dist.get(minNode);</span><br><span class="line">            <span class="keyword">for</span>(Edge edge : minNode.edges)&#123;</span><br><span class="line">                Node toNode = edge.to;</span><br><span class="line">                <span class="keyword">if</span>(set.contains(toNode))<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(!dist.containsKey(toNode))&#123;</span><br><span class="line">                    dist.put(toNode,distance + edge.weight);</span><br><span class="line">                &#125;</span><br><span class="line">                dist.put(toNode,Math.min(dist.get(toNode),distance + edge.weight));</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(minNode); <span class="comment">//使用过这个之后就标记</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找出dist中最小且没有选择的结点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">getMinAndUnSelect</span><span class="params">(HashMap&lt;Node, Integer&gt; dist, HashSet&lt;Node&gt; set)</span> </span>&#123;</span><br><span class="line">        Node minNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> minDistance = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(Entry&lt;Node,Integer&gt; entry : dist.entrySet())&#123; <span class="comment">// map遍历方式 https://www.cnblogs.com/fqfanqi/p/6187085.html</span></span><br><span class="line">            Node node = entry.getKey();</span><br><span class="line">            <span class="keyword">int</span> distance = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(node) &amp;&amp; distance &lt; minDistance)&#123;</span><br><span class="line">                minDistance = distance;</span><br><span class="line">                minNode = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line">        <span class="keyword">while</span>(cin.hasNext())&#123;</span><br><span class="line">            <span class="keyword">int</span> n = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> m = cin.nextInt();</span><br><span class="line">            Graph G = <span class="keyword">new</span> Graph();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)G.nodes.put(i,<span class="keyword">new</span> Node(i));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> a = cin.nextInt();</span><br><span class="line">                <span class="keyword">int</span> b = cin.nextInt();</span><br><span class="line">                <span class="keyword">int</span> w = cin.nextInt();</span><br><span class="line">                Node from = G.nodes.get(a);</span><br><span class="line">                Node to = G.nodes.get(b);</span><br><span class="line">                from.edges.add(<span class="keyword">new</span> Edge(from,to,w));</span><br><span class="line">                to.edges.add(<span class="keyword">new</span> Edge(to,from,w));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> start = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> end = cin.nextInt();</span><br><span class="line">            HashMap&lt;Node, Integer&gt; dist = dijkstra(G.nodes.get(start));<span class="comment">//从start开始</span></span><br><span class="line">            Integer res = dist.get(G.nodes.get(end));</span><br><span class="line">            System.out.println((res == <span class="keyword">null</span>) ? -<span class="number">1</span> : res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>堆优化，其他写法(建图稍有不同): </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> ArrayList&lt;Edge&gt;edges;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            edges = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> weight;</span><br><span class="line">        <span class="keyword">public</span> Node from;</span><br><span class="line">        <span class="keyword">public</span> Node to;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">( Node from, Node to,<span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.from = from;</span><br><span class="line">            <span class="keyword">this</span>.to = to;</span><br><span class="line">            <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> HashMap&lt;Integer,Node&gt;nodes;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            nodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeRecord</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Node node;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> distance;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">NodeRecord</span><span class="params">(Node node, <span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.node = node;</span><br><span class="line">            <span class="keyword">this</span>.distance = distance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">NodeRecord</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(NodeRecord o1, NodeRecord o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1.distance - o2.distance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> HashMap&lt;Node, Integer&gt; <span class="title">dijkstra</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        HashMap&lt;Node,Integer&gt;dist = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        dist.put(head,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(Edge edge : head.edges)&#123;<span class="comment">//这个不能少</span></span><br><span class="line">            dist.put(edge.to,edge.weight);</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;NodeRecord&gt;priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> EdgeComparator());</span><br><span class="line">        priorityQueue.add(<span class="keyword">new</span> NodeRecord(head,<span class="number">0</span>));</span><br><span class="line">        HashSet&lt;Node&gt;set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!priorityQueue.isEmpty())&#123;</span><br><span class="line">            NodeRecord poll = priorityQueue.poll();</span><br><span class="line">            Node cur = poll.node;</span><br><span class="line">            <span class="keyword">int</span> distance = poll.distance;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(cur))<span class="keyword">continue</span>;</span><br><span class="line">            set.add(cur);</span><br><span class="line">            <span class="keyword">for</span>(Edge edge : cur.edges)&#123;</span><br><span class="line">                <span class="keyword">int</span> w = edge.weight;</span><br><span class="line">                Node toNode = edge.to;</span><br><span class="line">                <span class="keyword">if</span>(set.contains(toNode))<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(!dist.containsKey(toNode))dist.put(toNode,distance + w);</span><br><span class="line">                dist.put(toNode,Math.min(dist.get(toNode),distance + w));</span><br><span class="line">                priorityQueue.add(<span class="keyword">new</span> NodeRecord(toNode,dist.get(toNode)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line">        <span class="keyword">while</span>(cin.hasNext())&#123;</span><br><span class="line">            <span class="keyword">int</span> n = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> m = cin.nextInt();</span><br><span class="line">            Graph G = <span class="keyword">new</span> Graph();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)G.nodes.put(i,<span class="keyword">new</span> Node(i));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> a = cin.nextInt();</span><br><span class="line">                <span class="keyword">int</span> b = cin.nextInt();</span><br><span class="line">                <span class="keyword">int</span> w = cin.nextInt();</span><br><span class="line">                Node from = G.nodes.get(a);</span><br><span class="line">                Node to = G.nodes.get(b);</span><br><span class="line">                from.edges.add(<span class="keyword">new</span> Edge(from,to,w));</span><br><span class="line">                to.edges.add(<span class="keyword">new</span> Edge(to,from,w)); <span class="comment">//注意无向图</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> start = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> end = cin.nextInt();</span><br><span class="line">            HashMap&lt;Node, Integer&gt; dist = dijkstra(G.nodes.get(start));<span class="comment">//从start开始</span></span><br><span class="line">            Integer res = dist.get(G.nodes.get(end));</span><br><span class="line">            System.out.println((res == <span class="keyword">null</span>) ? -<span class="number">1</span> : res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>手写堆解决写法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> ArrayList&lt;Edge&gt; edges;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            edges = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> weight;</span><br><span class="line">        <span class="keyword">public</span> Node from;</span><br><span class="line">        <span class="keyword">public</span> Node to;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">( Node from, Node to,<span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.from = from;</span><br><span class="line">            <span class="keyword">this</span>.to = to;</span><br><span class="line">            <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> HashMap&lt;Integer,Node&gt; nodes;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            nodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeRecord</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Node node;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> distance;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">NodeRecord</span><span class="params">(Node node, <span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.node = node;</span><br><span class="line">            <span class="keyword">this</span>.distance = distance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeHeap</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node[] nodes;</span><br><span class="line">        <span class="keyword">private</span> HashMap&lt;Node, Integer&gt; indexMap;<span class="comment">//堆的下标</span></span><br><span class="line">        <span class="keyword">private</span> HashMap&lt;Node, Integer&gt; distMap; <span class="comment">//堆里面Node对应的distance</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">NodeHeap</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">            nodes = <span class="keyword">new</span> Node[size];</span><br><span class="line">            indexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            distMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;<span class="comment">//堆是否为空</span></span><br><span class="line">            <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOrUpdateOrIgnore</span><span class="params">(Node node, <span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//如果在堆中已经有了这个结点，就要更新   -1表示的是被访问过了</span></span><br><span class="line">            <span class="keyword">if</span> (indexMap.containsKey(node) &amp;&amp; indexMap.get(node) != -<span class="number">1</span>) &#123; <span class="comment">//update contain and index != -1</span></span><br><span class="line">                distMap.put(node, Math.min(distMap.get(node), distance));</span><br><span class="line">                insertHeapify(node, indexMap.get(node));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果 堆中没有这个结点 就创建一个</span></span><br><span class="line">            <span class="keyword">if</span> (!indexMap.containsKey(node)) &#123;<span class="comment">//if isEntered --&gt; ignore</span></span><br><span class="line">                nodes[size] = node;</span><br><span class="line">                indexMap.put(node, size);</span><br><span class="line">                distMap.put(node, distance);</span><br><span class="line">                insertHeapify(node, size++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从堆中取一个</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> NodeRecord <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            NodeRecord top = <span class="keyword">new</span> NodeRecord(nodes[<span class="number">0</span>], distMap.get(nodes[<span class="number">0</span>]));<span class="comment">//取出堆顶</span></span><br><span class="line">            swap(<span class="number">0</span>, size - <span class="number">1</span>); <span class="comment">//和最后一个交换</span></span><br><span class="line">            indexMap.put(nodes[size - <span class="number">1</span>], -<span class="number">1</span>); <span class="comment">//标记已经用过，相当于　Hashset作用</span></span><br><span class="line">            distMap.remove(nodes[size - <span class="number">1</span>]);  <span class="comment">//距离数组中李处</span></span><br><span class="line">            nodes[size - <span class="number">1</span>] = <span class="keyword">null</span>;  <span class="comment">//结点数组中设置为null</span></span><br><span class="line">            heapify(<span class="number">0</span>, --size);</span><br><span class="line">            <span class="keyword">return</span> top;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertHeapify</span><span class="params">(Node node, <span class="keyword">int</span> index)</span> </span>&#123; <span class="comment">//插入并调整</span></span><br><span class="line">            <span class="keyword">while</span> (distMap.get(nodes[index]) &lt; distMap.get(nodes[(index - <span class="number">1</span>) / <span class="number">2</span>])) &#123;</span><br><span class="line">                swap(index, (index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">                index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; size) &#123;</span><br><span class="line">                <span class="keyword">int</span> minIndex = left + <span class="number">1</span> &lt; size &amp;&amp; distMap.get(nodes[left + <span class="number">1</span>]) &lt; distMap.get(nodes[left])</span><br><span class="line">                        ? left + <span class="number">1</span> : left;</span><br><span class="line">                minIndex = distMap.get(nodes[minIndex]) &lt; distMap.get(nodes[index]) ? minIndex : index;</span><br><span class="line">                <span class="keyword">if</span> (minIndex == index) <span class="keyword">break</span>;</span><br><span class="line">                swap(minIndex, index);</span><br><span class="line">                index = minIndex;</span><br><span class="line">                left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">            indexMap.put(nodes[a], b);<span class="comment">//交换各自的下标</span></span><br><span class="line">            indexMap.put(nodes[b], a);</span><br><span class="line">            Node tmp = nodes[a];</span><br><span class="line">            nodes[a] = nodes[b];</span><br><span class="line">            nodes[b] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> HashMap&lt;Node,Integer&gt; <span class="title">dijkstra</span><span class="params">(Graph G,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        NodeHeap heap = <span class="keyword">new</span> NodeHeap(G.nodes.size());</span><br><span class="line">        heap.addOrUpdateOrIgnore(G.nodes.get(start),<span class="number">0</span>);</span><br><span class="line">        HashMap&lt;Node,Integer&gt;dist = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!heap.isEmpty())&#123;</span><br><span class="line">            NodeRecord poll = heap.poll();</span><br><span class="line">            Node cur = poll.node;</span><br><span class="line">            <span class="keyword">int</span> distance = poll.distance;</span><br><span class="line">            <span class="keyword">for</span>(Edge edge : cur.edges)&#123;</span><br><span class="line">                heap.addOrUpdateOrIgnore(edge.to, distance + edge.weight);</span><br><span class="line">            &#125;</span><br><span class="line">            dist.put(cur,distance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Graph <span class="title">createGraph</span><span class="params">(Scanner cin,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        Graph G = <span class="keyword">new</span> Graph();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)G.nodes.put(i,<span class="keyword">new</span> Node(i));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> b = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> w = cin.nextInt();</span><br><span class="line">            Node from = G.nodes.get(a);</span><br><span class="line">            Node to = G.nodes.get(b);</span><br><span class="line">            from.edges.add(<span class="keyword">new</span> Edge(from,to,w));</span><br><span class="line">            to.edges.add(<span class="keyword">new</span> Edge(to,from,w));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> G;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line">        <span class="keyword">while</span>(cin.hasNext())&#123;</span><br><span class="line">            <span class="keyword">int</span> n = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> m = cin.nextInt();</span><br><span class="line">            Graph G = createGraph(cin,n,m);</span><br><span class="line">            <span class="keyword">int</span> start = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> end = cin.nextInt();</span><br><span class="line">            HashMap&lt;Node, Integer&gt; dist = dijkstra(G,start);<span class="comment">//从start开始</span></span><br><span class="line">            Integer res = dist.get(G.nodes.get(end));</span><br><span class="line">            System.out.println((res == <span class="keyword">null</span>) ? -<span class="number">1</span> : res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Graph</tag>
        <tag>dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title>各种排序算法总结(全面)</title>
    <url>/2021/12/29/%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93(%E5%85%A8%E9%9D%A2)/</url>
    <content><![CDATA[<h1 id="各种排序算法总结-全面"><a href="#各种排序算法总结-全面" class="headerlink" title="各种排序算法总结(全面)"></a>各种排序算法总结(全面)</h1><ul>
<li><a href="#%E6%A6%82%E6%8B%AC">概括</a></li>
<li><a href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序</a></li>
<li><a href="#%E6%94%B9%E8%BF%9B%E7%9A%84%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-%E9%B8%A1%E5%B0%BE%E9%85%92%E6%8E%92%E5%BA%8F">改进的冒泡排序-鸡尾酒排序</a></li>
<li><a href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">选择排序</a></li>
<li><a href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">插入排序</a></li>
<li><a href="#%E4%BA%8C%E5%88%86%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">二分插入排序</a></li>
<li><a href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序</a></li>
<li><a href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a></li>
<li><a href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">归并排序</a></li>
<li><a href="#%E5%A0%86%E6%8E%92%E5%BA%8F">堆排序</a></li>
<li><a href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F">计数排序</a></li>
<li><a href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F">基数排序</a></li>
<li><a href="#%E6%A1%B6%E6%8E%92%E5%BA%8F">桶排序</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">测试代码</a></li>
<li><a href="#%E9%99%84c%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81">附C++部分代码</a></li>
</ul>
<hr>
<h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><p>排序算法大体可分为两种：</p>
<ul>
<li>一种是比较排序，时间复杂度<code>O(nlogn) ~ O(n^2)</code>，主要有：冒泡排序，选择排序，插入排序，归并排序，堆排序，快速排序等。</li>
<li>另一种是非比较排序，时间复杂度可以达到<code>O(n)</code>，主要有：计数排序，基数排序，桶排序等。</li>
</ul>
<p>下面给出常见比较算法的排序性能</p>
<table>
<thead>
<tr>
<th>排序方法</th>
<th>平均情况</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>简单选择排序</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>直接插入排序</td>
<td>O(n<sup>2</sup>)</td>
<td>O(n)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(nlogn) ~ O(n<sup>2</sup>)</td>
<td>O(n<sup>1.3</sup>)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(n)</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(logn)~O(n)</td>
<td>不稳定</td>
</tr>
</tbody></table>
<ul>
<li><strong>另外在说一下关于排序算法的<font color = crimson>稳定性问题 :</font>　排序算法稳定性的简单形式化定义为：如果<code>arr[i] = arr[j]</code>，排序前<code>arr[i]</code>在<code>arr[j]</code>之前，排序后<code>arr[i]</code>还在<code>arr[j]</code>之前，则称这种排序算法是稳定的。通俗地讲就是保证排序前后两个相等的数的相对顺序不变。</strong>（<font color = blue>可以通过自定义比较函数来去除稳定性问题</font>）</li>
</ul>
<p>举例：对于冒泡排序，原本是稳定的排序算法，如果将记录交换的条件改成<code>arr[i] &gt;= arr[i + 1]</code>，则两个相等的记录就会交换位置，从而变成不稳定的排序算法。 </p>
<p><strong>为了使下面的代码方便，这里贴出Swap函数，交换数组中某两个位置的值</strong>；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j]; </span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者这样:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    arr[i] = arr[i] ^ arr[j];</span><br><span class="line">    arr[j] = arr[i] ^ arr[j];</span><br><span class="line">    arr[i] = arr[i] ^ arr[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><font color = red id = "1">冒泡排序</h2><p>冒泡排序是比较简单的排序算法，它的运作过程如下：</p>
<ul>
<li>进行<code>n-1</code>次排序。</li>
<li>每次排序从<code>0~n-1-i</code>(<code>i</code>是次数编号)，检查这个序列中的数，两两相邻的数，如果前面的大于后面的就将它们交换，这样使得大的数往后面走，每次冒泡就会将一个大的数往后面冒，从而达到目的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**冒泡排序(加入了判断是否已经排序了的boolean变量) */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> end = arr.length-<span class="number">1</span>; end &gt; <span class="number">0</span>; end--)&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isSort = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; end; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[i+<span class="number">1</span>])&#123;</span><br><span class="line">                swap(arr,i,i+<span class="number">1</span>);</span><br><span class="line">                isSort = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isSort)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以还可以做一个优化 :</p>
<ul>
<li>记录上一次最后交换的那个位置<code>border</code>；</li>
<li>下一轮交换只需要进行到这个位置即可；<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> end = arr.length-<span class="number">1</span>; end &gt; <span class="number">0</span>; end--)&#123;</span><br><span class="line">        <span class="keyword">int</span> border = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; end; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[i+<span class="number">1</span>])&#123;</span><br><span class="line">                swap(arr, i, i+<span class="number">1</span>);</span><br><span class="line">                border = i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        end = border;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="鸡尾酒排序-改进的冒泡排序"><a href="#鸡尾酒排序-改进的冒泡排序" class="headerlink" title="鸡尾酒排序-改进的冒泡排序"></a><font color = red id = "2">鸡尾酒排序-改进的冒泡排序</h2><p>也叫做<font color = crimson>定向</font>冒泡排序:</p>
<ul>
<li>它的改进在于同时的冒泡两边，<font color = crimson>从低到高，然后从高到低；</li>
<li>相当于顺便把最小的数也冒泡到最前面</font>这个方法比冒泡更加高效一点；</li>
</ul>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**改进的冒泡排序(鸡尾酒排序)  就是把最大的数往后面冒泡的同时，　最小的数也往前面冒泡*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cocktailSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>,R = arr.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(L &lt; R) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = L; i &lt; R; i++) <span class="keyword">if</span>(arr[i] &gt; arr[i+<span class="number">1</span>]) swap(arr,i,i+<span class="number">1</span>);</span><br><span class="line">        R--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = R; i &gt; L; i--) <span class="keyword">if</span>(arr[i] &lt; arr[i-<span class="number">1</span>]) swap(arr,i,i-<span class="number">1</span>);</span><br><span class="line">        L++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a><font color = red id = "3">选择排序</h2><p>选择排序的思想是：</p>
<ul>
<li>在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列；</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，放到<font color = crimson><strong>已排序序列的末尾</strong></font>。</li>
</ul>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;<span class="comment">/**记录后面的最小值的下标*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) <span class="comment">//注意从i+1开始</span></span><br><span class="line">            minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;</span><br><span class="line">        swap(arr,i,minIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a><font color = red id = "4">插入排序</h2><p>插入排序的思想有点类似抓扑克牌 ， 过程如下:</p>
<ul>
<li><p>从第一个元素开始，该元素可以看作已经排好序；</p>
</li>
<li><p>取出下一个元素，从这个元素从后往前开始扫描，如果该元素大于新元素，将该元素移到下一位置；</p>
</li>
<li><p>重复上述步骤，直到找到已排序的元素小于或者等于新元素的位置，将新元素插入到该位置后；</p>
</li>
<li><p><strong>注意插入排序和数据状况有关系，涉及到最好情况，最差情况和平均情况。</strong></p>
</li>
<li><p>插入排序在工程上，当数组元素个数少的时候用的多，因为如果数组比较有序的话，会很快；</p>
</li>
</ul>
<p><img src="images/1_%E6%8F%92%E5%85%A5.png" alt="这里写图片描述"></p>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> key = arr[i], j;</span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; key &lt; arr[j]; j--) arr[j + <span class="number">1</span>] = arr[j]; <span class="comment">//中间的元素往后面移动</span></span><br><span class="line">        arr[j + <span class="number">1</span>] = key;   <span class="comment">//将key插入到合适的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更加简单的做法，配上swap函数:(有点类似冒泡了):<font color = red>这里要注意第二层循环的下标j &gt; 0。</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j-<span class="number">1</span>]; j--)swap(arr,j,j-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="二分插入排序"><a href="#二分插入排序" class="headerlink" title="二分插入排序"></a><font color = red id = "5">二分插入排序</h2><p>二分插入排序是对插入排序的一个小小的改进：</p>
<ul>
<li>改进的地方在于<font color = crimson>在前面已经排好序的序列中找当前要插入的元素的时候采用二分查找的方式去找那个插入的位置(大于key的那个位置) ，关于二分查找可以看<a href="https://blog.csdn.net/zxzxzx0119/article/details/82670761#t4">这篇博客</a></font>；</li>
<li>找到那个位置之后，再进行元素的移动，已及把那个元素插入到找到的那个位置；</li>
</ul>
<p><img src="images/2_.png" alt="这里写图片描述"></p>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二分插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort3</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> key = arr[i];</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>, R = i-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(L &lt;= R) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = L + (R-L)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &gt; key)R = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//二分结束之后　L = 刚好大于key(不是等于)的那个位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i-<span class="number">1</span>; j &gt;= L; j--)arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">        arr[L] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a><font color = red id = "6">希尔排序</h2><p>希尔排序使更高效的插入排序，它的思想在于，</p>
<ul>
<li>把数组分成几块，每一块进行一个插入排序；</li>
<li>而分块的依据在于<font color = crimson >增量的选择</font>分好块之后，<font color = crimson >从gap开始到n，每一组和它前面的元素（自己组内的）进行插入排序</font>；</li>
</ul>
<p><strong>每次和组内的元素比较完之后，最后的元素基本就是有序的了，希尔排序相对于插入排序的优势在于插入排序每次只能将数据移动一位，不过希尔排序时间复杂度的大小还是要取决于步长的合适度，另外希尔排序不是一种稳定的排序算法。</strong></p>
<p><img src="images/3_%E5%B8%8C%E5%B0%94.png" alt="在这里插入图片描述"></p>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//步长为n/2....</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> gap = arr.length; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;     <span class="comment">//增量序列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;        <span class="comment">//从数组第gap个元素开始</span></span><br><span class="line">            <span class="keyword">int</span> key = arr[i],j;                        <span class="comment">//每个元素与自己组内的数据进行直接插入排序</span></span><br><span class="line">            <span class="keyword">for</span>(j = i-gap; j &gt;= <span class="number">0</span> &amp;&amp; key &lt; arr[j]; j -= gap) arr[j+gap] = arr[j];</span><br><span class="line">            arr[j+gap] = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//步长为 n*3+1</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(; gap &lt;= arr.length; gap = gap*<span class="number">3</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(; gap &gt; <span class="number">0</span>; gap = (gap-<span class="number">1</span>)/<span class="number">3</span>) &#123; <span class="comment">//增量序列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;  <span class="comment">//从数组第gap个元素开始</span></span><br><span class="line">            <span class="keyword">int</span> key = arr[i],j;  <span class="comment">//每个元素与自己组内的数据进行直接插入排序</span></span><br><span class="line">            <span class="keyword">for</span>(j = i-gap; j &gt;= <span class="number">0</span> &amp;&amp; key &lt; arr[j]; j -= gap) arr[j+gap] = arr[j];</span><br><span class="line">            arr[j+gap] = key; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<hr>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a><font color = red id = "7">快速排序</h2><p>快速排序有几种不同的实现方式，先看最简单的，快排的宏观过程就是每次递归左右两边划分，关键是划分的过程，即<code>partition</code>过程的写法，先看最原始的<code>partition</code>:</p>
<ul>
<li>在<code>[L, R]</code>之间，选取<code>arr[L]</code>为划分点<code>key</code>；</li>
<li>然后从<code>[L, R]</code>，如果当前<code>arr[i] &lt; key</code>，就放到左边部分<code>swap(arr, i, ++pivot);</code>，否则就不动；</li>
<li>最后将数组划分成了<code>arr[L...p-1] &lt; arr[p]</code> ， <code>arr[p+1...R] &gt; arr[p]</code>，并返回<code>p</code>；<br><img src="images/4_%E5%BF%AB1.png" alt="在这里插入图片描述"></li>
</ul>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    quickProcess(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickProcess</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= R)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> p = partition(arr, L, R);</span><br><span class="line">    quickProcess(arr, L, p - <span class="number">1</span>);</span><br><span class="line">    quickProcess(arr, p + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 对arr[l...r]部分进行partition操作</span></span><br><span class="line"><span class="comment">* 返回p, 使得arr[L...p-1] &lt; arr[p] ; arr[p+1...R] &gt; arr[p]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//直接选取 arr[L]作为pivot(中心点)</span></span><br><span class="line">    <span class="keyword">int</span> key = arr[L];</span><br><span class="line">    <span class="keyword">int</span> pivot = L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L + <span class="number">1</span>; i &lt;= R; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; key)</span><br><span class="line">            swap(arr, i, ++pivot);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, pivot, L); <span class="comment">// 将arr[L]放到pivot位置(中间) --&gt; 完全了按照arr[L]划分数组的目的</span></span><br><span class="line">    <span class="keyword">return</span> pivot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color = green><strong>第一个优化(随机快排) (解决划分数选取不好的问题)</strong></font><br>上面的快速排序当选取的划分的元素(<code>pivot = arr[L]</code>)很小(或者很大)，使得后面划分的数组极度的不平衡的时候，会将快速排序降到<font color = red>O(N<sup>2</sup>)</font>，于是我们使用<font color = red>随机快排</font>，即不是将<code>arr[L]</code>作为划分点，而是随机选取一个元素作为(<code>pivot</code>)：</p>
<p><img src="images/5_%E5%BF%AB2.png" alt="在这里插入图片描述"></p>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    quickProcess(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickProcess</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= R)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    swap(arr, L, L + (<span class="keyword">int</span>) (Math.random() * (R - L + <span class="number">1</span>))); <span class="comment">//随机选取一个pivot</span></span><br><span class="line">    <span class="keyword">int</span> p = partition(arr, L, R);</span><br><span class="line">    quickProcess(arr, L, p - <span class="number">1</span>);</span><br><span class="line">    quickProcess(arr, p + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//直接选取 arr[L]作为pivot(中心点)</span></span><br><span class="line">    <span class="keyword">int</span> key = arr[L];</span><br><span class="line">    <span class="keyword">int</span> pivot = L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L + <span class="number">1</span>; i &lt;= R; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; key)</span><br><span class="line">            swap(arr, i, ++pivot);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, pivot, L); <span class="comment">// 将arr[L]放到pivot位置(中间) --&gt; 完全了按照arr[L]划分数组的目的</span></span><br><span class="line">    <span class="keyword">return</span> pivot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color = green><strong>第二个优化(双路快速排序)(解决重复元素多的问题)</strong></font></p>
<p>当我们要排序的数组<font color = red>重复元素很多</font>的情况下，还是会使得划分极其的不均匀: </p>
<p><img src="images/6_%E5%BF%AB3.png" alt="在这里插入图片描述"></p>
<p>第一个解决的方法: <font color = blue>换一种划分的方式: </p>
<ul>
<li>将 <code>&lt;key</code>和<code>&gt;key</code>的元素放在数组的两边，更准确的说是: <font color =red>左端放的是 <code>&lt;=key</code>的元素，右端放的是<code>&gt;=key</code>的元素；</li>
<li>然后设置两个指针(一个从<code>L</code>开始，一个从<code>R</code>开始)，然后向中间靠拢，分别找到第一个<code>&gt;=key</code>(左边)、<code>&lt;=key</code>(右边)的元素，就停止扫描，然后交换这两个位置，终止条件是两个指针相碰；</li>
<li>为什么这样就可以解决重复元素多的问题呢? 因为两个指针的元素相等且都等于<code>key</code>的时候，还是要交换两个位置，这样就不会将重复的元素集中在同一侧。</li>
</ul>
<p>解决方式: </p>
<p><img src="images/7_%E5%BF%AB4.png" alt="在这里插入图片描述"></p>
<p>改进代码: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    quickProcess(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickProcess</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= R)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    swap(arr, L, L + (<span class="keyword">int</span>) (Math.random() * (R - L + <span class="number">1</span>))); <span class="comment">//随机选取一个pivot</span></span><br><span class="line">    <span class="keyword">int</span> p = partition(arr, L, R);</span><br><span class="line">    quickProcess(arr, L, p - <span class="number">1</span>);</span><br><span class="line">    quickProcess(arr, p + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key = arr[L];</span><br><span class="line">    <span class="keyword">int</span> less = L + <span class="number">1</span>, more = R;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (less &lt; R &amp;&amp; arr[less] &lt; key) less++;</span><br><span class="line">        <span class="keyword">while</span> (more &gt; L &amp;&amp; arr[more] &gt; key) more--;</span><br><span class="line">        <span class="keyword">if</span> (less &gt;= more)<span class="comment">// not less &gt; more  </span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        swap(arr, less++, more--);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, L, more); <span class="comment">// finally let L to the middle </span></span><br><span class="line">    <span class="keyword">return</span> more;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color = green><strong>第三个优化(三路快速排序)(更好的解决重复元素多的问题)</strong></font><br>三路快排关键在于<code>partion</code>的过程(荷兰国旗问题)，也就是将一个数组按照某个数划分成三部分:</p>
<ul>
<li>先从序列中选取一个数作为基数(<code>key</code>)；</li>
<li>分区过程，将<code>&lt;key</code>放到左边，<code>&gt;key</code>的放在右边，<code>=key</code>放到中间；</li>
<li>再对左右区间重复第二步，直到各区间只有一个数；</li>
<li>返回的<code>p</code>数组中<code>p[0]</code>代表的是等于区域的左边界，<code>p[1]</code>代表的是等于区域的右边界；</li>
</ul>
<p> 过程:<br> <img src="images/8_%E5%BF%AB5.png"></p>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> num) &#123;</span><br><span class="line">    <span class="keyword">int</span> less = L - <span class="number">1</span>; <span class="comment">//小于部分的最后一个数</span></span><br><span class="line">    <span class="keyword">int</span> more = R + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cur = L;</span><br><span class="line">    <span class="keyword">while</span> (cur &lt; more) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[cur] &lt; num) &#123;</span><br><span class="line">            swap(arr, ++less, cur++); <span class="comment">//把这个比num小的数放到小于区域的下一个，并且把小于区域扩大一个单位</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[cur] &gt; num) &#123;</span><br><span class="line">            swap(arr, --more, cur); <span class="comment">//把这个比num大的数放到大于去余的下一个，并且把大于区域扩大一个单位</span></span><br><span class="line">            <span class="comment">//同时，因为从大于区域拿过来的数是未知的，所以不能cur++ 还要再次判断一下arr[cur]</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 否则的话就直接移动</span></span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;less + <span class="number">1</span>, more - <span class="number">1</span>&#125;;  <span class="comment">//返回的是等于区域的两个下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color = red>荷兰国旗问题的一个<a href="https://blog.csdn.net/zxzxzx0119/article/details/82715141">经典应用题LeetCode75-Sort Colors</a>。</font><br>注意这里的快速排序就是<code>partition</code>更改的，默认将<code>R</code>中的最后一个作为划分(也可以用<code>arr[L]</code>)．<br><font color =  red>这里总结一下优化 (<strong>所有的优化都是为了划分的均匀</strong>):  </font></p>
<ul>
<li><p>这里实际上使用的是<font color = red>三路快排</font>，这个是为了<font color = blue>防止数组中有很多重复的元素</font>    ；</p>
</li>
<li><p>使用的是<font color = red>随机快排</fon>，时间复杂度是概率级别的<code>Ologn</code>(<font color = blue>防止数组近乎有序</font>)；</p>
</li>
<li><p>注意下面我写了<font color= red>四种</font><code>partition</code>的过程，达到的效果是一样的，分别使用<code>arr[L]</code>和<code>arr[R]</code>来作划分，一些细节和边界的不同导致程序不同；</p>
</li>
</ul>
<p>最终三路快排代码如下: (<strong>下面的四个partition都是三路快排，只不过写的稍微有点不同</strong>)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    quickProcess(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用随机快排 (也就是 时间复杂度是概率的，防止我们选取的划分的数使得左右两边划分的很不均匀)</span></span><br><span class="line"><span class="comment"> * 随机快排的额外空间复杂度为Ologn</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickProcess</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= R)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/**随机化的排序 期望为Ologn从前面的数中随机选出一个数和最后一个数交换 不至于极端的情况使得两边划分很不对称*/</span></span><br><span class="line">    swap(arr, R, L + (<span class="keyword">int</span>) (Math.random() * (R - L + <span class="number">1</span>))); <span class="comment">//例子3~6 --&gt; [0~1)*3 --&gt; 0~2</span></span><br><span class="line">    <span class="keyword">int</span>[] p = partition4(arr, L, R); <span class="comment">// 分别用partition、partition2、partition3测试都可以</span></span><br><span class="line">    quickProcess(arr, L, p[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">    quickProcess(arr, p[<span class="number">1</span>] + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 划分函数,这里使用的是arr[R]来划分, 左边的都比arr[R]小，右边都比arr[R]大</span></span><br><span class="line"><span class="comment"> * 返回的数组是中间相等的两个下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R) &#123;</span><br><span class="line">    <span class="keyword">int</span> cur = L, less = L - <span class="number">1</span>, more = R;</span><br><span class="line">    <span class="keyword">int</span> key = arr[R];</span><br><span class="line">    <span class="keyword">while</span> (cur &lt; more) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[cur] &lt; key)</span><br><span class="line">            swap(arr, ++less, cur++);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[cur] &gt; key)</span><br><span class="line">            swap(arr, --more, cur);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, more, R);  <span class="comment">//把最后那个数放到中间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;less + <span class="number">1</span>, more&#125;;  <span class="comment">//当然如果没有相等的部分  那less+1 = more</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上面的简写方式</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] partition2(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R) &#123;</span><br><span class="line">    <span class="keyword">int</span> less = L - <span class="number">1</span>, more = R;  <span class="comment">//把最后这个数当作标准 也可以使用第一个</span></span><br><span class="line">    <span class="keyword">while</span> (L &lt; more) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[L] &lt; arr[R])</span><br><span class="line">            swap(arr, ++less, L++);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[L] &gt; arr[R])</span><br><span class="line">            swap(arr, --more, L);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            L++;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, more, R);  <span class="comment">//把最后那个数放到中间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;less + <span class="number">1</span>, more&#125;;  <span class="comment">//为什么不是 more-1,因为上面又交换了一个, 当然如果没有相等的部分  那less+1 = more</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正方向：按照 arr[L]来划分</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] partition3(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R) &#123;</span><br><span class="line">    <span class="keyword">int</span> key = arr[L], cur = L + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> less = L, more = R + <span class="number">1</span>; <span class="comment">// more在外面(R+1)，等下循环cur &lt; more</span></span><br><span class="line">    <span class="keyword">while</span> (cur &lt; more) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[cur] &lt; key)</span><br><span class="line">            swap(arr, ++less, cur++);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[cur] &gt; key)</span><br><span class="line">            swap(arr, --more, cur);</span><br><span class="line">        <span class="keyword">else</span> cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, L, less);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;less, more - <span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对比partition3的不同</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] partition4(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R) &#123;</span><br><span class="line">    <span class="keyword">int</span> key = arr[L], cur = L + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> less = L, more = R; <span class="comment">// more = R，等下循环cur &lt;= more</span></span><br><span class="line">    <span class="keyword">while</span> (cur &lt;= more) &#123; <span class="comment">// not cur &lt; more</span></span><br><span class="line">        <span class="keyword">if</span> (arr[cur] &lt; key)</span><br><span class="line">            swap(arr, ++less, cur++);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[cur] &gt; key)</span><br><span class="line">            swap(arr, more--, cur); <span class="comment">// 对比上面,不是--more,这些就是边界问题</span></span><br><span class="line">        <span class="keyword">else</span> cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, L, less);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;less, more&#125;; <span class="comment">//同样返回的也不同</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[a];</span><br><span class="line">    arr[a] = arr[b];</span><br><span class="line">    arr[b] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意这里和荷兰国旗<code>partitiion</code>过程的不同:</strong></p>
<p><img src="images/9_%E5%BF%AB6.png" alt="这里写图片描述"></p>
<p><strong>注意最后的<code>arr[more]</code>和<code>arr[R]</code>的交换(注意最后的交换和返回的下标位置):</strong></p>
<p><img src="images/10_%E5%BF%AB7.png" alt="这里写图片描述"> </p>
<hr>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a><font color = red id = "8">归并排序</h2><p><strong>归并排序也是分治法一个很好的应用，先递归到最底层，然后从下往上每次两个序列进行归并合起来，是一个由上往下分开，再由下往上合并的过程。</strong></p>
<p><strong>而对于每一次合并操作，对于每一次<code>merge</code>的操作过程如下：</strong></p>
<ul>
<li> 准备一个额外的数组(<code>help</code>)，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>重复步骤3直到某一指针达到序列尾；</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾；</li>
</ul>
<p>看下面的例子合并过程如下：</p>
<p><img src="images/12_%E5%A0%861.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    mergeProcess(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeProcess</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= R)</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">//递归条件判断</span></span><br><span class="line">    <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>); <span class="comment">//这个相当于 (R+L)/2;</span></span><br><span class="line">    mergeProcess(arr, L, mid);  <span class="comment">//T(n/2)</span></span><br><span class="line">    mergeProcess(arr, mid + <span class="number">1</span>, R); <span class="comment">//T(n/2)</span></span><br><span class="line">    <span class="comment">/**这个是一个优化，因为arr[L,mid]和arr[mid+1,R]已经有序，所以如果满足这个条件，就不要排序了,防止一开始数组有序*/</span></span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &gt; arr[mid + <span class="number">1</span>])</span><br><span class="line">        merge(arr, L, mid, R);  <span class="comment">// O(n)</span></span><br><span class="line">    <span class="comment">//整个的表达式  T(n) = 2*T(n/2) + O(n) 使用master公式求出  N*logN</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> mid, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = L, p2 = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//while(p1 &lt;= mid &amp;&amp; p2 &lt;= R)</span></span><br><span class="line">    <span class="comment">//   help[k++] = arr[p1] &lt; arr[p2]  ? arr[p1++] : arr[p2++];</span></span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= R)</span><br><span class="line">        help[k++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];  <span class="comment">//左右两边相等的话，就先拷贝左边的(实现稳定性)</span></span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid)  <span class="comment">//左边剩余的部分</span></span><br><span class="line">        help[k++] = arr[p1++];</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= R)   <span class="comment">//右边剩余的部分</span></span><br><span class="line">        help[k++] = arr[p2++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) <span class="comment">//拷贝回原来的数组</span></span><br><span class="line">        arr[i + L] = help[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意几点: </p>
<ul>
<li><strong>注意上面的代码中<code>if(arr[mid] &gt; arr[mid+1])</code>防止一开始数组很有序的情况；</strong></li>
<li><strong>注意在外排比较的时候，为了保证稳定性，左右相等的时候，先拷贝左边的；</strong></li>
</ul>
<p><strong>另外再补充一个<a href="https://www.lintcode.com/problem/reverse-pairs/description">LintCode532Reverse Pairs归并排序求解逆序数</a>的问题</strong>:  </p>
<p><img src="images/11_%E5%BF%AB8.png" alt="在这里插入图片描述"></p>
<p>这个的关键在于，在合并<code>l ~ mid</code>和<code>mid+1~r</code>的过程中，只要<code>arr[p1] &gt; arr[p2]</code>，则<code>arr[p2]</code>和<code>arr[p1 ~ mid]</code>都能组成逆序对，所以我们每次都可以加上<code>mid - p1 + 1</code>个数，故可以方便求出逆序数对数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A: an array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: total of reverse pairs</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">1</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> mergeProcess(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">mergeProcess</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( L == R)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = L + ((R-L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> mergeProcess(arr,L,mid)</span><br><span class="line">                + mergeProcess(arr,mid+<span class="number">1</span>,R)</span><br><span class="line">                + merge(arr,L,mid,R);<span class="comment">//注意merge放在后面</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> L,<span class="keyword">int</span> mid,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[R-L+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p1 = L,p2 = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(p1 &lt;= mid &amp;&amp; p2 &lt;= R)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[p1] &lt;= arr[p2])&#123;</span><br><span class="line">                help[k++] = arr[p1++];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;   <span class="comment">//arr[p1] &gt; arr[p2] 此时p2都小于arr[p1,mid]之间的元素</span></span><br><span class="line">                sum += (mid-p1+<span class="number">1</span>);  <span class="comment">//加上逆序数的个数</span></span><br><span class="line">                help[k++] = arr[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p1 &lt;= mid)</span><br><span class="line">            help[k++] = arr[p1++];</span><br><span class="line">        <span class="keyword">while</span>(p2 &lt;= R) </span><br><span class="line">            help[k++] = arr[p2++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            arr[i+L] = help[i];</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>还有一个题目就是小和问题:  具体的问题和上面的逆序数差不多。</strong></p>
<p>题目:</p>
<blockquote>
<p>小和问题 </p>
<p>在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组<br>的小和。</p>
<p>例子;</p>
<p><code>[1,3,4 2,5]</code></p>
<p>1左边比1小的数，没有；</p>
<p>3左边比3小的数，1；</p>
<p>4左边比4小的数，1、3；</p>
<p>2左边比2小的数，1；</p>
<p>5左边比5小的数，1、3、4、2；<br>所以小和为1+1+3+1+1+3+4+2=16</p>
</blockquote>
<p>代码类似:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mergeSortSum</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> mergeProcess(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mergeProcess</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>); </span><br><span class="line">    <span class="keyword">return</span> mergeProcess(arr, L, mid) +</span><br><span class="line">            mergeProcess(arr, mid + <span class="number">1</span>, R) +</span><br><span class="line">            merge(arr, L, mid, R); <span class="comment">//左边的小和和右边的小和</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> mid, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = L, p2 = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[p1] &lt; arr[p2]) &#123;<span class="comment">//如果arr[p1] &lt; arr[p2] 则arr[p1] &lt; arr[p2 ~ R]</span></span><br><span class="line">            sum += arr[p1] * (R - p2 + <span class="number">1</span>);</span><br><span class="line">            help[i++] = arr[p1++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            help[i++] = arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid) help[i++] = arr[p1++];</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= R) help[i++] = arr[p2++];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= R - L; i++) arr[i + L] = help[i];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>另外，归并排序也可以<font color = red>自底向上</font>的进行: </p>
<p><img src="images/13_%E5%BD%92%E5%B9%B62.png" alt="在这里插入图片描述"></p>
<p>代码实现注意两个细节: </p>
<ul>
<li>第二层循环: <code>sz + i -1 = mid</code> ，注意不要越界，所以在第二层循环中<code>i+sz &lt; arr.length</code>；</li>
<li>同理，<code>i+2*sz - 1</code>也要保证不能越界，所以和<code>arr.length - 1</code>取最小值；<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSortBU</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt;= arr.length; sz += sz)&#123; <span class="comment">// 区间的个数，1..2..4..8</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; sz + i &lt; arr.length; i += sz+sz)&#123;  <span class="comment">// 对[i...i+sz-1]和[i+sz...i+2*sz-1]内归并</span></span><br><span class="line">            merge(arr, i, i+sz-<span class="number">1</span>, Math.min(arr.length-<span class="number">1</span>, i+<span class="number">2</span>*sz-<span class="number">1</span>)); <span class="comment">// min防止越界</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a><font color = red id = "9">堆排序</h2><p><font color =red>堆的相关介绍看<a href="https://blog.csdn.net/zxzxzx0119/article/details/79890060">这篇博客</a>。</p>
<p>堆排序的过程是一个反复调整堆的过程：</p>
<ul>
<li>利用数组建立一个大根堆（父亲比孩子的值大）；</li>
<li>把堆顶元素和堆尾元素互换；</li>
<li> 把堆（无序区）的尺寸缩小<code>1</code>，并调用<code>siftDown(arr, 0,len-1)</code>从新的堆顶元素开始进行堆调整；</li>
<li>重复步骤，直到堆的大小为<code>1</code>；</li>
</ul>
<p>基本的堆排序 : </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        siftUp(arr, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size = arr.length;</span><br><span class="line">    swap(arr, <span class="number">0</span>, --size);</span><br><span class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        siftDown(arr, <span class="number">0</span>, size);</span><br><span class="line">        swap(arr, <span class="number">0</span>, --size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上浮的过程  --&gt;  把新插入的数调整为大根堆的过程</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (arr[i] &gt; arr[(i - <span class="number">1</span>) / <span class="number">2</span>]) &#123;</span><br><span class="line">        swap(arr, i, (i - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        i = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下沉的过程  --&gt;  这个函数就是一个数变小了，往下沉的函数,改变的数为index  目前的自己指定的堆的大小为heapSize</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; heapSize) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxIndex = L + <span class="number">1</span> &lt; heapSize &amp;&amp; arr[L + <span class="number">1</span>] &gt; arr[L] ? L + <span class="number">1</span> : L;</span><br><span class="line">        maxIndex = arr[i] &gt; arr[maxIndex] ? i : maxIndex;</span><br><span class="line">        <span class="keyword">if</span> (maxIndex == i) <span class="keyword">break</span>; <span class="comment">//自己就是最大的， 不用忘下沉</span></span><br><span class="line">        <span class="comment">//否则就要一直往下沉</span></span><br><span class="line">        swap(arr, i, maxIndex);</span><br><span class="line">        i = maxIndex;</span><br><span class="line">        L = <span class="number">2</span> * i + <span class="number">1</span>; <span class="comment">//继续往下</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color = red> 下面是将一个数组建成堆的时候的优化过程: </font></p>
<p>下面的写法就是一个下沉的操作(这里建堆的时候没有使用上浮，而是从第一个非叶子结点开始使用下沉的方式建堆):<br><img src="images/14_%E5%A0%861.png" alt="在这里插入图片描述"></p>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> size = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (size - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        siftDown(arr, i, size);</span><br><span class="line">    swap(arr, <span class="number">0</span>, size);</span><br><span class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        siftDown(arr, <span class="number">0</span>, size);</span><br><span class="line">        swap(arr, <span class="number">0</span>, --size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 往下沉的函数,改变的数为index  目前的自己指定的堆的大小为heapSize</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; heapSize) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxIdx = L + <span class="number">1</span> &lt; heapSize &amp;&amp; arr[L + <span class="number">1</span>] &gt; arr[L] ? L + <span class="number">1</span> : L;</span><br><span class="line">        maxIdx = arr[i] &gt; arr[maxIdx] ? i : maxIdx;</span><br><span class="line">        <span class="keyword">if</span> (maxIdx == i) <span class="keyword">break</span>; <span class="comment">//自己就是最大的， 不用忘下沉</span></span><br><span class="line"></span><br><span class="line">        swap(arr, i, maxIdx);</span><br><span class="line">        i = maxIdx;</span><br><span class="line">        L = <span class="number">2</span> * i + <span class="number">1</span>; <span class="comment">//继续往下</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>shiftDown的过程也可以递归的换:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归的调整A[i]以下的堆</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> size)</span> </span>&#123; <span class="comment">//从A[i] 开始往下调整</span></span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">2</span> * i + <span class="number">1</span>; <span class="comment">//左孩子的下标</span></span><br><span class="line">    <span class="keyword">int</span> R = <span class="number">2</span> * i + <span class="number">2</span>;<span class="comment">//右孩子的下标</span></span><br><span class="line">    <span class="keyword">int</span> maxIdx = i;</span><br><span class="line">    <span class="keyword">if</span> (L &lt; size &amp;&amp; arr[L] &gt; arr[maxIdx]) maxIdx = L;</span><br><span class="line">    <span class="keyword">if</span> (R &lt; size &amp;&amp; arr[R] &gt; arr[maxIdx]) maxIdx = R;</span><br><span class="line">    <span class="keyword">if</span> (maxIdx != i) &#123;</span><br><span class="line">        swap(arr, i, maxIdx);  <span class="comment">//把当前结点和它的最大(直接)子节点进行交换</span></span><br><span class="line">        siftDown(arr, maxIdx, size);  <span class="comment">//继续调整它的孩子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (size - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        siftDown(arr, i, size);</span><br><span class="line">    swap(arr, <span class="number">0</span>, size);<span class="comment">//和最后一个数交换</span></span><br><span class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        siftDown(arr, <span class="number">0</span>, size);</span><br><span class="line">        swap(arr, <span class="number">0</span>, --size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a><font color = red id = "10">计数排序</h2><p>计数排序是一种非比较排序： </p>
<ul>
<li><strong>利用一个<code>count</code>数组，统计每个元素<code>arr[i]</code>出现的次数<code>count[arr[i]]</code>，<code>count</code>数组的大小代表的是能排序的元素的最大的值；</strong></li>
<li><strong>然后让<code>count</code>数组中每一个元素<code>count[i]</code>等于其与他前面一项<code>count[i-1]</code>相加，这时候<code>count[arr[i]]</code>表示的值就是小于等于<code>arr[i]</code>的元素的个数，这时就找到了<code>arr[i]</code>在输出数组中的位置；</strong></li>
<li><strong>最后通过<font color =red>反向填充</font>目标数组<code>tmp</code>，将数组元素<code>arr[i]</code> 放在数组<code>tmp</code>的第<code>count[arr[i]]</code>个位置(下标为<code>count[arr[i]]-1</code>)，每放一个元素就将<code>count[arr[i]]</code>递减，可以确保计数排序的稳定性；</strong></li>
</ul>
<p>看一个例子<br><img src="https://img-blog.csdn.net/20180405170000881?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>填充过程：</p>
<p><img src="images/15_%E8%AE%A1%E6%95%B01.png" alt="这里写图片描述"></p>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 计数排序   count 统计数组， tmp 目标填充数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> RANGE)</span> </span>&#123; <span class="comment">/**数组中最大的元素不能超过 RANGE*/</span></span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[RANGE + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">        count[arr[i]]++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**现在的count[i]表示小于i的数有count[i]个，排序后元素i就放在第C[i]个输出位置上*/</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= RANGE; i++)</span><br><span class="line">        count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 从后向前扫描保证计数排序的稳定性(重复元素相对次序不变)</span></span><br><span class="line"><span class="comment">         * 当再遇到重复元素时会被放在当前元素的前一个位置上保证计数排序的稳定性</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        tmp[--count[arr[i]]] = arr[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝回原来的数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">        arr[i] = tmp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color = red>可以看一个简单的关于计数排序的一个<a href="https://blog.csdn.net/zxzxzx0119/article/details/82715141">练习题LeetCode75-Sort Colors</a></font>。</p>
<hr>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a><font color = red id = "11">基数排序</h2><p>基数排序是按照不同的位数，或者优先级来排列某个元素，其中利用到了计数排序: </p>
<blockquote>
<p> 基数排序分为两种模式:</p>
<p>Least significant digit (LSD)</p>
<p>短的关键字被认为是小的，排在前面，然后相同长度的关键字再按照词典顺序或者数字大小等进行排序。比如<code>1，2，3，4，5，6，7，8，9，10，11</code>或者<code>&quot;b, c, d, e, f, g, h, i, j, b, a&quot;</code> 。</p>
<p>Most significance digit (MSD)<br>直接按照字典的顺序进行排序，对于字符串、单词或者是长度固定的整数排序比较合适。比如: <code>1, 10, 2, 3, 4, 5, 6, 7, 8, 9</code>和 <code>&quot;b, ba, c, d, e, f, g, h, i, j&quot;</code>。</p>
<p>假设我们有一些二元组<code>(a,b)</code>，要对它们进行以a为首要关键字，b的次要关键字的排序。</p>
<p>我们可以先把它们先按照首要关键字排序，分成首要关键字相同的若干堆。然后，在按照次要关键值分别对每一堆进行单独排序。最后再把这些堆连到一起，使首要关键字较小的-堆排在上面。按这种方式的基数排序称为MSD(Most Significant Dight)排序。</p>
<p>第二种方式是从最低有效关键字开始排序，称为LSD(Least Significant Dight)排序。首先对所有的数据按照次要关键字排序，然后对所有的数据按照首要关键字排序。要注意的是，使用的排序算法必须是稳定的，否则就会取消前一次排序的结果。由于不需要分堆对每堆单独排序，LSD方法往往比MSD简单而开销小。</p>
</blockquote>
<p>下面的方式是基于LSD的。 </p>
<p>LSD模式: </p>
<ul>
<li>基数排序将所有待比较正整数统一为同样的数位长度，<strong>数位较短的数前面补零；</strong></li>
<li>然后，从最低位开始进行基数为<code>10</code>的计数排序，一直到最高位计数排序完后，数列就变成一个有序序列（利用了计数排序的稳定性）；</li>
</ul>
<p>看下图例子，对<code>&#123; 329, 457, 657, 839, 436, 720, 355 &#125;</code>进行基数排序：</p>
<p><img src="images/16_%E5%9F%BA%E6%95%B0.png" alt="这里写图片描述"></p>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将整形数按照每位(从低到高)拆分，然后从低位(个位)到高位依次比较各个位，得到所在的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//dn表示最大的数的位数 3位的话只能表示到999</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> dn = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得元素x的第d位数字</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDigit</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] radix = &#123;<span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>&#125;; <span class="comment">//这里只排序总共有三位数,分别代表 个位，十位，百位</span></span><br><span class="line">    <span class="keyword">return</span> (num / radix[d]) % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据数组arr中每个元素 的第d位数,来对整个arr数组排序</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lsdRadixSortInfo</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];      <span class="comment">//  单独考虑每一个位的时候， 数字都是从[0~9]</span></span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">        count[getDigit(arr[i], d)]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) count[i] += count[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> digit = getDigit(arr[i], d);  <span class="comment">//元素arr[i]当前 的d位的数字为dight</span></span><br><span class="line">        tmp[--count[digit]] = arr[i];    <span class="comment">//根据当前位数字digit来排序，把每个元素A[i]放到它在输出数组B中的正确位置上</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) arr[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lsdRadixSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; dn; d++) <span class="comment">//从低位(个位)到高位 按照每一位排序</span></span><br><span class="line">        lsdRadixSortInfo(arr, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者另一种写法: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++)</span><br><span class="line">        max = arr[i] &gt; max ? arr[i] : max;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lsdRadixProcess</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> exp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">        count[(arr[i] / exp) % <span class="number">10</span>]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) count[i] += count[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        tmp[--count[(arr[i] / exp) % <span class="number">10</span>]] = arr[i];    <span class="comment">//根据当前位数字digit来排序，把每个元素A[i]放到它在输出数组B中的正确位置上</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) arr[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lsdRadixSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = getMax(arr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> exp = <span class="number">1</span>; max / exp &gt; <span class="number">0</span>; exp *= <span class="number">10</span>) <span class="comment">//从低位到高位</span></span><br><span class="line">        lsdRadixProcess(arr, exp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a><font color = red id = "12">桶排序</h2><p>桶排序的原理可以分为一下三个步骤：</p>
<ul>
<li><p>扫描序列，根据每个元素的值所属的区间(可以设置一个映射函数)，放入指定的桶中(顺序放置)；</p>
</li>
<li><p>对每个桶中的元素进行排序，(使用其它排序算法或以递归方式继续使用桶排序）；</p>
</li>
</ul>
<p>看下面对<code>&#123; 29, 25, 3, 49, 9, 37, 21, 43 &#125;</code>进行桶排序；</p>
<p><img src="images/17_%E6%A1%B6.png" alt="这里写图片描述"></p>
<p>因为每个桶各自的容量可能不同，所以也可以使用链表来储存，但是空间复杂度高；</p>
<p>下面的代码: </p>
<ul>
<li>主要是<font color =red>利用计数排序找到每个桶的起始下标和终止下标，然后对每个桶进行系统的排序；</li>
<li><code>mapToBucket()</code>采用的是<code> / bucketNum</code>(桶的个数) 的操作，如果对<code>0 ~ 99</code>排序就设置桶的个数为<code>10</code>个，如果是<code>0~999</code>就设置为<code>100</code>个…..；</li>
</ul>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> bucketNum = <span class="number">100</span>; <span class="comment">//桶的个数 0 ～ 9号桶</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//桶排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mapToBucket</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;   <span class="comment">// 映射函数f(x)</span></span><br><span class="line">    <span class="keyword">return</span> x / bucketNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[bucketNum];  <span class="comment">// 计数数组，存放桶的边界信息</span></span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)  <span class="comment">//count[i]保存着i号桶中元素的个数</span></span><br><span class="line">        count[mapToBucket(arr[i])]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; bucketNum; i++)  <span class="comment">// 定位桶边界初始时，count[i]-1(下标从0开始)为i号桶最后一个元素的位置</span></span><br><span class="line">        count[i] += count[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//count[0]~count[9]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        tmp[--count[mapToBucket(arr[i])]] = arr[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">        arr[i] = tmp[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用计数排序确定各个桶的边界（分桶）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> L = count[i];     <span class="comment">//count[i]为i号桶第一个元素的位置</span></span><br><span class="line">        <span class="keyword">int</span> R = (i == bucketNum - <span class="number">1</span> ? arr.length - <span class="number">1</span> : count[i + <span class="number">1</span>] - <span class="number">1</span>); <span class="comment">//count[i+1]-1为i号桶最后一个元素的位置</span></span><br><span class="line">        <span class="comment">//for(int j = L; j &lt;= R; j++)System.out.print( arr[j] + &quot; &quot;); System.out.println();  //print</span></span><br><span class="line">        <span class="keyword">if</span> (L &lt; R)  <span class="comment">//对每个桶里面进行排序</span></span><br><span class="line">            Arrays.sort(arr, L, R + <span class="number">1</span>);<span class="comment">//注意这里是R+1，系统库的sort的右边界是开区间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a><font color = red id = "13">测试代码</h2><p>上述排序都是用下面的程序测试的: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000</span>];</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">            arr[i] = random.nextInt(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//原数组</span></span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        bubbleSort(arr);</span></span><br><span class="line"><span class="comment">//        cocktailSort(arr);</span></span><br><span class="line"><span class="comment">//        selectSort(arr);</span></span><br><span class="line"><span class="comment">//        insertSort(arr);</span></span><br><span class="line"><span class="comment">//        insertSort2(arr);</span></span><br><span class="line"><span class="comment">//        insertSort3(arr);</span></span><br><span class="line"><span class="comment">//        shellSort(arr);</span></span><br><span class="line"><span class="comment">//        shellSort2(arr);</span></span><br><span class="line"><span class="comment">//        quickSort(arr);</span></span><br><span class="line"><span class="comment">//        heapSort(arr);</span></span><br><span class="line"><span class="comment">//        heapSort2(arr);</span></span><br><span class="line"><span class="comment">//        countSort(arr,1000);</span></span><br><span class="line"><span class="comment">//        lsdRadixSort(arr);</span></span><br><span class="line"><span class="comment">//        lsdRadixSort2(arr);</span></span><br><span class="line">        bucketSort(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//test</span></span><br><span class="line">        <span class="keyword">boolean</span> good = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt; arr[i-<span class="number">1</span>])&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;bad!&quot;</span>);</span><br><span class="line">                System.out.println(arr[i-<span class="number">1</span>] + <span class="string">&quot; &quot;</span> + arr[i]);</span><br><span class="line">                good = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(good)System.out.println(<span class="string">&quot;good!&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="附C-部分代码"><a href="#附C-部分代码" class="headerlink" title="附C++部分代码"></a>附C++部分代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SortTestHelper&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> *<span class="title">generateRandomArray</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> *arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            arr[i] = <span class="built_in">rand</span>() % (R - L + <span class="number">1</span>) + L;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> *<span class="title">generateNearlyOrderedArray</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> swapTimes)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> *arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; swapTimes; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> posx = <span class="built_in">rand</span>() % n;</span><br><span class="line">            <span class="keyword">int</span> posy = <span class="built_in">rand</span>() % n;</span><br><span class="line">            std::<span class="built_in">swap</span>(arr[posx], arr[posy]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> *<span class="title">copyArray</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> *arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            arr[i] = a[i];</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSorted</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testSort</span><span class="params">(<span class="keyword">const</span> std::string &amp;sortName, <span class="keyword">void</span> (*sort)(T[], <span class="keyword">int</span>), T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">clock_t</span> startTime = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="built_in">sort</span>(arr, n);</span><br><span class="line">        <span class="keyword">clock_t</span> endTime = <span class="built_in">clock</span>();</span><br><span class="line">        std::cout &lt;&lt; sortName &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">double</span></span>(endTime - startTime)/CLOCKS_PER_SEC &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="built_in">isSorted</span>(arr, n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> end = n<span class="number">-1</span>; end &gt; <span class="number">0</span>; end--)&#123; <span class="comment">// n-1次</span></span><br><span class="line">        <span class="keyword">int</span> border = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; end; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[i+<span class="number">1</span>])&#123;</span><br><span class="line">                std::<span class="built_in">swap</span>(arr[i], arr[i+<span class="number">1</span>]);</span><br><span class="line">                border = i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        end = border; <span class="comment">// 下一次只交换到这里</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;</span><br><span class="line">        std::<span class="built_in">swap</span>(arr[minIndex], arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[i]; j--) <span class="comment">//find the insert position,  notice init j = i is wrong  </span></span><br><span class="line">            arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort2</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j<span class="number">-1</span>]; j--)</span><br><span class="line">            std::<span class="built_in">swap</span>(arr[j], arr[j<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> __merge(T arr[], <span class="keyword">int</span> L, <span class="keyword">int</span> mid, <span class="keyword">int</span> R)&#123;</span><br><span class="line">    T* help = <span class="keyword">new</span> T[R-L+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> p1 = L, p2 = mid + <span class="number">1</span>, k = <span class="number">0</span>; <span class="comment">// note p1 = 0</span></span><br><span class="line">    <span class="keyword">while</span>(p1 &lt;= mid &amp;&amp; p2 &lt;= R)</span><br><span class="line">        help[k++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    <span class="keyword">while</span>(p1 &lt;= mid)</span><br><span class="line">        help[k++] = arr[p1++];</span><br><span class="line">    <span class="keyword">while</span>(p2 &lt;= R)</span><br><span class="line">        help[k++] = arr[p2++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) </span><br><span class="line">        arr[i+L] = help[i];</span><br><span class="line">    <span class="keyword">delete</span>[] help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> __mergeSort(T arr[], <span class="keyword">int</span> L, <span class="keyword">int</span> R)&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &gt;= R)</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// int mid = L + (R-L)/2;</span></span><br><span class="line">    <span class="keyword">int</span> mid = (L+R)/<span class="number">2</span>;</span><br><span class="line">    __mergeSort(arr, L, mid);</span><br><span class="line">    __mergeSort(arr, mid+<span class="number">1</span>, R);</span><br><span class="line">    <span class="keyword">if</span>(arr[mid] &gt; arr[mid+<span class="number">1</span>])  <span class="comment">// optimize</span></span><br><span class="line">        __merge(arr, L, mid, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    __mergeSort(arr, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSortBU</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt;= n; sz += sz)&#123; <span class="comment">// 区间的个数，1..2..4..8</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i+sz &lt; n; i += sz+sz)&#123;  <span class="comment">// 对[i...i+sz-1]和[i+sz...i+2*sz-1]内归并</span></span><br><span class="line">            __merge(arr, i, i+sz<span class="number">-1</span>, std::<span class="built_in">min</span>(n<span class="number">-1</span>, i+sz+sz<span class="number">-1</span>)); <span class="comment">// min防止越界</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对arr[l...r]部分进行partition操作</span></span><br><span class="line"><span class="comment">// 返回p, 使得arr[l...p-1] &lt; arr[p] ; arr[p+1...r] &gt; arr[p]</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> __partition1(T arr[], <span class="keyword">int</span> L, <span class="keyword">int</span> R)&#123;</span><br><span class="line">    std::<span class="built_in">swap</span>( arr[L] , arr[<span class="built_in">rand</span>()%(R-L+<span class="number">1</span>)+L] );<span class="comment">// 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot</span></span><br><span class="line">    T key = arr[L];</span><br><span class="line">    <span class="keyword">int</span> pivot = L;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = L+<span class="number">1</span> ; i &lt;= R; i++)</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; key)</span><br><span class="line">            std::<span class="built_in">swap</span>(arr[++pivot] , arr[i]);</span><br><span class="line">    std::<span class="built_in">swap</span>( arr[L] , arr[pivot]);</span><br><span class="line">    <span class="keyword">return</span> pivot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> __quickSort1(T arr[], <span class="keyword">int</span> L, <span class="keyword">int</span> R)&#123;</span><br><span class="line">    <span class="keyword">if</span>( L &gt;= R )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> p = __partition1(arr, L, R);</span><br><span class="line">    __quickSort1(arr, L, p<span class="number">-1</span> );</span><br><span class="line">    __quickSort1(arr, p+<span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort1</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>)); <span class="comment">// 设置随机种子</span></span><br><span class="line">    __quickSort1(arr, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> __partition2(T arr[], <span class="keyword">int</span> L, <span class="keyword">int</span> R)&#123;</span><br><span class="line">    std::<span class="built_in">swap</span>( arr[L] , arr[<span class="built_in">rand</span>()%(R-L+<span class="number">1</span>)+L] );<span class="comment">// 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot</span></span><br><span class="line">    T key = arr[L];</span><br><span class="line">    <span class="keyword">int</span> less = L+<span class="number">1</span>, more = R;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(less &lt; R &amp;&amp; arr[less] &lt; key) less++;</span><br><span class="line">        <span class="keyword">while</span>(more &gt; L &amp;&amp; arr[more] &gt; key) more--;</span><br><span class="line">        <span class="keyword">if</span>(less &gt;= more)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        std::<span class="built_in">swap</span>(arr[less++], arr[more--]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">swap</span>(arr[L], arr[more]);</span><br><span class="line">    <span class="keyword">return</span> more;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> __quickSort2(T arr[], <span class="keyword">int</span> L, <span class="keyword">int</span> R)&#123;</span><br><span class="line">    <span class="keyword">if</span>( L &gt;= R )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> p = __partition2(arr, L, R);</span><br><span class="line">    __quickSort2(arr, L, p<span class="number">-1</span> );</span><br><span class="line">    __quickSort2(arr, p+<span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort2</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>)); <span class="comment">// 设置随机种子</span></span><br><span class="line">    __quickSort2(arr, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span>* __partition3(T arr[], <span class="keyword">int</span> L, <span class="keyword">int</span> R)&#123;</span><br><span class="line">    std::<span class="built_in">swap</span>( arr[L] , arr[<span class="built_in">rand</span>()%(R-L+<span class="number">1</span>)+L] );<span class="comment">// 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot</span></span><br><span class="line">    T key = arr[L]; <span class="comment">// 将arr[L]作为划分</span></span><br><span class="line">    <span class="keyword">int</span> cur = L+<span class="number">1</span>, less = L, more = R+<span class="number">1</span>; <span class="comment">// more 也可以写成R, 但是下面的程序要改</span></span><br><span class="line">    <span class="keyword">while</span>(cur &lt; more)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[cur] &lt; key)</span><br><span class="line">            std::<span class="built_in">swap</span>(arr[++less], arr[cur++]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(arr[cur] &gt; key)</span><br><span class="line">            std::<span class="built_in">swap</span>(arr[--more], arr[cur]); <span class="comment">// cur不能--</span></span><br><span class="line">        <span class="keyword">else</span>    </span><br><span class="line">            cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">swap</span>(arr[L], arr[less]);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>]&#123;less, more<span class="number">-1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> __quickSort3(T arr[], <span class="keyword">int</span> L, <span class="keyword">int</span> R)&#123;</span><br><span class="line">    <span class="keyword">if</span>( L &gt;= R )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span>* p = __partition3(arr, L, R);</span><br><span class="line">    __quickSort3(arr, L, p[<span class="number">0</span>]<span class="number">-1</span>);</span><br><span class="line">    __quickSort3(arr, p[<span class="number">1</span>]+<span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort3</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>)); <span class="comment">// 设置随机种子</span></span><br><span class="line">    __quickSort3(arr, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">2000</span>;</span><br><span class="line">    <span class="keyword">int</span> *arr1 = SortTestHelper::<span class="built_in">generateRandomArray</span>(n,<span class="number">0</span>,n);</span><br><span class="line">    <span class="comment">// SortTestHelper::testSort(&quot;BubbleSort&quot;, bubbleSort, arr1, n);</span></span><br><span class="line">    <span class="comment">// SortTestHelper::testSort(&quot;selectionSort&quot;, selectionSort, arr1, n);</span></span><br><span class="line">    <span class="comment">// SortTestHelper::testSort(&quot;insertSort&quot;, insertSort, arr1, n);</span></span><br><span class="line">    <span class="comment">// SortTestHelper::testSort(&quot;insertSort2&quot;, insertSort2, arr1, n);</span></span><br><span class="line">    <span class="comment">// SortTestHelper::testSort(&quot;mergeSort&quot;, mergeSort, arr1, n);</span></span><br><span class="line">    <span class="comment">// SortTestHelper::testSort(&quot;mergeSortBU&quot;, mergeSortBU, arr1, n);</span></span><br><span class="line">    <span class="comment">// SortTestHelper::testSort(&quot;quickSort1&quot;, quickSort1, arr1, n);</span></span><br><span class="line">    <span class="comment">// SortTestHelper::testSort(&quot;quickSort2&quot;, quickSort2, arr1, n);</span></span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;quickSort3&quot;</span>, quickSort3, arr1, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树模板题(Kruskal算法和Prim算法实现)</title>
    <url>/2022/03/26/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E6%A8%A1%E6%9D%BF%E9%A2%98(Kruskal%E7%AE%97%E6%B3%95%E5%92%8CPrim%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0)/</url>
    <content><![CDATA[<h2 id="最小生成树模板题-Kruskal算法和Prim算法实现"><a href="#最小生成树模板题-Kruskal算法和Prim算法实现" class="headerlink" title="最小生成树模板题(Kruskal算法和Prim算法实现)"></a>最小生成树模板题(Kruskal算法和Prim算法实现)</h2><ul>
<li><code>Kruskal</code>算法思想及流程</li>
<li><code>Prim</code>算法思想及流程: </li>
</ul>
<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1863">题目链接</a></h4><blockquote>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1863">http://acm.hdu.edu.cn/showproblem.php?pid=1863</a></p>
</blockquote>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><img src="images/tree1.png"></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p> 就是一个求最小生成树的模板题(<font color = blue>一般是无向图</font>)。</p>
<hr>
<h3 id="Kruskal算法思想及流程"><a href="#Kruskal算法思想及流程" class="headerlink" title="Kruskal算法思想及流程"></a><code>Kruskal</code>算法思想及流程</h3><ul>
<li>首先各个顶点看成一个集合，每个顶点的根就是自己；</li>
<li>从整个图中边的集合中取出<strong>最小</strong>的一条(一开始对边的集合排序)，判断该边的两个定点是不是同一个集合，如果不是，<strong>合并两个集合；</strong></li>
<li>如果是同一个集合，舍弃，继续取下一条边；</li>
<li>直到集合中有<code>n - 1</code>条边为止；</li>
</ul>
<p><strong>时间复杂度为为<font color =red>O(e<sup>2</sup>)</font>, 使用并查集优化后复杂度为 <font color = red>O（eloge）</font>，与网中的边数有关，适用于求边稀疏的网的最小生成树</strong></p>
<p><img src="images/tree2.png" alt="这里写图片描述"></p>
<p><strong>推荐写法</strong> </p>
<ul>
<li>建图和上面稍有不同，<code>kruskal</code>的特性只需要用到<code>Edge</code>这个类即可，对边集排序然后不断合并两个顶点即可；</li>
<li>这里并查集使用的数组，和上面有点不同，但是原理都是一样的；<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;Edge&gt; edges;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Edge</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> from;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> to;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> w;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.from = from;</span><br><span class="line">            <span class="keyword">this</span>.to = to;</span><br><span class="line">            <span class="keyword">this</span>.w = w;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Edge o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> w - o.w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionSet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] rank;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnionSet</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">            rank = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                parent[i] = i;</span><br><span class="line">                rank[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameSet</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (parent[v] != v) &#123;</span><br><span class="line">                parent[v] = parent[parent[v]];  <span class="comment">// 路径压缩优化</span></span><br><span class="line">                v = parent[v];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> aRoot = find(a);</span><br><span class="line">            <span class="keyword">int</span> bRoot = find(b);</span><br><span class="line">            <span class="keyword">if</span> (aRoot == bRoot)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (rank[aRoot] &lt; rank[bRoot]) &#123; <span class="comment">// a更矮,所以挂到b更好</span></span><br><span class="line">                parent[aRoot] = bRoot;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[aRoot] &gt; rank[bRoot]) &#123;</span><br><span class="line">                parent[bRoot] = aRoot;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent[aRoot] = bRoot;</span><br><span class="line">                rank[bRoot]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Collections.sort(edges);  <span class="comment">// 对边集排序</span></span><br><span class="line">        UnionSet uset = <span class="keyword">new</span> UnionSet(n);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> from = edges.get(i).from;</span><br><span class="line">            <span class="keyword">int</span> to = edges.get(i).to;</span><br><span class="line">            <span class="keyword">int</span> w = edges.get(i).w;</span><br><span class="line">            <span class="keyword">if</span> (!uset.isSameSet(from, to)) &#123; <span class="comment">//两个顶点不属于同一个集合</span></span><br><span class="line">                res += w;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span> (count == n - <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                uset.union(from, to);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count == n - <span class="number">1</span> ? res : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line">        <span class="keyword">while</span> (cin.hasNext()) &#123;</span><br><span class="line">            m = cin.nextInt(); <span class="comment">// 先输入道路条数</span></span><br><span class="line">            n = cin.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (m == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            edges = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> from = cin.nextInt();</span><br><span class="line">                <span class="keyword">int</span> to = cin.nextInt();</span><br><span class="line">                <span class="keyword">int</span> w = cin.nextInt();</span><br><span class="line">                edges.add(<span class="keyword">new</span> Edge(from, to, w));</span><br><span class="line">                edges.add(<span class="keyword">new</span> Edge(to, from, w));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> res = kruskal();</span><br><span class="line">            System.out.println(res == -<span class="number">1</span> ? <span class="string">&quot;?&quot;</span> : res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其他写法。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; <span class="comment">//提交时改成Main</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        ArrayList&lt;Node&gt; nexts;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            nexts = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> weight;</span><br><span class="line">        <span class="keyword">public</span> Node from;</span><br><span class="line">        <span class="keyword">public</span> Node to;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(Node from, Node to, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.from = from;</span><br><span class="line">            <span class="keyword">this</span>.to = to;</span><br><span class="line">            <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> HashMap&lt;Integer, Node&gt; nodes;</span><br><span class="line">        <span class="keyword">public</span> HashSet&lt;Edge&gt; edges;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            nodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            edges = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//并查集结构</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionSet</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> HashMap&lt;Node, Node&gt; faMap;</span><br><span class="line">        <span class="keyword">public</span> HashMap&lt;Node, Integer&gt; sizeMap;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnionSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            faMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            sizeMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Collection&lt;Node&gt; nodes)</span> </span>&#123;</span><br><span class="line">            faMap.clear();</span><br><span class="line">            sizeMap.clear();</span><br><span class="line">            <span class="keyword">for</span> (Node node : nodes) &#123;</span><br><span class="line">                faMap.put(node, node);</span><br><span class="line">                sizeMap.put(node, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Node <span class="title">findHead</span><span class="params">(Node v)</span> </span>&#123;</span><br><span class="line">            Node fa = faMap.get(v);</span><br><span class="line">            <span class="keyword">if</span> (fa != v) &#123;</span><br><span class="line">                fa = findHead(fa);</span><br><span class="line">            &#125;</span><br><span class="line">            faMap.put(v, fa); <span class="comment">//v的父改为根(沿途所有的)</span></span><br><span class="line">            <span class="keyword">return</span> fa;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameSet</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> findHead(a) == findHead(b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">            Node aF = findHead(a);</span><br><span class="line">            Node bF = findHead(b);</span><br><span class="line">            <span class="keyword">if</span> (aF == bF) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">int</span> aSize = sizeMap.get(a);</span><br><span class="line">            <span class="keyword">int</span> bSize = sizeMap.get(b);</span><br><span class="line">            <span class="keyword">if</span> (aSize &gt;= bSize) &#123;</span><br><span class="line">                faMap.put(bF, aF); <span class="comment">//把bF挂到aF下面</span></span><br><span class="line">                sizeMap.put(aF, aSize + bSize);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                faMap.put(aF, bF); <span class="comment">//把aF挂到bF下面</span></span><br><span class="line">                sizeMap.put(bF, aSize + bSize);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在优先级队列中按照边的权值升序排列</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Edge</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Edge o1, Edge o2)</span> </span>&#123; <span class="comment">//按照边的权重升序排列</span></span><br><span class="line">            <span class="keyword">return</span> o1.weight - o2.weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Set&lt;Edge&gt; <span class="title">kruskal</span><span class="params">(Graph graph)</span> </span>&#123;</span><br><span class="line">        UnionSet unionSet = <span class="keyword">new</span> UnionSet();</span><br><span class="line">        unionSet.init(graph.nodes.values()); <span class="comment">//初始化</span></span><br><span class="line">        PriorityQueue&lt;Edge&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;Edge&gt;(<span class="keyword">new</span> EdgeComparator());</span><br><span class="line">        <span class="keyword">for</span> (Edge edge : graph.edges) &#123;</span><br><span class="line">            priorityQueue.add(edge);</span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;Edge&gt; set = <span class="keyword">new</span> HashSet&lt;Edge&gt;();  <span class="comment">//保存这n-1条边</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!priorityQueue.isEmpty()) &#123;</span><br><span class="line">            Edge poll = priorityQueue.poll();</span><br><span class="line">            <span class="keyword">if</span> (!unionSet.isSameSet(poll.from, poll.to)) &#123;</span><br><span class="line">                set.add(poll);</span><br><span class="line">                cnt++;</span><br><span class="line">                unionSet.union(poll.from, poll.to);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt == graph.nodes.size() - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> set;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line">        <span class="keyword">while</span> (cin.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> n = cin.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            Graph G = <span class="keyword">new</span> Graph();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) G.nodes.put(i, <span class="keyword">new</span> Node(i));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> from = cin.nextInt();</span><br><span class="line">                <span class="keyword">int</span> to = cin.nextInt();</span><br><span class="line">                <span class="keyword">int</span> w = cin.nextInt();</span><br><span class="line">                G.edges.add(<span class="keyword">new</span> Edge(G.nodes.get(from), G.nodes.get(to), w));</span><br><span class="line">            &#125;</span><br><span class="line">            Set&lt;Edge&gt; set = kruskal(G);</span><br><span class="line">            <span class="keyword">if</span> (set.size() != n - <span class="number">1</span>) &#123; <span class="comment">//没有n-1条边  不足以保持畅通</span></span><br><span class="line">                System.out.println(<span class="string">&quot;?&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (Edge edge : set) &#123;</span><br><span class="line">                    sum += edge.weight;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="Prim算法思想及流程"><a href="#Prim算法思想及流程" class="headerlink" title="Prim算法思想及流程:"></a><code>Prim</code>算法思想及流程:</h3><ul>
<li>一开始也有一个集合，和<code>Kruskal</code>算法不同的是，这个不是慢慢的合并(通过并查集)变大，而是一个一个的添加结点；</li>
<li>一开始选择一个起点，有一个<font color =  red>优先队列</font>存放边的集合，<strong>把这个结点相连的边加入优先队列</strong>；</li>
<li>然后选择一条相连的且<strong>权值最小</strong>的边，<strong>并判断这条边的终点是否已经加入过点的集合(<font color = red>准确的来说是看这两个点相连的边是否已经加入过集合(但是这里是用两个端点都是否进过<code>vis</code>数组替代)</font>)，如果没有，就加入，并且把这条边加入到结果集，并且解锁和它相连的边(解锁就是把边加入到优先队列)</strong></li>
<li>如果出现过，<font color = blue>继续从优先队列中拿出最小的边判断</font>；</li>
<li>直到结果集达到<code>n-1</code>条边，或者图不连通；</li>
</ul>
<p><img src="images/tree3.png" alt="这里写图片描述"></p>
<p><strong>推荐写法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span>[] vis;</span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;Edge&gt;[] G;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Edge</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> to;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> w;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.to = to;</span><br><span class="line">            <span class="keyword">this</span>.w = w;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Edge o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> w - o.w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Edge&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[start].size(); i++)</span><br><span class="line">            pq.add(G[start].get(i));</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        vis[start] = <span class="keyword">true</span>; <span class="comment">// 起始节点已经在集合中</span></span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            Edge curEdge = pq.poll();</span><br><span class="line">            <span class="keyword">int</span> to = curEdge.to;</span><br><span class="line">            <span class="keyword">if</span> (!vis[to]) &#123;</span><br><span class="line">                vis[to] = <span class="keyword">true</span>;</span><br><span class="line">                count++;</span><br><span class="line">                res += curEdge.w;</span><br><span class="line">                <span class="keyword">if</span> (count == n - <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[to].size(); i++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> nxtNode = G[to].get(i).to;</span><br><span class="line">                    <span class="keyword">if</span> (!vis[nxtNode]) <span class="comment">// to -&gt; nxtNode 没有加入过</span></span><br><span class="line">                        pq.add(G[to].get(i)); <span class="comment">// 将to-&gt; nxtNode的边加入优先队列</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count != n - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line">        <span class="keyword">while</span> (cin.hasNext()) &#123;</span><br><span class="line">            m = cin.nextInt(); <span class="comment">// 先输入道路条数</span></span><br><span class="line">            n = cin.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (m == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            G = <span class="keyword">new</span> ArrayList[n + <span class="number">1</span>];  <span class="comment">// 1~n</span></span><br><span class="line">            vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                G[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> from = cin.nextInt();</span><br><span class="line">                <span class="keyword">int</span> to = cin.nextInt();</span><br><span class="line">                <span class="keyword">int</span> w = cin.nextInt();</span><br><span class="line">                G[from].add(<span class="keyword">new</span> Edge(to, w));</span><br><span class="line">                G[to].add(<span class="keyword">new</span> Edge(from, w));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> res = prim(<span class="number">1</span>);</span><br><span class="line">            System.out.println(res == -<span class="number">1</span> ? <span class="string">&quot;?&quot;</span> : res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其他写法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        ArrayList&lt;Edge&gt; edges; <span class="comment">//以这个点作为起点出发的边</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            edges = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> weight;</span><br><span class="line">        <span class="keyword">public</span> Node from;</span><br><span class="line">        <span class="keyword">public</span> Node to;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(Node from, Node to, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.from = from;</span><br><span class="line">            <span class="keyword">this</span>.to = to;</span><br><span class="line">            <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> HashMap&lt;Integer, Node&gt; nodes;</span><br><span class="line">        <span class="keyword">public</span> HashSet&lt;Edge&gt; edges;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            nodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            edges = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Edge</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Edge o1, Edge o2)</span> </span>&#123; <span class="comment">//按照边的权重升序排列</span></span><br><span class="line">            <span class="keyword">return</span> o1.weight - o2.weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Set&lt;Edge&gt; <span class="title">prim</span><span class="params">(Graph graph)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Edge&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> EdgeComparator());</span><br><span class="line">        HashSet&lt;Edge&gt; res = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        HashSet&lt;Node&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Node start = graph.nodes.get(<span class="number">1</span>); <span class="comment">//从第一个点开始</span></span><br><span class="line">        set.add(start);</span><br><span class="line">        <span class="keyword">for</span> (Edge edge : start.edges) &#123;</span><br><span class="line">            priorityQueue.add(edge);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!priorityQueue.isEmpty()) &#123;</span><br><span class="line">            Edge poll = priorityQueue.poll();</span><br><span class="line">            Node toNode = poll.to;   <span class="comment">//这条边的to点</span></span><br><span class="line">            <span class="keyword">if</span> (!set.contains(toNode)) &#123;</span><br><span class="line">                set.add(toNode);</span><br><span class="line">                res.add(poll);    <span class="comment">//注意这个不能放在if的上面</span></span><br><span class="line">                <span class="keyword">if</span> (res.size() == graph.nodes.size() - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">for</span> (Edge nextEdge : toNode.edges) &#123;</span><br><span class="line">                    priorityQueue.add(nextEdge);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Graph <span class="title">createGraph</span><span class="params">(Scanner in, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        Graph G = <span class="keyword">new</span> Graph();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) G.nodes.put(i, <span class="keyword">new</span> Node(i));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = in.nextInt();</span><br><span class="line">            <span class="keyword">int</span> b = in.nextInt();</span><br><span class="line">            <span class="keyword">int</span> w = in.nextInt();</span><br><span class="line">            Node from = G.nodes.get(a);</span><br><span class="line">            Node to = G.nodes.get(b);</span><br><span class="line">            Edge newEdge = <span class="keyword">new</span> Edge(from, to, w);</span><br><span class="line">            G.edges.add(newEdge);</span><br><span class="line">            from.edges.add(newEdge);  <span class="comment">//记得添加这条边</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> G;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line">        <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = in.nextInt();</span><br><span class="line">            <span class="keyword">int</span> n = in.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            Graph G = createGraph(in, n, m);</span><br><span class="line">            Set&lt;Edge&gt; set = prim(G);</span><br><span class="line">            <span class="keyword">if</span> (set.size() != n - <span class="number">1</span>) &#123; <span class="comment">//没有n-1条边  不足以保持畅通</span></span><br><span class="line">                System.out.println(<span class="string">&quot;?&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (Edge edge : set) &#123;</span><br><span class="line">                    sum += edge.weight;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Graph</tag>
        <tag>Kruskal</tag>
        <tag>Prim</tag>
      </tags>
  </entry>
  <entry>
    <title>图的基本结构以及BFS和DFS(递归和非递归)</title>
    <url>/2022/01/29/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8ABFS%E5%92%8CDFS(%E9%80%92%E5%BD%92%E5%92%8C%E9%9D%9E%E9%80%92%E5%BD%92)/</url>
    <content><![CDATA[<h2 id="图的基本结构以及BFS和DFS-递归和非递归"><a href="#图的基本结构以及BFS和DFS-递归和非递归" class="headerlink" title="图的基本结构以及BFS和DFS(递归和非递归)"></a>图的基本结构以及BFS和DFS(递归和非递归)</h2><ul>
<li>完整的图结构</li>
<li>有向图建图以及BFS和DFS</li>
<li>无向图建图以及BFS和DFS</li>
<li>DFS和BFS常见应用</li>
</ul>
<hr>
<h3 id="完整的图结构"><a href="#完整的图结构" class="headerlink" title="完整的图结构"></a>完整的图结构</h3><ul>
<li>图的每个顶点包括顶点的值、入度、出度、和<strong>它相邻的点(或者在有向图中就是下一个可以到达的点)的集合</strong>、以及<strong>以它为起点出发的边的集合；</strong></li>
<li>图的每条边包括边的权值、边的起点、边的终点；</li>
<li>一个图包括点的集合和边的集合；</li>
</ul>
<p>综上可以得到如下的图结构:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//点  (默认我是from的情况下)</span></span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">int</span> in; <span class="comment">//入度</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">int</span> out; <span class="comment">//出度</span></span><br><span class="line">       <span class="keyword">public</span> ArrayList&lt;Node&gt;nexts;<span class="comment">// 从我出发能到达的下一级结点，就是邻居结点  可以有多个(邻居)(跳一步)	</span></span><br><span class="line">       <span class="keyword">public</span> ArrayList&lt;Edge&gt;edges;<span class="comment">//我是from的情况下，从我出发，发散出边的集合</span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.value = value;</span><br><span class="line">           in = <span class="number">0</span>;</span><br><span class="line">           out = <span class="number">0</span>;</span><br><span class="line">           nexts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           edges = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//边</span></span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span></span>&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">int</span> weight;</span><br><span class="line">       <span class="keyword">public</span> Node from;</span><br><span class="line">       <span class="keyword">public</span> Node to;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">( Node from, Node to, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.from = from;</span><br><span class="line">           <span class="keyword">this</span>.to = to;</span><br><span class="line">           <span class="keyword">this</span>.weight = weight;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//图</span></span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span>&#123;</span><br><span class="line">       HashMap&lt;Integer,Node&gt;nodes; <span class="comment">// 点的编号,以及实际对应的node</span></span><br><span class="line">       HashSet&lt;Edge&gt;edges;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           nodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">           edges = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="有向图建图以及BFS和DFS"><a href="#有向图建图以及BFS和DFS" class="headerlink" title="有向图建图以及BFS和DFS"></a>有向图建图以及BFS和DFS</h3><p>这里使用一个二维矩阵来表示图(<strong>每一行都代表输入一条边</strong>)，第一列表示的是边的起点、第二列是边的终点、第三列是边的权值。如下例子: </p>
<p><img src="images/p1.png" alt="这里写图片描述"></p>
<p>使用上面的例子来建图并进行BFS(广度遍历)和DFS(深度遍历)的代码如下: (<strong>在遍历的过程中边的集合几乎用不到</strong>)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完整的图的结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//点</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> in; <span class="comment">//入度</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> out; <span class="comment">//出度</span></span><br><span class="line">        <span class="keyword">public</span> ArrayList&lt;Node&gt; nexts;</span><br><span class="line">        <span class="keyword">public</span> ArrayList&lt;Edge&gt; edges;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            in = <span class="number">0</span>;</span><br><span class="line">            out = <span class="number">0</span>;</span><br><span class="line">            nexts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            edges = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//边</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> weight;</span><br><span class="line">        <span class="keyword">public</span> Node from;</span><br><span class="line">        <span class="keyword">public</span> Node to;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(Node from, Node to, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.from = from;</span><br><span class="line">            <span class="keyword">this</span>.to = to;</span><br><span class="line">            <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//图</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Node&gt; nodes;</span><br><span class="line">        HashSet&lt;Edge&gt; edges;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            nodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            edges = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Graph <span class="title">createGraph</span><span class="params">(Integer[][] matrix)</span> </span>&#123;</span><br><span class="line">        Graph graph = <span class="keyword">new</span> Graph();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            Integer from = matrix[i][<span class="number">0</span>];</span><br><span class="line">            Integer to = matrix[i][<span class="number">1</span>];</span><br><span class="line">            Integer weight = matrix[i][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!graph.nodes.containsKey(from)) graph.nodes.put(from, <span class="keyword">new</span> Node(from));</span><br><span class="line">            <span class="keyword">if</span> (!graph.nodes.containsKey(to)) graph.nodes.put(to, <span class="keyword">new</span> Node(to));</span><br><span class="line"></span><br><span class="line">            Node fromNode = graph.nodes.get(from);</span><br><span class="line">            Node toNode = graph.nodes.get(to);</span><br><span class="line"></span><br><span class="line">            fromNode.nexts.add(toNode);<span class="comment">//有向图</span></span><br><span class="line">            fromNode.out++;</span><br><span class="line">            toNode.in++;</span><br><span class="line"></span><br><span class="line">            Edge newEdge = <span class="keyword">new</span> Edge(fromNode, toNode, weight);</span><br><span class="line">            fromNode.edges.add(newEdge);</span><br><span class="line">            graph.edges.add(newEdge);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> graph;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        Queue&lt;Node&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        HashSet&lt;Node&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">//相当于记录是否访问过</span></span><br><span class="line">        que.add(node);</span><br><span class="line">        set.add(node);</span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            Node cur = que.poll();</span><br><span class="line">            System.out.print(cur.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Node next : cur.nexts) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!set.contains(next)) &#123;</span><br><span class="line">                    set.add(next);</span><br><span class="line">                    que.add(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归的</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(Node node, HashSet&lt;Node&gt; set)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        set.add(node);</span><br><span class="line">        System.out.print(node.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Node next : node.nexts) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(next)) dfs1(next, set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非递归的</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        HashSet&lt;Node&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        stack.push(node);</span><br><span class="line">        System.out.print(node.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        set.add(node);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            Node cur = stack.pop();</span><br><span class="line">            <span class="keyword">for</span> (Node next : cur.nexts) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!set.contains(next)) &#123;</span><br><span class="line">                    stack.push(cur); <span class="comment">//注意这个也要入栈</span></span><br><span class="line">                    stack.push(next);</span><br><span class="line">                    set.add(next);</span><br><span class="line">                    System.out.print(next.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每一列分别代表的是    边的 起点,终点,和权值</span></span><br><span class="line">        Integer[][] martix = &#123;</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;,</span><br><span class="line">                &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>&#125;,</span><br><span class="line">                &#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>&#125;,</span><br><span class="line">                &#123;<span class="number">2</span>, <span class="number">8</span>, <span class="number">2</span>&#125;,</span><br><span class="line">                &#123;<span class="number">3</span>, <span class="number">7</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;,</span><br><span class="line">                &#123;<span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">        Graph G = createGraph(martix);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------BFS-----------&quot;</span>);</span><br><span class="line">        bfs(G.nodes.get(<span class="number">1</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;----------DFS-----------&quot;</span>);</span><br><span class="line">        dfs1(G.nodes.get(<span class="number">1</span>), <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;----------DFS-----------&quot;</span>);</span><br><span class="line">        dfs2(G.nodes.get(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>BFS就是按照到起点的距离(按层次)遍历; </li>
<li>DFS就是只要某个结点可以往下走，就一直走下去(一条路走到黑)，走不了了再回溯回来;</li>
<li>其中非递归的DFS使用栈完成，注意，<strong>访问某个结点的<code>next</code>结点集合的时候，只访问一个，然后结点本身还是要先入栈;</strong> </li>
<li>BFS和DFS都要记录某个结点是否已经被访问过; </li>
</ul>
<p>上面例子的遍历结果: </p>
<p><img src="images/p2.png" alt="这里写图片描述"></p>
<hr>
<h3 id="无向图建图以及BFS和DFS"><a href="#无向图建图以及BFS和DFS" class="headerlink" title="无向图建图以及BFS和DFS"></a>无向图建图以及BFS和DFS</h3><p>无向图和有向图的区别就是<strong>度没有出度和入度之分，结点的<code>nexts</code>域、和结点相邻的边集要相互的添加</strong>；<br>看下图的例子: </p>
<p><img src="images/p3.png" alt="这里写图片描述"></p>
<p>建图以及BFS和DFS遍历如下: (这里省去了边的集合)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无向图BFS和DFS</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BFS_DFS</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> ArrayList&lt;Node&gt; nexts;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            nexts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Node&gt; nodes;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            nodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建一个无向图</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line">        <span class="keyword">while</span> (cin.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> m = cin.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            Graph G = <span class="keyword">new</span> Graph();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> a = cin.nextInt();</span><br><span class="line">                <span class="keyword">int</span> b = cin.nextInt();</span><br><span class="line">                <span class="keyword">if</span> (!G.nodes.containsKey(a)) G.nodes.put(a, <span class="keyword">new</span> Node(a));</span><br><span class="line">                <span class="keyword">if</span> (!G.nodes.containsKey(b)) G.nodes.put(b, <span class="keyword">new</span> Node(b));</span><br><span class="line">                Node from = G.nodes.get(a);</span><br><span class="line">                Node to = G.nodes.get(b);</span><br><span class="line">                from.nexts.add(to);</span><br><span class="line">                to.nexts.add(from); <span class="comment">//无向图</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;---------------BFS----------------&quot;</span>);</span><br><span class="line">            bfs(G.nodes.get(<span class="number">1</span>)); <span class="comment">// 从某个结点开始BFS遍历</span></span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(<span class="string">&quot;---------------DFS----------------&quot;</span>);</span><br><span class="line">            dfs1(G.nodes.get(<span class="number">1</span>), <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(<span class="string">&quot;---------------DFS----------------&quot;</span>);</span><br><span class="line">            dfs2(G.nodes.get(<span class="number">1</span>));</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Queue&lt;Node&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        HashSet&lt;Node&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">//相当于记录是否访问过</span></span><br><span class="line">        que.add(node);</span><br><span class="line">        set.add(node);</span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            Node cur = que.poll();</span><br><span class="line">            System.out.print(cur.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Node next : cur.nexts) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!set.contains(next)) &#123;</span><br><span class="line">                    set.add(next);</span><br><span class="line">                    que.add(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归的</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(Node node, HashSet&lt;Node&gt; set)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        set.add(node);</span><br><span class="line">        System.out.print(node.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Node next : node.nexts) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(next)) dfs1(next, set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非递归的</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        HashSet&lt;Node&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        stack.push(node);</span><br><span class="line">        System.out.print(node.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        set.add(node);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            Node cur = stack.pop();</span><br><span class="line">            <span class="keyword">for</span> (Node next : cur.nexts) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!set.contains(next)) &#123;</span><br><span class="line">                    stack.push(cur); <span class="comment">//注意这个也要入栈</span></span><br><span class="line">                    stack.push(next);</span><br><span class="line">                    set.add(next);</span><br><span class="line">                    System.out.print(next.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历结果</p>
<p><img src="images/p4.png" alt="这里写图片描述"></p>
<hr>
<h3 id="DFS和BFS常见应用"><a href="#DFS和BFS常见应用" class="headerlink" title="DFS和BFS常见应用"></a>DFS和BFS常见应用</h3><p><code>DFS</code> :  求一个图的连通分量以及判断两个点是否可通，以及求出任意一条路径；<br><code>DFS</code>：求最短路径；</p>
<p>代码：（未测试）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无权图</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseGraph</span> </span>&#123; <span class="comment">// 稀疏图</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> n; <span class="comment">// vertex num</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> m; <span class="comment">// edge num</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> directed; <span class="comment">// is a directed graph</span></span><br><span class="line">        <span class="keyword">public</span> ArrayList&lt;Integer&gt;[] g;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">boolean</span> directed)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.n = n;</span><br><span class="line">            <span class="keyword">this</span>.m = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">this</span>.directed = directed;</span><br><span class="line">            g = <span class="keyword">new</span> ArrayList[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                g[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">            g[from].add(to);</span><br><span class="line">            <span class="keyword">if</span> (from != to &amp;&amp; !directed) <span class="comment">// 自环, 无向图</span></span><br><span class="line">                g[to].add(from);</span><br><span class="line">            m++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// from to is connected</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">hasEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[from].size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[from].get(i) == to)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求一个图的连通分量以及　判断两个点是否可通</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Graph G;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span>[] vis;  <span class="comment">// 记录dfs的过程中节点是否被访问</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] id;        <span class="comment">// 每个节点所对应的联通分量标记</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Component</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.G = G;</span><br><span class="line">            vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.n];</span><br><span class="line">            id = <span class="keyword">new</span> <span class="keyword">int</span>[G.n];</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.n; i++) &#123;</span><br><span class="line">                vis[i] = <span class="keyword">false</span>;</span><br><span class="line">                id[i] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回连通分量</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.n; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G.g[i].size(); j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!vis[j])&#123;</span><br><span class="line">                        dfs(j);</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">            vis[v] = <span class="keyword">true</span>;</span><br><span class="line">            id[v] = count; <span class="comment">// 当前节点在第count个连通分量</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.g[v].size(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!vis[i])</span><br><span class="line">                    dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> id[i] == id[j]; <span class="comment">// 判断两个点所属连通分量是不是同一个</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用dfs获取路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Path</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Graph G;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span>[] vis;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] pre; <span class="comment">// 记录路径, pre[i]表示查找的路径上i的上一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Path</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.G = G;</span><br><span class="line">            vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.n];</span><br><span class="line">            pre = <span class="keyword">new</span> <span class="keyword">int</span>[G.n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.n; i++)&#123;</span><br><span class="line">                vis[i] = <span class="keyword">false</span>;</span><br><span class="line">                pre[i] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">            vis[v] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.g[i].size(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">                    pre[i] = v; <span class="comment">// is important</span></span><br><span class="line">                    dfs(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">getPath</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">            dfs(start);</span><br><span class="line">            <span class="keyword">if</span>(!vis[end])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// no path</span></span><br><span class="line">            Stack&lt;Integer&gt;stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> p = end;</span><br><span class="line">            <span class="keyword">while</span>(p != -<span class="number">1</span>)&#123;</span><br><span class="line">                stack.push(p);</span><br><span class="line">                p = pre[p];</span><br><span class="line">            &#125;</span><br><span class="line">            ArrayList&lt;Integer&gt;res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty())</span><br><span class="line">                res.add(stack.pop());</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用BFS求最短路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortestPath</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Graph G;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span>[] vis;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] pre;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ShortestPath</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.G = G;</span><br><span class="line">            vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.n];</span><br><span class="line">            pre = <span class="keyword">new</span> <span class="keyword">int</span>[G.n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.n; i++)&#123;</span><br><span class="line">                vis[i] = <span class="keyword">false</span>;</span><br><span class="line">                pre[i] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取从s到所有顶点的最短路径</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] getShortestPath(<span class="keyword">int</span> start)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[G.n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.n; i++) dist[i] = -<span class="number">1</span>;</span><br><span class="line">            Queue&lt;Integer&gt;queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            queue.add(start);</span><br><span class="line">            vis[start] = <span class="keyword">true</span>;</span><br><span class="line">            dist[start] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">int</span> cur = queue.poll();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.g[cur].size(); i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">                        queue.add(i);</span><br><span class="line">                        vis[i] = <span class="keyword">true</span>;</span><br><span class="line">                        pre[i] = cur;</span><br><span class="line">                        dist[i] = dist[cur]+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">            vis[v] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.g[i].size(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">                    pre[i] = v; <span class="comment">// is important</span></span><br><span class="line">                    dfs(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">getPath</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">            dfs(start);</span><br><span class="line">            <span class="keyword">if</span>(!vis[end])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// no path</span></span><br><span class="line">            Stack&lt;Integer&gt;stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> p = end;</span><br><span class="line">            <span class="keyword">while</span>(p != -<span class="number">1</span>)&#123;</span><br><span class="line">                stack.push(p);</span><br><span class="line">                p = pre[p];</span><br><span class="line">            &#125;</span><br><span class="line">            ArrayList&lt;Integer&gt;res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty())</span><br><span class="line">                res.add(stack.pop());</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Graph</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>最长公共子序列LCS 和 最长公众子串</title>
    <url>/2022/01/15/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97LCS%20%E5%92%8C%20%E6%9C%80%E9%95%BF%E5%85%AC%E4%BC%97%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="最长公共子序列LCS-和-最长公众子串"><a href="#最长公共子序列LCS-和-最长公众子串" class="headerlink" title="最长公共子序列LCS 和 最长公众子串"></a>最长公共子序列LCS 和 最长公众子串</h2><ul>
<li><a href="#51nod-1006-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97lcs">51Nod-1006-最长公共子序列LCS</a></li>
<li><a href="#%E6%9C%80%E9%95%BF%E5%85%AC%E4%BC%97%E5%AD%90%E4%B8%B2">最长公众子串</a></li>
</ul>
<hr>
<h3 id="51Nod-1006-最长公共子序列LCS"><a href="#51Nod-1006-最长公共子序列LCS" class="headerlink" title="51Nod-1006-最长公共子序列LCS"></a><font color =red id = "1">51Nod-1006-最长公共子序列LCS</h3><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="http://www.51nod.com/Challenge/Problem.html#!#problemId=1006">题目链接</a></h4><blockquote>
<p><a href="http://www.51nod.com/Challenge/Problem.html#!#problemId=1006">http://www.51nod.com/Challenge/Problem.html#!#problemId=1006</a></p>
</blockquote>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>就是输入两个字符串<code>str1</code>、<code>str2</code>，输出任意一个最长公共子序列。</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p><code>dp[i][j]</code>代表的是 : 必须以<code>str1[i]</code>、<code>str2[j]</code>结尾的最长公共子序列，<code>dp[i][j]</code>来源: </p>
<ul>
<li>可能是<code>dp[i-1][j]</code>，代表<code>str1[0~i-1]</code>与<code>str2[0~j]</code>的最长公共子序列。</li>
<li>可能是<code>dp[i][j-1]</code>，代表<code>str1[0~i]</code>与<code>str2[0~j-1]</code>的最长公共子序列。</li>
<li>如果<code>str1[i] == str2[j]</code>，还可能是<code>dp[i-1][j-1] + 1</code>。</li>
</ul>
<p>这三种情况中取最大值。</p>
<p><img src="images/dp1.png" alt="在这里插入图片描述"></p>
<p>构造结果的过程(利用<code>dp</code>数组即可)</p>
<ul>
<li>从矩阵的右下角开始，有三种移动方式: <font color = blue>向上、向左、向左上。</font></li>
<li>如果<code>dp[i][j] &gt; dp[i-1][j] &amp;&amp; dp[i][j] &gt; dp[i][j-1]</code>，说明之前在计算<code>dp[i][j]</code>的时候，一定是选择了<code>dp[i-1][j-1]+1</code>，所以可以确定<code>str1[i] = str2[j]</code>，并且这个字符一定输入最长公共子序列，把这个字符放进结果字符串，然后向左上方移动；</li>
<li>如果<code>dp[i][j] == dp[i-1][j]</code>，说明之前计算<code>dp[i][j]</code>的时候，<code>dp[i-1][j-1]+1</code>不是必须的选择，向 <font color = blue>上方</fonT>移动即可；</li>
<li> 如果<code>dp[i][j] == dp[i][j-1]</code>，向 <font color = blue>左方</fonT>移动即可；</li>
<li>如果<code>dp[i][j]</code>同时等于<code>dp[i-1][j]</code>和<code>dp[i][j-1]</code>，向上向左都可以，选择一个即可，不会错过必须选择的字符；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** dp[i][j]代表的是 str[0..i]与str[0...j]的最长公共子序列*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] getDp(<span class="keyword">char</span>[] sa,<span class="keyword">char</span>[] sb)&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[sa.length][sb.length];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = sa[<span class="number">0</span>] == sb[<span class="number">0</span>] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sa.length; i++)  <span class="comment">// 一旦dp[i][0]被设置成1,则dp[i~N-1][0]都为1</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>], sa[i] == sb[<span class="number">0</span>] ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; sb.length; j++)</span><br><span class="line">            dp[<span class="number">0</span>][j] = Math.max(dp[<span class="number">0</span>][j-<span class="number">1</span>], sb[j] == sa[<span class="number">0</span>] ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sa.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; sb.length; j++)&#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(sa[i] == sb[j])&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j],dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** 求出最长公共子序列*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getLCS</span><span class="params">(String sa, String sb, <span class="keyword">int</span>[][] dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sa == <span class="keyword">null</span> || sb == <span class="keyword">null</span> || sa.equals(<span class="string">&quot;&quot;</span>) || sb.equals(<span class="string">&quot;&quot;</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chs1 = sa.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] chs2 = sb.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> i = chs1.length - <span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">int</span> j = chs2.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>[] res = <span class="keyword">new</span> <span class="keyword">char</span>[dp[i][j]]; <span class="comment">//生成答案的数组</span></span><br><span class="line">        <span class="keyword">int</span> index = dp[i][j] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(index &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; dp[i][j] == dp[i-<span class="number">1</span>][j])&#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j &gt; <span class="number">0</span> &amp;&amp; dp[i][j] == dp[i][j-<span class="number">1</span>])&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">// dp[i][j] = dp[i-1][j-1]+1</span></span><br><span class="line">                res[index--] = chs1[i];</span><br><span class="line">                i--;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line">        String sa = cin.next();</span><br><span class="line">        String sb = cin.next();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = getDp(sa.toCharArray(), sb.toCharArray());</span><br><span class="line"><span class="comment">//        System.out.println(dp[sa.length()-1][sb.length()-1]); //length of lcs</span></span><br><span class="line">        System.out.println(getLCS(sa, sb, dp));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="最长公众子串"><a href="#最长公众子串" class="headerlink" title="最长公众子串"></a><font color =red id = "2">最长公众子串</h3><h4 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a><a href="https://www.nowcoder.com/questionTerminal/02e7cc263f8a49e8b1e1dc9c116f7602?toCommentId=1532408">题目链接</a></h4><blockquote>
<p><a href="https://www.nowcoder.com/questionTerminal/02e7cc263f8a49e8b1e1dc9c116f7602?toCommentId=1532408">https://www.nowcoder.com/questionTerminal/02e7cc263f8a49e8b1e1dc9c116f7602?toCommentId=1532408</a></p>
</blockquote>
<h4 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h4><ul>
<li><code>dp</code>矩阵第一列即<code>dp[0~N-1][0]</code>，对某一个位置<code>(i,0)</code>来说，如果<code>str1[i] == str2[0]</code>，令<code>dp[i][0] = 1</code>，否则令<code>dp[i][0] = 0</code>；</li>
<li>矩阵<code>dp</code>第一行，即<code>dp[0][0~M-1]</code>，对某个位置<code>(0,j)</code>来说，如果<code>str1[0] == str2[j]</code>，令<code>dp[0][j] = 1</code>，否则令<code>dp[0][j] = 0</code>；</li>
<li>一般的位置有两种情况，如果<code>str1[i] != str2[j]</code>，说明在必须把<code>str1[i]</code>和<code>str2[j]</code>当做公共子串最后一个字符是不可能的，所以<code>dp[i][j] = 0</code>； 如果<code>str1[i] = str2[j]</code>，说明可以将<code>str1[i]</code>和<code>str2[j]</code>作为公共子串的最后一个字符，其长度就是<code>dp[i-1][j-1] + 1</code>；</li>
</ul>
<p><img src="images/dp2.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestSubstring</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLongest</span><span class="params">(String A, <span class="keyword">int</span> n, String B, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] sa = A.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] sb = B.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[sa.length][sb.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sa.length; i++) <span class="comment">//注意和最长公共子序列有点不同</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = sa[i] == sb[<span class="number">0</span>] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sb.length; j++)</span><br><span class="line">            dp[<span class="number">0</span>][j] = sa[<span class="number">0</span>] == sb[j] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sa.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; sb.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(sa[i] == sb[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    res = Math.max(res, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;  <span class="comment">//dp数组中的最大值，就是最大公共字串的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由<code>dp</code>表生成答案字符串也是不难的，找到最大值，然后往左边的<code>res</code>个字符就是答案。</p>
<p>测试程序: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LCSub</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] getDp(<span class="keyword">char</span>[] sa,<span class="keyword">char</span>[] sb)&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[sa.length][sb.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sa.length; i++) <span class="comment">//注意和最长公共子序列有点不同</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = sa[i] == sb[<span class="number">0</span>] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sb.length; j++)</span><br><span class="line">            dp[<span class="number">0</span>][j] = sa[<span class="number">0</span>] == sb[j] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sa.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; sb.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(sa[i] == sb[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    res = Math.max(res, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);  <span class="comment">//4</span></span><br><span class="line">        <span class="keyword">return</span> dp;  <span class="comment">//dp数组中的最大值，就是最大公共字串的长度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 根据dp表得到答案*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getLongestSubstring</span><span class="params">(String sa, String sb, <span class="keyword">int</span>[][] dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sa == <span class="keyword">null</span> || sb == <span class="keyword">null</span> || sa.length() == <span class="number">0</span> || sb.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dp[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &gt; max)&#123;</span><br><span class="line">                    max = dp[i][j];</span><br><span class="line">                    end = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sa.substring(end - max + <span class="number">1</span>, end+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String sa = <span class="string">&quot;abcdefq&quot;</span>;</span><br><span class="line">        String sb = <span class="string">&quot;cdefab&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = getDp(sa.toCharArray(), sb.toCharArray()); </span><br><span class="line">        System.out.println(getLongestSubstring(sa, sb, dp)); <span class="comment">// cdef</span></span><br><span class="line">        System.out.println(getLongestSubstring(sa, sb, dp).length()); <span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>另外，还有一种可以优化空间的做法:</p>
<ul>
<li>因为<code>dp[i][j]</code>只依赖于左上角位置的<code>dp[i-1][j-1]</code>，所以用一个变量记录左上角的值即可。</li>
<li>遍历方向从右上角的斜线开始，一直遍历到左下角，中间记录最大值<code>max</code>和结束位置<code>end</code>即可。<br><img src="images/dp3.png" alt="在这里插入图片描述"></li>
</ul>
<p>代码如下: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getLongestSubstring2</span><span class="params">(String sa,String sb)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sa == <span class="keyword">null</span> || sb == <span class="keyword">null</span> || sa.length() == <span class="number">0</span> || sb.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span>[] chs1 = sa.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] chs2 = sb.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>, col = chs2.length-<span class="number">1</span>; <span class="comment">//从右上角开始</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>, end = <span class="number">0</span>; <span class="comment">//记录最大长度和结束位置</span></span><br><span class="line">    <span class="keyword">while</span>(row &lt; chs1.length)&#123;</span><br><span class="line">        <span class="keyword">int</span> i = row, j = col;</span><br><span class="line">        <span class="keyword">int</span> ul = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; chs1.length &amp;&amp; j &lt; chs2.length)&#123; <span class="comment">//从(i,j)向右下方开始遍历</span></span><br><span class="line">            <span class="keyword">if</span>(chs1[i] == chs2[j])</span><br><span class="line">                ul++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ul = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(ul &gt; max)&#123; <span class="comment">//记录最大值以及结尾字符的位置</span></span><br><span class="line">                max = ul;</span><br><span class="line">                end = i;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(col &gt; <span class="number">0</span>) <span class="comment">// 斜线还没到最左边 --&gt;　往左移动</span></span><br><span class="line">            col--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            row++;  <span class="comment">//到了最左  --&gt; 往下移动</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(max);</span><br><span class="line">    <span class="keyword">return</span> sa.substring(end-max+<span class="number">1</span>, end+<span class="number">1</span>); <span class="comment">// [end-max+1, end]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵相关操作和矩阵快速幂</title>
    <url>/2022/05/06/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E5%92%8C%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    <content><![CDATA[<h2 id="矩阵相关操作和矩阵快速幂"><a href="#矩阵相关操作和矩阵快速幂" class="headerlink" title="矩阵相关操作和矩阵快速幂"></a>矩阵相关操作和矩阵快速幂</h2><ul>
<li>矩阵基本运算以及快速幂模板</li>
<li>POJ - 3070. Fibonacci</li>
<li>Hdu - 1757A. Simple Math Problem</li>
<li>Codeforces - 185A. Plant</li>
</ul>
<hr>
<h3 id="矩阵基本运算以及快速幂模板"><a href="#矩阵基本运算以及快速幂模板" class="headerlink" title="矩阵基本运算以及快速幂模板"></a>矩阵基本运算以及快速幂模板</h3><p>先看一下矩阵的乘法规则: </p>
<p><img src="images/m1.png" alt="在这里插入图片描述"></p>
<h5 id="直接给出一个模板题，直接包含了基本的乘法和求幂，求幂的详细解释，可以看这篇乘法快速幂。"><a href="#直接给出一个模板题，直接包含了基本的乘法和求幂，求幂的详细解释，可以看这篇乘法快速幂。" class="headerlink" title="直接给出一个模板题，直接包含了基本的乘法和求幂，求幂的详细解释，可以看这篇乘法快速幂。"></a><font color = red>直接给出一个模板题，直接包含了基本的乘法和求幂，求幂的详细解释，可以看这篇<a href="https://blog.csdn.net/zxzxzx0119/article/details/82816131">乘法快速幂</a>。</font></h5><h4 id="题目来源-XYNU-OJ"><a href="#题目来源-XYNU-OJ" class="headerlink" title="题目来源: XYNU OJ"></a>题目来源: XYNU OJ</h4><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><img src="images/m2.png" alt="在这里插入图片描述"></p>
<p>注意: </p>
<ul>
<li>矩阵的乘法必须满足第一个矩阵的列 = 第二个矩阵的行；</li>
<li>矩阵的求幂必须满足矩阵是一个方阵；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> row;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> col;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[][] m;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Matrix</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.row = row;</span><br><span class="line">            <span class="keyword">this</span>.col = col;</span><br><span class="line">            m = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个矩阵相加  --&gt;  a,b必须为 同型矩阵</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Matrix <span class="title">add</span><span class="params">(Matrix a, Matrix b)</span> </span>&#123;</span><br><span class="line">        Matrix c = <span class="keyword">new</span> Matrix(a.row, a.col);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.col; j++) &#123;</span><br><span class="line">                c.m[i][j] = a.m[i][j] + b.m[i][j]; <span class="comment">// sub 减法换成-</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须满足a.col = b.row  才能相乘</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Matrix <span class="title">mul</span><span class="params">(Matrix a, Matrix b)</span> </span>&#123;</span><br><span class="line">        Matrix c = <span class="keyword">new</span> Matrix(a.row, b.col); <span class="comment">//注意这里</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.col; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; a.col; k++)</span><br><span class="line">                    c.m[i][j] = c.m[i][j] + a.m[i][k] * b.m[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须为 方阵才能 求幂</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Matrix <span class="title">pow</span><span class="params">(Matrix a, <span class="keyword">int</span> k)</span> </span>&#123; <span class="comment">// 矩阵 a 的 k次幂</span></span><br><span class="line">        Matrix res = <span class="keyword">new</span> Matrix(a.row, a.col);  <span class="comment">//求幂必须满足 a.row = a.col(也就是方阵)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.row; i++)</span><br><span class="line">            res.m[i][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 真正的快速幂</span></span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((k &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">                res = mul(res, a);</span><br><span class="line">            a = mul(a, a);</span><br><span class="line">            k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = cin.nextInt();</span><br><span class="line">        <span class="keyword">int</span> k = cin.nextInt();</span><br><span class="line"></span><br><span class="line">        Matrix a = <span class="keyword">new</span> Matrix(n, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                a.m[i][j] = cin.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Matrix res = pow(a, k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == n - <span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.println(res.m[i][j]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.print(res.m[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="POJ-3070-Fibonacci"><a href="#POJ-3070-Fibonacci" class="headerlink" title="POJ - 3070. Fibonacci"></a>POJ - 3070. Fibonacci</h3><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="http://poj.org/problem?id=3070">题目链接</a></h4><blockquote>
<p><a href="http://poj.org/problem?id=3070">http://poj.org/problem?id=3070</a></p>
</blockquote>
<h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p><img src="images/m3.png" alt="在这里插入图片描述"></p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>关键在于推导出递推式，也就是左边是一个<code>A</code>矩阵，<code>B</code>一般是一个列向量；<br><img src="images/m4.png" alt="在这里插入图片描述"></p>
<p>类似的规律: </p>
<p><img src="images/m5.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Matrix</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> row;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> col;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[][] m;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Matrix</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.row = row;</span><br><span class="line">            <span class="keyword">this</span>.col = col;</span><br><span class="line">            m = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> mod = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Matrix <span class="title">mul</span><span class="params">(Matrix a,Matrix b)</span></span>&#123;</span><br><span class="line">        Matrix c = <span class="keyword">new</span> Matrix(a.row,b.col); <span class="comment">//注意这里</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.col; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; a.col; k++)</span><br><span class="line">                    c.m[i][j] = (c.m[i][j] + a.m[i][k]*b.m[k][j]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Matrix <span class="title">pow</span><span class="params">(Matrix a,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        Matrix res = <span class="keyword">new</span> Matrix(a.row,a.col); <span class="comment">// 方阵</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.row; i++)</span><br><span class="line">            res.m[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (k&amp;<span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">                res = mul(res,a);</span><br><span class="line">            a = mul(a,a);</span><br><span class="line">            k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cin.hasNext())&#123;</span><br><span class="line">            <span class="keyword">int</span> n = cin.nextInt();</span><br><span class="line">            <span class="keyword">if</span>( n == -<span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Matrix a = <span class="keyword">new</span> Matrix(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">            a.m[<span class="number">0</span>][<span class="number">0</span>] = a.m[<span class="number">0</span>][<span class="number">1</span>] = a.m[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            a.m[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            Matrix res = pow(a,n-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(res.m[<span class="number">0</span>][<span class="number">0</span>] % mod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Hdu-1757A-Simple-Math-Problem"><a href="#Hdu-1757A-Simple-Math-Problem" class="headerlink" title="Hdu - 1757A. Simple Math Problem"></a>Hdu - 1757A. Simple Math Problem</h3><h4 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1757">题目链接</a></h4><blockquote>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1757">http://acm.hdu.edu.cn/showproblem.php?pid=1757</a></p>
</blockquote>
<h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p><img src="images/m6.png" alt="在这里插入图片描述"></p>
<h4 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h4><p><img src="images/m7.png" alt="在这里插入图片描述"><br>继续递推: </p>
<p><img src="images/m8.png" alt="这里写图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Matrix</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> row;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> col;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[][] m;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Matrix</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.row = row;</span><br><span class="line">            <span class="keyword">this</span>.col = col;</span><br><span class="line">            m = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Matrix <span class="title">mul</span><span class="params">(Matrix a,Matrix b,<span class="keyword">int</span> mod)</span></span>&#123;</span><br><span class="line">        Matrix c = <span class="keyword">new</span> Matrix(a.row,b.col); <span class="comment">//注意这里</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.col; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; a.col; k++)</span><br><span class="line">                    c.m[i][j] = (c.m[i][j] + a.m[i][k]*b.m[k][j]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Matrix <span class="title">pow</span><span class="params">(Matrix a,<span class="keyword">int</span> k,<span class="keyword">int</span> mod)</span></span>&#123;</span><br><span class="line">        Matrix res = <span class="keyword">new</span> Matrix(a.row,a.col); <span class="comment">// 方阵</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.row; i++)</span><br><span class="line">            res.m[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (k&amp;<span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">                res = mul(res,a,mod);</span><br><span class="line">            a = mul(a,a,mod);</span><br><span class="line">            k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cin.hasNext())&#123;</span><br><span class="line">            <span class="keyword">int</span> k = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> mod = cin.nextInt();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(k &lt; <span class="number">10</span>)&#123;</span><br><span class="line">                System.out.println(k);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Matrix a = <span class="keyword">new</span> Matrix(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">            <span class="comment">// init</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">                a.m[<span class="number">0</span>][i] = cin.nextInt();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">                a.m[i][i-<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// computer  matrix ^ (k-9)</span></span><br><span class="line">            Matrix res = pow(a,k-<span class="number">9</span>,mod);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">                sum += (res.m[<span class="number">0</span>][i] * (<span class="number">9</span> - i)) % mod;</span><br><span class="line"></span><br><span class="line">            System.out.println(sum % mod); <span class="comment">// also should mod</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Codeforces-185A-Plant"><a href="#Codeforces-185A-Plant" class="headerlink" title="Codeforces - 185A. Plant"></a>Codeforces - 185A. Plant</h3><h4 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a><a href="http://codeforces.com/problemset/problem/185/A">题目链接</a></h4><blockquote>
<p><a href="http://codeforces.com/problemset/problem/185/A">http://codeforces.com/problemset/problem/185/A</a></p>
</blockquote>
<h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p><img src="images/m9.png" alt="在这里插入图片描述"></p>
<p><img src="images/m10.png" alt="在这里插入图片描述"></p>
<h4 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h4><p><img src="images/m11.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> row;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> col;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">long</span>[][] m;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Matrix</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.row = row;</span><br><span class="line">            <span class="keyword">this</span>.col = col;</span><br><span class="line">            m = <span class="keyword">new</span> <span class="keyword">long</span>[row][col];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Matrix <span class="title">mul</span><span class="params">(Matrix a, Matrix b)</span> </span>&#123;</span><br><span class="line">        Matrix c = <span class="keyword">new</span> Matrix(a.row, b.col); <span class="comment">//注意这里</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.col; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; a.col; k++)</span><br><span class="line">                    c.m[i][j] = (c.m[i][j] + a.m[i][k] * b.m[k][j]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Matrix <span class="title">pow</span><span class="params">(Matrix a, <span class="keyword">long</span> k)</span> </span>&#123;</span><br><span class="line">        Matrix res = <span class="keyword">new</span> Matrix(a.row, a.col); <span class="comment">// 方阵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.row; i++)</span><br><span class="line">            res.m[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((k &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">                res = mul(res, a);</span><br><span class="line">            a = mul(a, a);</span><br><span class="line">            k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> n = cin.nextLong();</span><br><span class="line"></span><br><span class="line">        Matrix a = <span class="keyword">new</span> Matrix(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        a.m[<span class="number">0</span>][<span class="number">0</span>] = a.m[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">        a.m[<span class="number">0</span>][<span class="number">1</span>] = a.m[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        Matrix res = pow(a, n);</span><br><span class="line"></span><br><span class="line">        System.out.println(res.m[<span class="number">0</span>][<span class="number">0</span>] % mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>素数回文以及素数相关总结</title>
    <url>/2022/04/08/%E7%B4%A0%E6%95%B0%E5%9B%9E%E6%96%87%E4%BB%A5%E5%8F%8A%E7%B4%A0%E6%95%B0%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="素数回文以及素数相关总结"><a href="#素数回文以及素数相关总结" class="headerlink" title="素数回文以及素数相关总结"></a>素数回文以及素数相关总结</h2><ul>
<li>普通筛素数法</li>
<li>埃式筛法</li>
<li>优化筛法</li>
<li>整数分解(唯一分解定理)</li>
<li>约数枚举</li>
<li>Hdu - 1431. 素数回文</li>
</ul>
<hr>
<h3 id="普通筛素数法"><a href="#普通筛素数法" class="headerlink" title="普通筛素数法"></a>普通筛素数法</h3><p>这个也是普通的素数判定的方法，这个方法判定素数时间复杂度为<code>O (sqrt(n))。</code></p>
<p><img src="images/m19.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">sieve</span><span class="params">(<span class="keyword">boolean</span>[] is_prime, <span class="keyword">int</span> MAX)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; prime = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="keyword">false</span>; <span class="comment">// 01 不是素数</span></span><br><span class="line">    <span class="keyword">boolean</span> flag;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX; i++) &#123;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j * j &lt;= i; j++) &#123;<span class="comment">// 根号i的时间复杂度</span></span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                is_prime[i] = <span class="keyword">false</span>;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            prime.add(i);</span><br><span class="line">            is_prime[i] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="埃式筛法"><a href="#埃式筛法" class="headerlink" title="埃式筛法"></a>埃式筛法</h3><p><img src="images/m20.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//经典的埃式筛法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">sieve</span><span class="params">(<span class="keyword">boolean</span>[] is_prime, <span class="keyword">int</span> MAX)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; prime = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Arrays.fill(is_prime, <span class="keyword">true</span>);</span><br><span class="line">    is_prime[<span class="number">0</span>] = is_prime[<span class="number">0</span>] = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_prime[i]) &#123;</span><br><span class="line">            prime.add(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt;= MAX; j += i)</span><br><span class="line">                is_prime[j] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="优化筛法"><a href="#优化筛法" class="headerlink" title="优化筛法"></a>优化筛法</h3><ul>
<li><p>上面的方法还是有一些重复的计算，比如说在搞定素数<code>2</code>的时候，筛选掉<code>6 (2 + 2 + 2)</code>；而在搞定素数<code>3</code>的时候，也要筛选掉<code>6 (3 + 3)</code> ，所以此时重复筛选；</p>
</li>
<li><p>解决办法是 只筛选<font color = red>小于等于<code>i</code>的素数和<code>i</code>的乘积</font>，这样可以<font color = red>尽量的</font>的减少重复的筛选，也不会遗漏；</p>
<p><img src="images/m21.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//优化筛法</span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">sieve2</span><span class="params">(<span class="keyword">boolean</span>[] is_prime, <span class="keyword">int</span> MAX)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; prime = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Arrays.fill(is_prime, <span class="keyword">true</span>);</span><br><span class="line">    is_prime[<span class="number">0</span>] = is_prime[<span class="number">0</span>] = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_prime[i])</span><br><span class="line">            prime.add(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; prime.size() &amp;&amp; prime.get(j) &lt;= MAX / i; j++) &#123;<span class="comment">// MAX/i防止溢出</span></span><br><span class="line">            is_prime[prime.get(j) * i] = <span class="keyword">false</span>; <span class="comment">//筛掉  (小于等于i的素数 * i)  构成的合数</span></span><br><span class="line">            <span class="keyword">if</span> (i % prime.get(j) == <span class="number">0</span>) <span class="comment">//如果 i是 &lt; i的素数的倍数 就不用筛了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="整数分解-唯一分解定理"><a href="#整数分解-唯一分解定理" class="headerlink" title="整数分解(唯一分解定理)"></a>整数分解(唯一分解定理)</h3><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="https://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/1634.html">题目链接</a></h4><blockquote>
<p><a href="https://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/1634.html">https://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/1634.html</a></p>
</blockquote>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><img src="images/m22.png" alt="在这里插入图片描述"></p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p><img src="images/m23.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> MAX)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; prime = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span>[] is_prime = <span class="keyword">new</span> <span class="keyword">boolean</span>[MAX + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        Arrays.fill(is_prime, <span class="keyword">true</span>);</span><br><span class="line">        is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (is_prime[i]) &#123;</span><br><span class="line">                prime.add(i);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt;= MAX; j += i) &#123;</span><br><span class="line">                    is_prime[j] = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> T = cin.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (T-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = cin.nextInt();</span><br><span class="line"></span><br><span class="line">            ArrayList&lt;Integer&gt; prime = sieve(n);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> isFirst = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prime.size(); i++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> num = prime.get(i);</span><br><span class="line">                <span class="keyword">while</span> (n % num == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isFirst) &#123;</span><br><span class="line">                        System.out.print(num);</span><br><span class="line">                        isFirst = <span class="keyword">false</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span></span><br><span class="line">                        System.out.print(<span class="string">&quot;*&quot;</span> + num);</span><br><span class="line"></span><br><span class="line">                    n /= num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="约数枚举"><a href="#约数枚举" class="headerlink" title="约数枚举"></a>约数枚举</h3><p>就是得到某个数的约数，和普通筛法有点像: </p>
<p><img src="images/m19.png" alt="在这里插入图片描述"></p>
<p>这里把上面的整数分解的保存也贴在这个代码里面: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPrime</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//约数枚举</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">divisor</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n % i == <span class="number">0</span>)</span><br><span class="line">                res.add(i);</span><br><span class="line">            <span class="keyword">if</span>(i != n/i)</span><br><span class="line">                res.add(n/i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//整数分解</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> HashMap&lt;Integer,Integer&gt; <span class="title">prime_factor</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(n % i == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(i)) &#123;</span><br><span class="line">                    map.put(i, map.get(i) + <span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    map.put(i,<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                n /= i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n != <span class="number">1</span>)</span><br><span class="line">            map.put(n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(divisor(<span class="number">12</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----测试分解素因子(唯一分解定理)-----&quot;</span>);</span><br><span class="line">        HashMap&lt;Integer,Integer&gt;map = prime_factor(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Integer num : map.keySet())&#123;</span><br><span class="line">            System.out.println(num  + <span class="string">&quot; &quot;</span> + map.get(num));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果: </p>
<p><img src="images/m24.png" alt="在这里插入图片描述"></p>
<hr>
<h3 id="Hdu-1431-素数回文"><a href="#Hdu-1431-素数回文" class="headerlink" title="Hdu - 1431. 素数回文"></a>Hdu - 1431. 素数回文</h3><h4 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1431">题目链接</a></h4><blockquote>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1431">http://acm.hdu.edu.cn/showproblem.php?pid=1431</a></p>
</blockquote>
<h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p><img src="images/m25.png" alt="在这里插入图片描述"></p>
<h4 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h4><ul>
<li>先用素数筛法筛出<code>0~9989899</code>之间的素数，然后再遍历一遍，判断一下是不是回文，最后判断是不是在那个区间即可；</li>
<li>注意这里使用的三种筛法，第一种会超时，第二种和第三种可以通过；<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目链接:  http://acm.hdu.edu.cn/showproblem.php?pid=1431</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; <span class="comment">//提交时改成main</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 经典筛法，超时</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">primary</span><span class="params">(<span class="keyword">boolean</span>[] is_prime,<span class="keyword">int</span> MAX)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; prime = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="keyword">false</span>; <span class="comment">// 01 不是素数</span></span><br><span class="line">        <span class="keyword">boolean</span> flag;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX; i++)&#123; <span class="comment">//范围是1000 我筛选 0~2000内的素数</span></span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j * j &lt;= i; j++)&#123;<span class="comment">// 根号i的时间复杂度</span></span><br><span class="line">                <span class="keyword">if</span>(i % j == <span class="number">0</span>)&#123;</span><br><span class="line">                    is_prime[i] = <span class="keyword">false</span>;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                prime.add(i);</span><br><span class="line">                is_prime[i] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//经典的埃式筛法</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">sieve</span><span class="params">(<span class="keyword">boolean</span>[] is_prime,<span class="keyword">int</span> MAX)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; prime = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.fill(is_prime,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        is_prime[<span class="number">0</span>] = is_prime[<span class="number">0</span>] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(is_prime[i])&#123;</span><br><span class="line">                prime.add(i);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt;= MAX; j+=i)</span><br><span class="line">                    is_prime[j] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//优化筛法</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">sieve2</span><span class="params">(<span class="keyword">boolean</span>[] is_prime,<span class="keyword">int</span> MAX)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; prime = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.fill(is_prime,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        is_prime[<span class="number">0</span>] = is_prime[<span class="number">0</span>] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(is_prime[i])</span><br><span class="line">                prime.add(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; prime.size() &amp;&amp; prime.get(j) &lt;= MAX / i; j++) &#123;</span><br><span class="line">                is_prime[prime.get(j) * i] = <span class="keyword">false</span>; <span class="comment">//筛掉  (小于等于i的素数 * i)  构成的合数</span></span><br><span class="line">                <span class="keyword">if</span>(i % prime.get(j) == <span class="number">0</span>) <span class="comment">//如果 i是 &lt; i的素数的倍数 就不用筛了</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldNum = num;</span><br><span class="line">        <span class="keyword">int</span> newNum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//反过来计算</span></span><br><span class="line">        <span class="keyword">while</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            newNum = newNum * <span class="number">10</span> + num % <span class="number">10</span>;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newNum == oldNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> maxn = <span class="number">9989899</span>; <span class="comment">//题目中最大的回文素数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] is_prime = <span class="keyword">new</span> <span class="keyword">boolean</span>[maxn + <span class="number">1</span>];</span><br><span class="line"><span class="comment">//        primary(is_prime,maxn); //超时</span></span><br><span class="line"><span class="comment">//        sieve(is_prime,maxn); // ok</span></span><br><span class="line">        sieve2(is_prime,maxn); <span class="comment">// ok  fast</span></span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxn; i++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>(is_prime[i] &amp;&amp; isPalindrome(i))</span><br><span class="line">                res.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cin.hasNext())&#123;</span><br><span class="line">            <span class="keyword">int</span> a = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> b = cin.nextInt();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.size(); i++)&#123;</span><br><span class="line">                num = res.get(i);</span><br><span class="line">                <span class="keyword">if</span>(num &lt; a)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(num &gt; b)</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 直接退出</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    System.out.println(num);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络知识总结一计算机网络和协议(一)</title>
    <url>/2021/11/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%E4%B8%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8D%8F%E8%AE%AE(%E4%B8%80)/</url>
    <content><![CDATA[<h2 id="计算机网络知识总结一计算机网络和协议-一"><a href="#计算机网络知识总结一计算机网络和协议-一" class="headerlink" title="计算机网络知识总结一计算机网络和协议(一)"></a>计算机网络知识总结一计算机网络和协议(一)</h2><ul>
<li><a href="#%E4%BA%92%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0">互联网概述</a></li>
<li><a href="#%E4%BA%92%E8%81%94%E7%BD%91%E7%BB%84%E6%88%90">互联网组成</a></li>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87">计算机网络的性能指标</a></li>
<li><a href="#osi%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B%E4%BB%A5%E5%8F%8Atcpip%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE">OSI参考模型以及TCP/IP四层模型、五层协议</a></li>
<li><a href="#%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87">通信过程、数据传输、网络设备</a></li>
<li><a href="#%E5%B0%8F%E7%BB%93">小结</a></li>
</ul>
<hr>
<h3 id="互联网概述"><a href="#互联网概述" class="headerlink" title="互联网概述"></a>互联网概述</h3><ul>
<li>计算机网络: 由若干节点和连接这些节点的链路组成，网络中的节点可以是计算机、集线器、交换机、或路由器等；</li>
<li>网络之间可以通过路由器相互连接，这就构成了一个更大范围的计算机网路，这样的网路称为<font color = red>互连网</font>，因此互连网是<font color = red>网路的网路</font>；</li>
<li>因特网(互联网):  全球最大的特定互连网；</li>
</ul>
<p>注意以下两个意思相差很大的名词 <code>internet</code> 和 <code>Internet</code> [RFC 1208]:</p>
<ul>
<li><p>以小写字母 i 开始的 <code>internet</code> (互连网) 是一个通用名词，它泛指由多个计算机网络互连而成的计算机网络。在这些网络之间的通信协议〈即通信规则) 可以任意选择，不一定非要使用<code>TCP/IP</code> 协议；</p>
</li>
<li><p>以大写字母 I 开始的 <code>Internet</code> 〈互联网或因特网) 则是一个专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定互连网，它采用 <code>TCP/IP</code> 协议族作为通信的规则，且其前身是美国的 ARPANET；</p>
</li>
<li><p>可见，任意把几个计算机网络互连起来〈不管采用什么协议)，并能够相互通信，这样构成的是一个互连网(<code>internet</code>，而不是互联网(<code>Internet</code>)。</p>
</li>
</ul>
<p><img src="images/1_1.png" alt="在这里插入图片描述"></p>
<ul>
<li>路由器（Router），是连接因特网中各局域网、广域网的设备，它会根据信道的情况自动选择和设定路由，以最佳路径，按前后顺序发送信号。</li>
<li> 路由器是互联网络的枢纽，”交通警察”。**<font color = red>路由和交换机之间的主要区别就是交换机发生在OSI参考模型第二层（数据链路层），而路由发生在第三层，即网络层**。</font>这一区别决定了路由和交换机在移动信息的过程中需使用不同的控制信息，所以说两者实现各自功能的方式是不同的。</li>
<li>路由器（<code>Router</code>）又称网关设备（<code>Gateway</code>）是用于连接多个逻辑上分开的网络，所谓逻辑网络是代表一个单独的网络或者一个子网。当数据从一个子网传输到另一个子网时，可通过路由器的路由功能来完成。因此，路由器具有判断网络地址和选择IP路径的功能。</li>
<li><font color = red><strong>交换机是将不同IP地址的电脑连在一起，共享一根网线；路由器是将同一个IP给不同的电脑使用，就像一条大路分成很多条小路。一句话，路由器是接外网的，路由器是接内网的。(交换机没有开关，路由器有开关)</strong></font></li>
</ul>
<p><img src="images/1_2.png" alt="在这里插入图片描述"></p>
<hr>
<h3 id="互联网组成"><a href="#互联网组成" class="headerlink" title="互联网组成"></a>互联网组成</h3><p>基本组成:</p>
<ul>
<li>①边缘部分: 由所有连接在互联网上的主机组成，这部分是用户直接使用的，用来进行通信（传送数据，音频或视频）和资源共享；</li>
<li>②核心部分: 由大量网络和连接这些网络的<font color = red><strong>路由器</strong></font> 组成，这部分是为边缘部分提供服务的(提供连通性和交换)；</li>
</ul>
<p><img src="images/1_3.png" alt="在这里插入图片描述"></p>
<p>边缘部分的主机间的通信方式: </p>
<p><img src="images/1_4.png" alt="在这里插入图片描述"></p>
<p><strong>(1). 客户程序:</strong></p>
<ul>
<li>被用户调用后运行，在通信时主动向远地服务器发起通信(请求服务)。因此，客</li>
</ul>
<p>户程序必须知道服务器程序的地址。</p>
<ul>
<li>不需要特殊的硬件和很复杂的操作系统。</li>
</ul>
<p><strong>(2). 服务器程序:</strong></p>
<ul>
<li>是一种专门用来提供某种服务的程序，可同时处理多个远地或本地客户的请求。</li>
<li>系统启动后即自动调用并一直不断地运行着，被动地等待并接受来自各地的客户的</li>
</ul>
<p>通信请求。因此，服务器程序不需要知道客户程序的地址。</p>
<p><strong>客户与服务器的通信关系建立后，通信可以是双向的，客户和服务器都可发送和接收</strong></p>
<p><strong>数据。</strong></p>
<p><strong>网络的传输过程(从客户端和服务器的角度来看):</strong></p>
<p><img src="images/1_5.png" alt="在这里插入图片描述"></p>
<p><strong><font color = red>电路交换:</font></strong></p>
<p><img src="images/1_6.png" alt="在这里插入图片描述"></p>
<p> <strong><font color = red>分组交换: </font></strong></p>
<p><img src="images/1_7.png" alt="在这里插入图片描述"></p>
<p><strong>三种交换方式的比较</strong></p>
<p><img src="images/1_8.png" alt="在这里插入图片描述"></p>
<hr>
<h3 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h3><p><img src="images/1_9.png"></p>
<h5 id="速率"><a href="#速率" class="headerlink" title="速率"></a><font color = blue>速率</font></h5><ul>
<li>网络技术中的速率是指每秒钟传输的比特数量，称为数据率或比特率，速率的单位是<code>bit/s</code>，或<code>b/s</code>(比特每秒)；</li>
<li>速率较高时，就可以使用kb/s，Mb/s，Gb/s，Tb/s，人们现在所说的10M网速，其实是10Mb/s；</li>
<li>360等可以显示网速的软件，测试你电脑的那个网速，这里单位是<font color = red>B/秒，大写的B是字节(byte)，8bit = 1byte，也就是说如果测速为3.82MB/s，则下载速率为3.82 * 8Mb/s。</li>
</ul>
<h5 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a><font color = blue>带宽</font></h5><ul>
<li>带宽用来表示网络通信线路传输数据的能力(数字信道所能传送的最高数据率)，即最高速率；</li>
<li>比如说家里使用ADSL拨号，有4M带宽、8M带宽，这里说的带宽就是你访问Internet的最高带宽，你家里的带宽由电信运营商控制；</li>
</ul>
<h5 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a><font color = blue>吞吐量</font></h5><ul>
<li>吞吐量表示在单位时间内通过某个网络或接口的数据量，包括<font color = red>全部上传和下载的流量；</li>
<li>吞吐量受网络带宽或网络额定速率的限制，计算机的网卡如果连接交换机，网卡就可以工作在全双工模式，即能够同时接收和发送数据；如果计算机的网卡连接的是集线器，网卡就只能工作在半双工模式，即不能同时发送和接收数据；</li>
</ul>
<p><img src="images/1_10.png" alt="在这里插入图片描述"></p>
<h5 id="时延"><a href="#时延" class="headerlink" title=" 时延"></a><font color = blue> 时延</font></h5><ul>
<li>时延(delay)是指数据(一个数据包或bit)从网络的一段传送到另一端所需要的时间，是一个很重要的性能指标；</li>
<li>时延包括: 发送时延、传播时延、处理时延、排队时延；（数据在网络中经历的的总时延就是这四种时延的累加和）；</li>
</ul>
<h6 id="发送时延"><a href="#发送时延" class="headerlink" title="发送时延"></a><font color = green>发送时延</h6><p><img src="images/1_11.png" alt="在这里插入图片描述"></p>
<h6 id="传播时延"><a href="#传播时延" class="headerlink" title="传播时延"></a><font color = green>传播时延</h6><ul>
<li>传播时延是<font color = red>是电磁波在信道中传播一定的距离要花费的时间； </li>
</ul>
<p><img src="images/1_12.png" alt="在这里插入图片描述"></p>
<h6 id="排队时延和处理时延"><a href="#排队时延和处理时延" class="headerlink" title="排队时延和处理时延"></a><font color = green>排队时延和处理时延</h6><p><img src="images/1_13.png" alt="在这里插入图片描述"></p>
<h6 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a><font color = green>时延带宽积</h6><p><img src="images/1_14.png" alt="在这里插入图片描述"></p>
<h5 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a><font color = blue>往返时间</font></h5><p><strong>表示从发送端发送数据开始，到发送端接收到来自接收端的确认(发送端收到确认立即发送确认)，总共经历的时间；</strong></p>
<h5 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a><font color = blue>利用率</font></h5><p><img src="images/1_15.png" alt="在这里插入图片描述"></p>
<hr>
<h3 id="OSI参考模型以及TCP-IP四层模型、五层协议"><a href="#OSI参考模型以及TCP-IP四层模型、五层协议" class="headerlink" title="OSI参考模型以及TCP/IP四层模型、五层协议"></a>OSI参考模型以及TCP/IP四层模型、五层协议</h3><p><img src="images/1_16.png" alt="在这里插入图片描述"></p>
<p><img src="images/1_17.png" alt="在这里插入图片描述"></p>
<p><img src="images/1_18.png" alt="在这里插入图片描述"></p>
<p>TCP/IP只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p>
<p>TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p>
<p><img src="images/1_19.png" alt="在这里插入图片描述"></p>
<hr>
<h3 id="通信过程、数据传输、网络设备"><a href="#通信过程、数据传输、网络设备" class="headerlink" title="通信过程、数据传输、网络设备"></a>通信过程、数据传输、网络设备</h3><h4 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程:"></a><font color = blue>通信过程:</h4><p><img src="images/1_20.png" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>注意: MAC地址由48位二进制数组成，在Windows操作系统命令提示符下，    输入”ipconfig / all”能够看到计算机网卡的MAC地址，物理地址…. : C8-60-00-2E-6E-EB，这里显示的是十六进制表示的MAC地址，使用MA和MB代替MAC地址是为了简化说明。</strong></p>
</blockquote>
<p><strong><font color = red>解释:</font></strong> </p>
<p><img src="images/1_21.png"></p>
<p><img src="images/1_22.png"></p>
<p><img src="images/1_23.png"></p>
<blockquote>
<p>为什么计算机通信需要物理地址和IP地址?，物理地址决定了数据帧下一跳给谁，而 IP地址决定了数据包最终给谁。如果全球的计算机都使用集线器或交换机连接，就可以只使用 MAC 地址进行通信了。</p>
</blockquote>
<p><img src="images/1_24.png"></p>
<p><font color = green>通过本图也可以看出:</p>
<ul>
<li><strong>目标MAC地址决定了数据帧下一跳由哪个设备接收；</strong></li>
<li><strong>目标IP地址决定了数据包最终到达那个计算机；</strong></li>
<li><strong>不同的网络数据链路层使用不同的协议，帧格式也不相同，路由器在不同网络转发数据包，需要将数据包重新封装；</strong><h4 id="数据封装和解封-数据传输"><a href="#数据封装和解封-数据传输" class="headerlink" title="数据封装和解封(数据传输)"></a><font color = blue>数据封装和解封(数据传输)</h4><img src="images/1_25.png" alt="在这里插入图片描述"></li>
</ul>
<p><img src="images/1_26.png" alt="在这里插入图片描述"></p>
<p><img src="images/1_27.png" alt="在这里插入图片描述"></p>
<h4 id="网络设备"><a href="#网络设备" class="headerlink" title="网络设备"></a><font color = blue>网络设备</h4><p>现实中各个网络设备的样子: </p>
<p><img src="images/1_28.png" alt="在这里插入图片描述"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li><p>计算机网络〈可简称为网络) 把许多计算机连接在一起，而互连网则把许多网络连接在一起，是网络的网络。</p>
</li>
<li><p>以小写字母<code>i </code>开始的 <code>internet</code> 〈互连网) 是通用名词，它泛指由多个计算机网络互连而成的网络。在这些网络之间的通信协议〈即通信规则) 可以是任意的。</p>
</li>
<li><p> 以大写字母 <code>I </code>开始的 Internet (互联网) 是专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定互连网，并采用 TCP/P 协议族作为通信规则，且其前身是美国的 ARPANET。Internet 的推荐译名是“因特网” 但很少被使用。</p>
</li>
<li><p> 互联网现在采用存储转发的分组交换技术，以及三层 ISP 结构。</p>
</li>
<li><p>互联网按工作方式可划分为<strong>边缘部分与核心部分</strong>。<strong>主机在网络的边缘部分，其作用是进行信息处理。路由器在网络的核心部分，其作用是按存储转发方式进行分组交换。</strong></p>
</li>
<li><p> 计算机通信是计算机中的进程〈即运行着的程序) 之间的通信。<strong>计算机网络采用的通信方式是客户-服务器方式和对等连接方式 (P2P 方式)。</strong></p>
</li>
<li><p> 客户和服务器都是指通信中所涉及的应用进程。客户是服务请求方，服务器是服务 提供方。</p>
</li>
<li><p>按作用范围的不同，计算机网络分为广域网 WAN、城域网 MAN、局域网 LAN 和个人区域网 PAN。</p>
</li>
<li><p>计算机网络最常用的性能指标是: <strong>速率、带宽、吞吐量、时延〈发送时延、传播时延、处理时延、排队时延)、时延带宽积、往返时间和信道〈或网络》利用率。</strong></p>
</li>
<li><p>网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层及其协议的集合，称为网络的体系结构。</p>
</li>
<li><p>五层协议的体系结构由应用层、运输层、网络层〈或网际层)、数据链路层和物理层组成。<strong>运输层最重要的协议是 <code>TCP</code> 和 <code>UDP</code> 协议，而网络层最重要的协议是 <code>IP</code>协议。</strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Computer Network</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>TCP/IP</tag>
        <tag>OSI</tag>
      </tags>
  </entry>
  <entry>
    <title>Implement Trie (Prefix Tree)以及实现字典树(前缀树)</title>
    <url>/2022/11/07/Implement%20Trie%20(Prefix%20Tree)%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%AD%97%E5%85%B8%E6%A0%91(%E5%89%8D%E7%BC%80%E6%A0%91)/</url>
    <content><![CDATA[<h2 id="LeetCode-208-Implement-Trie-Prefix-Tree-以及实现字典树-前缀树"><a href="#LeetCode-208-Implement-Trie-Prefix-Tree-以及实现字典树-前缀树" class="headerlink" title="LeetCode - 208. Implement Trie (Prefix Tree)以及实现字典树(前缀树)"></a>LeetCode - 208. Implement Trie (Prefix Tree)以及实现字典树(前缀树)</h2><ul>
<li>基础知识和结构</li>
<li>字符串的插入</li>
<li> 统计某个字符串的数量 || 查询是否有某个字符串</li>
<li>统计以某个字符串为前缀的字符串数量  ||  是否有某个前缀</li>
<li>字符串的删除</li>
<li>完整测试代码</li>
<li>题目解析　</li>
<li>使用Map来保存next</li>
<li>更多字典树</li>
</ul>
<hr>
<h3 id="基础知识和结构"><a href="#基础知识和结构" class="headerlink" title="基础知识和结构"></a>基础知识和结构</h3><p><code>Map</code>和<code>Trie</code>的差别，关于映射集合等可以看<a href="https://blog.csdn.net/zxzxzx0119/article/details/79891408"><strong>这篇博客</strong></a>。</p>
<p><img src="images/t1.png" alt="在这里插入图片描述"></p>
<ul>
<li> <font color = red> <strong>字典树也叫做前缀树，可以存储一组元素(一般是字符串)，可以快速的查找某个字符串在树中的个数以及寻找以某个字符串为前缀的字符串的个数，先看下图为一些字符串插入到字典树中的情形。</strong></li>
</ul>
<p>字典树的存储结构: </p>
<ul>
<li><strong>首先字母是画在树的边上的；</strong></li>
<li><strong>而结点中的<code>path</code>代表的是经过这个结点的字母的次数；</strong></li>
<li><strong>为了方便前缀的计算，而<code>end</code>表示的是以这个结点结尾的字符串的数量，方便统计树中某个字符串的数量。</strong></li>
<li><strong>而<code>next</code>表示的是多个儿子结点，因为可以有大小写字母，所以我初始化为<code>52</code>(如果是小写字母的就为<code>26</code>)(也可以使用<code>Map</code>来存储)。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> path;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> end;</span><br><span class="line">        <span class="keyword">public</span> Node[] next;<span class="comment">//使用整数表示字符　c - &#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            path = <span class="number">0</span>;</span><br><span class="line">            end = <span class="number">0</span>;</span><br><span class="line">            next = <span class="keyword">new</span> Node[<span class="number">26</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如: 下面的这颗字典树: </p>
<p><img src="images/t2.png" alt="这里写图片描述"></p>
<p>再如:  <strong>树中有<code>&quot;abc&quot;,&quot;ab&quot;,&quot;ab&quot;,&quot;abd&quot;,&quot;bc&quot;,&quot;bd&quot;,&quot;cd&quot;,&quot;cde&quot;,&quot;ce&quot;</code>总共<code>9</code>个字符串。如下的结构:</strong> </p>
<p><img src="images/t3.png" alt="这里写图片描述"></p>
<hr>
<h3 id="字符串的插入"><a href="#字符串的插入" class="headerlink" title="字符串的插入"></a>字符串的插入</h3><ul>
<li>遍历每个字符，算出每个<code>字符-&#39;a&#39;</code>的值，表示的是在结点儿子中的位置；</li>
<li>一开始结点的儿子都是<code>null</code>(<code>nexts</code>数组结构)，如果对应的位置为<code>null</code>，创建即可，然后走向下一个结点，并维护<code>path</code>。</li>
<li>记得遍历完之后，最后一个结点的<code>end++</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入一个字符</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(word == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    Node cur = root;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">        index = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur.next[index] == <span class="keyword">null</span>)&#123; <span class="comment">//没有就新建</span></span><br><span class="line">            cur.next[index] = <span class="keyword">new</span> Node();</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next[index];</span><br><span class="line">        cur.path++; <span class="comment">//经过这里</span></span><br><span class="line">    &#125;</span><br><span class="line">    cur.end++;<span class="comment">//以这个结尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="统计某个字符串的数量-查询是否有某个字符串"><a href="#统计某个字符串的数量-查询是否有某个字符串" class="headerlink" title="统计某个字符串的数量 || 查询是否有某个字符串"></a>统计某个字符串的数量 || 查询是否有某个字符串</h3><ul>
<li>这个很简单，怎么插入的就怎么查找，如果查找到某个结点(数组还没有遍历完)，就找到<code>nexts[index]</code>为空，直接返回<code>0</code>就可以了；</li>
<li>否则遍历完之后，返回结点的<code>end</code>的值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//统计某个字符串的数量</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(word == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       Node cur = root;</span><br><span class="line">       <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">           index = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">           <span class="keyword">if</span>(cur.next[index] == <span class="keyword">null</span>)</span><br><span class="line">               <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">           cur = cur.next[index];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> cur.end;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//查询是否有某个字符串</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> count(word) &gt; <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="统计以某个字符串为前缀的字符串数量-是否有某个前缀"><a href="#统计以某个字符串为前缀的字符串数量-是否有某个前缀" class="headerlink" title="统计以某个字符串为前缀的字符串数量  ||  是否有某个前缀"></a>统计以某个字符串为前缀的字符串数量  ||  是否有某个前缀</h3><ul>
<li>这个和上面都是一个套路，遍历完之后，返回结点的<code>path</code>的值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prefixNum</span><span class="params">(String prefix)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(prefix == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       Node cur = root;</span><br><span class="line">       <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i++)&#123;</span><br><span class="line">           index = prefix.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">           <span class="keyword">if</span>(cur.next[index] == <span class="keyword">null</span>)</span><br><span class="line">               <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">           cur = cur.next[index];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> cur.path; <span class="comment">//返回这个经过的　　也就是以这个为前驱的</span></span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//是否有某个前缀(以某个字符串开头)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> prefixNum(prefix) &gt; <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="字符串的删除"><a href="#字符串的删除" class="headerlink" title="字符串的删除"></a>字符串的删除</h3><p>我们删除某个字符串的时候，不能直接删除，要看某个结点的<code>path</code>的值：</p>
<ul>
<li><strong>如果<code>path</code>是<code>1</code>，以后的所有结点都可以删除了(释放后面所有结点)；</strong></li>
</ul>
<p><img src="https://img-blog.csdn.net/20180908115347286?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<ul>
<li><strong>否则只是将结点的<code>path--</code>就可以了。</strong></li>
</ul>
<p><img src="https://img-blog.csdn.net/20180908115421994?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(word == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">if</span>(!search(word)) <span class="comment">//不包含这个字符串</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      Node cur = root;</span><br><span class="line">      <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">          index = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">          <span class="keyword">if</span>(--cur.next[index].path == <span class="number">0</span>)&#123;</span><br><span class="line">              cur.next[index] = <span class="keyword">null</span>; <span class="comment">//释放掉下面的这棵树</span></span><br><span class="line">              <span class="keyword">return</span> ;</span><br><span class="line">          &#125;</span><br><span class="line">          cur = cur.next[index];</span><br><span class="line">      &#125;</span><br><span class="line">      cur.end--; <span class="comment">//最后这个字符串也要--</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="完整测试代码"><a href="#完整测试代码" class="headerlink" title="完整测试代码"></a>完整测试代码</h3><p>上面图形的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> path;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> end;</span><br><span class="line">        <span class="keyword">public</span> Node[] next;<span class="comment">//使用整数表示字符　c - &#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            path = <span class="number">0</span>;</span><br><span class="line">            end = <span class="number">0</span>;</span><br><span class="line">            next = <span class="keyword">new</span> Node[<span class="number">26</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入一个字符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        Node cur = root;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            index = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur.next[index] == <span class="keyword">null</span>)&#123; <span class="comment">//没有就新建</span></span><br><span class="line">                cur.next[index] = <span class="keyword">new</span> Node();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next[index];</span><br><span class="line">            cur.path++; <span class="comment">//经过这里</span></span><br><span class="line">        &#125;</span><br><span class="line">        cur.end++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//统计某个字符串的数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Node cur = root;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            index = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur.next[index] == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            cur = cur.next[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count(word) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prefixNum</span><span class="params">(String prefix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prefix == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Node cur = root;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i++)&#123;</span><br><span class="line">            index = prefix.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur.next[index] == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            cur = cur.next[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.path; <span class="comment">//返回这个经过的　　也就是以这个为前驱的</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prefixNum(prefix) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(!search(word)) <span class="comment">//不包含这个字符串</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        Node cur = root;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            index = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(--cur.next[index].path == <span class="number">0</span>)&#123;</span><br><span class="line">                cur.next[index] = <span class="keyword">null</span>; <span class="comment">//释放掉下面的这棵树</span></span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next[index];</span><br><span class="line">        &#125;</span><br><span class="line">        cur.end--; <span class="comment">//最后这个字符串也要--</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Trie trie = <span class="keyword">new</span> Trie();</span><br><span class="line"></span><br><span class="line">        trie.insert(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        trie.insert(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">        trie.insert(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">        trie.insert(<span class="string">&quot;abd&quot;</span>);</span><br><span class="line">        trie.insert(<span class="string">&quot;bc&quot;</span>);</span><br><span class="line">        trie.insert(<span class="string">&quot;bd&quot;</span>);</span><br><span class="line">        trie.insert(<span class="string">&quot;cd&quot;</span>);</span><br><span class="line">        trie.insert(<span class="string">&quot;cde&quot;</span>);</span><br><span class="line">        trie.insert(<span class="string">&quot;ce&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(trie.count(<span class="string">&quot;ab&quot;</span>));</span><br><span class="line">        trie.remove(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">        System.out.println(trie.count(<span class="string">&quot;ab&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(trie.count(<span class="string">&quot;abd&quot;</span>));</span><br><span class="line">        trie.remove(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">        System.out.println(trie.count(<span class="string">&quot;ab&quot;</span>));</span><br><span class="line">        System.out.println(trie.count(<span class="string">&quot;abd&quot;</span>));</span><br><span class="line"></span><br><span class="line">        trie.remove(<span class="string">&quot;abd&quot;</span>);</span><br><span class="line">        System.out.println(trie.count(<span class="string">&quot;abd&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试结果输出: </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="https://leetcode.com/problems/implement-trie-prefix-tree/description/">题目链接</a></h4><blockquote>
<p><a href="https://leetcode.com/problems/implement-trie-prefix-tree/description/">https://leetcode.com/problems/implement-trie-prefix-tree/description/</a></p>
</blockquote>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><img src="images/t4.png" alt="在这里插入图片描述"></p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>运用上面的操作完全能解决这个问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> path;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> end;</span><br><span class="line">        <span class="keyword">public</span> Node[] next;<span class="comment">//使用整数表示字符　c - &#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            path = <span class="number">0</span>;</span><br><span class="line">            end = <span class="number">0</span>;</span><br><span class="line">            next = <span class="keyword">new</span> Node[<span class="number">26</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入一个字符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        Node cur = root;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            index = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur.next[index] == <span class="keyword">null</span>)&#123; <span class="comment">//没有就新建</span></span><br><span class="line">                cur.next[index] = <span class="keyword">new</span> Node();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next[index];</span><br><span class="line">            cur.path++; <span class="comment">//经过这里</span></span><br><span class="line">        &#125;</span><br><span class="line">        cur.end++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//统计某个字符串的数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Node cur = root;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            index = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur.next[index] == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            cur = cur.next[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count(word) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prefixNum</span><span class="params">(String prefix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prefix == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Node cur = root;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i++)&#123;</span><br><span class="line">            index = prefix.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur.next[index] == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            cur = cur.next[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.path; <span class="comment">//返回这个经过的　　也就是以这个为前驱的</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prefixNum(prefix) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="使用Map来保存next"><a href="#使用Map来保存next" class="headerlink" title="使用Map来保存next"></a>使用Map来保存next</h3><p>还有一种写法就是 </p>
<ul>
<li>使用<code>Map</code>来保存<code>next</code>数组，这样不只可以存<code>26</code>或者<code>52</code>个孩子: </li>
</ul>
<p>还是上面那个题目代码: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">int</span> path;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">int</span> end;</span><br><span class="line">     <span class="keyword">public</span> HashMap&lt;Character,Node&gt;next;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         path = <span class="number">0</span>;</span><br><span class="line">         end = <span class="number">0</span>;</span><br><span class="line">         next = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     root = <span class="keyword">new</span> Node();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//插入一个字符</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(word == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">return</span> ;</span><br><span class="line">     Node cur = root;</span><br><span class="line">     <span class="keyword">char</span> c;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">         c = word.charAt(i);</span><br><span class="line">         <span class="keyword">if</span>(cur.next.get(c) == <span class="keyword">null</span>)&#123; <span class="comment">//没有就新建</span></span><br><span class="line">             cur.next.put(c,<span class="keyword">new</span> Node());</span><br><span class="line">         &#125;</span><br><span class="line">         cur = cur.next.get(c);</span><br><span class="line">         cur.path++; <span class="comment">//经过这里</span></span><br><span class="line">     &#125;</span><br><span class="line">     cur.end++;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//统计某个字符串的数量</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(word == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     Node cur = root;</span><br><span class="line">     <span class="keyword">char</span> c;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">         c = word.charAt(i);</span><br><span class="line">         <span class="keyword">if</span>(cur.next.get(c) == <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         cur = cur.next.get(c);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> cur.end;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> count(word) &gt; <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prefixNum</span><span class="params">(String prefix)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(prefix == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     Node cur = root;</span><br><span class="line">     <span class="keyword">char</span> c;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i++)&#123;</span><br><span class="line">         c = prefix.charAt(i);</span><br><span class="line">         <span class="keyword">if</span>(cur.next.get(c) == <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         cur = cur.next.get(c);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> cur.path; <span class="comment">//返回这个经过的　　也就是以这个为前驱的</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> prefixNum(prefix) &gt; <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(word == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     <span class="keyword">if</span>(!search(word)) <span class="comment">//不包含这个字符串</span></span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     Node cur = root;</span><br><span class="line">     <span class="keyword">char</span> c;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">         c = word.charAt(i);</span><br><span class="line">         <span class="keyword">if</span>(--cur.next.get(c).path == <span class="number">0</span>)&#123;</span><br><span class="line">             cur.next.remove(c);</span><br><span class="line">             <span class="keyword">return</span> ;</span><br><span class="line">         &#125;</span><br><span class="line">         cur = cur.next.get(c);</span><br><span class="line">     &#125;</span><br><span class="line">     cur.end--; <span class="comment">//最后这个字符串也要--</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="更多字典树"><a href="#更多字典树" class="headerlink" title="更多字典树"></a>更多字典树</h3><ul>
<li><strong>压缩字典树；</strong></li>
</ul>
<p><img src="images/t5.png" alt="这里写图片描述"></p>
<ul>
<li><strong>三分搜索树；</strong></li>
</ul>
<p><img src="images/t6.png" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程基础</title>
    <url>/2023/01/12/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Java多线程基础"><a href="#Java多线程基础" class="headerlink" title="Java多线程基础"></a>Java多线程基础</h1><ul>
<li><a href="#%E4%B8%80%E7%BA%BF%E7%A8%8B%E4%BB%8B%E7%BB%8D">一、线程介绍</a><ul>
<li><a href="#1%E7%AE%80%E5%8D%95%E6%A1%88%E4%BE%8B%E5%BC%95%E5%85%A5">1、简单案例引入</a></li>
<li><a href="#2start%E5%92%8Crun%E6%96%B9%E6%B3%95%E5%8C%BA%E5%88%AB">2、start和run方法区别</a></li>
<li><a href="#3%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">3、线程生命周期</a></li>
<li><a href="#4%E9%93%B6%E8%A1%8C%E6%8E%92%E9%98%9F%E4%B8%9A%E5%8A%A1%E6%A1%88%E4%BE%8B">4、银行排队业务案例</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3thread%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">二、深入理解Thread构造函数</a><pre><code>- [1、线程的默认命名](#1线程的默认命名)
- [2、线程的父子关系](#2线程的父子关系)
- [3、Thread和ThreadGroup](#3thread和threadgroup)
- [4、Thread和JVM虚拟机栈](#4thread和jvm虚拟机栈)
- [5、守护线程](#5守护线程)
</code></pre>
</li>
<li><a href="#%E4%B8%89threadapi%E7%9A%84%E8%AF%A6%E7%BB%86%E5%86%85%E5%AE%B9">三、Thread API的详细内容</a><ul>
<li><a href="#1%E7%BA%BF%E7%A8%8Bsleep">1、线程sleep</a></li>
<li><a href="2%E7%BA%BF%E7%A8%8Byield">2、线程yield</a></li>
<li><a href="#3%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7">3、设置线程的优先级</a></li>
<li><a href="#4%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8Bid">4、获取线程ID</a></li>
<li><a href="5%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B">5、获取当前线程</a></li>
<li><a href="#6%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8">6、设置线程上下文类加载器</a></li>
<li><a href="#7%E7%BA%BF%E7%A8%8Binterrupt">7、线程interrupt</a></li>
<li><a href="#8%E7%BA%BF%E7%A8%8Bjoin">8、线程join</a></li>
<li><a href="9%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B">9、关闭线程</a></li>
</ul>
</li>
<li>四、线程安全与数据同步</li>
<li>五、线程间通信</li>
<li>六、ThreadGroup详细讲解</li>
</ul>
<hr>
<h2 id="一、线程介绍"><a href="#一、线程介绍" class="headerlink" title="一、线程介绍"></a>一、线程介绍</h2><h3 id="1、简单案例引入"><a href="#1、简单案例引入" class="headerlink" title="1、简单案例引入"></a>1、简单案例引入</h3><blockquote>
<p>模拟同时从数据库中读取数据和写入文件；</p>
</blockquote>
<ul>
<li>模拟同时从数据库中读取数据和写入文件，这两个操作作为两个线程同时进行，不需要相互的等待；</li>
<li>这里使用的是匿名类创建的线程，重写了Thread类中的run方法，当然也可以通过继承Thread类或者实现Runnable接口来创建线程；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基本的创建线程</span></span><br><span class="line"><span class="comment"> * 模拟两个线程同时执行 读数据库和写文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_01_TryConcurrency</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一边从数据库读取，一边写入文件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">&quot;Read-Thread&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">                readFromData();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();<span class="comment">//start()方法是立刻返回的，不会阻塞</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">&quot;Write-Thread&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                writeToFile() ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start(); <span class="comment">//只有调用start()方法才是线程,不然只是一个普通的类</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFromData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            println(<span class="string">&quot;Begin read data from db......&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span> * <span class="number">5L</span>);</span><br><span class="line">            println(<span class="string">&quot;After read data !&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;Read data successfully!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeToFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            println(<span class="string">&quot;Begin write data to File.......&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span> * <span class="number">5L</span>);</span><br><span class="line">            println(<span class="string">&quot;After write date !&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;Write data successfully!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>效果:</p>
<p><img src="images/t1.png" alt="这里写图片描述"> </p>
<h3 id="2、start和run方法区别"><a href="#2、start和run方法区别" class="headerlink" title="2、start和run方法区别"></a>2、start和run方法区别</h3><ul>
<li>注意只有当Thread的实例调用<code>start()</code>方法时，才能真正的成为一个线程，否则<code>Thread</code>和其他普通的Java对象没有什么区别；</li>
<li>调用<code>run()</code>方法不是一个线程；</li>
<li><code>start()</code>方法是一个立即返回的方法，不会让程序陷入阻塞；</li>
</ul>
<p>下面的代码，如果是<code>t.start()</code>输出的线程名为<code>&quot;Read-Thread&quot;</code>，而如果调用的是<code>t.run()</code>则会输出<code>main</code>线程名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread(<span class="string">&quot;Read-Thread&quot;</span>)&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        println(Thread.currentThread().getName()); <span class="comment">//如果调用start就是&quot;Read-Thread&quot;，如果调用的是run方法就是main</span></span><br><span class="line">        readFromDataBase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  t.start();  //只有调用start()方法才是真正的线程</span></span><br><span class="line">t.run();</span><br></pre></td></tr></table></figure>

<p>Thread中使用了<a href="https://blog.csdn.net/zxzxzx0119/article/details/81709199">模板方法设计模式</a>，也就是我们继承Thread类，重写的是<code>run()</code>方法(钩子方法)，但是调用的却是<code>start()</code>方法(最终方法)的原因。</p>
<p><img src="https://img-blog.csdn.net/20181007190314719?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p>
<p>关于模板方法，简单说: <strong>就是父类写了一些固定的逻辑，但是给自己留了一个方法可以实现，有些逻辑不能改，有些可以改</strong>，看一个简单的例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_02_TemplateMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能给子类实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;################&quot;</span>);</span><br><span class="line">        wrapPrint(msg);</span><br><span class="line">        System.out.println(<span class="string">&quot;################&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给子类实现(也可以写成抽象方法，子类必须实现)</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">wrapPrint</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Code_02_TemplateMethod t1 = <span class="keyword">new</span> Code_02_TemplateMethod()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">wrapPrint</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;**&quot;</span> + msg + <span class="string">&quot;**&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.print(<span class="string">&quot;Hello Thread&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Code_02_TemplateMethod t2 = <span class="keyword">new</span> Code_02_TemplateMethod()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">wrapPrint</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;++&quot;</span> + msg + <span class="string">&quot;++&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.print(<span class="string">&quot;Hello Thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">################</span><br><span class="line">**Hello Thread**</span><br><span class="line">################</span><br><span class="line">################</span><br><span class="line">++Hello Thread++</span><br><span class="line">################</span><br></pre></td></tr></table></figure>

<ul>
<li><code>print</code> 方法类似于 Thread 的 <code>start</code>方法，而 wrapPrint 则类似于 <code>run</code> 方法；</li>
<li>这样做的好处是，程序结构由父类控制，并且是 <code>final</code> 修饰的，不允许被重写，子类只需要实现想要的罗辑任务即可；</li>
</ul>
<p>也就是说<code>start</code>方法中会调用<code>start0</code>方法(并没有调用<code>run</code>方法)，而重新的<code>run</code>方法何时被调用呢?</p>
<p>在开始执行这个线程时，JVM 将会调用该线程的 <code>run</code> 方法，换言之，**<code>run</code> 方法是被 JNI 方法 <code>start0()</code> 调用的**，仔细阅读 <code>start()</code> 的源码将会总结出如下几个知识要点。</p>
<ul>
<li>Thread 被构造后的NEW 状态，事实上 threadStatus 这个内部属性为 0。</li>
<li>不能两次启动 Thread，否则就会出现 IlegalThreadStateException 异常。</li>
<li>线程启动后将会被加入到一个 ThreadGroup 中；</li>
<li>一个线程生命周期结束，也就是到了 TERMINATED 状态，再次调用 start 方法是不允许的，也就是说 TERMINATED 状态是没有办法回到RUNNABLE/RUNNING 状态的。</li>
</ul>
<p>其他总结:</p>
<ul>
<li>Java应用程序的main函数是一个线程，在JVM启动的时候调用，名字叫<code>main</code>；</li>
<li><strong>当你调用一个线程<code>start()</code>方法的时候，此时至少有两个线程，一个是调用你的线程(例如<code>main</code>)，还有一个是执行<code>run()</code>方法的线程；</strong></li>
<li>如果在构造Thread的时候没有传递Runable或者没有复写<code>Thread</code>的<code>run()</code>方法，就不会调用任何东西。只有传递<code>Runable</code>接口的实例(策略模式的算法族)；或者复写了<code>Thread</code>的<code>run()</code>方法(在<code>start()</code>中有一个<code>start0()</code>方法（会调用子类重写的<code>run()</code>方法）)，才会执行相应的逻辑代码；</li>
<li>JVM启动时，实际上有多个线程，但是至少有一个<strong>非守护线程</strong>；s</li>
</ul>
<p>关于守护线程和非守护线程:</p>
<blockquote>
<p>Java分为两种线程：用户线程和守护线程</p>
<p>所谓守护线程是指在程序运行的时候在后台提供一种通用服务的线程，比如<strong>垃圾回收线程</strong>就是一个很称职的守护者，并且这种线程并不属于程序中不可或缺的部分。因此，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任何非守护线程还在运行，程序就不会终止。</p>
<p>守护线程和用户线程的没啥本质的区别：唯一的不同之处就在于<strong>虚拟机的离开：如果用户线程已经全部退出运行了，只剩下守护线程存在了</strong>，虚拟机也就退出了。 因为没有了被守护者，守护线程也就没有工作可做了，也就没有继续运行程序的必要了。</p>
<p>将线程转换为守护线程可以通过调用Thread对象的<code>setDaemon(true)</code>方法来实现。在使用守护线程时需要注意一下几点：</p>
<ul>
<li><code>thread.setDaemon(true)</code>必须在<code>thread.start()</code>之前设置，否则会抛出一个<code>IllegalThreadStateException</code>异常。你不能把正在运行的常规线程设置为守护线程。</li>
<li>在Daemon线程中产生的新线程也是Daemon的。</li>
<li>守护线程应该永远不去访问固有资源，如文件、数据库，因为它会在任何时候甚至在一个操作的中间发生中断。</li>
</ul>
</blockquote>
<h3 id="3、线程生命周期"><a href="#3、线程生命周期" class="headerlink" title="3、线程生命周期"></a>3、线程生命周期</h3><p><img src="images/t2_%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="这里写图片描述"></p>
<p>每种状态的解释: </p>
<h4 id="1-、New状态"><a href="#1-、New状态" class="headerlink" title="1)、New状态"></a>1)、New状态</h4><ul>
<li>当我们用关键字 new 创建一个 Thread 对象时，<strong>此时它并不处于执行状态</strong>；</li>
<li>因为没有调用 <code>start</code> 方法启动该线程，那么线程的状态为<code>NEW</code> 状态。</li>
<li>准确地说，它只是 Thread 对象的状态，因为在没有 start 之前，该线程根本不存在，与你用关键字 new 创建一个普通的 Java对象没什么区别。</li>
<li>NEW 状态通过 <code>start</code> 方法进入 <code>RUNNABLE</code> 状态。</li>
</ul>
<h4 id="2-、Runnable状态"><a href="#2-、Runnable状态" class="headerlink" title="2)、Runnable状态"></a>2)、Runnable状态</h4><ul>
<li><p>线程对象进入 RUNNABLE 状态必须调用 start 方法，那么此时才是真正地在 JVM 进程中创建了一个线程，线程一经启动就可以立即得到执行吗?</p>
</li>
<li><p>答案是否定的，线程的运行与否和进程一样都要听令于 CPU 的调度，那么我们把这个中间状态称为可执行状态(RUNNABLE)，<strong>也就是说它具备执行的资格，但是并没有真正地执行起来而是在等待 CPU的调度</strong>；</p>
</li>
<li><p>由于存在<code>Running</code> 状态，所以不会直接进入<code>BLOCKED</code> 状态和<code>TERMINATED </code>状态，即使是在线程的执行逻辑中调用 wait、sleep 或者其他 block 的 IO 操作等，也必须先获得 CPU 的调度执行权才可以，严格来讲，RUNNABLE 的线程只能<strong>意外终止或者进入RUNNING 状态</strong>；(即<code>Runnable</code>不能直接到<code>BLOCKED</code>和<code>TERMINATED</code>状态)</p>
</li>
</ul>
<h4 id="3-、Running状态"><a href="#3-、Running状态" class="headerlink" title="3)、Running状态"></a>3)、Running状态</h4><p>一且 CPU 通过轮询或者其他方式从任务可执行队列中选中了线程，那么此时它才能真正地执行自己的逻辑代码(也就是RUNNING)，需要说明的一点是<strong>一个正在 RUNNING 状态的线程事实上也是RUNNABLE 的，但是反过来则不成立</strong>。在该状态中，线程的状态可以发生如下的状态转换。</p>
<ul>
<li>直接进入TERMINATED 状态，比如调用 JDK 已经不推荐使用的 stop 方法或者判断某个逻辑标识；</li>
<li>进入 BLOCKED 状态，比如调用了 <code>sleep</code> ，或者 <code>wait</code> 方法而加入了 <code>waitSet</code> 中；</li>
<li>进行某个阻塞的 IO 操作，比如因网络数据的读写而进入了 BLOCKED 状态；</li>
<li>获取某个锁资源，从而加入到该锁的阻塞队列中而进入了 BLOCKED 状态；</li>
<li>由于 CPU 的调度器轮询使该线程放弃执行，进入RUNNABLE 状态；</li>
<li>线程主动调用 <code>yield</code> 方法，放弃 CPU 执行权，进入RUNNABLE 状态；</li>
</ul>
<h4 id="4-、BLOCKED状态"><a href="#4-、BLOCKED状态" class="headerlink" title="4)、BLOCKED状态"></a>4)、BLOCKED状态</h4><p>在BLOCKED状态可以转换的状态:</p>
<ul>
<li> 直接进入TERMINATED 状态，比如调用 JDK 已经不推荐使用的 stop 方法或者意外死亡 (<code>JVM Crash</code> ) ；</li>
<li>  线程阻塞的操作结束，比如读取了想要的数据字节进入到RUNNABLE 状态；</li>
<li> 线程完成了指定时间的休眠，进入到了 RUNNABLE 状态；</li>
<li> Wait 中的线程被其他线程 <code>notify/notifyall</code> 唤醒，进入RUNNABLE 状态；</li>
<li> 线程获取到了某个锁资源，进入RUNNABLE 状态；</li>
<li> 线程在阻塞过程中被打断，比如其他线程调用了 <code>interrupt</code> 方法，进入RUNNABLE；</li>
</ul>
<h4 id="5-、TERMINATED状态"><a href="#5-、TERMINATED状态" class="headerlink" title="5)、TERMINATED状态"></a>5)、TERMINATED状态</h4><p>TERMINATED 是一个线程的最终状态，在该状态中线程将<strong>不会切换到其他任何状态，线程进入TERMINATED 状态，意味着该线程的整个生命周期都结束了。</strong></p>
<p>下列这些情况将会使线程进入 TERMINATED 状态。</p>
<ul>
<li>线程运行正常结束，结束生命周期；</li>
<li>线程运行出错意外结束；</li>
<li><code>JVM Crash</code>，导致所有的线程都结束；</li>
</ul>
<hr>
<h3 id="4、银行排队业务案例"><a href="#4、银行排队业务案例" class="headerlink" title="4、银行排队业务案例"></a>4、银行排队业务案例</h3><p><img src="https://img-blog.csdn.net/20180908220950149?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h4 id="1-、方案一，各个线程各搞各的"><a href="#1-、方案一，各个线程各搞各的" class="headerlink" title="1)、方案一，各个线程各搞各的"></a>1)、方案一，各个线程各搞各的</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_03_TicketWindowTest01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketWindow</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TicketWindow</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (index &lt;= MAX) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;柜台: &quot;</span> + name + <span class="string">&quot;,当前号码: &quot;</span> + (index++));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        TicketWindow t1 = <span class="keyword">new</span> TicketWindow(<span class="string">&quot;一号&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        TicketWindow t2 = <span class="keyword">new</span> TicketWindow(<span class="string">&quot;二号&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        TicketWindow t3 = <span class="keyword">new</span> TicketWindow(<span class="string">&quot;三号&quot;</span>);</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下，可以看到每个柜台都有<code>5</code>个号，显然不对，银行总共才<code>5</code>个号。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">柜台: 二号,当前号码: <span class="number">1</span></span><br><span class="line">柜台: 一号,当前号码: <span class="number">1</span></span><br><span class="line">柜台: 三号,当前号码: <span class="number">1</span></span><br><span class="line">柜台: 二号,当前号码: <span class="number">2</span></span><br><span class="line">柜台: 一号,当前号码: <span class="number">2</span></span><br><span class="line">柜台: 三号,当前号码: <span class="number">2</span></span><br><span class="line">柜台: 二号,当前号码: <span class="number">3</span></span><br><span class="line">柜台: 一号,当前号码: <span class="number">3</span></span><br><span class="line">柜台: 三号,当前号码: <span class="number">3</span></span><br><span class="line">柜台: 一号,当前号码: <span class="number">4</span></span><br><span class="line">柜台: 三号,当前号码: <span class="number">4</span></span><br><span class="line">柜台: 二号,当前号码: <span class="number">4</span></span><br><span class="line">柜台: 一号,当前号码: <span class="number">5</span></span><br><span class="line">柜台: 三号,当前号码: <span class="number">5</span></span><br><span class="line">柜台: 二号,当前号码: <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h4 id="2-、方案二，使用static关键字"><a href="#2-、方案二，使用static关键字" class="headerlink" title="2)、方案二，使用static关键字"></a>2)、方案二，使用static关键字</h4><p>最简单的解决方案 : 将<code>index</code>设置成<code>static</code>，这样每个对象都是用这个值，总共就只有<code>MAX</code>个了。</p>
<p>但是这种方案也有一些缺点:</p>
<ul>
<li><code>static</code>修饰的变量生命周期很长，浪费资源；</li>
<li>如果将号码<code>MAX</code>调整到<code>500、1000</code>等稍微大一点的数字就会出现线程安全问题； </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketWindow</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TicketWindow</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= MAX) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;柜台: &quot;</span> + name + <span class="string">&quot;,当前号码: &quot;</span> + (index++));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类不变， 输出如下，可以看到总共只会输出<code>5</code>次，但是不是好的方案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">柜台: 一号,当前号码: <span class="number">1</span></span><br><span class="line">柜台: 二号,当前号码: <span class="number">2</span></span><br><span class="line">柜台: 三号,当前号码: <span class="number">3</span></span><br><span class="line">柜台: 一号,当前号码: <span class="number">4</span></span><br><span class="line">柜台: 二号,当前号码: <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h4 id="3-、方法三，使用Runnable接口以及策略"><a href="#3-、方法三，使用Runnable接口以及策略" class="headerlink" title="3)、方法三，使用Runnable接口以及策略"></a>3)、方法三，使用Runnable接口以及策略</h4><p><strong>可以使用实现Runnable接口来传入到Thread的构造方法当中，完成和static关键字同样的效果。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_03_TicketWindowTest02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketWindow</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">1</span>; <span class="comment">// 没有做static修饰</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (index &lt;= MAX) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot; 的号码是: &quot;</span> + (index++));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        TicketWindow ticketWindow = <span class="keyword">new</span> TicketWindow(); <span class="comment">// 只有一个 TicketWindow实例</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(ticketWindow, <span class="string">&quot;一号窗口&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(ticketWindow, <span class="string">&quot;二号窗口&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(ticketWindow, <span class="string">&quot;三号窗口&quot;</span>);</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出: (此时号码就是有序的):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread[一号窗口,<span class="number">5</span>,main] 的号码是: <span class="number">1</span></span><br><span class="line">Thread[二号窗口,<span class="number">5</span>,main] 的号码是: <span class="number">2</span></span><br><span class="line">Thread[三号窗口,<span class="number">5</span>,main] 的号码是: <span class="number">3</span></span><br><span class="line">Thread[一号窗口,<span class="number">5</span>,main] 的号码是: <span class="number">4</span></span><br><span class="line">Thread[二号窗口,<span class="number">5</span>,main] 的号码是: <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>重写Thread类的<code>run</code>方法和实现<code>Runnable</code>接口的<code>run</code>方法有一个很大的不同:</p>
<ul>
<li>Thread类的<code>run</code>方法是不能共享的，也就是说<code>A</code>线程不能把<code>B</code>线程的<code>run</code>方法当做自己的执行单元；</li>
<li>而使用<code>Runnable</code>接口则很任意就能实现这一点，<strong>使用同一个<code>Runnable</code>的实例构造不同的Thread实例</strong>；</li>
</ul>
<p><strong>这里注意Runnable接口使用的是设计模式中的<a href="https://blog.csdn.net/zxzxzx0119/article/details/81327444">策略模式</a></strong>: </p>
<ul>
<li>Runnable接口类类似接口的行为族；</li>
<li>具体的实现由我们自己创建的是实现Runnable接口的类来指定，并且重写方法<code>run()</code>方法，具体指定自己的实现。 </li>
</ul>
<blockquote>
<p>很多书籍经常会提到，创建线程有两种方式，第一种是构造一个Thread，第二种是实现 Runnable 接口，这种说法是错误的，最起码是不严谨的，在 JDK 中代表线程的就只有 Thread 这个类，我们在前面分析过，线程的执行单元就是run方法，你可以通过继承 Thread 然后重写 run 方法实现自己的业务逻辑，也可以实现 Runnable 接口实现自己的业务逻辑，代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果构造Thread时传入了Runnable，则会执行runnable的run方法</span></span><br><span class="line">    <span class="keyword">if</span>(target != <span class="keyword">null</span>)&#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则需要重写Thread类的run()方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>准确地讲，创建线程只有一种方式那就是构造Thread 类。</strong></p>
<p><strong>而实现线程的执行单元则有两种方式，第一种是重写 Thread 的 run 方法，第二种是实现 Runnable 接口的 run 方法，并且将 Runnable 实例用作构造 Thread 的参数。</strong></p>
</blockquote>
<h2 id="二、深入理解Thread构造函数"><a href="#二、深入理解Thread构造函数" class="headerlink" title="二、深入理解Thread构造函数"></a>二、深入理解Thread构造函数</h2><h3 id="1、线程的默认命名"><a href="#1、线程的默认命名" class="headerlink" title="1、线程的默认命名"></a>1、线程的默认命名</h3><p>打开JDK的源码可以看到我们构造Thread的时候，默认的线程的名字是</p>
<ul>
<li>以<code>Thread-</code>开头，从<code>0</code>开始计数；</li>
<li>即<code>Thread-0、Thread-1、Thread-2...</code>；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* For autonumbering anonymous threads. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> threadInitNumber;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">nextThreadNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> threadInitNumber++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改线程的名字，在线程启动之前，还有一个而已修改线程名字的机会，一旦线程启动，名字就不可以修改: </p>
<p>下面是在Thread中修改名字的代码: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;name cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>) &#123;</span><br><span class="line">        setNativeName(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、线程的父子关系"><a href="#2、线程的父子关系" class="headerlink" title="2、线程的父子关系"></a>2、线程的父子关系</h3><p>Thread的所有构造函数，最终都会去调用一个静态方法<code>init</code>，我们截取片段代码对其进行分析，不难发现新创建的任何一个线程都会有一个父线程:</p>
<p>这里截取<code>Thread</code>的<code>init</code>的部分代码: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;name cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    Thread parent = currentThread();<span class="comment">//获取当前运行的线程作为赴现场</span></span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">this</span>.group = g;<span class="comment">// 设置线程组</span></span><br><span class="line">    <span class="keyword">this</span>.daemon = parent.isDaemon();<span class="comment">// 当前线程是否为守护线程，取决于父线程</span></span><br><span class="line">    <span class="keyword">this</span>.priority = parent.getPriority(); <span class="comment">// 设置优先级</span></span><br><span class="line">    setPriority(priority);</span><br><span class="line">    <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line">    <span class="comment">/* Set thread ID */</span></span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中的 <code>currentThread() </code>是获取当前线程，在线程生命周期中，我们说过线程的最初状态为NEW，没有执行 start 方法之前，它只能算是一个 Thread 的实例，并不意味着一个新的线程被创建，因此 <code>currentThread()</code> 代表的将会是<strong>创建它的那个线程</strong>，因此我们可以得出以下结论。</p>
<ul>
<li> 一个线程的创建肯定是由另一个线程完成的。</li>
<li> <strong>被创建线程的父线程是创建它的线程</strong>。</li>
</ul>
<p><strong>我们都知道 main 函数所在的线程是由 JVM 创建的，也就是 main 线程，那就意味着我们前面创建的所有线程，其父线程都是 main 线程。</strong></p>
<h3 id="3、Thread和ThreadGroup"><a href="#3、Thread和ThreadGroup" class="headerlink" title="3、Thread和ThreadGroup"></a>3、Thread和ThreadGroup</h3><p>在Thread的构造函数中，可以显示的指定线程的Group，也就是ThreadGroup，下面看<code>init</code>方法的中间部分: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">/* Determine if it&#x27;s an applet or not */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If there is a security manager, ask the security manager</span></span><br><span class="line"><span class="comment">              what to do. */</span></span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        g = security.getThreadGroup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the security doesn&#x27;t have a strong opinion of the matter</span></span><br><span class="line"><span class="comment">              use the parent thread group. */</span></span><br><span class="line">    <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">        g = parent.getThreadGroup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码的意思: <strong>如果在构造Thread的时候没有显示的指定一个ThreadGroup，那么子线程将会被加入父线程所在的线程组。</strong></p>
<p>简单测试代码: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_04_ThreadGroupTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        PrintStream out = System.out;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="string">&quot;t1&quot;</span>);<span class="comment">// 没有给t1指定group</span></span><br><span class="line">        ThreadGroup group1 = <span class="keyword">new</span> ThreadGroup(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(group1, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        ThreadGroup mainGroup = Thread.currentThread().getThreadGroup();</span><br><span class="line"></span><br><span class="line">        out.println(<span class="string">&quot;Main Thread Group : &quot;</span> + mainGroup.getName());</span><br><span class="line">        out.println(t1.getThreadGroup() == mainGroup); <span class="comment">// true // 默认就是main线程的</span></span><br><span class="line">        out.println(t2.getThreadGroup() == mainGroup); <span class="comment">// false</span></span><br><span class="line">        out.println(group1 == t2.getThreadGroup()); <span class="comment">// true // 指定了就是这个了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Main Thread Group : main</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>得出结论: </p>
<ul>
<li>main线程所在的<code>ThreadGroup</code>称为<code>main</code>；</li>
<li>构造一个线程的时候如果没有显示的指定<code>ThreadGroup</code>，那么它将会和父线程属于同一个<code>ThreadGroup</code>（且拥有同样的优先级）；</li>
</ul>
<h3 id="4、Thread和JVM虚拟机栈"><a href="#4、Thread和JVM虚拟机栈" class="headerlink" title="4、Thread和JVM虚拟机栈"></a>4、Thread和JVM虚拟机栈</h3><h4 id="1-、Thread与Stacksize"><a href="#1-、Thread与Stacksize" class="headerlink" title="1)、Thread与Stacksize"></a>1)、Thread与Stacksize</h4><p>看下列<code>Thread</code>构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread(ThreadGroup group, Runnable target, String name, <span class="keyword">long</span> stackSize) </span><br><span class="line"><span class="comment">//分配新的 Thread 对象，以便将 target 作为其运行对象，将指定的 name 作为其名称，作为 group 所引用的线程组的一员，并具有指定的堆栈大小。</span></span><br></pre></td></tr></table></figure>

<p>构造Thread的时候传入<code>stackSize</code>代表着线程占用的<code>stack</code>大小，如果没有指定<code>stackSize</code>的大小，默认是<code>0</code>，<code>0</code>代表着会忽略该参数，改参数会被JNI函数(<code>Native</code>)去使用。</p>
<h4 id="2-、JVM内存结构"><a href="#2-、JVM内存结构" class="headerlink" title="2)、JVM内存结构"></a>2)、JVM内存结构</h4><p>详见<code>JVM</code>相关知识。可看我的<a href="../../Java%E5%9F%BA%E7%A1%80/JVM/JVM%E6%80%BB%E7%BB%93(%E4%B8%80">另一篇博客</a> - 内存区域与内存管理.md)。</p>
<h4 id="3-、Thread与虚拟机栈"><a href="#3-、Thread与虚拟机栈" class="headerlink" title="3)、Thread与虚拟机栈"></a>3)、Thread与虚拟机栈</h4><p>虚拟机栈的大小大概是可以存放21456个栈桢(栈桢中存放局部变量表、操作数栈、动态链接…)，而自己创建的线程的虚拟机栈只有大概15534个栈桢，但是我们可以在创建线程的时候指定<code>stackSize</code>；</p>
<h3 id="5、守护线程"><a href="#5、守护线程" class="headerlink" title="5、守护线程"></a>5、守护线程</h3><p>基本性质。</p>
<ul>
<li>在正常的情况下，如果JVM没有一个<strong>非守护线程</strong>，JVM的进程才会退出。(当只有<code>Daemon</code>线程运行的时候才会退出)；</li>
<li><code>setDaemon()</code>方法必须在<code>start()</code>方法之前调用(否则会抛出<code>IllegalThreadException</code>)；</li>
</ul>
<p>线程是否为守护线程和它的父线程有很大的关系，如果父线程是正常线程，则子线程也是正常线程，反之亦然，如果你想要修改它的特性则可以借助 <code>setDaemon</code> 方法。<code>isDaemon()</code> 方法可以判断该线程是不是守护线程。</p>
<p>另外需要注意的就是，<code>setDaemon()</code> 方法只在线程启动之前才能生效，如果一个线程已经死亡，那么再设置 <code>setDaemon()</code> 则会抛出 <code>IllegalThreadStateException</code> 异常。</p>
<p>看一个<code>daemonThread</code>的例子: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_05_DaemonThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;t running...&quot;</span>);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   Thread.sleep(<span class="number">1_000</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//        t.setDaemon(true);</span></span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">2_000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Main 线程结束!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面注释了<code>t.setDaemon(true);</code>运行结果如下，发现<code>main</code> 线程结束了，但是里面的线程没有结束。</p>
<p><img src="images/t3_Daemon%E7%BB%93%E6%9E%9C.png"></p>
<p>但是如果不注释<code>t.setDaemon(true);</code>，当<code>main</code>线程结束，里面的线程就会结束。</p>
<p><img src="images/t4_.png"></p>
<p><strong>守护线程的作用</strong></p>
<p><strong>如果一个 JVM 进程中没有一个非守护线程，那么 JVM 会退出，也就是说守护线程具备自动结束生命周期的特性，而非守护线程则不具备这个特点</strong>，试想一下如果 JVM 进程的垃圾回收线程是非守护线程，如果 main 线程完成了工作，则 JVM 无法退出，因为垃圾回收线程还在正常的工作。再比如有一个简单的游戏程序，其中有一个线程正在与服务器不断地交互以获取玩家最新的金币、武器信息，若希望在退出游戏客户端的时候，这些数据同步的工作也能够立即结束，等等。</p>
<p>守护线程经常用作与执行一些后台任务，因此有时它也被称为<strong>后台线程</strong>，<strong>当你希望关闭某些线程的时候，或者退出 JVM 进程的时候，一些线程能够自动关闭</strong>，此时就可以考虑用守护线程(<code>setDaemon()</code>)为你完成这样的工作。</p>
<hr>
<h2 id="三、Thread-API的详细内容"><a href="#三、Thread-API的详细内容" class="headerlink" title="三、Thread API的详细内容"></a>三、Thread API的详细内容</h2><h3 id="1、线程sleep"><a href="#1、线程sleep" class="headerlink" title="1、线程sleep"></a>1、线程sleep</h3><h4 id="1-、简单介绍"><a href="#1-、简单介绍" class="headerlink" title="1)、简单介绍"></a>1)、简单介绍</h4><p>两个构造方法</p>
<ul>
<li><p>public static void sleep(long millis) throws InterruptedException</p>
</li>
<li><p>public static void sleep(long millis, int nanos) throws InterruptedException</p>
</li>
</ul>
<p><code>sleep</code> 方法会<strong>使当前线程进入指定毫秒数的休眠</strong>，和暂停执行，虽然给定了一个休眠的时间，但是最终要以系统的定时器和调度器的精度为准，休眠有一个非常重要的特性，那就是其不会放弃 monitor 锁的所有权。</p>
<p>每个线程的休眠互不影响。</p>
<h4 id="2-、使用TimeUnit代替Thread-sleep"><a href="#2-、使用TimeUnit代替Thread-sleep" class="headerlink" title="2)、使用TimeUnit代替Thread.sleep"></a>2)、使用TimeUnit代替Thread.sleep</h4><p>JDKE 引入了一个枚举 TimeUnit，<strong>其对 sleep 方法提供了很好的封装</strong>，使用它可以省去时间单位的换算步骤，比如线程想休眠 3小时24分17秒 88 毫秒，使用TimeUnit 来实现就非常的简便优雅了:</p>
<p>Thread.sleep(12257088L)；</p>
<p>TimeUnit.HOURS.sleep(3)；</p>
<p>TimeUnit.MINUTES.sleep(24) ；</p>
<p>TimeUnit.SECONDS.sleep(17) ;</p>
<p>TimeUnit .MILLISECONDS.sleep(88)；</p>
<p>同样的时间表达，TimeUnit 显然清晰很多，强烈建议，在使用 Thread.sleep 的地方，完全使用TimeUnit 来代替，因为 sleep 能做的事，TimeUnit 全部都能完成，并且功能更加的强大。</p>
<h3 id="2、线程yield"><a href="#2、线程yield" class="headerlink" title="2、线程yield"></a>2、线程yield</h3><h4 id="1-、简单介绍-1"><a href="#1-、简单介绍-1" class="headerlink" title="1)、简单介绍"></a>1)、简单介绍</h4><ul>
<li>这也是一个静态方法，调用该方法，是告诉操作系统的调度器，<strong>我现在不着急占用CPU，你可以先让其他线程运行</strong>。不过，<strong>这对调度器也仅仅是建议，调度器如何处理是不一定的</strong>，它可能完全忽略该调用；</li>
<li>调用<code>yield()</code>方法会使得当前线程从<code>RUNNING</code>状态切换到<code>RUNNABLE</code>状态，这个方法不太常用；</li>
</ul>
<p>例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_06_YieldTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">            create(i).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Thread <span class="title">create</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"><span class="comment">//           if(index == 0)</span></span><br><span class="line"><span class="comment">//               Thread.yield();</span></span><br><span class="line">            System.out.println(index);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的程序运行很多次，你会发现输出的结果不一致，有时候是 0 最先打印出来，有时候是 1 最先打印出来，但是当你打开代码的注释部分，你会发现，顺序始终是0，1。</p>
<p>因为第一个线程如果最先获得了 CPU 资源，它会比较谦虚，主动告诉 CPU 调度器释放了原本属于自己的资源，但是 <code>yield</code> 只是一个提示 (<code>hint</code>)，CPU 调度器并不会担保每次都能满足 <code>yield</code> 提示；</p>
<h4 id="2-、yield和sleep的区别"><a href="#2-、yield和sleep的区别" class="headerlink" title="2)、yield和sleep的区别"></a>2)、yield和sleep的区别</h4><p>看过前面的内容之后，会发现 yield 和 sleep 有一些混淆的地方， 在 JDK1.5 以前的版本中 yield 的方法事实上是调用了 <code>sleep(0)</code>，但是它们之间存在着本质的区别，具体如下。</p>
<ul>
<li><p><code>sleep</code> 会导致当前线程暂停指定的时间，没有 CPU 时间片的消耗。</p>
</li>
<li><p><code>yield</code> 只是对 CPU 调度器的一个提示，如果 CPU 调度器没有忽略这个提示，它会导致线程上下文的切换。</p>
</li>
<li><p><code>sleep</code> 会使线程短暂 block，会在给定的时间内释放 CPU 资源。</p>
</li>
<li><p><code>yield</code> 会使RUNNING 状态的 Thread 进入RUNNABLE 状态 (如果 CPU 调度器没有<br>忽略这个提示的话)。</p>
</li>
<li><p><code>sleep</code> 几乎百分之百地完成了给定时间的休眠，而 yield 的提示并不能一定担保。</p>
</li>
<li><p>一个线程 sleep 另一个线程调用 interrupt 会捕获到<strong>中断信号</strong>，而 yield 则不会。</p>
</li>
</ul>
<h3 id="3、线程优先级"><a href="#3、线程优先级" class="headerlink" title="3、线程优先级"></a>3、线程优先级</h3><p><code>setPriority(int newPriority)</code>、<code>getPriority()</code>方法。</p>
<h4 id="1-、简单介绍-2"><a href="#1-、简单介绍-2" class="headerlink" title="1)、简单介绍"></a>1)、简单介绍</h4><p>进程有进程的优先级，线程同样也有优先级，理论上是优先级比较高的线程会获取优先被 CPU 调度的机会，<strong>但是事实上往往并不会如你所愿</strong>，设置线程的优先级同样也是一个<strong>hint 操作</strong>，有具体如下。</p>
<ul>
<li>对于 root 用户，它会 hint 操作系统你想要设置的优先级别，否则它会被忽略。</li>
<li>如果 CPU 比较忙，设置优先级可能会获得更多的 CPU 时间片，但是闲时优先级的高低几乎不会有任何作用。</li>
</ul>
<p>所以，<strong>不要在程序设计当中企图使用线程优先级绑定某些特定的业务，或者让业务严重依赖于线程优先级</strong>，这可能会让你大失所望。</p>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_07_ThreadPriority</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.setPriority(<span class="number">3</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t2.setPriority(<span class="number">10</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序，会发现t2出现的频率更高一点。</p>
<h4 id="2-、setPriority-int-newPriority-源码"><a href="#2-、setPriority-int-newPriority-源码" class="headerlink" title="2)、setPriority(int newPriority)源码"></a>2)、setPriority(int newPriority)源码</h4><p>源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span> </span>&#123;</span><br><span class="line">    ThreadGroup g;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((g = getThreadGroup()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">            newPriority = g.getMaxPriority();</span><br><span class="line">        &#125;</span><br><span class="line">        setPriority0(priority = newPriority);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出</p>
<ul>
<li>线程的优先级不能小于 1 也不能大于 10；</li>
<li>如果指定的线程优先级大于线程所在 group 的优先级，那么指定的优先级将会失效，取而代之的是 group 的最大优先级；</li>
<li>另外，我们一般不会设置线程优先级，直接使用默认优先级即可，默认优先级一般是5；</li>
</ul>
<h3 id="4、获取线程ID"><a href="#4、获取线程ID" class="headerlink" title="4、获取线程ID"></a>4、获取线程ID</h3><p>简单介绍:</p>
<ul>
<li><code>public long getId()</code>获取线程唯一的ID，线程的ID在整个JVM进程中都是唯一的。并且是从 0 开始逐次递增；</li>
<li>如果你在 main 线程(main 函数) 中创建了一个唯一的线程，并且调用 getId() 后发现其并不等于0，也许你会纳闷，不应该是从 0 开始的吗? 因为在一个JVM 进程启动的时候，实际上是开辟了很多个线程，自增序列已经有了一定的消耗，因此我们自己创建的线程绝非第 0 号线程；</li>
</ul>
<h3 id="5、获取当前线程"><a href="#5、获取当前线程" class="headerlink" title="5、获取当前线程"></a>5、获取当前线程</h3><p>很简单，就是<code>public static Thread currentThread()</code>方法。作用就是返回当前执行线程的引用。</p>
<h3 id="6、设置线程上下文类加载器"><a href="#6、设置线程上下文类加载器" class="headerlink" title="6、设置线程上下文类加载器"></a>6、设置线程上下文类加载器</h3><ul>
<li><code>public ClassLoader getContextClassLoader()</code>获取线程上下文的类加载器，简单来说就是这个线程是由哪个<strong>类加器</strong>加载的，如果是在没有修改线程上下文类加载器的情况下，<strong>则保持与父线程同样的类加载器</strong>。</li>
<li><code>public void setContextClassLoader(ClassLoader cl)</code> 设置该线程的类加载器，这个方法可以打破 JAVA 类加载器的父委托机制，有时候该方法也被称为 JAVA 类加载器的后门。</li>
</ul>
<h3 id="7、线程interrupt"><a href="#7、线程interrupt" class="headerlink" title="7、线程interrupt"></a>7、线程interrupt</h3><p>三个方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="1-、interrupt"><a href="#1-、interrupt" class="headerlink" title="1)、interrupt()"></a>1)、interrupt()</h4><p><strong>调用下面的方法会使得当前线程进入阻塞状态(blocked)，而调用当前线程的<code>interrupt()</code>方法，就可以打断这个阻塞</strong>；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object 的 wait();</span><br><span class="line">Object 的 wait(<span class="keyword">long</span>);</span><br><span class="line">Object 的 wait(<span class="keyword">long</span>, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">Thread 的 sleep(<span class="keyword">long</span>);</span><br><span class="line">Thread 的 sleep(<span class="keyword">long</span>, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">Thread 的 join();</span><br><span class="line">Thread 的 join(<span class="keyword">long</span>);</span><br><span class="line">Thread 的 join(<span class="keyword">long</span>, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">InterruptibleChannel的io方法；</span><br><span class="line">Selector 的 wakeup();</span><br><span class="line">其他</span><br></pre></td></tr></table></figure>

<p>上述若干方法都会使得当前线程进入阻塞状态。</p>
<ul>
<li>若<strong>另外的一个线程调用被阻塞线程的<code>interrupt</code> 方法，则会打断这种阻塞</strong>，因此这种方法有时会被称为可中断方法，记住，<strong>打断一个线程并不等于该线程的生命周期结束</strong>，仅仅是打断了当前线程的阻塞状态。</li>
<li>一旦线程在阻塞的情况下被打断，都会抛出一个称为 <code>InterruptedException </code>的异常，这个异常就像一个 signal (信号) 一样通知当前线程被打断了。</li>
</ul>
<p>简单测试:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_08_ThreadInterrupt</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MINUTES.sleep(<span class="number">1</span>); <span class="comment">// 企图休眠一分钟</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Oh, I am be interrupted...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t.start();</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">2</span>); <span class="comment">// 这里简短的休眠是为了确保线程已经启动了</span></span><br><span class="line">        t.interrupt(); <span class="comment">// 打断线程休眠</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>程序输出:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Oh, I am be interrupted...</span><br></pre></td></tr></table></figure>

<p>解释:</p>
<p>上面的代码创建了一个线程，并且企图休眠 1 分钟的时长，不过很可惜，大约在 2 毫秒秒之后就被主线程调用 <code>interrupt</code> 方法打断。</p>
<p>interrupt 这个方法内部到底做了什么样的事情呢? 在一个线程内部存在着名为 <code>interrupt flag</code>的标识，如果一个线程被 interrupt，那么它的 flag 将被设置。</p>
<p>但是如果当前线程正在执行可中断方法被阻塞时(<code>sleep()</code>)，调用 interrupt 方法将其中断，反而会导致 flag 被清除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        Interruptible b = blocker;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            interrupt0();           <span class="comment">// flag , Just to set the interrupt flag</span></span><br><span class="line">            b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，如果一个线程已经是死亡状态，那么尝试对其的 interrupt 会直接被忽略。</p>
<h4 id="2-、isInterrupted"><a href="#2-、isInterrupted" class="headerlink" title="2)、isInterrupted"></a>2)、isInterrupted</h4><p>作用: 判断当前线程是否被中断。</p>
<p>给个代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_08_ThreadInterrupt2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">//        test1();</span></span><br><span class="line">        test2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">2</span>); <span class="comment">// 这里简短的休眠是为了确保线程已经启动了</span></span><br><span class="line">        System.out.println(t.isInterrupted());</span><br><span class="line">        t.interrupt(); <span class="comment">// 打断线程休眠</span></span><br><span class="line">        System.out.println(t.isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MINUTES.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// 忽略这个异常</span></span><br><span class="line">                    <span class="comment">// 这里 interrupt flag 将会被clear</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;I am be interrupted ?&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">2</span>); <span class="comment">// 这里简短的休眠是为了确保线程已经启动了</span></span><br><span class="line">        System.out.println(t.isInterrupted());</span><br><span class="line">        t.interrupt(); <span class="comment">// 打断线程休眠</span></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">2</span>); <span class="comment">// 这里简短的休眠是为了确保线程已经启动了</span></span><br><span class="line">        System.out.println(t.isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>test1()</code>输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<p><code>test2()</code>输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">false</span><br><span class="line">I am be interrupted ?</span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<p>解释:</p>
<ul>
<li><code>test1()</code>代码代码中定义了一个线程，并且在线程的执行单元中(run 方法) 写了一个空的死循环，为什么不写 sleep 呢? 因为 sleep 是可中断方法，会捕获到中断信号，从而干扰我们程序的结果；</li>
<li><code>test2()</code>对<code>test1()</code>代码做了一些修改。中断方法补货了中断信号<code>signal</code>之后，也就是捕获了<code>InterruptedException</code>异常之后就会擦除<code>interrupt</code>的标识；</li>
</ul>
<h4 id="3-、interrupted"><a href="#3-、interrupted" class="headerlink" title="3)、interrupted"></a>3)、interrupted</h4><p>interrupted 是一个静态方法，虽然其也用于判断当前线程是否被中断，但是它和成员方法 <code>isInterrupted</code> 还是有很大的区别的，<strong>调用该方法会直接控除掉线程的 interrupt 标识</strong>。</p>
<p>需要注意的是，如果当前线程被打断了，那么第一次调用 <code>interrupted </code>方法会返回 true，并且立即清除了 interrupt 标识；第二次包括以后的调用永远都会返回 false，除非在此期间线程又一次地被打断。</p>
<p>写一个程序简单测试:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_08_ThreadInterrupt3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                System.out.println(Thread.interrupted());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.setDaemon(<span class="keyword">true</span>);<span class="comment">//和主程序一起退出</span></span><br><span class="line">        t.start();</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面程序输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">false</span><br><span class="line">false</span><br><span class="line">true  &#x2F;&#x2F; 只会输出一个true</span><br><span class="line">false</span><br><span class="line">false</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="4-、interrupt注意事项"><a href="#4-、interrupt注意事项" class="headerlink" title="4)、interrupt注意事项"></a>4)、interrupt注意事项</h4><p>打开Thread的源码，发现: <code>isInterrupted()</code>和<code>interrupted()</code>方法都调用了同一个本地方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>其中参数<code>ClearInterrupted</code>主要用来控制是否擦除线程<code>interrupted</code>的标识</strong>。</p>
<p><code>isInterrupted()</code>方法的源码中该参数为<code>false</code>，表示不想擦除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);<span class="comment">// 表示不想擦除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>interrupted</code>静态方法中该参数则为<code>true</code>，表示想要擦除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>); <span class="comment">// 表示想要擦除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8、线程join"><a href="#8、线程join" class="headerlink" title="8、线程join"></a>8、线程join</h3>]]></content>
      <categories>
        <category>Java</category>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>Thread</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>MYSQL高级</title>
    <url>/2022/12/31/MYSQL%E9%AB%98%E7%BA%A7/</url>
    <content><![CDATA[<h1 id="MYSQL高级"><a href="#MYSQL高级" class="headerlink" title="MYSQL高级"></a>MYSQL高级</h1><ul>
<li>一、Mysql的架构介绍</li>
<li>二、索引优化分析</li>
<li>三、查询截取分析</li>
<li>四、主从复制</li>
<li>五、Mysql锁机制</li>
</ul>
<h2 id="一、Mysql的架构介绍"><a href="#一、Mysql的架构介绍" class="headerlink" title="一、Mysql的架构介绍"></a>一、Mysql的架构介绍</h2><h3 id="1、Mysql在Linux下的基本安装配置"><a href="#1、Mysql在Linux下的基本安装配置" class="headerlink" title="1、Mysql在Linux下的基本安装配置"></a>1、Mysql在Linux下的基本安装配置</h3><h4 id="1-、查看是否已经安装好"><a href="#1-、查看是否已经安装好" class="headerlink" title="1)、查看是否已经安装好"></a>1)、查看是否已经安装好</h4><p><img src="images/ad1_.png" alt="pic.png"></p>
<h4 id="2-、Mysql的启动和停止"><a href="#2-、Mysql的启动和停止" class="headerlink" title="2)、Mysql的启动和停止"></a>2)、Mysql的启动和停止</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service mysql start # 启动</span><br><span class="line">service mysql stop # 停止</span><br><span class="line"><span class="meta">#</span><span class="bash"> 另外一种启动停止的方式</span></span><br><span class="line">/etc/init.d/mysql start</span><br><span class="line">/etc/init.d/mysql stop</span><br></pre></td></tr></table></figure>

<h4 id="3-、在Linux下配置Mysql的密码"><a href="#3-、在Linux下配置Mysql的密码" class="headerlink" title="3)、在Linux下配置Mysql的密码"></a>3)、在Linux下配置Mysql的密码</h4><p>方式一(在mysql系统之外):<br>在mysql系统外:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqladmin -u root -p password &quot;test123&quot;</span><br><span class="line">Enter password: 【输入原来的密码】</span><br></pre></td></tr></table></figure>

<p>方式二(登录mysql):</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br><span class="line">Enter password: 【输入原来的密码】</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash">use mysql;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> update user <span class="built_in">set</span> password=password(<span class="string">&quot;test&quot;</span>) <span class="built_in">where</span> user=<span class="string">&#x27;root&#x27;</span>;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> flush privileges;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> <span class="built_in">exit</span>;</span>      </span><br></pre></td></tr></table></figure>

<h4 id="4-、Mysql在linux下的安装位置"><a href="#4-、Mysql在linux下的安装位置" class="headerlink" title="4)、Mysql在linux下的安装位置"></a>4)、Mysql在linux下的安装位置</h4><table>
<thead>
<tr>
<th>路径</th>
<th>解释</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>/var/lib/mysql/</td>
<td>mysql数据库文件的存放路径</td>
<td>/var/lib/mysql/</td>
</tr>
<tr>
<td>/usr/share/mysql</td>
<td>配置文件目录</td>
<td>mysql.server命令以及配置文件</td>
</tr>
<tr>
<td>/usr/bin</td>
<td>相关命令目录</td>
<td>mysqladmin mysqldump等命令</td>
</tr>
<tr>
<td>/etc/init.d/mysql</td>
<td>启停相关脚本</td>
<td></td>
</tr>
</tbody></table>
<h4 id="5-、中文乱码问题"><a href="#5-、中文乱码问题" class="headerlink" title="5)、中文乱码问题"></a>5)、中文乱码问题</h4><p>一个很重要的点: <strong>乱码问题解决是你修改完配置之后再建的新的表，之前的表还是会是乱码</strong>。</p>
<p>给一个博客讲解。</p>
<blockquote>
<p><a href="https://www.2cto.com/database/201305/215563.html">https://www.2cto.com/database/201305/215563.html</a></p>
</blockquote>
<h3 id="2、主要配置文件"><a href="#2、主要配置文件" class="headerlink" title="2、主要配置文件"></a>2、主要配置文件</h3><ul>
<li>二进制日志<code>log-bin</code> : 主从复制；</li>
<li>错误日志<code>log-error</code> : <strong>默认是关闭的</strong>，记录严重的警告和错误信息，每次启动和关闭的详细信息等；</li>
<li>查询日志<code>log</code> : 默认关闭，记录查询的<code>sql</code>语句，如果开启会减低<code>mysql</code>的整体性能，因为记录日志也是需要消耗系统资源的；</li>
<li>数据文件</li>
</ul>
<p><img src="images/ad2_%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6.png" alt="images/ad2_数据文件.png"></p>
<ul>
<li>如何配置: ①<code>windows</code>: <code>my.ini</code>文件；②<code>linux</code>: <code>/etc/my.cnf</code>文件；</li>
</ul>
<h3 id="3、Mysql逻辑架构介绍"><a href="#3、Mysql逻辑架构介绍" class="headerlink" title="3、Mysql逻辑架构介绍"></a>3、Mysql逻辑架构介绍</h3><p>Mysql逻辑架构图如下:</p>
<p><img src="images/ad3_mysql%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="images/ad3_mysql服务器逻辑架构图.png"></p>
<p>下面是mysql官网的体系图:</p>
<p><img src="images/ad4_%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84.png" alt="images/ad4_逻辑架构.pngs"></p>
<p>各层的基本概述</p>
<blockquote>
<p>1.连接层</p>
<p>最上层是一些<strong>客户端和连接服务</strong>，包含本地sock通信和大多数基于客户端/服务端工具实现的类似于<code>tcp/ip</code>的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了<strong>线程池</strong>的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p>
<p>2.服务层</p>
<p>第二层架构主要完成大多少的核心服务功能，如SQL接口，并完成<strong>缓存的查询，SQL的分析和优化及部分内置函数的执行</strong>。所有跨存储引擎的功能也在这一层实现，如<strong>过程、函数</strong>等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定查询表的顺序，是否利用索引等，最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</p>
<p>3.引擎层</p>
<p>存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过APl与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。</p>
<p>4.存储层</p>
<p>数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互。</p>
</blockquote>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>InnoDB</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>The Suspects以及并查集总结</title>
    <url>/2022/11/26/The%20Suspects%E4%BB%A5%E5%8F%8A%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="The-Suspects以及并查集总结"><a href="#The-Suspects以及并查集总结" class="headerlink" title="The Suspects以及并查集总结"></a>The Suspects以及并查集总结</h2><ul>
<li>题目</li>
<li>基本并查集</li>
<li>Size优化并查集</li>
<li>Rank优化并查集</li>
<li>路径压缩优化一(最好)</li>
<li>路径压缩优化二(递归)</li>
</ul>
<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="http://poj.org/problem?id=1611">题目链接</a></h4><blockquote>
<p><a href="http://poj.org/problem?id=1611">http://poj.org/problem?id=1611</a></p>
</blockquote>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p> 就是告诉你<code>0</code>号同学被感染了，他还参加了一些社团，给出一些社团以及里面的人，问总共多少人感染。输入给出<code>n</code>表示人数(标号为<code>0~n-1</code>)，<code>m</code>表示社团数目，接下来<code>m</code>行每行第一个数<code>k</code> ，表示该社团有<code>k</code>人，然后是<code>k</code>个人的编号。要你输出有多少个人感染了病毒。</p>
<p><img src="images/uf1.png" alt="在这里插入图片描述"></p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>题目本身并不难: </p>
<ul>
<li>把每个社团加入到各自的集合中，然后不断的合并相同的集合，最后看哪些和<code>0</code>号同学在同一个集合中，使用一个变量记录和<code>0</code>号同学在同一个集合中的人数即可；</li>
<li>这里主要是总结并查集几种优化的方式；</li>
</ul>
<h3 id="基本并查集"><a href="#基本并查集" class="headerlink" title="基本并查集"></a>基本并查集</h3><p>基本并查集，记录一个每个结点p的父亲结点是<code>parent[p]</code>，然后是一个不断从孩子找父亲的过程: </p>
<ul>
<li><code>find()</code>操作，<code> while(p != parent[p])p = parent[p]</code>，一直往上找根的过程；</li>
<li><code>union()</code>操作，就是找到两个结点的根节点，然后将其中一个结点的根节点挂到另一个结点的根节点即可；</li>
</ul>
<p><font color =red>例如: <code>union()</code>操作合并6和3所在的集合:<br><img src="https://img-blog.csdn.net/20180909134516253?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionSet</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnionSet</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">            <span class="comment">/** 初始化, 每一个parent[i]指向自己, 表示每一个元素自己自成一个集合 */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> parent.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找过程, 查找元素p所对应的集合编号</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (p &lt; <span class="number">0</span> || p &gt;= parent.length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;p is out of bound.&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (p != parent[p])</span><br><span class="line">                p = parent[p];</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameSet</span><span class="params">(Integer a, Integer b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> find(b) == find(a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并元素p和元素q所属的集合</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> aRoot = find(a);</span><br><span class="line">            <span class="keyword">int</span> bRoot = find(b);</span><br><span class="line">            <span class="keyword">if</span> (aRoot == bRoot)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            parent[aRoot] = bRoot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line">        <span class="keyword">while</span> (cin.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = cin.nextInt();</span><br><span class="line">            <span class="keyword">int</span> m = cin.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            UnionSet unionSet = <span class="keyword">new</span> UnionSet(n);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> k = cin.nextInt();</span><br><span class="line">                <span class="keyword">int</span> root = cin.nextInt();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k - <span class="number">1</span>; j++) &#123; <span class="comment">//k-1个</span></span><br><span class="line">                    <span class="keyword">int</span> x = cin.nextInt();</span><br><span class="line">                    unionSet.union(root, x); <span class="comment">//这个集合的根</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">1</span>; <span class="comment">//0号已经被感染</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (unionSet.isSameSet(<span class="number">0</span>, i)) &#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Size优化并查集"><a href="#Size优化并查集" class="headerlink" title="Size优化并查集"></a><code>Size</code>优化并查集</h3><ul>
<li>在<code>union()</code>操作中，有一种情况会使得我们的集合变得深度很深，这对查询来说是会降低效率的；</li>
<li><strong>例如下面的<code>union</code>，合并<code>3</code>和<code>9</code>所在的集合，如果我们将<code>3</code>的根<code>8</code>挂在<code>9</code>下面，会使得高度变成<code>4</code>：(不好的）</strong>；</li>
</ul>
<p><img src="https://img-blog.csdn.net/20180909134535670?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><font color =red>于是，我们的解决办法是: </font></p>
<ul>
<li><font color =red>每一个集合记录一个<code>size</code>，在<code>union()</code>操作的时候，我们将<code>size</code>小的挂到<code>size</code>大的下面，这样会使得深度稍微小一点； </font></li>
<li><font color =red>操作完之后记得维护被挂的那个集合的<code>size()</code>；</li>
</ul>
<p><img src="https://img-blog.csdn.net/20180909134546891?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionSet</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] sz;     <span class="comment">// sz[i]表示以i为根的集合中元素个数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionSet</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        sz = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="comment">/** 初始化, 每一个parent[i]指向自己, 表示每一个元素自己自成一个集合 */</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size ; i ++ ) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            sz[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p &lt; <span class="number">0</span> || p &gt;= parent.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;p is out of bound.&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(p != parent[p])</span><br><span class="line">            p = parent[p];</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameSet</span><span class="params">(Integer a, Integer b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(b) == find(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> aRoot = find(a);</span><br><span class="line">        <span class="keyword">int</span> bRoot = find(b);</span><br><span class="line">        <span class="keyword">if</span>(aRoot == bRoot)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 根据两个元素所在树的元素个数不同判断合并方向</span></span><br><span class="line"><span class="comment">         * 将元素个数少的集合合并到元素个数多的集合上</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(sz[aRoot] &lt; sz[bRoot])&#123;</span><br><span class="line">            parent[aRoot] = bRoot;</span><br><span class="line">            sz[bRoot] += sz[aRoot];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            parent[bRoot] = aRoot;</span><br><span class="line">            sz[aRoot] += sz[bRoot];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Rank优化并查集"><a href="#Rank优化并查集" class="headerlink" title="Rank优化并查集"></a><code>Rank</code>优化并查集</h3><ul>
<li><font color= red>基于<code>rank</code>的优化，其中<code>rank[i]</code>表示的是根节点为<code>i</code>的树的高度；</li>
</ul>
<p>发现问题: </p>
<ul>
<li><font color =red>虽然上面的<code>size</code>优化已经很不错，但是如果出现下面的情况，例如合并<code>0</code>和<code>3</code>所在的集合，如下，这样会使得高度变成<code>4</code>，而如果反着合并就只需要变成<code>3</code>；</li>
<li>于是我们需要记录的不是<code>size</code>，而是记录一个高度<code>rank</code>即可；</li>
</ul>
<p><img src="https://img-blog.csdn.net/20180909134703162?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><font color =red>下面是改造的做法，我们将高度小的挂在高度大的下面，这样使得深度更低；<br><img src="https://img-blog.csdn.net/20180909134731165?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionSet</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] rank;   <span class="comment">// rank[i]表示以i为根的集合所表示的树的层数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionSet</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size ; i ++ ) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            rank[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p &lt; <span class="number">0</span> || p &gt;= parent.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;p is out of bound.&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(p != parent[p])</span><br><span class="line">            p = parent[p];</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameSet</span><span class="params">(Integer a, Integer b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(b) == find(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> aRoot = find(a);</span><br><span class="line">        <span class="keyword">int</span> bRoot = find(b);</span><br><span class="line">        <span class="keyword">if</span>(aRoot == bRoot)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *根据两个元素所在树的rank不同判断合并方向</span></span><br><span class="line"><span class="comment">         *将rank低的集合合并到rank高的集合上</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(rank[aRoot] &lt; rank[bRoot])</span><br><span class="line">            parent[aRoot] = bRoot; <span class="comment">// a 挂在 b 下</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rank[bRoot] &lt; rank[aRoot])</span><br><span class="line">            parent[bRoot] = aRoot;</span><br><span class="line">        <span class="keyword">else</span> &#123;  <span class="comment">//rank[aRoot] == rank[bRoot]</span></span><br><span class="line">            parent[aRoot] = bRoot; <span class="comment">// a 挂在　b 下</span></span><br><span class="line">            rank[bRoot]++; <span class="comment">//此时维护rank的值</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="路径压缩优化一-最好"><a href="#路径压缩优化一-最好" class="headerlink" title="路径压缩优化一(最好)"></a>路径压缩优化一(最好)</h3><p>并查集另一个优化就是<font color =red>路径压缩: </font></p>
<ul>
<li>例如下面的三个集合是等价的，但是查询的效率确实逐渐的增加的，第一个查询效率最低，第三个查询效率最高；</li>
<li>我们需要做的就是在find()的时候，沿途将查找的孩子结点改变他们的父亲parent达到路径压缩的目的；</li>
</ul>
<p><img src="images/uf2.png" alt="这里写图片描述"></p>
<p><font color =red>首先来看改造成第二个版本: (使用非递归   )</p>
<ul>
<li><font color =red>这个优化就是对于沿途的结点，我们从底到上，依次更改他们的父亲结点为他们的父亲结点的父亲结点<code>(parent[p] = parent[parent[p]] )</code>；</li>
<li>例如我们查询<code>find(4)</code>，第一步，我们先将<code>parent[4] = 2</code>，（<code>2</code>就是<code>4</code>的父亲(<code>3</code>)的父亲）；</li>
</ul>
<p><img src="https://img-blog.csdn.net/20180909134753889?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<ul>
<li>继续往上，把<code>2</code>的父亲结点改为<code>2</code>的父亲结点的父亲结点，也就是<code>0</code>结点，此时我们的树结构变成了下面的样子；</li>
</ul>
<p><img src="https://img-blog.csdn.net/20180909134808127?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><strong>于是我们就完成了从第一种情况到第二种情况的优化:</strong> </p>
<p><img src="images/uf3.png" alt="这里写图片描述"></p>
<ul>
<li>代码如下： 在代码中的更改只有上一个版本中find()函数中增加了一行代码: parent[p] = parent[parent[p]]；<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionSet</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  在后续的代码中, 我们并不会维护rank的语意, 也就是rank的值在路径压缩的过程中, 有可能不在是树的层数值</span></span><br><span class="line"><span class="comment">     *  这也是我们的rank不叫height或者depth的原因, 他只是作为比较的一个标准</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] rank;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionSet</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size ; i ++ ) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            rank[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p &lt; <span class="number">0</span> || p &gt;= parent.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;p is out of bound.&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(p != parent[p]) &#123;</span><br><span class="line">            <span class="comment">/** p这个结点的父亲设置为它父亲的父亲   ,  相对于第三个版本只增加了这一行代码 */</span></span><br><span class="line">            parent[p] = parent[parent[p]];</span><br><span class="line">            p = parent[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameSet</span><span class="params">(Integer a, Integer b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(b) == find(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> aRoot = find(a);</span><br><span class="line">        <span class="keyword">int</span> bRoot = find(b);</span><br><span class="line">        <span class="keyword">if</span>(aRoot == bRoot)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rank[aRoot] &lt; rank[bRoot])</span><br><span class="line">            parent[aRoot] = bRoot;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rank[bRoot] &lt; rank[aRoot])</span><br><span class="line">            parent[bRoot] = aRoot; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[aRoot] = bRoot;</span><br><span class="line">            rank[bRoot]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="路径压缩优化二-递归"><a href="#路径压缩优化二-递归" class="headerlink" title="路径压缩优化二(递归)"></a>路径压缩优化二(递归)</h3><p><font color = red>继续完成从第一种情况到第三种情况的优化，其实核心代码只有几行: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p != parent[p])</span><br><span class="line">        parent[p] = find(parent[p]);</span><br><span class="line">    <span class="keyword">return</span> parent[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>我们宏观的就是将<code>parent[p]</code>执行了最终的那个根节点，并返回了；</strong></li>
</ul>
<p><img src="images/uf4.png" alt="这里写图片描述"><br><img src="images/uf5.png" alt="这里写图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionSet</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] rank;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionSet</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size ; i ++ ) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            rank[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p &lt; <span class="number">0</span> || p &gt;= parent.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;p is out of bound.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**和上一种路径压缩不同的是　这里使用的是递归　会将所有的孩子都直接挂在根下面*/</span></span><br><span class="line">        <span class="keyword">if</span>(p != parent[p])</span><br><span class="line">            parent[p] = find(parent[p]);</span><br><span class="line">        <span class="keyword">return</span> parent[p];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameSet</span><span class="params">(Integer a, Integer b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(b) == find(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> aRoot = find(a);</span><br><span class="line">        <span class="keyword">int</span> bRoot = find(b);</span><br><span class="line">        <span class="keyword">if</span>(aRoot == bRoot)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rank[aRoot] &lt; rank[bRoot])</span><br><span class="line">            parent[aRoot] = bRoot;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rank[bRoot] &lt; rank[aRoot])</span><br><span class="line">            parent[bRoot] = aRoot;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[aRoot] = bRoot;</span><br><span class="line">            rank[bRoot]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>POJ上测试效率对比，从下到上，从版本一到版本五的时间: </p>
<p><img src="images/uf6.png" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>UnionFind</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基础</title>
    <url>/2022/12/15/MySQL%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h1><ul>
<li><a href="#%E4%B8%80%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">一、数据库的基本操作</a><ul>
<li><a href="#1%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4">1、基本命令</a></li>
<li><a href="#2%E6%95%B0%E6%8D%AE%E5%BA%93%E5%82%A8%E5%AD%98%E5%BC%95%E6%93%8E">2、数据库储存引擎</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">二、数据表的基本操作</a><ul>
<li><a href="#1%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E8%A1%A8">1、创建数据表</a></li>
<li><a href="#2%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E8%A1%A8">2、修改数据表</a></li>
<li><a href="#3%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E8%A1%A8">3、删除数据表</a></li>
<li><a href="#4%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%E5%B0%8F%E7%BB%93">4、综合案例小结</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6">三、数据类型和运算符</a><ul>
<li><a href="#1mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D">1、MYSQL数据类型介绍</a></li>
<li><a href="#2%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">2、如何选择数据类型</a></li>
<li><a href="#3%E5%B8%B8%E8%A7%81%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BB%8B%E7%BB%8D">3、常见运算符介绍</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9Bmysql%E5%87%BD%E6%95%B0">四、Mysql函数</a></li>
<li>查询数据</li>
<li>插入、更新与删除数据</li>
<li>索引</li>
</ul>
<hr>
<h2 id="一、数据库的基本操作"><a href="#一、数据库的基本操作" class="headerlink" title="一、数据库的基本操作"></a>一、数据库的基本操作</h2><h3 id="1、基本命令"><a href="#1、基本命令" class="headerlink" title="1、基本命令"></a>1、基本命令</h3><p><strong>登陆数据库命令:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -h localhost -u root -p</span><br></pre></td></tr></table></figure>
<p><strong>创建数据库命令:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database test_db;</span><br></pre></td></tr></table></figure>
<p><strong>查看已经创建的数据库的定义</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show create database test_db;</span><br></pre></td></tr></table></figure>
<p><strong>查看已经存在的所有数据库:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure>
<p><strong>删除数据库</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> database test_db;</span><br></pre></td></tr></table></figure>
<p>注意删除数据库时要小心，不会给出提示，数据和数据表会一同删除。</p>
<h3 id="2、数据库储存引擎"><a href="#2、数据库储存引擎" class="headerlink" title="2、数据库储存引擎"></a>2、数据库储存引擎</h3><h4 id="1-、查看引擎命令"><a href="#1-、查看引擎命令" class="headerlink" title="1)、查看引擎命令"></a>1)、查看引擎命令</h4><p>使用如下命令查看系统所支持的引擎类型: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show engines;</span><br></pre></td></tr></table></figure>

<h4 id="2-、InnoDB引擎"><a href="#2-、InnoDB引擎" class="headerlink" title="2)、InnoDB引擎"></a>2)、InnoDB引擎</h4><p>InnoDB 是事务型数据库的首选引擎，<strong>支持事务安全表 (ACID ) ，支持行锁定和外键。</strong></p>
<p>InnoDB 作为<strong>默认存储引擎</strong>，特性有:</p>
<ul>
<li> InnoDB 给 MySQL 提供了<strong>具有提交、回滚和崩溃恢复能力的事务安全 (ACID 兼容)存储引擎</strong>。InnoDB 锁定在<strong>行级</strong>并且也在 SELECT 语句中提供一个类似 Oracle 的<strong>非锁定读</strong>。这些功能增加了多用户部署和性能。在 SQL 查询中，可以自由地将 <strong>InnoDB 类型的表与其他MySQL 的表的类型混合起来</strong>，甚至在同一个查询中也可以混合。</li>
<li> InnoDB 是<strong>为处理巨大数据量的最大性能设计</strong>。它的 CPU 效率可能是任何其他基于磁盘的关系数据库引擎所不能匹敌的。</li>
<li> InnoDB 存储引擎完全与 MySQL 服务器整合，I<strong>nnoDB 存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池</strong>。InnoDB <strong>将它的表和索引存在一个逻辑表空间中，表空间可以包含数个文件〈或原始磁盘分区) 。</strong>这与 MyISAM 表不同，比如在 <code>MyISAM</code> 表中每个表被存在分离的文件中。InnoDB 表可以是任何尺寸,，即使在文件尺寸被限制为 2GB 的操作系统上。</li>
<li> InnoDB <strong>支持外键完整性约束 (FOREIGN KEY)</strong> 。存储表中的数据时, 每张表的存储都按主键顺序存放, 如果没有显示在表定义时指定主键，InnoDB 会为每一行生成一个 6B 的ROWID，并以此作为主键。</li>
<li> InnoDB 被用在众多需要高性能的大型数据库站点上。</li>
<li> InnoDB 不创建目录，使用 InnoDB 时，MySQL 将在 MySQL 数据目录下创建一个名为<code>ibdata1</code> 的 10MB 大小的自动扩展数据文件，以及两个名为<code> ib_logfile0</code> 和<code>ib_logfilel</code>的 <code>5MB</code>大小的日志文件。</li>
</ul>
<p>InnoDB 不创建目录，使用 InnoDB 时，MySQL 将在 MySQL 数据目录下创建一个名为<br>ibdatal 的 10MB 大小的自动扩展数据文件，以及两个名为 ib_logfile0 和 ib_logfilel 的 SMB<br>大小的日志文件。</p>
<h4 id="3-、MyISAM引擎"><a href="#3-、MyISAM引擎" class="headerlink" title="3)、MyISAM引擎"></a>3)、MyISAM引擎</h4><p>MyISAM 基于 ISAM 的存储引擎，并对其进行扩展。它是在 <strong>Web、数据存储</strong>和其他应用<br>环境下最常使用的存储引擎之一。MyISAM 拥有较高的插入、查询速度，<strong>但不支持事务</strong>。在<br>MyISAM 主要特性有:</p>
<ul>
<li><strong>大文件</strong> (达 63 位文件长度) 在支持大文件的文件系统和操作系统上被支持。</li>
<li>当把删除、更新及插入操作混合使用的时候，动态尺寸的行产生更少碎片。这要通过合并相邻被删除的块，以及若下一个块被删除，就扩展到下一块来自动完成。</li>
<li>每个 MyISAM 表最大索引数是 64，这可以通过重新编译来改变。每个索引最大的列数是 16 个。</li>
<li>最大的键长度是 1000B，这也可以通过编译来改变。对于键长度超过 250B 的情况，一个超过 1024B 的键将被用上。</li>
<li><strong>BLOB 和TEXT 列可以被索引</strong>。</li>
<li><strong>NULL 值被允许在索引的列中。这个值占每个键的 0~1 个字节</strong>。</li>
<li>所有数字键值以高字节优先被存储以允许一个更高的索引压缩。</li>
<li>每表一个<code>AUTO_INCREMENT</code> 列的内部处理。MyISAM 为 <code>INSERT</code> 和 <code>UPDATE</code> 操作自动更新这一列。这使得 <code>AUTO_INCREMENT </code>列更快〈至少 10%) 。在序列顶的值被删除之后就不能再利用。</li>
<li>可以把<strong>数据文件和索引文件</strong>放在不同目录。</li>
<li>每个字符列可以有不同的字符集。</li>
<li>有VARCHAR 的表可以固定或动态记录长度。</li>
<li>VARCHAR 和CHAR 列可以多达 64KB。</li>
</ul>
<blockquote>
<p>使用 MyISAM 引擎创建数据库，将生产 3 个文件。文件的名字以<strong>表的名字</strong>开始，扩展名指出文件类型， <code>frm</code>文件存储表定义，数据文件的扩展名为<code>.MYD (MYData)</code>，索引文件的扩展名是<code>.MYI MYIndex)</code> 。</p>
</blockquote>
<h4 id="4-、MEMORY引擎"><a href="#4-、MEMORY引擎" class="headerlink" title="4)、MEMORY引擎"></a>4)、MEMORY引擎</h4><p>MEMORY 存储引擎<strong>将表中的数据存储到内存中，为查询和引用其他表数据提供快速访问</strong>。MEMORY 主要特性有:</p>
<ul>
<li>MEMORY 表的每个表可以有多达 32 个索引，每个索引 16 列，以及 500B 的最大键长度。     </li>
<li>MEMORY 存储引擎执行 <strong>HASH 和 BTREE</strong> 索引。</li>
<li>可以在一个MEMORY 表中有非唯一键。</li>
<li>MEMORY 表使用一个固定的记录长度格式。</li>
<li>MEMORY 不支持BLOB 或TEXT 列。</li>
<li>MEMORY 支持 <code>AUTO_INCREMENT</code> 列和<strong>对可包含NULL 值的列的索引</strong>。</li>
<li>MEMORY 表在所有客户端之间共享 (就像其他任何非 TEMPORARY 表) 。</li>
<li><strong>MEMORY 表内容被存在内存中，内存是 MEMORY 表和服务器在查询处理时的空闲中创建的内部表共享</strong>。</li>
<li>当不再需要 MEMORY 表的内容时，<strong>要释放被 MEMORY 表使用的内存</strong>，应该执行<code>DELETE FROM</code> 或TRUNCATE TABLE，或者删除整个表 〈使用DROP TABLE) 。</li>
</ul>
<h4 id="5-、存储引擎的选择"><a href="#5-、存储引擎的选择" class="headerlink" title="5)、存储引擎的选择"></a>5)、存储引擎的选择</font></h4><p>不同存储引擎都有各自的特点，以适应不同的需求。下面是各种引擎的不同的功能: </p>
<p><img src="images/1_%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E9%80%89%E6%8B%A9.png"></p>
<ul>
<li><p>如果要提供提交、回滚和崩溃恢复能力的<strong>事务安全</strong> (ACID 兼容) 能力，并要求实现<strong>并发控制</strong>，InnoDB 是个很好的选择；</p>
</li>
<li><p>如果数据表主要用来<strong>插入和查询记录</strong>，则 MyISAM 引擎能提供较<strong>高的处理效率</strong>；</p>
</li>
<li><p>如果只是<strong>临时存放数据</strong>，数据量不大，并且<strong>不需要较高的数据安全性</strong>，可以选择将<strong>数据保存在内存中</strong>的 Memory 引擎，MySQL 中使用该引擎作为临时表，存放查询的中间结果；</p>
</li>
<li><p>如果只有 <strong>INSERT 和 SELECT 操作</strong>，可以选择 Archive 引擎，Archive 存储引擎支持高并发的插入操作，但是本身<strong>并不是事务安全</strong>的。Archive 存储引擎非常适合<strong>存储归档数据</strong>，如记录日志信息可以使用 Archive 引擎。</p>
</li>
</ul>
<p>使用哪一种引擎要根据需要灵活选择, 一个数据库中多个表可以使用不同引擎以满足各种性能和实际需求。使用合适的存储引擎，将会提高整个数据库的性能。</p>
<blockquote>
<p> 顺便说一下<code>Mysql</code>中单行注释是<code>#</code>，而不是<code>--</code>。</p>
</blockquote>
<hr>
<h2 id="二、数据表的基本操作"><a href="#二、数据表的基本操作" class="headerlink" title="二、数据表的基本操作"></a>二、数据表的基本操作</h2><h3 id="1、创建数据表"><a href="#1、创建数据表" class="headerlink" title="1、创建数据表"></a>1、创建数据表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use test_db;</span><br><span class="line">create table tb_emp1</span><br><span class="line">(</span><br><span class="line">	id int(11),</span><br><span class="line">	name varchar(15),</span><br><span class="line">	deptID int(11),</span><br><span class="line">	salary 	float</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>使用下面语句查看此数据库存在的表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure>
<h4 id="1-、主键约束"><a href="#1-、主键约束" class="headerlink" title="1)、主键约束"></a>1)、主键约束</h4><blockquote>
<p> 主键，又称主码，是表中<strong>一列或多列的组合</strong>。主键约束〈Primary Key Constraint) 要求<strong>主键列的数据唯一，并且不允许为空<code>!= null</code><strong>。主键能够唯一地标识表中的一条记录，可以结合外键</strong>来定义不同数据表之间的关系</strong>， 并且可以加快数据库查询的速度。主键和记录之间的关系如同身份证和人之间的关系，它们之间是一一对应的。主键分为两种类型: <strong>单字段主键和多字段联合主键。</strong></p>
</blockquote>
<ul>
<li>单字段主键；</li>
<li>在定义完所有列之后定义主键；</li>
<li>多字段联合主键；</li>
</ul>
<p>单字段约束: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table tb_emp2</span><br><span class="line">(</span><br><span class="line">	id int(11) primary key,</span><br><span class="line">	name varchar(15),</span><br><span class="line">	deptID int(11),</span><br><span class="line">	salary 	float</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>后面约束: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table tb_emp3</span><br><span class="line">(</span><br><span class="line">	id int(11),</span><br><span class="line">	name varchar(15),</span><br><span class="line">	deptID int(11),</span><br><span class="line">	salary 	float,</span><br><span class="line">	primary key(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>联合约束：假设没有主键<code>id</code>，可以通过<code>name</code>和<code>deptID</code>来确定一个唯一的员工。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table tb_emp4</span><br><span class="line">(</span><br><span class="line">	id int(11),</span><br><span class="line">	name varchar(15),</span><br><span class="line">	deptID int(11),</span><br><span class="line">	salary 	float,</span><br><span class="line">	primary key(name,deptID)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="2-、外键约束"><a href="#2-、外键约束" class="headerlink" title="2)、外键约束"></a>2)、外键约束</h4><ul>
<li>外键用来在两个表的数据之间建立链接， 它可以是一列或者多列。一个表可以有一个或多个外键。<strong>外键对应的是参照完整性</strong>，一个表的外键可以为空值，<strong>若不为空值，则每一个外键值必须等于另一个表中主键的某个值。</strong></li>
<li>外键 : 首先它是表中的一个字段，<strong>它可以不是本表的主键，但对应另外一个表的主键。外键主要作用是保证数据引用的完整性， 定义外键后</strong>，不允许删除在另一个表中具有关联关系的行。外键的作用是保持数据的一致性、完整性。例如，部门表 <code>tb_dept </code>的主键是<code>id</code>，在员工表<code>tb_emp5</code>中有一个键 <code>deptId</code> 与这个<code> id</code> 关联。</li>
</ul>
<p>有关主表和从表:</p>
<ul>
<li><p>主表(父表) : 对于两个具有关联关系的表而言，相关联字段中<strong>主键所在的那个表</strong>即是主表。</p>
</li>
<li><p>从表(子表) : 对于两个具有关联关系的表而言，相关联字段中<strong>外键所在的那个表</strong>即是从表。</p>
</li>
</ul>
<p>需要注意: </p>
<ul>
<li><u>子表的外键必须要关联父表的<strong>主键</strong></u>；</li>
<li><strong>相关联的数据类型必须匹配</strong>；</li>
<li><strong>先删子表，再删父表</strong>；</li>
</ul>
<p>下面的例子**tb_emp5(员工表)中的deptID关联部门表中的ID(主键)**：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;父表</span><br><span class="line">create table tb_dept1</span><br><span class="line">(</span><br><span class="line">	id int(11)primary key,</span><br><span class="line">	name varchar(22) not null,</span><br><span class="line">	location varchar(50)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;子表</span><br><span class="line">create table tb_emp5</span><br><span class="line">(</span><br><span class="line">	id int(11) primary key,</span><br><span class="line">	name varchar(25),</span><br><span class="line">	deptID int(11),</span><br><span class="line">	salary float,</span><br><span class="line">	constraint fk_emp5_dept foreign key(deptID) references tb_dept1(id)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="3-、非空约束"><a href="#3-、非空约束" class="headerlink" title="3)、非空约束"></a>3)、非空约束</h4><p>非空约束指定的字段不能为空，如果添加数据的时候没有指定值，会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table tb_emp6</span><br><span class="line">(</span><br><span class="line">	id int(11) primary key,</span><br><span class="line">	name varchar(15) not null,</span><br><span class="line">	deptID int(11),</span><br><span class="line">	salary 	float</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="4-、唯一性约束"><a href="#4-、唯一性约束" class="headerlink" title="4)、唯一性约束"></a>4)、唯一性约束</h4><ul>
<li>唯一性要求该列唯一；</li>
<li><strong>允许为空，但只能出现一个空值；</strong></li>
<li>唯一性可以确保一列或几列不出现重复值；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table tb_dept2</span><br><span class="line">(</span><br><span class="line">	id int(11)primary key,</span><br><span class="line">	name varchar(22) unique,</span><br><span class="line">	location varchar(50)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table tb_dept3</span><br><span class="line">(</span><br><span class="line">	id int(11)primary key,</span><br><span class="line">	name varchar(22),</span><br><span class="line">	location varchar(50),</span><br><span class="line">	constraint N_uq unique(name)  #N_uq是约束名</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>注意<code>UNIQUE</code>和主键约束(<code>PRIMARY KEY </code>)的区别:</strong> </p>
<ul>
<li> <u>一个表中可以有多个字段声明为<code>UNIQUE</code>，但只能有一个<code>PRIMARY KEY</code> 声明；</u></li>
<li> <u>声明为 <code>PRIMAY KEY</code> 的列不允许有空值，但是声明为 <code>UNIQUE</code>的字段允许空值 (NULL) 的存在。</u></li>
</ul>
<h4 id="5-、默认约束"><a href="#5-、默认约束" class="headerlink" title="5)、默认约束"></a>5)、默认约束</h4><p>指定了默认约束之后，如果没有指定值，就用默认的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table tb_emp7</span><br><span class="line">(</span><br><span class="line">	id int(11) primary key,</span><br><span class="line">	name varchar(15) not null,</span><br><span class="line">	deptID int(11) default 111,</span><br><span class="line">	salary 	float</span><br><span class="line">); </span><br></pre></td></tr></table></figure>
<h4 id="6-、设置表的属性自加"><a href="#6-、设置表的属性自加" class="headerlink" title="6)、设置表的属性自加"></a>6)、设置表的属性自加</h4><ul>
<li>在数据库应用中，经常希望在每次插入新记录时，系统自动生成字段的主键值。可以通过为表主键添加<code>AUTO_INCREMENT</code> 关键字来实现。</li>
<li>默认的，在MySQL 中 <code>AUTO _INCREMENT</code>的初始值是 1，每新增一条记录，字段值自动加 1。</li>
<li><strong>一个表只能有一个字段使用AUTO_INCREMENT 约束，且该字段必须为主键的一部分。</strong></li>
<li><code>AUTO_INCREMENT </code>约束的字段可以是任何整数类型 (TINYINT、SMALLIN、INT、BIGINT 等) 。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table tb_emp8</span><br><span class="line">(</span><br><span class="line">	id int(11) primary key auto_increment,</span><br><span class="line">	name varchar(15) not null,</span><br><span class="line">	deptID int(11),</span><br><span class="line">	salary 	float</span><br><span class="line">); </span><br></pre></td></tr></table></figure>
<h4 id="7-、查看表的结构"><a href="#7-、查看表的结构" class="headerlink" title="7)、查看表的结构"></a>7)、查看表的结构</h4><p><code>desc</code>可以查看表的字段名，数据类型，是否为主键，是否默认值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">desc tb_emp8;</span><br></pre></td></tr></table></figure>
<p>效果如图</p>
<p><img src="images/2_desc%E6%9F%A5%E7%9C%8B%E7%BB%93%E6%9E%9C.png" alt="这里写图片描述"></p>
<p>查看表的详细结构，可以看储存引擎，和字符编码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show create table tb_emp8;</span><br></pre></td></tr></table></figure>
<h3 id="2、修改数据表"><a href="#2、修改数据表" class="headerlink" title="2、修改数据表"></a>2、修改数据表</h3><h4 id="1-、修改表名"><a href="#1-、修改表名" class="headerlink" title="1)、修改表名"></a>1)、修改表名</h4><p>将表<code>tb_dept3</code>改为<code>tb_deptment3</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table tb_dept3 rename tb_deptment3;</span><br></pre></td></tr></table></figure>
<p>查看数据库中的表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure>
<p>修改表名不会改变结构，<code>desc</code>前后结果一样。</p>
<h4 id="2-、修改字段的数据类型"><a href="#2-、修改字段的数据类型" class="headerlink" title="2)、修改字段的数据类型"></a>2)、修改字段的数据类型</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 修改表字段的数据类型,把name列的数据类型改为varchar(33)</span><br><span class="line">alter table tb_dept1 modify name varchar(33);</span><br></pre></td></tr></table></figure>
<h4 id="3-、修改字段名"><a href="#3-、修改字段名" class="headerlink" title="3)、修改字段名"></a>3)、修改字段名</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 修改表的字段名,不改数据类型 将tb_dept1中的location字段改成loc</span><br><span class="line">alter table tb_dept1 change location loc varchar(50);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 修改表的字段名,并且改变数据类型, 同时改变数据类型</span><br><span class="line">alter table tb_dept1 change loc location varchar(60);</span><br></pre></td></tr></table></figure>
<p><code>change</code>也可以只改变数据类型，但是一般不要<strong>轻易改变数据类型</strong>。</p>
<h4 id="4-、添加字段"><a href="#4-、添加字段" class="headerlink" title="4)、添加字段"></a>4)、添加字段</h4><p>有三种添加方式:</p>
<ul>
<li>①默认在最后面添加；</li>
<li>②在第一个位置添加<code>first</code>；</li>
<li>③和指定的位置添加<code>after</code>；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 添加字段(默认在最后面添加)</span><br><span class="line">alter table tb_dept1 add managerID int(10);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 添加字段(默认在最后面添加)(非空约束)</span><br><span class="line">alter table tb_dept1 add column1 int(10) not null;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 添加字段(在第一个位置添加)</span><br><span class="line">alter table tb_dept1 add column2 int(10) first;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 添加字段(在指定位置后面添加)</span><br><span class="line">alter table tb_dept1 add column3 int(10) after name;</span><br></pre></td></tr></table></figure>
<h4 id="5-、删除字段"><a href="#5-、删除字段" class="headerlink" title="5)、删除字段"></a>5)、删除字段</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 删除字段, 删除tb_dept1的column3字段</span><br><span class="line">alter table tb_dept1 drop column3;</span><br></pre></td></tr></table></figure>
<h4 id="6-、修改字段的排列位置"><a href="#6-、修改字段的排列位置" class="headerlink" title="6)、修改字段的排列位置"></a>6)、修改字段的排列位置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 修改字段的排列位置(改到第一个位置)</span><br><span class="line">alter table tb_dept1 modify column1 int(10) first;</span><br><span class="line"># 修改字段的位置为指定的位置</span><br><span class="line">alter table tb_dept1 modify column2 int(10) after name;</span><br></pre></td></tr></table></figure>
<h4 id="7-、更改表的储存引擎"><a href="#7-、更改表的储存引擎" class="headerlink" title="7)、更改表的储存引擎"></a>7)、更改表的储存引擎</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看数据表的定义</span><br><span class="line">show create table tb_deptment3;</span><br><span class="line"># 更改数据表的引擎</span><br><span class="line">alter table tb_deptment3 engine &#x3D; MyISAM;</span><br></pre></td></tr></table></figure>
<h4 id="8-、删除表的外键约束"><a href="#8-、删除表的外键约束" class="headerlink" title="8)、删除表的外键约束"></a>8)、删除表的外键约束</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table tb_emp9</span><br><span class="line">(</span><br><span class="line">	id int(11)primary key,</span><br><span class="line">	deptID int(11),</span><br><span class="line">	name varchar(25),</span><br><span class="line">	salary float,</span><br><span class="line">	constraint fk_emp9_dept foreign key(deptID) references tb_dept1(id)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 删除外键约束</span><br><span class="line">alter table tb_emp9 drop foreign key fk_emp9_dept;</span><br></pre></td></tr></table></figure>
<h3 id="3、删除数据表"><a href="#3、删除数据表" class="headerlink" title="3、删除数据表"></a>3、删除数据表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 删除表</span><br><span class="line">drop table if exists tb_emp9;</span><br></pre></td></tr></table></figure>
<p>注意注意: <strong>删除有关联的数据表的父表的时候，先删除外键再删除父表</strong></p>
<h3 id="4、综合案例小结"><a href="#4、综合案例小结" class="headerlink" title="4、综合案例小结"></a>4、综合案例小结</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database company;</span><br><span class="line">use company;</span><br><span class="line">create table offices</span><br><span class="line">(</span><br><span class="line">	officeCode int(10) primary key not null unique,</span><br><span class="line">	city varchar(50) not null,</span><br><span class="line">	address varchar(50),</span><br><span class="line">	country varchar(50) not null,</span><br><span class="line">	postalCode varchar(15) unique</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">create table employees</span><br><span class="line">(</span><br><span class="line">	employeeNumber int(11) primary key not null unique auto_increment,</span><br><span class="line">	lastName varchar(50) not null,</span><br><span class="line">	firstName varchar(50) not null,</span><br><span class="line">	mobile varchar(25) unique,</span><br><span class="line">	officeCode int(10) not null,</span><br><span class="line">	jobTitle varchar(50) not null,</span><br><span class="line">	birth datetime not null,</span><br><span class="line">	note varchar(255),</span><br><span class="line">	sex varchar(5)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">show tables;</span><br><span class="line">desc employees;</span><br><span class="line"></span><br><span class="line">#将mobile字段修改到officeCode后面</span><br><span class="line">alter table employees modify mobile varchar(25) after officeCode;</span><br><span class="line">#将birth的字段名改为employee_birth</span><br><span class="line">alter table employees change birth employee_birth datetime;</span><br><span class="line">#修改sex字段为char(1)类型，非空约束</span><br><span class="line">alter table employees modify sex char(1) not null;</span><br><span class="line">#删除字段note </span><br><span class="line">alter table employees drop note;</span><br><span class="line">#增加字段名</span><br><span class="line">alter table employees add favoriate_activity varchar(100);</span><br><span class="line"></span><br><span class="line">#为employee增加一个外键</span><br><span class="line">alter table employees add constraint fk_em_off foreign key(officeCode) references offices(officeCode);</span><br><span class="line"></span><br><span class="line">#删除表的外键约束</span><br><span class="line">alter table employees drop foreign key fk_em_off;</span><br><span class="line"></span><br><span class="line">#更改employee的数据引擎</span><br><span class="line">alter table employees engine &#x3D; MyISAM;</span><br><span class="line"></span><br><span class="line">#更改employee的表名</span><br><span class="line">alter table employees rename employees_info;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="三、数据类型和运算符"><a href="#三、数据类型和运算符" class="headerlink" title="三、数据类型和运算符"></a>三、数据类型和运算符</h2><h3 id="1、MYSQL数据类型介绍"><a href="#1、MYSQL数据类型介绍" class="headerlink" title="1、MYSQL数据类型介绍"></a>1、MYSQL数据类型介绍</h3><p>数据类型主要有下面几种</p>
<p>MySQL 支持多种数据类型，主要有<strong>数值类型、日期/时间类型和字符串类型</strong>。</p>
<ul>
<li>数值数据类型: 包括整数类型 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT；浮点小数数据类型 FLOAT 和 DOUBLE；定点小数类型 DECIMAL 。</li>
<li> 日期/时间类型: 包括 YEAR、TIME、DATE、DATETIME 和TIMESTAMP。</li>
<li>字符串类型: 包括 CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM 和 SET 等。字符串类型又分为<strong>文本字符串和二进制字符串</strong>。</li>
</ul>
<h4 id="1-、整数类型"><a href="#1-、整数类型" class="headerlink" title="1)、整数类型"></a>1)、整数类型</h4><p>整数数据类型主要有一下几种：</p>
<p><img src="images/3_%E6%95%B4%E5%BD%A2.png"></p>
<p>不同的数据类型取值范围如下：</p>
<p><img src="images/4_%E6%95%B4%E5%BD%A2%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4.png" alt="在这里插入图片描述"></p>
<p>注意<code>INT</code>(<code>num</code>)中的数和取值范围无关。</p>
<p>举例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table tb_emp1&#123;</span><br><span class="line">	id INT(11),</span><br><span class="line">	name VARCHAR(25),</span><br><span class="line">	deptId INT(11),</span><br><span class="line">	salary FLOAT</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>id </code>字段的数据类型为 INT(11)，注意到后面的数字 11，这表示的是该数据类型指定的显示宽度，指定能够显示的数值中数字的个数。例如，假设声明一个 INT 类型的字段:<code>year INT(4)</code>该声明指明，在 year 字段中的数据一般只显示 4 位数字的宽度。在这里要注意: <strong>显示宽度和数据类型的取值范围是无关的</strong>。显示宽度只是指明 MySQL最大可能显示的数字个数，数值的位数小鱼指定的宽度时会由空格填充。</p>
<h4 id="2-、浮点数类型和定点数类型"><a href="#2-、浮点数类型和定点数类型" class="headerlink" title="2)、浮点数类型和定点数类型"></a>2)、浮点数类型和定点数类型</h4><p>小数类型:</p>
<table>
<thead>
<tr>
<th>类型名称</th>
<th>说明</th>
<th>存储需求</th>
</tr>
</thead>
<tbody><tr>
<td>FLOAT</td>
<td>单精度浮点数</td>
<td>4个字节</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>双精度浮点数</td>
<td>8个字节</td>
</tr>
<tr>
<td>DECIMAL(M, D), DEC</td>
<td>压缩的”严格”<strong>定点数</strong></td>
<td>M+2个字节</td>
</tr>
</tbody></table>
<p>DECIMAL 类型不同于 FLOAT 和 DOUBLE，DECIMAL 实际是以<strong>串</strong>存放的，DECIMAL可能的最大取值范围与 DOUBLE 一样，<strong>但是其有效的取值范围由M 和 D 的值决定</strong>。如果改变 M 而固定D，则其取值范围将随 M 的变大而变大。从表中可以看到，DECIMAL 的存储空间并不是固定的，而由<strong>其精度值 M</strong> 决定，占用 M+2 个字节。</p>
<p>FLOAT 类型的取值范围如下:</p>
<ul>
<li>有符号的取值范围: <code>-3.402823466E+38 ~ -1.175494351E-38</code>。</li>
<li>无符号的取值范围: <code>0</code> 和 <code>1.175494351E-38 ~ 3.402823466E+38</code>。</li>
</ul>
<p>DOUBLE 类型的取值范围如下:</p>
<ul>
<li>有符号的取值范围: <code>-1.7976931348623157E+308 ~ -2.2250738585072014E-308</code>。</li>
<li>无符号的取值范围: <code>0</code> 和 <code>2.2250738585072014E-308 ~ 1.7976931348623157E+308</code>。</li>
</ul>
<p>注意: <strong>不论定点还是浮点类型，如果用户指定的精度超出精度范围，则会四舍五入进行处理。</strong></p>
<p>注意浮点数和定点数的使用场合：</p>
<ul>
<li>在MySQL 中，<strong>定点数以字符串形式存储</strong>，在对精度要求比较高的时候〈如货币，科学数据等) 使用 DECIMAL 的类型比较好；</li>
<li>另外两个浮点数进行减法和比较运算时也容易出问题，<strong>所以在使用浮点型时需要注意，并尽量避免做浮点数比较。</strong></li>
</ul>
<h4 id="3-、时间和日期类型"><a href="#3-、时间和日期类型" class="headerlink" title="3)、时间和日期类型"></a>3)、时间和日期类型</h4><p><img src="images/5_%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F.png" alt="在这里插入图片描述"></p>
<h5 id="a-、Year"><a href="#a-、Year" class="headerlink" title="a)、Year"></a>a)、Year</h5><p><img src="images/6_%E6%97%A5%E6%9C%9FDate.png" alt="在这里插入图片描述"></p>
<p>举几个例子:</p>
<ul>
<li><strong><code>0</code>表示<code>0000</code>，<code>‘0’</code>和<code>‘00’</code>表示<code>2000</code>；</strong></li>
<li>**<code>‘78’</code>和<code>78</code>表示<code>1978</code>，<code>‘68’</code>和<code>68</code>表示<code>2068</code>**；</li>
</ul>
<h5 id="b-、Time"><a href="#b-、Time" class="headerlink" title="b)、Time"></a>b)、Time</h5><p><img src="images/7_%E6%97%B6%E9%97%B4Time.png" alt="在这里插入图片描述"></p>
<p>案例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table tmp4(t Time);</span><br><span class="line">delete from tmp4;</span><br><span class="line">insert into tmp4 values(&#39;10:05:05&#39;),(&#39;23:23&#39;),(&#39;2 10:10&#39;),(&#39;3 02&#39;),(&#39;10&#39;),(now()),(current_time);</span><br></pre></td></tr></table></figure>
<p>效果</p>
<p><img src="images/8_%E6%BC%94%E7%A4%BA%E6%8F%92%E5%85%A5%E7%BB%93%E6%9E%9C.png" alt="这里写图片描述"></p>
<h5 id="c-、Date"><a href="#c-、Date" class="headerlink" title="c)、Date"></a>c)、Date</h5><p><img src="images/9_Date%E6%97%A5%E6%9C%9F.png" alt="在这里插入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table tmp5(d Date);</span><br><span class="line">insert into tmp5 values(&#39;1998-09-01&#39;),(&#39;19980902&#39;),(&#39;980903&#39;),(19980904),(980905),(100906),(000907),(current_date);</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="images/10_%E6%BC%94%E7%A4%BA%E7%BB%93%E6%9E%9C.png" alt="这里写图片描述"></p>
<h5 id="d-、DateTime"><a href="#d-、DateTime" class="headerlink" title="d)、DateTime"></a>d)、DateTime</h5><p><img src="images/11_DateTime.png" alt="在这里插入图片描述"></p>
<p>举例:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tmp6(dt DateTime);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp6 <span class="keyword">values</span>(<span class="string">&#x27;1998-08-08 08:08:08&#x27;</span>),(<span class="string">&#x27;19980809080808&#x27;</span>),(<span class="string">&#x27;98-08-08 08:08:08&#x27;</span>),(<span class="string">&#x27;980808080808&#x27;</span>),(<span class="number">19980808080808</span>),(<span class="number">980808080808</span>);</span><br></pre></td></tr></table></figure>
<p>效果</p>
<p><img src="images/12_%E6%BC%94%E7%A4%BA%E6%95%88%E6%9E%9C.png" alt="这里写图片描述"></p>
<h5 id="e-、TimeStamp"><a href="#e-、TimeStamp" class="headerlink" title="e)、TimeStamp"></a>e)、TimeStamp</h5><p><img src="images/13_TimeStamp.png"></p>
<p><code>TimeStamp</code>把时区修改之后查询结果就会不同，但是<code>DateTime</code>不会。</p>
<h4 id="4-、文本字符串类型"><a href="#4-、文本字符串类型" class="headerlink" title="4)、文本字符串类型"></a>4)、文本字符串类型</h4><p><img src="images/14_%E6%96%87%E6%9C%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B.png" alt="在这里插入图片描述"></p>
<h5 id="a-、char和varchar类型"><a href="#a-、char和varchar类型" class="headerlink" title="a)、char和varchar类型"></a>a)、<code>char</code>和<code>varchar</code>类型</h5><p><code>char</code>数据类型长度不可变，<code>varchar</code>长度可变</p>
<p><img src="images/15_char%E5%92%8Cvarchar.png" alt="在这里插入图片描述"></p>
<p>举例:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tmp8(ch <span class="type">char</span>(<span class="number">4</span>),vch <span class="type">varchar</span>(<span class="number">4</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp8 <span class="keyword">values</span>(<span class="string">&#x27;ab  &#x27;</span>,<span class="string">&#x27;ab  &#x27;</span>);<span class="comment">-- 注意这里有空格</span></span><br><span class="line"><span class="keyword">select</span> concat(<span class="string">&#x27;(&#x27;</span>,ch,<span class="string">&#x27;)&#x27;</span>),concat(<span class="string">&#x27;(&#x27;</span>,vch,<span class="string">&#x27;)&#x27;</span>) <span class="keyword">from</span> tmp8;</span><br></pre></td></tr></table></figure>
<p>看效果<code>vch</code>中的空格没有被截取(即<code>ch</code>末尾的两个空格被删除了，而<code>vch</code>的没有删除)<br><img src="images/16_char%E5%92%8Cvarchar2.png" alt="这里写图片描述"></p>
<h5 id="b-、Text类型"><a href="#b-、Text类型" class="headerlink" title="b)、Text类型"></a>b)、Text类型</h5><p>TEXT 列保存<strong>非二进制字符串</strong>，如文章内容、评论等。当保存或查询 TEXT 列的值时，不删除尾部空格。Text 类型分为 4 种: TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。不同的 TEXT 类型的存储空间和数据长度不同。</p>
<ul>
<li><p>TINYTEXT 最大长度为 255(2<sup>8</sup> - 1)字符的 TEXT 列；</p>
</li>
<li><p>TEXT 最大长度为 65535(2<sup>16</sup> - 1)字符的TEXT 列；</p>
</li>
<li><p>MEDIUMTEXT 最大长度为 16777215(2<sup>24</sup> - 1)字符的TEXT列；</p>
</li>
<li><p>LONGTEXT 最大长度为 4294967295 或 4GB(2<sup>32</sup> - 1)字符的TEXT 列；</p>
</li>
</ul>
<h5 id="c-、Enum类型"><a href="#c-、Enum类型" class="headerlink" title="c)、Enum类型"></a>c)、<code>Enum</code>类型</h5><p>ENUM 是一个字符串对象，其值为表创建时在列规定中枚举的一列值。语法格式如下:’’</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字段名 ENUM(&#39;值1&#39;, &#39;值2&#39;, ..., &#39;值n&#39;)</span><br></pre></td></tr></table></figure>

<p>字段名指将<strong>要定义的字段</strong>，值n指枚举列表中的第 n 个值。 ENUM 类型的字段在取值时，只能在指定的枚举列表中取，而且一次只能取一个。如果创建的成员中有空格时，其尾部的空格将自动被删除。ENUM 值在内部用整数表示，每个枚举值均有一个索引值: <strong>列表值所允许的成员值从 1 开始编号</strong>，MySQL 存储的就是这个索引编号。枚举最多可以有 65 535 个元素。</p>
<p>例如定义 ENUM 类型的列(first，’second’，’third)，该列可以取的值和每个值的索引如表所示:</p>
<p><img src="images/17_emum.png"></p>
<p>举例:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tmp9(enm Enum(<span class="string">&#x27;first&#x27;</span>,<span class="string">&#x27;second&#x27;</span>,<span class="string">&#x27;third&#x27;</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp9 <span class="keyword">values</span>(<span class="string">&#x27;first&#x27;</span>),(<span class="string">&#x27;second&#x27;</span>),(<span class="string">&#x27;third&#x27;</span>),(<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">select</span> enm,enm<span class="operator">+</span><span class="number">0</span> <span class="keyword">from</span> tmp9;</span><br></pre></td></tr></table></figure>
<p><img src="images/18_%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png" alt="这里写图片描述"><br>再看一个实例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tmp10(soc <span class="type">int</span> ,level enum(<span class="string">&#x27;excellent&#x27;</span>,<span class="string">&#x27;good&#x27;</span>,<span class="string">&#x27;bad&#x27;</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp10 <span class="keyword">values</span>(<span class="number">70</span>,<span class="string">&#x27;good&#x27;</span>),(<span class="number">90</span>,<span class="number">1</span>),(<span class="number">75</span>,<span class="number">2</span>),(<span class="number">50</span>,<span class="number">3</span>); #<span class="string">&#x27;excellent&#x27;</span>,<span class="string">&#x27;good&#x27;</span>,<span class="string">&#x27;bad&#x27;</span><span class="comment">--&gt;对应 1，2，3</span></span><br><span class="line"><span class="keyword">select</span> soc,level,level<span class="operator">+</span><span class="number">0</span> <span class="keyword">from</span> tmp10;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tmp10 <span class="keyword">values</span>(<span class="number">100</span>,<span class="number">4</span>); #没有<span class="number">4</span>这个选项</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="images/19_%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C2.png" alt="这里写图片描述"></p>
<h5 id="d-、Set类型"><a href="#d-、Set类型" class="headerlink" title="d)、Set类型"></a>d)、Set类型</h5><p>SET 是一个字符串对象，可以有零或多个值，SET 列最多可以有 64 个成员，其值为表创建时规定的一列值。指定包括多个 SET 成员的 SET 列值时，各成员之间用逗号<code>(, )</code>间隔开。语法格式如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET(&#39;值1&#39;, &#39;值2&#39;, ... &#39;值n&#39;)</span><br></pre></td></tr></table></figure>

<p>与 ENUM 类型相同，SET 值在内部用整数表示，<strong>列表中每一个值都有一个索引编号</strong>。当创建表时，SET 成员值的尾部空格将自动被删除。但与 ENUM 类型不同的是，ENUM 类型的字段只能从定义的列值中选择一个值插入，而 SET 类型的列可从定义的列值中选择多个字符的联合。</p>
<p>如果插入 SET 字段中列值有重复，则 <strong>MySQL 自动删除重复的值</strong>，<strong>插入 SET 字段的值的顺序并不重要</strong>，MySQL 会在存入数据库时，按照定义的顺序显示；如果插入了不正确的值，默认情况下，MySQL 将忽视这些值，并给出警告。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 自动排序去重</span><br><span class="line">create table tmp11(s set(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;));  # 只能插入a,b,c,d这四个值</span><br><span class="line">insert into tmp11 values(&#39;a&#39;),(&#39;a,b,a&#39;),(&#39;c,a,d&#39;);</span><br><span class="line">select *from tmp11;</span><br></pre></td></tr></table></figure>
<p>效果</p>
<p><img src="images/20_SET%E6%B5%8B%E8%AF%95.png" alt="这里写图片描述"></p>
<hr>
<h4 id="5-、二进制字符串类型"><a href="#5-、二进制字符串类型" class="headerlink" title="5)、二进制字符串类型"></a>5)、二进制字符串类型</h4><p><img src="images/21_%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B.png" alt="这里写图片描述"></p>
<h5 id="a-、Bit类型"><a href="#a-、Bit类型" class="headerlink" title="a)、Bit类型"></a>a)、Bit类型</h5><p>保存的是数的二进制表示:</p>
<p>BIT 类型是位字段类型。M 表示每个值的位数，范围为 1-64。如果 M 被省略，默认为 1。如果为 BIT(M)列分配的值的长度小于 M 位，在值的左边用 0填充。例如，为 BIT(6)列分配一个值<code>b&#39;101&#39;</code>，其效果与分配 <code>b&#39;000101&#39;</code>相同。<strong>BIT 数据类型用来保存位字段值</strong>，例如: 以二进制的形式保存数据 13，13 的二进制形式为 1101，在这里需要位数至少为<code>4</code>位的 BIT 类型，即可以定义列类型为 BIT(4)。大于二进制 1111 的数据是不能插入 BIT(4)类型的字段中的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#bit</span><br><span class="line">create table tmp12(b bit(4));</span><br><span class="line">insert into tmp12 values(2),(9),(15);</span><br><span class="line">insert into tmp12 values(16);#报错，只能存到0-15</span><br><span class="line">select b,b+0 from tmp12;</span><br></pre></td></tr></table></figure>
<p>效果</p>
<p><img src="images/22_Bit%E7%B1%BB%E5%9E%8B.png" alt="这里写图片描述"></p>
<h5 id="b-、Binary和varBinary"><a href="#b-、Binary和varBinary" class="headerlink" title="b)、Binary和varBinary"></a>b)、Binary和varBinary</h5><p>BINARY 类型的长度是固定的 指定长度之后 不足最大长度的 将在它们右边填充 <code>&quot;\0&quot;</code>补齐以达到指定长度。例如: 指定列数据类型为 BINARY(3)，当插入“a”时，存储的内容实际为<code>“a\0\0”</code>，当插入<code>“ab”</code>时，实际存储的内容为<code>“ab\0”</code>，不管存储的内容是否达到指定的长度，其存储空间均为指定的值 M。</p>
<p>VARBINARY 类型的长度是可变的，指定好长度之后，其长度可以在 0 到最大值之间。例如: 指定列数据类型为 VARBINARY(20)，如果插入的值的长度只有 10，则实际存储空间为 10 加 1，即其实际占用的空间为字符串的实际长度加 1。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#binary和varbinary</span><br><span class="line">create table tmp13(b binary(3),vb varbinary(30));</span><br><span class="line">insert into tmp13 values(5,5);</span><br><span class="line">select length(b),length(vb) from tmp13;</span><br></pre></td></tr></table></figure>
<p>效果如图:</p>
<p><img src="images/23_%E6%95%88%E6%9E%9C.png" alt="这里写图片描述"></p>
<h5 id="c-、Blob类型"><a href="#c-、Blob类型" class="headerlink" title="c)、Blob类型"></a>c)、Blob类型</h5><p>BLOB是一个二进制大对象，用来存储可变数量的数据。有四种类型: TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB。</p>
<p>**BLOB列存储的是二进制字符串(字节字符串)，TEXT存储的是非二进制字符串(字符字符串)**。</p>
<hr>
<h3 id="2、如何选择数据类型"><a href="#2、如何选择数据类型" class="headerlink" title="2、如何选择数据类型"></a>2、如何选择数据类型</h3><h4 id="1-、整数和浮点数"><a href="#1-、整数和浮点数" class="headerlink" title="1)、整数和浮点数"></a>1)、整数和浮点数</h4><p>如果不需要小数部分，则使用整数来保存数据；</p>
<p>如果需要表示小数部分，则使用浮点数类型。对于浮点数据列，存入的数值会对该列定义的小数位<strong>进行四舍五入</strong>。 例如，如果列的值的范围为 1-99999, 若使用整数，则MEDIUMINT UNSIGNED 是最好的类型，若需要存储小数，则使用 FLOAT 类型。</p>
<p>浮点类型包括 FLOAT 和 DOUBLE 类型。DOUBLE 类型精度比 FLOAT 类型高，因此，如要求存储精度较高时，应选择 DOUBLE 类型。</p>
<h4 id="2-、浮点数和定点数"><a href="#2-、浮点数和定点数" class="headerlink" title="2)、浮点数和定点数"></a>2)、浮点数和定点数</h4><p>浮点数FLOAT、DOUBLE 相对于定点数 DECIMAL 的优势是: <strong>在长度一定的情况下, 浮点数能表示更大的数据范围</strong>，但是由于浮点数容易产生误差。</p>
<p><strong>因此对精确度要求比较高时，建议使用DECIMAL 来存储</strong>。DECIMAL 在 MySQL 中是以<strong>字符串存储</strong>的，用于定义货币等对精确度要求较高的数据。另外<strong>两个浮点数进行减法和比较运算时也容易出问</strong>题，因此在进行计算的时候，一定要小心。如果进行<strong>数值比较，最好使用 DECIMAL 类型</strong>。</p>
<h4 id="3-、日期和时间类型"><a href="#3-、日期和时间类型" class="headerlink" title="3)、日期和时间类型"></a>3)、日期和时间类型</h4><p>MySQL 对于不同种类的日期和时间有很多的数据类型，比如 YEAR 和 TIME。如果只需要记录年份，则使用YEAR 类型即可； 如果只记录时间，只需使用TIME 类型。</p>
<p><strong>如果同时需要记录日期和时间，则可以使用 TIMESTAMP 或者 DATETIME 类型</strong>。由于TIMESTAMP 列的取值范围小于 DATETIME 的取值范围，<strong>因此存储范围较大的日期最好使用DATETIME</strong>。</p>
<p>TIMESTAMP 也有一个DATETIME 不具备的属性。默认的情况下，当插入一条记录但并没有指定 TIMESTAMP 这个列值时，MySQL 会把 TIMESTAMP 列设为当前的时间。<strong>因此当需要插入记录同时插入当前时间</strong>时，使用TIMESTAMP 是方便的，另外 TIMESTAMP 在空间上比 DATETIME 更有效。</p>
<h4 id="4-、char和varchar"><a href="#4-、char和varchar" class="headerlink" title="4)、char和varchar"></a>4)、char和varchar</h4><p>char和varchar的区别:</p>
<ul>
<li><p>char是固定长度字符，varchar是可变长度字符；</p>
</li>
<li><p>CHAR 会自动删除插入数据的尾部空格，VARCHAR 不会删除尾部空格。</p>
</li>
</ul>
<p>CHAR 是固定长度，<strong>所以它的处理速度比 VARCHAR 的速度要快</strong>，但是它的缺点就是浪费存储空间。所以对存储不大，但在速度上有要求的可以使用 CHAR 类型，反之可以使用VARCHAR 类型来实现。</p>
<p>存储引擎对于选择 CHAR 和 VARCHAR 的影响:</p>
<ul>
<li>对于MYyISAM 存储引擎: 最好使用固定长度(<code>char</code>)的数据列代替可变长度的数据列。这样可以使整个表静态化，从而使数据检索更快，用空间换时间。</li>
<li>对于 InnoDB 存储引擎: 使用可变长度(<code>varchar</code>)的数据列，因为 InnoDB 数据表的存储格式不分固定长度和可变长度，因此使用 CHAR 不一定比使用 VARCHAR 更好，但由于VARCHAR 是按照实际的长度存储，比较节省空间，所以对磁盘 IO 和数据存储总量比较好。</li>
</ul>
<h4 id="5-、ENUM和SET"><a href="#5-、ENUM和SET" class="headerlink" title="5)、ENUM和SET"></a>5)、ENUM和SET</h4><p><strong>ENUM 只能取单值</strong>, 它的数据列表是一个<strong>枚举集合</strong>。它的合法取值列表最多允许有 65 535个成员。因此，在需要从<strong>多个值中选取一个</strong>时，可以使用 ENUM。比如: 性别字段适合定义为 ENUM 类型，每次只能从“男”或“女”中取一个值。</p>
<p><strong>SET 可取多值</strong>。它的合法取值列表最多允许有 64 个成员。空字符串也是一个合法的 SET值。在需要<strong>取多个值的时候</strong>，适合使用 SET 类型，比如: 要存储一个人兴趣爱好，最好使用SET 类型 。</p>
<p><strong>ENUM 和 SET 的值是以字符串形式出现的，但在内部，MySQL 以数值的形式存储它们</strong>。</p>
<h4 id="6-、BLOB和TEXT"><a href="#6-、BLOB和TEXT" class="headerlink" title="6)、BLOB和TEXT"></a>6)、BLOB和TEXT</h4><p><strong>BLOB 是二进制字符串，TEXT 是非二进制字符串</strong>，两者均可存放大容量的信息。BLOB主要存储图片、音频信息等，而 TEXT 只能存储纯文本文件。</p>
<hr>
<h3 id="3、常见运算符介绍"><a href="#3、常见运算符介绍" class="headerlink" title="3、常见运算符介绍"></a>3、常见运算符介绍</h3><h4 id="1-、运算符概述"><a href="#1-、运算符概述" class="headerlink" title="1)、运算符概述"></a>1)、运算符概述</h4><p>总共有四大类: </p>
<ol>
<li>算术运算符</li>
</ol>
<p>算术运算符用于各类数值运算，包括加 (+) 、减 (-) 、乘 (+) 、除 (/) 、求余(或称模运算，%) 。</p>
<ol start="2">
<li>比较运算符</li>
</ol>
<p>比较运算符用于比较运算。包括大于 (&gt;) 、小于 (&lt;) 、等于 (=) 、大于等于 (&gt;=) 、小于等于 (&lt;=) 、不等于 (!=) ，以及<code>IN、BETWEEN AND、IS NULL、GREATEST、LEAST、LIKE、REGEXP </code>等。</p>
<ol start="3">
<li>逻辑运算符</li>
</ol>
<p>逻辑运算符的求值所得结果均为1 (TRUE) 、0 (FALSE) ，这类运算符有逻辑非 (NOT或者!) 、逻辑与 (AND 或者&amp;&amp;) 、逻辑或 (OR 或者|) 、逻辑异或 C(XOR) 。</p>
<ol start="4">
<li>位操作运算符</li>
</ol>
<p>位操作运算符参与运算的操作数按二进制位进行运算。包括位与(&amp;) 、位或 (|) 、位非(~) 、位异或 (^) 、左移 (&lt;&lt;) 、右移 (&gt;&gt;) 6种。</p>
<h4 id="2-、算数运算符"><a href="#2-、算数运算符" class="headerlink" title="2)、算数运算符"></a>2)、算数运算符</h4><p>没啥好说的就是<code>+、－、*、/、%</code>。</p>
<h4 id="3-、比较运算符"><a href="#3-、比较运算符" class="headerlink" title="3)、比较运算符"></a>3)、比较运算符</h4><p>注意一下比较运算符</p>
<p><img src="images/24_%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6.png" alt="这里写图片描述"></p>
<p>数值比较有如下规则:</p>
<ul>
<li>若有一个或两个参数为NULL，则比较运算的结果为NULL；</li>
<li>若同一个比较运算中的两个参数都是字符串，则按照字符串进行比较；</li>
<li>若两个参数均为整数，则按照整数进行比较；</li>
<li><strong>若一个字符串和数字进行相等判断，则 MySQL 可以自动将字符串转换为数字</strong>；</li>
</ul>
<p><strong>安全等于运算符</strong></p>
<p>这个操作符和=操作符执行相同的比较操作，不过<code>&lt;=&gt;</code>可以用来判断 NULL 值。在两个操作数均为NULL 时，其返回值为 1 而不为NULL；而当一个操作数为 NULL 时，其返回值为0而不为NULL。</p>
<p><code>&lt;=&gt;</code>在执行比较操作时和<code>&quot;=&quot;</code>的作用是相似的，唯一的区别是<code>&lt;=&gt;</code>可以来对NULL进行判断，两者都为NULL时返回<code>1</code>。</p>
<p><strong>不等于运算符<code>&lt;&gt;</code>或者<code>!=</code></strong>:</p>
<p><code>&quot;&lt;&gt;&quot;</code>或者<code>&quot;!=&quot;</code>用于判断数字、字符串、表达式不相等的判断。如果不相等，返回值为 1； 否则返回值为 0。这两个运算符不能用于判断空值 NULL。</p>
<p><strong>LEAST运算符</strong></p>
<p>语法格式为: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LEAST(值 1,值 2…,值m)</span><br></pre></td></tr></table></figure>

<p>其中值 <code>n</code> 表示参数列表中有<code>n</code>个值。在有两个或多个参数的情况下, 返回最小值。假如任意一个自变量为NULL,则<code>LEAST()</code>的返回值为<code>NULL</code>。</p>
<p><strong>GREATEST</strong></p>
<p>语法格式：<code>GREATEST(值1, 值2, 值3)</code> ，其中<code>n</code>表示参数列表中有<code>n</code>个值。当有<code>2</code>个或多个参数时，返回为最大值，假如任意一个自变量为NULL，则<code>GREATEST()</code>的返回值为NULL。\</p>
<p><strong>LIKE</strong></p>
<p><img src="images/26_LIKE.png" alt="这里写图片描述"></p>
<p><strong>正则表达式REGEXP</strong></p>
<p><img src="images/27_REGEXP.png" alt="这里写图片描述"></p>
<p>看一个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select &#39;ssky&#39; regexp &#39;^s&#39;,&#39;ssky&#39; regexp &#39;y$&#39;, &#39;ssky&#39; regexp &#39;.sky&#39;, &#39;ssky&#39; regexp &#39;[ab]&#39;;</span><br></pre></td></tr></table></figure>
<p>效果</p>
<p><img src="images/25_%E6%AD%A3%E5%88%99%E7%BB%93%E6%9E%9C.png" alt="这里写图片描述">s</p>
<h4 id="4-、逻辑运算符"><a href="#4-、逻辑运算符" class="headerlink" title="4)、逻辑运算符"></a>4)、逻辑运算符</h4><p>和高级语言差不多，不赘述。</p>
<h4 id="5-、位运算"><a href="#5-、位运算" class="headerlink" title="5)、位运算"></a>5)、位运算</h4><p>和高级语言差不多，不赘述。</p>
<h4 id="6-、运算符优先级"><a href="#6-、运算符优先级" class="headerlink" title="6)、运算符优先级"></a>6)、运算符优先级</h4><p><img src="images/28_%E4%BC%98%E5%85%88%E7%BA%A7.png"></p>
<h3 id="4、综合案例-运算符的使用"><a href="#4、综合案例-运算符的使用" class="headerlink" title="4、综合案例-运算符的使用"></a>4、综合案例-运算符的使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table tmp15(note varchar(100),price int);</span><br><span class="line">insert into tmp15 values(&quot;Thisisgood&quot;,50);</span><br><span class="line">#算术运算符</span><br><span class="line">select price,price+10,price-10,price*2,price&#x2F;2,price%3 from tmp15;</span><br><span class="line">#比较运算符</span><br><span class="line">select price,price&gt;10,price&lt;10,price !&#x3D; 10,price &#x3D; 10,price &lt;&#x3D;&gt;10,price &lt;&gt;10 from tmp15;</span><br><span class="line"># in, greatest等</span><br><span class="line">select price,price between 30 and 80,greatest(price,70,30),price in(10,20,50,35) from tmp15;</span><br><span class="line"># 正则等</span><br><span class="line">select note,note is null,note like &#39;t%&#39;,note regexp &#39;$y&#39;,note regexp &#39;[gm]&#39; from tmp15;</span><br><span class="line"># 逻辑运算</span><br><span class="line">select price,price&amp;2,price|4, ~price from tmp15;</span><br><span class="line"># 位运算</span><br><span class="line">select price,price&lt;&lt;2,price&gt;&gt;2 from tmp15;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="四、Mysql函数"><a href="#四、Mysql函数" class="headerlink" title="四、Mysql函数"></a>四、Mysql函数</h2><p>###数学函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#绝对值，π，平方根，去余函数(适用小数)</span><br><span class="line">select abs(-1),pi(),sqrt(9),Mod(31,8),Mod(45.5,6);</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414100041110?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#获取整数的函数</span><br><span class="line">select ceil(-3.5),ceiling(3.5),floor(-3.5),floor(3.5);</span><br></pre></td></tr></table></figure>
<p>效果<img src="https://img-blog.csdn.net/20180414100448562?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#获取随机数的函数</span><br><span class="line">select rand(),rand(),rand(10),rand(10);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdn.net/20180414100756428?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#Round函数(四舍五入函数)，truncate()函数</span><br><span class="line">select round(3.4),(3.6),round(3.16,1),round(3.16,0),round(232.28,-1),truncate(1.31,1),truncate(1.99,1),truncate(19.99,-1);</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414101532820?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#符号函数，幂运算函数pow,power,exp()&#x2F;&#x2F;e的x乘方</span><br><span class="line">select sign(-21),sign(0),sign(21),pow(2,2),power(2,-2),exp(2);</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414101833603?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#自然对数运算和以10为底的对数运算,弧度，角度 radians角度转弧度，弧度转角度</span><br><span class="line">select log(3),log(-3),log10(100),log10(-100),radians(180),degrees(pi()&#x2F;2);</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414102846475?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#正弦函数余弦函数</span><br><span class="line">select sin(pi()&#x2F;2),degrees(asin(1)),cos(pi()),degrees(acos(-1)),round(tan(pi()&#x2F;4)),degrees(atan(1)),cot(pi()&#x2F;4);</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414103636239?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>###字符串函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#字符串函数,concat_ws忽略空值null</span><br><span class="line">select char_length(&#39;aab&#39;),length(&#39;aabb&#39;),concat(&#39;My sql &#39;,&#39;5.7&#39;),concat(&#39;My&#39;,null,&#39;sql&#39;),concat_ws(&#39;-&#39;,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;),concat_ws(&#39;*&#39;,&#39;aa&#39;,null,&#39;bb&#39;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/2018041410443992?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#替换字符串的函数</span><br><span class="line">select insert(&#39;Quest&#39;,2,4,&#39;What&#39;) as Coll,insert(&#39;Quest&#39;,-1,4,&#39;What&#39;) as Coll2,insert(&#39;Quest&#39;,3,100,&#39;Wh&#39;) as Coll3;</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414110146458?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#大小写转换,获取指定长度字符串的函数left,right;</span><br><span class="line">select lower(&#39;ZHENGXIN&#39;),lcase(&#39;ZHENGXIN&#39;),upper(&#39;zhengxin&#39;),ucase(&#39;zhengxin&#39;),left(&#39;football&#39;,5),right(&#39;football&#39;,5);</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414110548833?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#填充字符串的函数,删除空格的函数</span><br><span class="line">select lpad(&#39;hello&#39;,4,&#39;*&#39;),lpad(&#39;hello&#39;,10,&#39;*&#39;),</span><br><span class="line">rpad(&#39;hello&#39;,10,&#39;*&#39;),concat(&#39;(&#39;,ltrim(&#39;   book   &#39;),&#39;)&#39;),</span><br><span class="line">concat(&#39;(&#39;,rtrim(&#39;   book   &#39;),&#39;)&#39;),</span><br><span class="line">concat(&#39;(&#39;,trim(&#39;   book   &#39;),&#39;)&#39;),</span><br><span class="line">trim(&#39;xy&#39; from &#39;xyxyabababxyxy&#39;);</span><br></pre></td></tr></table></figure>
<hr>
<p>效果<br><img src="https://img-blog.csdn.net/20180414112006326?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#重复生成,空格函数，替换函数，比较大小的函数</span><br><span class="line">select repeat(&#39;mysql&#39;,3),concat(&#39;(&#39;,space(6),&#39;)&#39;),</span><br><span class="line">replace(&#39;xxx.baidu.com&#39;,&#39;x&#39;,&#39;w&#39;),strcmp(&#39;abc&#39;,&#39;abd&#39;);</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414133734950?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#获取字串的函数</span><br><span class="line">select substring(&#39;breakfast&#39;,5) as coll,</span><br><span class="line">substring(&#39;breakfast&#39;,3,5) as coll2,</span><br><span class="line">substring(&#39;breakfast&#39;,-3) as coll3, #从后面开始截取3个</span><br><span class="line">substring(&#39;breakfast&#39;,-1,4) as coll4; #从结尾开始第一个位置截取四个</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414134457483?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><font color = crimson>注意还有一个MID函数和substring作用是一样的</font></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#匹配字串开始的位置,字符串逆序</span><br><span class="line">select locate(&#39;ball&#39;,&#39;football&#39;),position(&#39;ball&#39;in&#39;football&#39;),</span><br><span class="line">instr(&#39;football&#39;,&#39;ball&#39;),reverse(&#39;abc&#39;);</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414140015303?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#返回指定位置的值,返回指定字符串的位置的函数</span><br><span class="line">select elt(3,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;),elt(2,&#39;a&#39;),</span><br><span class="line">field(&#39;Hi&#39;,&#39;hihi&#39;,&#39;Hey&#39;,&#39;Hi&#39;,&#39;bas&#39;) as coll,</span><br><span class="line">field(&#39;Hi&#39;,&#39;hihi&#39;,&#39;a&#39;,&#39;b&#39;) as coll2,</span><br><span class="line">find_in_set(&#39;Hi&#39;,&#39;hihi,Hey,Hi,bas&#39;); #返回字串位置的函数</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414141233663?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#make_set()函数的使用</span><br><span class="line">select make_set(1,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;) as coll,#0001选第一个</span><br><span class="line">make_set(1|4, &#39;hello&#39;,&#39;nice&#39;,&#39;word&#39;) as coll2, #0001 0100--&gt;0101 --&gt;选第一和第三</span><br><span class="line">make_set(1|4,&#39;hello&#39;,&#39;nice&#39;,null,&#39;word&#39;) as coll3,#0001 0100--&gt;0101 --&gt;选第一和第三</span><br><span class="line">make_set(0,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;) as coll4; </span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414142118936?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<p>###日期和时间函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#获取日期时间函数</span><br><span class="line">select current_date(),curdate(),curdate()+0,</span><br><span class="line">current_time(),curtime(),curtime()+0,</span><br><span class="line">current_timestamp(),localtime(),now(),sysdate();</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414142607410?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#获取时间的数字,根据时间获取日期(互为反函数)</span><br><span class="line">select unix_timestamp(),unix_timestamp(now()),now(),</span><br><span class="line">from_unixtime(1523689758);</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414151053533?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#返回当前时区日期和时间的函数,日期月份时间函数</span><br><span class="line">select utc_time(),utc_time()+0,</span><br><span class="line">utc_date(),utc_date()+0,</span><br><span class="line">month(&#39;2016-03-04&#39;),monthname(&#39;2016-03-04&#39;),</span><br><span class="line">dayname(&#39;2018-04-14&#39;),dayofweek(&#39;2018-04-14&#39;),</span><br><span class="line">weekday(&#39;2018-04-14&#39;);</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414152120121?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>注意dayofweek和weekday的差别<br><img src="https://img-blog.csdn.net/20180414152202919?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180414152209424?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#返回是这一年的第几周</span><br><span class="line">select week(&#39;2018-4-16&#39;),#默认0表示第一天从周末开始</span><br><span class="line">week(&#39;2018-04-16&#39;,1), #周一#返回是这一年的第几周</span><br><span class="line">dayofyear(&#39;2018-4-16&#39;),dayofmonth(&#39;2018-4-14&#39;), #返回一年中的第几天</span><br><span class="line">year(&#39;2018-4-14&#39;),quarter(&#39;2018-4-14&#39;),</span><br><span class="line">minute(&#39;10:10:02&#39;),second(&quot;10:10:02&quot;);</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414161034181?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#获取指定日期的指定值的函数</span><br><span class="line">select extract(year from &#39;2018-07-06&#39;) as coll,</span><br><span class="line">extract(year_month from &#39;2018-08-06&#39;) as coll2,</span><br><span class="line">extract(day_minute from &#39;2018-07-06 10:11:05&#39;) as coll3;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414161511106?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#时间和秒钟转换的函数</span><br><span class="line">select time_to_sec(&#39;01:00:40&#39;),</span><br><span class="line">sec_to_time(3600);</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414174423286?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#计算日期和时间的函数</span><br><span class="line">select date_add(&#39;2010-12-31 23:59:59&#39;,interval 1 second) as coll,</span><br><span class="line">adddate(&#39;2010-12-31 23:59:59&#39;,interval 1 second) as coll2,</span><br><span class="line">date_add(&#39;2010-12-31 23:59:59&#39;,interval &#39;0:0:1&#39; hour_second) as coll3, #后面的hour_second要看表决定</span><br><span class="line">date_sub(&#39;2011-01-02&#39;,interval 31 day) as coll4,</span><br><span class="line">subdate(&#39;2011-01-02&#39;,interval 31 day) as coll5,</span><br><span class="line">date_sub(&#39;2011-01-02 00:01:00&#39;,interval &#39;0 0:1:1&#39; day_second) as coll6; #对应位置的相减</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414174708360?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#直接输入两个时间，计算</span><br><span class="line">select addtime(&#39;2000-12-31 23:59:59&#39;,&#39;1:1:1&#39;) as coll,</span><br><span class="line">subtime(&#39;2000-12-31 23:59:59&#39;,&#39;1:1:1&#39;)as coll2,</span><br><span class="line">datediff(&#39;2000-12-28&#39;,&#39;2001-01-03&#39;) as coll3; #前面的减后面的</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdn.net/20180414175044280?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>注意看表<br><img src="https://img-blog.csdn.net/20180414174815850?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<p>#####日期和时间格式化的函数<br><img src="https://img-blog.csdn.net/2018041417493265?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180414174940784?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180414174950614?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#时间日期格式化函数</span><br><span class="line">select date_format(&#39;1997-10-04 22:23:00&#39;,&#39;%W %M %Y&#39;) as coll,</span><br><span class="line">date_format(&#39;1997-10-04 22:23:00&#39;,&#39;%D %y %a %d %m %b %j&#39;),</span><br><span class="line">time_format(&#39;16:00:00&#39;,&#39;%H %k %h %I %l&#39;),</span><br><span class="line">date_format(&#39;2000-10-05 22:23:00&#39;,get_format(date,&#39;USA&#39;));</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdn.net/20180414175142523?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>###条件约束函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#条件约束函数</span><br><span class="line">select if(1&gt;2,2,3),</span><br><span class="line">ifNull(null,10),ifNull(1&#x2F;0,100),</span><br><span class="line">case 2 when 1 then &#39;one&#39; when 2 then &#39;two&#39; when 3 then &#39;three&#39; else &#39;more&#39; end, #2等于后面的2返回后面的then</span><br><span class="line">case when 1&gt;2 then &#39;a&#39; else &#39;b&#39; end;</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414190109796?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>###系统信息函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#系统信息函数</span><br><span class="line">select version(),connection_id(),#版本号，连接次数</span><br><span class="line">database(),schema(), #查看当前的数据库名</span><br><span class="line">user(),current_user(),system_user(),session_user();</span><br><span class="line">show processlist;#输出当前用户的连接信息</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414190945328?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#获取字符串的字符集和排列方式的函数</span><br><span class="line">select charset(&#39;abc&#39;),charset(convert(&#39;abc&#39; using latin1)),</span><br><span class="line">charset(version()), #获取字符集</span><br><span class="line">collation(&#39;abc&#39;),collation(convert(&#39;abc&#39; using utf8));#获取排列方式</span><br></pre></td></tr></table></figure>
<p>效果<br>还要注意Last_insert_id最后自动生成的ID值<br><img src="https://img-blog.csdn.net/20180414194735908?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>###加/解密函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#加密解密函数</span><br><span class="line">select password(&#39;newpwd&#39;),MD5(&#39;mypwd&#39;), </span><br><span class="line">encode(&#39;secret&#39;,&#39;cry&#39;),length(encode(&#39;secret&#39;,&#39;cry&#39;)),</span><br><span class="line">decode(encode(&#39;secret&#39;,&#39;cry&#39;),&#39;cry&#39;);#加密后解密</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414195439560?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>###其他函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#其他函数</span><br><span class="line">select format(123.1234,2),format(123.1,3),format(123.123,0),#格式化函数</span><br><span class="line">#不同进制数之间的转换</span><br><span class="line">conv(&#39;a&#39;,16,2),conv(15,10,2),conv(15,10,8),conv(15,10,16);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdn.net/20180414200512674?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#IP地址与数字相互转换的函数</span><br><span class="line">select inet_aton(&#39;209.207.224.40&#39;),inet_ntoa(3520061480),</span><br><span class="line">#枷锁函数和解锁函数</span><br><span class="line">get_lock(&#39;lock1&#39;,10),#这个锁持续10秒</span><br><span class="line">is_used_lock(&#39;lock1&#39;),  #返回当前连接ID</span><br><span class="line">is_free_lock(&#39;lock1&#39;), #是否是可用的</span><br><span class="line">release_lock(&#39;lock1&#39;);</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414201609394?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#重复执行指定操作的函数</span><br><span class="line">select benchmark(5000,password(&#39;newpad&#39;)),</span><br><span class="line">charset(&#39;abc&#39;),charset(convert(&#39;abc&#39; using latin1)),#改变字符集的函数</span><br><span class="line">cast(100 as char(2)),convert(&#39;2010-10-11 12:12:12&#39;,time);#改变数据类型的函数</span><br></pre></td></tr></table></figure>
<p>效果<br><img src="https://img-blog.csdn.net/20180414202751518?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>###综合案列-Mysql函数的使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select round(rand() * 10),round(rand() * 10),round(rand() * 10);#产生三个1-10之间的随机数</span><br><span class="line">select pi(),sin(pi()),cos(0),round(tan(pi()&#x2F;4)),floor(cot(pi()&#x2F;4));</span><br><span class="line"></span><br><span class="line">create database test_db3;</span><br><span class="line">use test_db3;</span><br><span class="line">show tables;</span><br><span class="line">create table member</span><br><span class="line">(</span><br><span class="line">	m_id int(11) primary key auto_increment,</span><br><span class="line">	m_FN varchar(15),</span><br><span class="line">	m_LN varchar(15),</span><br><span class="line">	m_brith datetime,</span><br><span class="line">	m_info varchar(15) null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into member values(null,&#39;Halen&#39;,&#39;Park&#39;,&#39;1970-06-29&#39;,&#39;GoodMan&#39;);</span><br><span class="line"></span><br><span class="line">select length(m_FN),#返回m_FN的长度</span><br><span class="line">concat(m_FN,m_LN),#返回第一条记录中的全名</span><br><span class="line">lower(m_info),#将m_info转换成小写</span><br><span class="line">reverse(m_info) from member;</span><br><span class="line"></span><br><span class="line">select year(curdate())-year(m_brith) as age,#计算年龄</span><br><span class="line">dayofyear(m_brith) as days,</span><br><span class="line">date_format(m_brith,&#39;%W %D %M %Y&#39;) as birthDate from member;</span><br><span class="line"></span><br><span class="line">insert into member values(null,&#39;Samuel&#39;,&#39;Green&#39;,now(),null);</span><br><span class="line"></span><br><span class="line">select last_insert_id(); #输出最后插入的自增的编号</span><br><span class="line"></span><br><span class="line">select m_brith,case when year(m_brith) &lt; 2000 then &#39;old&#39; </span><br><span class="line">when year(m_brith) &gt; 2000 then &#39;young&#39; </span><br><span class="line">else &#39;not born&#39; end as status from member;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>InnoDB</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树之Morris遍历</title>
    <url>/2022/07/05/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8BMorris%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="二叉树之Morris遍历"><a href="#二叉树之Morris遍历" class="headerlink" title="二叉树之Morris遍历"></a>二叉树之Morris遍历</h2><ul>
<li>递归理解以及<code>morris</code>遍历</li>
<li>由<code>morris</code>遍历改成前序遍历</li>
<li>由<code>morris</code>遍历改成中序遍历</li>
<li>由<code>morris</code>遍历改成后续遍历</li>
<li>完整测试代码</li>
</ul>
<hr>
<h3 id="递归理解以及morris遍历"><a href="#递归理解以及morris遍历" class="headerlink" title="递归理解以及morris遍历"></a>递归理解以及<code>morris</code>遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rec</span><span class="params">(Node head)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    System.out.print(head.value + <span class="string">&quot; &quot;</span>); <span class="comment">//这里打印就是前序遍历</span></span><br><span class="line">    rec(head.left);</span><br><span class="line">    System.out.print(head.value + <span class="string">&quot; &quot;</span>); <span class="comment">//这里打印就是中序遍历</span></span><br><span class="line">    rec(head.right);</span><br><span class="line">    System.out.print(head.value + <span class="string">&quot; &quot;</span>); <span class="comment">//这里打印就是后续遍历</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是我们用递归写的三种遍历方法，如果是下面的例子，上面程序输出如下：</p>
<p><img src="images/morris1.png" alt="这里写图片描述"></p>
<p>程序输出:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">4</span> <span class="number">4</span> <span class="number">2</span> <span class="number">5</span> <span class="number">5</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">5</span> <span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">6</span> <span class="number">10</span> <span class="number">10</span> <span class="number">10</span> <span class="number">6</span> <span class="number">6</span> <span class="number">3</span> <span class="number">7</span> <span class="number">11</span> <span class="number">11</span> <span class="number">11</span> <span class="number">7</span> <span class="number">7</span> <span class="number">3</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>可以看到，每一个结点都会被访问三次，也就是说，访问的过程中，每一个结点都会经过三次；</strong></li>
<li><strong>一个结点如果没有<code>parent</code>指针或者我们在非递归遍历中使用栈，是不能回到它的父节点的；</strong></li>
<li><strong>而<code>morris</code>就是借助叶子结点的空闲指针帮助我们想办法回到父亲结点，省去了递归的空间，或者栈的空间，达到<code>O(1)</code>空间；</strong></li>
</ul>
<p>每个结点来到三次: </p>
<p><img src="images/morris2.png" alt="在这里插入图片描述"></p>
<p>下面介绍<code>morris</code>遍历规则(现在和前、中、后序无关，就是<code>morris</code>序):</p>
<p><img src="images/morris3.png" alt="这里写图片描述"></p>
<p>流程看下图的举例:</p>
<p><img src="images/morris4.png" alt="这里写图片描述"> </p>
<p><img src="images/morris5.png" alt="这里写图片描述"></p>
<p>按照上面的解释可以完全写出下面的<code>morris</code>遍历过程(没有打印)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morris</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node mostRight = <span class="keyword">null</span>;<span class="comment">//左子树上最右的结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        mostRight = cur.left;   <span class="comment">//cur的第一个左结点</span></span><br><span class="line">        <span class="keyword">if</span>(mostRight != <span class="keyword">null</span>)&#123;  <span class="comment">//如果左子树不为空</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != cur)&#123; <span class="comment">//找到最右边的结点 有两种情况</span></span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(mostRight.right == <span class="keyword">null</span>)&#123; <span class="comment">//第一次来到这个结点  满足第二大条中的第一条</span></span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">//  cur = cur.left 直接结束所有的</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">//第二次来到这个结点         满足第二大条中的第二条</span></span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.right;  <span class="comment">//包括两种情况的 左子树为空和第二次来到这个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="由morris遍历改成前序遍历"><a href="#由morris遍历改成前序遍历" class="headerlink" title="由morris遍历改成前序遍历"></a>由<code>morris</code>遍历改成前序遍历</h3><p>需要注意几点: </p>
<ul>
<li>首先可以肯定是第一次来到这个结点的时候打印，所以是当<code>mostRight.right == null</code>(第一次来的时候，打印当前的<code>cur</code>)；</li>
<li><strong>其次，如果一个结点没有左子树，相当于只会来到结点一次，就直接打印一遍就可以了；</strong></li>
<li><strong>其实这样的做法等同于在递归的时候把打印的行为放在第一次来到这个结点的时候；</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morrisPre</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node mostRight = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        mostRight = cur.left;</span><br><span class="line">        <span class="keyword">if</span>(mostRight != <span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != cur)&#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(mostRight.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                System.out.print(cur.value + <span class="string">&quot; &quot;</span>);   <span class="comment">//先序是第一次来到这个结点的时候打印</span></span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;    <span class="comment">//如果一个结点没有左子树  相当于只会来到这个结点一次  直接打印，然后往右走</span></span><br><span class="line">            System.out.print(cur.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="由morris遍历改成中序遍历"><a href="#由morris遍历改成中序遍历" class="headerlink" title="由morris遍历改成中序遍历"></a>由<code>morris</code>遍历改成中序遍历</h3><p>中序更加简单: </p>
<ul>
<li>如果一个结点有左子树，那么我打印的时机是我遍历完左子树之后的打印，也就是第二次来到这个结点时候打印，也就是<code>mostRight.right = cur</code>的时候打印；</li>
<li>如果一个结点没有左子树，那么本来也要打印一下，打印完就往右边窜了；</li>
<li>本质就是不论怎么样要处理玩左子树才打印根结点；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morrisIn</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node mostRight = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        mostRight = cur.left;</span><br><span class="line">        <span class="keyword">if</span>(mostRight != <span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != cur)&#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(mostRight.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(cur.value + <span class="string">&quot; &quot;</span>);<span class="comment">//这里包括两种情况 没有左子树和有左子树的第二次来到这里打印</span></span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="由morris遍历改成后续遍历"><a href="#由morris遍历改成后续遍历" class="headerlink" title="由morris遍历改成后续遍历"></a>由<code>morris</code>遍历改成后续遍历</h3><p>后续遍历比较麻烦:  因为<code>morris</code>只会来到一个结点两次，但是递归会来到一个结点三次: </p>
<p>主要看以下几点: </p>
<ul>
<li>我们只关心那些有左子树，也就是会到一个结点两次的结点；</li>
<li>逆序打印有左子树结点的左子树的右边界；</li>
<li>最后打印整棵树的右边界的逆序；</li>
</ul>
<p><img src="images/morris6.png" alt="这里写图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//morris后续</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morrisPos</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node mostRight = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        mostRight = cur.left;</span><br><span class="line">        <span class="keyword">if</span>(mostRight != <span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != cur)&#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(mostRight.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">//第二次来的时候</span></span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">                printEdge(cur.left); <span class="comment">//打印左子树的右边界</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    printEdge(head); <span class="comment">//最后打印整棵树的右边界</span></span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印边界</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printEdge</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先逆序边界</span></span><br><span class="line">    Node tail = reverseEdge(head);</span><br><span class="line">    <span class="comment">//打印</span></span><br><span class="line">    Node cur = tail;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.print(cur.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再逆序回来</span></span><br><span class="line">    reverseEdge(tail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有点类似链表的逆序</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Node <span class="title">reverseEdge</span><span class="params">(Node cur)</span> </span>&#123;</span><br><span class="line">    Node pre = <span class="keyword">null</span>;</span><br><span class="line">    Node next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        next = cur.right;<span class="comment">//先保存下一个</span></span><br><span class="line">        cur.right = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>完整测试代码(例子就是上面的例子): </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Morris</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">createTree</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= arr.length || arr[i] == -<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Node head = <span class="keyword">new</span> Node(arr[i]);</span><br><span class="line">        head.left = createTree(arr, <span class="number">2</span> * i + <span class="number">1</span>);</span><br><span class="line">        head.right = createTree(arr, <span class="number">2</span> * i + <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        System.out.print(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        process(head.left);</span><br><span class="line">        System.out.print(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        process(head.right);</span><br><span class="line">        System.out.print(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        System.out.print(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        pre(head.left);</span><br><span class="line">        pre(head.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        in(head.left);</span><br><span class="line">        System.out.print(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        in(head.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pos</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        pos(head.left);</span><br><span class="line">        pos(head.right);</span><br><span class="line">        System.out.print(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morris</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        Node mostRight = <span class="keyword">null</span>;<span class="comment">//左子树上最右的结点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mostRight = cur.left;   <span class="comment">//cur的第一个左结点</span></span><br><span class="line">            <span class="keyword">if</span> (mostRight != <span class="keyword">null</span>) &#123;  <span class="comment">//如果左子树不为空</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != cur) &#123; <span class="comment">//找到最右边的结点 有两种情况</span></span><br><span class="line">                    mostRight = mostRight.right;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mostRight.right == <span class="keyword">null</span>) &#123; <span class="comment">//第一次来到这个结点  满足第二大条中的第一条</span></span><br><span class="line">                    mostRight.right = cur;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">//  cur = cur.left 直接结束所有的</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">//第二次来到这个结点         满足第二大条中的第二条</span></span><br><span class="line">                    mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.right;  <span class="comment">//包括两种情况的 左子树为空和第二次来到这个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//先序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morrisPre</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        Node mostRight = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mostRight = cur.left;</span><br><span class="line">            <span class="keyword">if</span> (mostRight != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;</span><br><span class="line">                    mostRight = mostRight.right;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mostRight.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mostRight.right = cur;</span><br><span class="line">                    System.out.print(cur.value + <span class="string">&quot; &quot;</span>);   <span class="comment">//先序是第一次来到这个结点的时候打印</span></span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    <span class="comment">//如果一个结点没有左子树  相当于只会来到这个结点一次  直接打印，然后往右走</span></span><br><span class="line">                System.out.print(cur.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morrisIn</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        Node mostRight = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mostRight = cur.left;</span><br><span class="line">            <span class="keyword">if</span> (mostRight != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;</span><br><span class="line">                    mostRight = mostRight.right;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mostRight.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mostRight.right = cur;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(cur.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//morris后续</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morrisPos</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        Node mostRight = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mostRight = cur.left;</span><br><span class="line">            <span class="keyword">if</span> (mostRight != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;</span><br><span class="line">                    mostRight = mostRight.right;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mostRight.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mostRight.right = cur;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">//第二次来的时候</span></span><br><span class="line">                    mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">                    printEdge(cur.left); <span class="comment">//打印左子树的右边界</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        printEdge(head); <span class="comment">//最后打印整棵树的右边界</span></span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印边界</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printEdge</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先逆序边界</span></span><br><span class="line">        Node tail = reverseEdge(head);</span><br><span class="line">        <span class="comment">//打印</span></span><br><span class="line">        Node cur = tail;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(cur.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再逆序回来</span></span><br><span class="line">        reverseEdge(tail);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有点类似链表的逆序</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">reverseEdge</span><span class="params">(Node cur)</span> </span>&#123;</span><br><span class="line">        Node pre = <span class="keyword">null</span>;</span><br><span class="line">        Node next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = cur.right;<span class="comment">//先保存下一个</span></span><br><span class="line">            cur.right = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">9</span>, <span class="number">10</span>, -<span class="number">1</span>, <span class="number">11</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        Node head = createTree(arr, <span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;------------递归树每个结点回到三次-----------&quot;</span>);</span><br><span class="line">        process(head);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------前序----------------&quot;</span>);</span><br><span class="line">        pre(head);</span><br><span class="line">        System.out.println();</span><br><span class="line">        morrisPre(head);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------中序----------------&quot;</span>);</span><br><span class="line">        in(head);</span><br><span class="line">        System.out.println();</span><br><span class="line">        morrisIn(head);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------后序----------------&quot;</span>);</span><br><span class="line">        pos(head);</span><br><span class="line">        System.out.println();</span><br><span class="line">        morrisPos(head);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果:<br><img src="https://img-blog.csdn.net/20180814163945869?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4enh6eDAxMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的各种操作(递归和非递归遍历,树深度,结点个数等等)</title>
    <url>/2022/06/06/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%84%E7%A7%8D%E6%93%8D%E4%BD%9C(%E9%80%92%E5%BD%92%E5%92%8C%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86,%E6%A0%91%E6%B7%B1%E5%BA%A6,%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0%E7%AD%89%E7%AD%89)/</url>
    <content><![CDATA[<h1 id="二叉树的各种操作-递归和非递归遍历-树深度-结点个数等等"><a href="#二叉树的各种操作-递归和非递归遍历-树深度-结点个数等等" class="headerlink" title="二叉树的各种操作(递归和非递归遍历,树深度,结点个数等等)"></a>二叉树的各种操作(递归和非递归遍历,树深度,结点个数等等)</h1><ul>
<li><a href="#%E5%BB%BA%E7%AB%8B%E4%BA%8C%E5%8F%89%E6%A0%91">建立二叉树</a><ul>
<li><a href="#1%E6%A0%B9%E6%8D%AE%E4%B8%8B%E6%A0%87%E5%85%B3%E7%B3%BB">1、根据下标关系</a></li>
<li><a href="#2%E5%89%8D%E5%BA%8F%E8%BE%93%E5%85%A5cin%E5%BB%BA%E7%AB%8B">2、前序输入(cin)建立</a></li>
</ul>
</li>
<li><a href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86">前序遍历</a><ul>
<li><a href="#1%E9%80%92%E5%BD%92%E5%89%8D%E5%BA%8F">1、递归前序</a></li>
<li><a href="#2%E9%9D%9E%E9%80%92%E5%BD%92%E5%89%8D%E5%BA%8F">2、非递归前序</a></li>
</ul>
</li>
<li><a href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86">中序遍历</a><ul>
<li><a href="#1%E9%80%92%E5%BD%92%E4%B8%AD%E5%BA%8F">1、递归中序</a></li>
<li><a href="#2%E3%80%81%E9%9D%9E%E9%80%92%E5%BD%92%E4%B8%AD%E5%BA%8F">2、非递归中序</a></li>
</ul>
</li>
<li><a href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86">后序遍历</a><ul>
<li><a href="#1%E9%80%92%E5%BD%92%E5%90%8E%E5%BA%8F">1、递归后序</a></li>
<li><a href="#2%E9%9D%9E%E9%80%92%E5%BD%92%E5%90%8E%E5%BA%8F">2、非递归后序</a></li>
</ul>
</li>
<li><a href="#%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86">层次遍历</a></li>
<li><a href="#%E5%AF%BB%E6%89%BE%E6%A0%91%E4%B8%AD%E6%9C%89%E6%B2%A1%E6%9C%89%E5%80%BC%E4%B8%BAx%E7%9A%84%E7%BB%93%E7%82%B9">寻找树中有没有值为x的结点</a></li>
<li><a href="#%E7%BB%9F%E8%AE%A1%E6%A0%91%E4%B8%AD%E7%BB%93%E7%82%B9%E7%9A%84%E4%B8%AA%E6%95%B0">统计树中结点的个数</a></li>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6">计算树的高度</a></li>
<li><a href="#%E5%88%A4%E6%96%AD%E4%B8%A4%E9%A2%97%E6%A0%91%E6%98%AF%E4%B8%8D%E6%98%AF%E7%9B%B8%E7%AD%89">判断两颗树是不是相等</a></li>
<li><a href="#%E5%AE%8C%E6%95%B4%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">完整测试代码</a></li>
</ul>
<hr>
<h2 id="二叉树建立"><a href="#二叉树建立" class="headerlink" title="二叉树建立"></a>二叉树建立</h2><p>先给出结点结构: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种建立方式:</p>
<ul>
<li>可以根据二叉树根节点和左右子结点的下标关系递归建立二叉树，层次输入二叉树结点；</li>
<li><font color = red>也可以使用输入流前序建立二叉树(注意空树要输入-1)；</li>
</ul>
<h3 id="1、根据下标关系"><a href="#1、根据下标关系" class="headerlink" title="1、根据下标关系"></a>1、根据下标关系</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// given a arr to build</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Node <span class="title">createTree</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= arr.length || arr[i] == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Node root = <span class="keyword">new</span> Node(arr[i]);</span><br><span class="line">    root.left = createTree(arr, <span class="number">2</span> * i + <span class="number">1</span>);</span><br><span class="line">    root.right = createTree(arr, <span class="number">2</span> * i + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大致过程如下:<br><img src="images/all1.png" alt="这里写图片描述"></p>
<h3 id="2、前序输入-cin-建立"><a href="#2、前序输入-cin-建立" class="headerlink" title="2、前序输入(cin)建立"></a>2、前序输入(cin)建立</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cin method	</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Node <span class="title">buildTree</span><span class="params">(Scanner cin)</span> </span>&#123;</span><br><span class="line">    Node root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> data = cin.nextInt();</span><br><span class="line">    <span class="keyword">if</span> (data != -<span class="number">1</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node(data);</span><br><span class="line">        root.left = buildTree(cin);</span><br><span class="line">        root.right = buildTree(cin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>过程如下:<br><img src="images/all2.png" alt="这里写图片描述"></p>
<h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><h3 id="1、递归前序"><a href="#1、递归前序" class="headerlink" title="1、递归前序"></a>1、递归前序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    System.out.print(T.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    preOrder(T.left);</span><br><span class="line">    preOrder(T.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、非递归前序"><a href="#2、非递归前序" class="headerlink" title="2、非递归前序"></a>2、非递归前序</h3><p>前序遍历顺序为: <strong>根结点-&gt;左子树-&gt;右子树</strong>，所以对于正在访问的根结点，可以直接访问，访问完之后，按照相同的方式访问左子树，再访问右子树，过程如下 : </p>
<ul>
<li>如果当前节点<code>p</code>不为空，访问结点<code>p</code>，并将结点<code>p</code>入栈，并继续访问左子树(直到左子树为空)；</li>
<li>否则将栈顶元素出栈，并访问栈顶的元素的右子树；</li>
<li>直到栈为空且<code>p</code>为空，循环结束。</li>
</ul>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativePre</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Node p = root;</span><br><span class="line">    <span class="keyword">while</span> (!s.empty() || p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;<span class="comment">//也可以写一个while循环，直到左子树为空</span></span><br><span class="line">            s.push(p);</span><br><span class="line">            System.out.print(p.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = s.pop();</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以将上面的一直访问到左子树为空写成一个<code>while</code>循环:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativePre2</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Node p = root;</span><br><span class="line">    <span class="keyword">while</span> (!s.empty() || p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123; <span class="comment">// while循环，直到左子树为空</span></span><br><span class="line">            s.push(p);</span><br><span class="line">            System.out.print(p.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">        p = s.pop();</span><br><span class="line">        p = p.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 还有另外一种写法是:　</p>
<ul>
<li>先把根节点入栈，然后每次出栈一个元素，先访问这个元素，然后如果它的右子树存在，就入栈，如果它的左子树存在也入栈；</li>
<li><strong>为什么要先入右子树呢，因为，前序遍历是中-&gt;左-&gt;右，而栈可以逆序，所以先右再左；</strong></li>
</ul>
<blockquote>
<p>这个方法在后续遍历的双栈法中有体现，那个只是这个稍微的修改。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativePre3</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Node p = root;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.add(p);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        p = stack.pop();</span><br><span class="line">        System.out.print(p.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (p.right != <span class="keyword">null</span>)<span class="comment">// 先右再左即可</span></span><br><span class="line">            stack.push(p.right);</span><br><span class="line">        <span class="keyword">if</span> (p.left != <span class="keyword">null</span>)</span><br><span class="line">            stack.push(p.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><h3 id="1、递归中序"><a href="#1、递归中序" class="headerlink" title="1、递归中序"></a>1、递归中序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    inOrder(T.left);</span><br><span class="line">    System.out.print(T.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    inOrder(T.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、非递归中序"><a href="#2、非递归中序" class="headerlink" title="2、非递归中序"></a>2、非递归中序</h3><p>中序遍历 : <strong>左子树-&gt;根-&gt;右子树</strong>，过程如下：</p>
<ul>
<li>当前节点不空<code>!= null</code>，压入栈中(和前序遍历不同的是，不需要打印)，当前节点向左；</li>
<li>当前节点为空<code>== null</code>，从栈中拿出一个并且打印(在这里打印) ，当前节点向右；</li>
</ul>
<p>直到栈为空且p为空，循环结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1)、当前节点不空(!=null)，压入栈中(和前序遍历不同的是，不需要打印)，当前节点向左；</span></span><br><span class="line"><span class="comment">* 2)、当前节点为空(==null)，从栈中拿出一个并且打印(在这里打印) ，当前节点向右；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativeIn</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Node p = root;</span><br><span class="line">    <span class="keyword">while</span> (!s.empty() || p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            s.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = s.pop();</span><br><span class="line">            System.out.print(p.val + <span class="string">&quot; &quot;</span>); <span class="comment">//在这里打印</span></span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同理，那个一直访问左孩子那里也可以改成<code>whlie</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativeIn2</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Node p = root;</span><br><span class="line">    <span class="keyword">while</span> (!s.empty() || p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123; <span class="comment">//这里改成while</span></span><br><span class="line">            s.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">        p = s.pop();</span><br><span class="line">        System.out.print(p.val + <span class="string">&quot; &quot;</span>); <span class="comment">//在这里打印</span></span><br><span class="line">        p = p.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><h3 id="1、递归后序"><a href="#1、递归后序" class="headerlink" title="1、递归后序"></a>1、递归后序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    postOrder(T.left);</span><br><span class="line">    postOrder(T.right);</span><br><span class="line">    System.out.print(T.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、非递归后序"><a href="#2、非递归后序" class="headerlink" title="2、非递归后序"></a>2、非递归后序</h3><h4 id="1-、双栈法"><a href="#1-、双栈法" class="headerlink" title="1)、双栈法"></a>1)、双栈法</h4><p>这个其实就是非递归前序(<code>iterativePre3</code>)的稍微一点改进。</p>
<ul>
<li>首先，前序遍历入栈(<code>iterativePre3</code>)的顺序是<strong>先 右　再左</strong>；</li>
<li>这时，我们可以做到<strong>反过来先　左　再右</strong>，这样遍历的顺序可以做到 **”中右左”**，而后续遍历是 <strong>“左右中”<strong>，正好是前面那个的相反，所以我们</strong>再使用一个栈反转保存即可</strong>；</li>
</ul>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 非递归后续1(双栈法解决非递归后续)</span></span><br><span class="line"><span class="comment">* 后续遍历是要实现　　　左-&gt;右-&gt;中</span></span><br><span class="line"><span class="comment">* 这个方法和前序遍历的第二种方法　只是多了一个栈而已</span></span><br><span class="line"><span class="comment">* 因为　前序遍历是  中-&gt;左-&gt;右　　压栈顺序是 右-&gt;左</span></span><br><span class="line"><span class="comment">* 这样，我们就很容易实现　中-&gt;右-&gt;左遍历　　压栈顺序是　左-&gt;右</span></span><br><span class="line"><span class="comment">* 而后续遍历是要实现  左-&gt;右-&gt;中，</span></span><br><span class="line"><span class="comment">* 我们把上面的　　中右左　压入到另一个栈中　就实现了　左右中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativePos</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;&gt;(), s2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Node p;</span><br><span class="line">    s.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">        p = s.pop();</span><br><span class="line">        s2.push(p);</span><br><span class="line">        <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) s.push(p.left); <span class="comment">//这里是先左再右  (非递归前序是先右再左)</span></span><br><span class="line">        <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) s.push(p.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!s2.empty())</span><br><span class="line">        System.out.print(s2.pop().val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-、设置pre结点"><a href="#2-、设置pre结点" class="headerlink" title="2)、设置pre结点"></a>2)、设置<code>pre</code>结点</h4><p>过程如下:</p>
<ul>
<li>对于任一结点<code>p</code>，先将其入栈；</li>
<li>可以访问的情况:  ①若<code>p</code>不存在左孩子和右孩子，则可以直接访问它。②或者<code>p</code>存在左孩子或者右孩子，但是左孩子和右孩子都已经被访问过了，则也可以直接访问该结点；</li>
<li>若非上述两种情况，<strong>则将右孩子和左孩子依次入栈</strong>。这样可以保证每次取栈顶元素时，左孩子在右孩子前面被访问，根结点在左孩子和右孩子访问<strong>之后</strong>被访问；</li>
</ul>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*** 非递归后续2(设置pre结点) */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativePos2</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    Node cur, pre = <span class="keyword">null</span>;</span><br><span class="line">    Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    s.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!s.empty()) &#123; </span><br><span class="line">        cur = s.peek();</span><br><span class="line">        <span class="comment">// 两种可以访问的情况</span></span><br><span class="line">        <span class="keyword">if</span> ((cur.left == <span class="keyword">null</span> &amp;&amp; cur.right == <span class="keyword">null</span>) ||</span><br><span class="line">            ((pre != <span class="keyword">null</span>) &amp;&amp; (pre == cur.left || pre == cur.right))) &#123;</span><br><span class="line">            System.out.print(cur.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            s.pop();</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) s.push(cur.right);</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) s.push(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h2><p>很简单。利用队列BFS即可，每次访问完<code>p</code>，若左右孩子存在，则入队，直至队空；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        Node now = queue.poll();</span><br><span class="line">        System.out.print(now.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (now.left != <span class="keyword">null</span>) queue.add(now.left);</span><br><span class="line">        <span class="keyword">if</span> (now.right != <span class="keyword">null</span>) queue.add(now.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="寻找树中有没有值为x的结点"><a href="#寻找树中有没有值为x的结点" class="headerlink" title="寻找树中有没有值为x的结点"></a>寻找树中有没有值为x的结点</h2><p>递归条件有两个，一个是为空代表没找到，找到了的话直接返回，否则递归查找左右子树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找某个值为x的结点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Node <span class="title">search</span><span class="params">(Node T, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (T.val == x)</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (search(T.left, x) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> search(T.right, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> search(T.left, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="统计树中结点的个数"><a href="#统计树中结点的个数" class="headerlink" title="统计树中结点的个数"></a>统计树中结点的个数</h2><p>树中结点的个数等于根节点(1) + 左子树结点个数 + 右子树的个数，递归求解即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//统计结点个数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(Node T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> count(T.left) + count(T.right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="计算树的高度"><a href="#计算树的高度" class="headerlink" title="计算树的高度"></a>计算树的高度</h2><p>也是递归求解，左右子树的高度中的比较高的加上根节点就是树的高度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算二叉树的深度</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(Node T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.max(depth(T.left), depth(T.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断两棵树是不是相等"><a href="#判断两棵树是不是相等" class="headerlink" title="判断两棵树是不是相等"></a>判断两棵树是不是相等</h2><p>也是递归求解，两棵树相等，既要根节点的值相等，而且左右子树也要相等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断两棵树是不是相等</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">is_SameTree</span><span class="params">(Node T1, Node T2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T1 == <span class="keyword">null</span> &amp;&amp; T2 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> T1 != <span class="keyword">null</span> &amp;&amp; T2 != <span class="keyword">null</span> &amp;&amp; T1.val == T2.val</span><br><span class="line">            &amp;&amp; is_SameTree(T1.left, T2.left) &amp;&amp; is_SameTree(T1.right, T2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="完整测试代码"><a href="#完整测试代码" class="headerlink" title="完整测试代码"></a>完整测试代码</h2><p>完整的测试代码，这里输入的样例树(就是建树的时候那个例子)如下:</p>
<p><img src="images/all3.png" alt="这里写图片描述"></p>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// given a arr to build</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">createTree</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= arr.length || arr[i] == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Node root = <span class="keyword">new</span> Node(arr[i]);</span><br><span class="line">        root.left = createTree(arr, <span class="number">2</span> * i + <span class="number">1</span>);</span><br><span class="line">        root.right = createTree(arr, <span class="number">2</span> * i + <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cin method	</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">buildTree</span><span class="params">(Scanner cin)</span> </span>&#123;</span><br><span class="line">        Node root = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> data = cin.nextInt();</span><br><span class="line">        <span class="keyword">if</span> (data != -<span class="number">1</span>) &#123;</span><br><span class="line">            root = <span class="keyword">new</span> Node(data);</span><br><span class="line">            root.left = buildTree(cin);</span><br><span class="line">            root.right = buildTree(cin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (T == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        System.out.print(T.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        preOrder(T.left);</span><br><span class="line">        preOrder(T.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativePre</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Node p = root;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty() || p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                s.push(p);</span><br><span class="line">                System.out.print(p.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                p = p.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p = s.pop();</span><br><span class="line">                p = p.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativePre2</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Node p = root;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty() || p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123; <span class="comment">// while循环，直到左子树为空</span></span><br><span class="line">                s.push(p);</span><br><span class="line">                System.out.print(p.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                p = p.left;</span><br><span class="line">            &#125;</span><br><span class="line">            p = s.pop();</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 理解 :  push右子树，再push左子树，这样的话弹栈的时候就是先访问左子树，再右子树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativePre3</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        Node p = root;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.add(p);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            p = stack.pop();</span><br><span class="line">            System.out.print(p.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (p.right != <span class="keyword">null</span>)</span><br><span class="line">                stack.push(p.right);</span><br><span class="line">            <span class="keyword">if</span> (p.left != <span class="keyword">null</span>)</span><br><span class="line">                stack.push(p.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (T == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        inOrder(T.left);</span><br><span class="line">        System.out.print(T.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        inOrder(T.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1)、当前节点不空(!=null)，压入栈中(和前序遍历不同的是，不需要打印)，当前节点向左；</span></span><br><span class="line"><span class="comment">     * 2)、当前节点为空(==null)，从栈中拿出一个并且打印(在这里打印) ，当前节点向右；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativeIn</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Node p = root;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty() || p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                s.push(p);</span><br><span class="line">                p = p.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p = s.pop();</span><br><span class="line">                System.out.print(p.val + <span class="string">&quot; &quot;</span>); <span class="comment">//在这里打印</span></span><br><span class="line">                p = p.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativeIn2</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Node p = root;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty() || p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123; <span class="comment">//这里改成while</span></span><br><span class="line">                s.push(p);</span><br><span class="line">                p = p.left;</span><br><span class="line">            &#125;</span><br><span class="line">            p = s.pop();</span><br><span class="line">            System.out.print(p.val + <span class="string">&quot; &quot;</span>); <span class="comment">//在这里打印</span></span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (T == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        postOrder(T.left);</span><br><span class="line">        postOrder(T.right);</span><br><span class="line">        System.out.print(T.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非递归后续1(双栈法解决非递归后续)</span></span><br><span class="line"><span class="comment">     * 后续遍历是要实现　　　左-&gt;右-&gt;中</span></span><br><span class="line"><span class="comment">     * 这个方法和前序遍历的第二种方法　只是多了一个栈而已</span></span><br><span class="line"><span class="comment">     * 因为　前序遍历是  中-&gt;左-&gt;右　　压栈顺序是 右-&gt;左</span></span><br><span class="line"><span class="comment">     * 这样，我们就很容易实现　中-&gt;右-&gt;左遍历　　压栈顺序是　左-&gt;右</span></span><br><span class="line"><span class="comment">     * 而后续遍历是要实现  左-&gt;右-&gt;中，</span></span><br><span class="line"><span class="comment">     * 我们把上面的　　中右左　压入到另一个栈中　就实现了　左右中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativePos</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;&gt;(), s2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Node p;</span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">            p = s.pop();</span><br><span class="line">            s2.push(p);</span><br><span class="line">            <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) s.push(p.left); <span class="comment">//这里是先左再右  (非递归前序是先右再左)</span></span><br><span class="line">            <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) s.push(p.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!s2.empty())</span><br><span class="line">            System.out.print(s2.pop().val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** 非递归后续2(设置pre结点) */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativePos2</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        Node cur, pre = <span class="keyword">null</span>;</span><br><span class="line">        Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">            cur = s.peek();</span><br><span class="line">            <span class="comment">// 两种可以访问的情况</span></span><br><span class="line">            <span class="keyword">if</span> ((cur.left == <span class="keyword">null</span> &amp;&amp; cur.right == <span class="keyword">null</span>) ||</span><br><span class="line">                    ((pre != <span class="keyword">null</span>) &amp;&amp; (pre == cur.left || pre == cur.right))) &#123;</span><br><span class="line">                System.out.print(cur.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                s.pop();</span><br><span class="line">                pre = cur;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) s.push(cur.right);</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) s.push(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Node now = queue.poll();</span><br><span class="line">            System.out.print(now.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (now.left != <span class="keyword">null</span>) queue.add(now.left);</span><br><span class="line">            <span class="keyword">if</span> (now.right != <span class="keyword">null</span>) queue.add(now.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找某个值为x的结点</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">search</span><span class="params">(Node T, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (T == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (T.val == x)</span><br><span class="line">            <span class="keyword">return</span> T;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (search(T.left, x) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> search(T.right, x);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> search(T.left, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//统计结点个数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(Node T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (T == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> count(T.left) + count(T.right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算二叉树的深度</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(Node T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (T == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(depth(T.left), depth(T.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断两棵树是不是相等</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">is_SameTree</span><span class="params">(Node T1, Node T2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (T1 == <span class="keyword">null</span> &amp;&amp; T2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> T1 != <span class="keyword">null</span> &amp;&amp; T2 != <span class="keyword">null</span> &amp;&amp; T1.val == T2.val</span><br><span class="line">                    &amp;&amp; is_SameTree(T1.left, T2.left) &amp;&amp; is_SameTree(T1.right, T2.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(System.in));</span><br><span class="line">        <span class="comment">//		int[] arr = &#123;1,2,3,4,5,6,7,8,-1,9,-1,10,-1,11,-1, -1,-1,-1,-1,-1,-1,-1,-1&#125;;</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, -<span class="number">1</span>, <span class="number">9</span>, -<span class="number">1</span>, <span class="number">10</span>, -<span class="number">1</span>, <span class="number">11</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        Node root = createTree(arr, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//		树结构和上面相同,输入: 1 2 4 8 -1 -1 -1 5 9 -1 -1 -1 3 6 10 -1 -1 -1 7 11 -1 -1 -1</span></span><br><span class="line">        Node root2 = buildTree(cin);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-------前序遍历-------&quot;</span>);</span><br><span class="line">        preOrder(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">        iterativePre(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">        iterativePre2(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">        iterativePre3(root);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;-------中序遍历-------&quot;</span>);</span><br><span class="line">        inOrder(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">        iterativeIn(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">        iterativeIn2(root);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;-------后序遍历-------&quot;</span>);</span><br><span class="line">        postOrder(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">        iterativePos(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">        iterativePos2(root);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;-------层次遍历-------&quot;</span>);</span><br><span class="line">        levelOrder(root);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;------结点个数-------&quot;</span>);</span><br><span class="line">        System.out.println(count(root));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;------二叉树深度-------&quot;</span>);</span><br><span class="line">        System.out.println(depth(root));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;-----判断两棵树是不是相同-----&quot;</span>);</span><br><span class="line">        System.out.println(is_SameTree(root, root2));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;-----寻找树中有没有值为3的结点-----&quot;</span>);</span><br><span class="line">        Node Find = search(root, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == Find)</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到结点&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">&quot;这个结点的左右子结点的值是&quot;</span> + Find.left.val + <span class="string">&quot; &quot;</span> + Find.right.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果如下图:</p>
<p><img src="images/all4.png"></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树结点间的最大距离问题</title>
    <url>/2022/06/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%93%E7%82%B9%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%9D%E7%A6%BB%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="二叉树结点间的最大距离问题"><a href="#二叉树结点间的最大距离问题" class="headerlink" title="二叉树结点间的最大距离问题"></a>二叉树结点间的最大距离问题</h2><ul>
<li>递归</li>
<li>改进的写法</li>
<li>完整测试代码<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4></li>
</ul>
<p><img src="images/tree1.png" alt="在这里插入图片描述"></p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>解析<br>这个也是一个二叉树的问题，分为三步:</p>
<ul>
<li>列出所有可能性；</li>
<li>列出结点需要的信息，并整合信息(成一个结构体)；</li>
<li>改递归 ，先假设左和右都给我信息(黑盒)，然后怎么利用左边和右边的信息组出来我该返回的信息，最后<code>basecase</code>(边界)填什么；</li>
</ul>
<p>具体到这个题目:<br><strong>第一步，列出可能性：</strong> 一个以<code>node</code>为头的树上，最大距离只可能来自下面三种情况: </p>
<ul>
<li>不需要经过<code>node</code>这个点，node的左子树上自己的最大距离；</li>
<li>不需要经过<code>node</code>这个点，node的右子树上自己的最大距离；</li>
<li>要经过<code>node</code>这个点，此时就是左子树的高度 <code>+ </code>右子树的高度<code> +</code> <code>1 </code>；</li>
</ul>
<p><strong>第二步，确定结点需要的信息，并整合:</strong></p>
<ul>
<li>信息一: 返回的以<code>node</code>为头的树的最大距离；</li>
<li>信息二: 返回的以<code>node</code>为头的高度；</li>
</ul>
<p><strong>第三步，封装信息，写出递归</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> max;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> h;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> max, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.max = max;</span><br><span class="line">            <span class="keyword">this</span>.h = h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rec(head).max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Pair <span class="title">rec</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Pair(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        Pair L = rec(head.left);</span><br><span class="line">        Pair R = rec(head.right);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair(Math.max((L.h + R.h + <span class="number">1</span>), Math.max(L.max, R.max)),</span><br><span class="line">                Math.max(L.h, R.h) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="改进的写法"><a href="#改进的写法" class="headerlink" title="改进的写法"></a>改进的写法</h3><p>可以使用一个全局变量记录高度，然后<code>max</code>正常返回: <font color = red>注意在<code>java</code>中要使用数组，<strong>是引用</strong>，这样的话就可以一直传递，不能使用一个变量</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxDistance2</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] rec = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> rec2(head, rec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rec2</span><span class="params">(Node head, <span class="keyword">int</span>[] rec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        rec[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> L = rec2(head.left, rec);</span><br><span class="line">    <span class="keyword">int</span> lH = rec[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> R = rec2(head.right, rec);</span><br><span class="line">    <span class="keyword">int</span> rH = rec[<span class="number">0</span>];</span><br><span class="line">    rec[<span class="number">0</span>] = Math.max(lH, rH) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.max(lH + rH + <span class="number">1</span>, Math.max(L, R));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="完整测试代码"><a href="#完整测试代码" class="headerlink" title="完整测试代码"></a>完整测试代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxDistance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> max;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> h;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> max, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.max = max;</span><br><span class="line">            <span class="keyword">this</span>.h = h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rec(head).max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Pair <span class="title">rec</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Pair(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Pair L = rec(head.left);</span><br><span class="line">        Pair R = rec(head.right);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair(Math.max((L.h + R.h + <span class="number">1</span>), Math.max(L.max, R.max)), Math.max(L.h, R.h) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxDistance2</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] rec = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> rec2(head, rec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rec2</span><span class="params">(Node head, <span class="keyword">int</span>[] rec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            rec[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> L = rec2(head.left, rec);</span><br><span class="line">        <span class="keyword">int</span> lH = rec[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> R = rec2(head.right, rec);</span><br><span class="line">        <span class="keyword">int</span> rH = rec[<span class="number">0</span>];</span><br><span class="line">        rec[<span class="number">0</span>] = Math.max(lH, rH) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(lH + rH + <span class="number">1</span>, Math.max(L, R));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">build</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= arr.length || arr[index] == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Node root = <span class="keyword">new</span> Node(arr[index]);</span><br><span class="line">        root.left = build(arr, index * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        root.right = build(arr, index * <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTree</span><span class="params">(Node head, <span class="keyword">int</span> height, String to, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        printTree(head.right, height + <span class="number">1</span>, <span class="string">&quot;v&quot;</span>, len);</span><br><span class="line">        String val = to + head.value + to;  <span class="comment">//两边指示的字符</span></span><br><span class="line">        <span class="keyword">int</span> lenV = val.length();</span><br><span class="line">        <span class="keyword">int</span> lenL = (len - lenV) / <span class="number">2</span>;  <span class="comment">//左边的空格(分一半)</span></span><br><span class="line">        <span class="keyword">int</span> lenR = len - lenV - lenL; <span class="comment">// 右边的空格</span></span><br><span class="line">        System.out.println(getSpace(len * height) + getSpace(lenL) + val + getSpace(lenR));</span><br><span class="line"></span><br><span class="line">        printTree(head.left, height + <span class="number">1</span>, <span class="string">&quot;^&quot;</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取指定的空格</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">getSpace</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        StringBuffer str = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) str.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        Node head = build(arr, <span class="number">0</span>);</span><br><span class="line">        printTree(head, <span class="number">0</span>, <span class="string">&quot;H&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        System.out.println(maxDistance(head));</span><br><span class="line">        System.out.println(maxDistance2(head));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:(打印二叉树见<a href="https://blog.csdn.net/zxzxzx0119/article/details/81096554"><strong>这个博客</strong></a>)<br><img src="images/tree2.png" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>单调栈介绍以及构造数组的MaxTree问题</title>
    <url>/2022/09/29/%E5%8D%95%E8%B0%83%E6%A0%88%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E6%9E%84%E9%80%A0%E6%95%B0%E7%BB%84%E7%9A%84MaxTree%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="单调栈介绍以及构造数组的MaxTree问题"><a href="#单调栈介绍以及构造数组的MaxTree问题" class="headerlink" title="单调栈介绍以及构造数组的MaxTree问题"></a>单调栈介绍以及构造数组的MaxTree问题</h2><ul>
<li>单调栈介绍</li>
<li>单调栈解决构造数组的MaxTree问题</li>
<li>堆解决构造数组的MaxTree问题</li>
<li>完整测试代码</li>
</ul>
<hr>
<h4 id="题目-构造数组的MaxTree问题"><a href="#题目-构造数组的MaxTree问题" class="headerlink" title="题目(构造数组的MaxTree问题)"></a>题目(构造数组的MaxTree问题)</h4><p><img src="images/ms3.png" alt="在这里插入图片描述"></p>
<h3 id="单调栈介绍"><a href="#单调栈介绍" class="headerlink" title="单调栈介绍"></a>单调栈介绍</h3><p>单调栈最初解决的问题就是<strong>寻找一个数组中 ，每一个数的左右两边离它最近的数</strong>。</p>
<ul>
<li>遍历一个数组，如果<strong>栈为空或者栈顶比当前数大(或者相等，相等的话就多个下标对应一个值)，就把当前数入栈</strong>；</li>
<li>如果栈顶比当前数小，那么就<strong>处理这个栈顶，即这个栈顶右边第一个比它大的数就是当前数，左边第一个比它大的数就是在栈里面它的下面的那个数，也就是它出栈之后的栈顶</strong>；</li>
<li> 当遍历完所有的数之后，栈中还有数，这时，逐个判断栈中的数，每一个数，<strong>它的右边不存在比它大的</strong>，如果这个数在栈里面它的下面还有数，它左边离他最近的大的数就是它下面的数；</li>
</ul>
<p><img src="images/ms2.png" alt="这里写图片描述"></p>
<h3 id="单调栈解决构造数组的MaxTree问题"><a href="#单调栈解决构造数组的MaxTree问题" class="headerlink" title="单调栈解决构造数组的MaxTree问题"></a>单调栈解决构造数组的MaxTree问题</h3><p>按照下面的方法来建树</p>
<ul>
<li>每一个树的<strong>父节点是它左边第一个比它大的数和它右边第一个比它大的数中，比较<font color = red>小</font>的那个</strong>；</li>
<li>如果左边没有没有比它大的数，右边也没有。也就是说，这个数是整个数组的最大值，那么这个数是<code>MaxTree</code>的头结点；</li>
</ul>
<p>按照大根堆和上面的方案放置如下：<br><img src="images/ms4.png" alt="这里写图片描述"></p>
<p>相关证明:</p>
<p><img src="images/ms5.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回构造的树的头结点</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> Node <span class="title">getMaxTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">       Node[] nArr = <span class="keyword">new</span> Node[arr.length];  <span class="comment">//生成树的结构,数组中的每一个值都代表一个结点</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">           nArr[i] = <span class="keyword">new</span> Node(arr[i]);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       HashMap&lt;Node, Node&gt; lMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       HashMap&lt;Node, Node&gt; rMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//找每一个数左边离它最近的大的</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nArr.length; i++) &#123;</span><br><span class="line">           Node cur = nArr[i];</span><br><span class="line">           <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().value &lt; cur.value) &#123;</span><br><span class="line">               popStackSetValue(stack, lMap);</span><br><span class="line">           &#125;</span><br><span class="line">           stack.push(cur);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">           popStackSetValue(stack, lMap);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//找每一个数右边比它最近的大的</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = nArr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">           Node cur = nArr[i];</span><br><span class="line">           <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().value &lt; cur.value) &#123;</span><br><span class="line">               popStackSetValue(stack, rMap);</span><br><span class="line">           &#125;</span><br><span class="line">           stack.push(cur);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">           popStackSetValue(stack, rMap);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//开始构造这棵树</span></span><br><span class="line">       Node head = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nArr.length; i++) &#123;</span><br><span class="line">           Node cur = nArr[i];</span><br><span class="line">           Node L = lMap.get(cur); <span class="comment">//左边离cur最近的</span></span><br><span class="line">           Node R = rMap.get(cur); <span class="comment">//右边离cur最近的</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (L == <span class="keyword">null</span> &amp;&amp; R == <span class="keyword">null</span>) &#123;</span><br><span class="line">               head = cur;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (L == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (R.left == <span class="keyword">null</span>)R.left = cur;</span><br><span class="line">               <span class="keyword">else</span> R.right = cur;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (R == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (L.left == <span class="keyword">null</span>)L.left = cur;</span><br><span class="line">               <span class="keyword">else</span> L.right = cur;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               Node minNode = L.value &lt; R.value ? L : R;</span><br><span class="line">               <span class="keyword">if</span> (minNode.left == <span class="keyword">null</span>) minNode.left = cur;</span><br><span class="line">               <span class="keyword">else</span> minNode.right = cur;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//弹出来一个数，并且得到它左/右边边最近的比他大的数</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">popStackSetValue</span><span class="params">(Stack&lt;Node&gt; stack, HashMap&lt;Node, Node&gt; map)</span> </span>&#123;</span><br><span class="line">       Node top = stack.pop();</span><br><span class="line">       <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">           map.put(top, <span class="keyword">null</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           map.put(top, stack.peek());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆解决构造数组的MaxTree问题"><a href="#堆解决构造数组的MaxTree问题" class="headerlink" title="堆解决构造数组的MaxTree问题"></a>堆解决构造数组的MaxTree问题</h3><p>由于从上到下减小，所以正好是一个堆，可以使用堆来写: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Node <span class="title">getMaxTree2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    Node[] nArr = <span class="keyword">new</span> Node[arr.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) nArr[i] = <span class="keyword">new</span> Node(arr[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nArr.length; i++) &#123;</span><br><span class="line">        heapfiyInsert(nArr,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nArr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span> * i + <span class="number">1</span> &lt; nArr.length)&#123;</span><br><span class="line">            nArr[i].left = nArr[<span class="number">2</span>*i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span> * i + <span class="number">2</span> &lt; nArr.length)&#123;</span><br><span class="line">            nArr[i].right = nArr[<span class="number">2</span>*i + <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nArr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapfiyInsert</span><span class="params">(Node[] nArr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (nArr[index].value &gt; nArr[(index - <span class="number">1</span>) / <span class="number">2</span>].value) &#123;</span><br><span class="line">        swap(nArr,index,(index-<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">        index = (index-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Node[] nArr,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    Node temp = nArr[a];</span><br><span class="line">    nArr[a] = nArr[b];</span><br><span class="line">    nArr[b] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完整测试代码"><a href="#完整测试代码" class="headerlink" title="完整测试代码"></a>完整测试代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 利用单调栈解决构造数组的 maxTree问题 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回构造的树的头结点</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">getMaxTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        Node[] nArr = <span class="keyword">new</span> Node[arr.length];  <span class="comment">//生成树的结构,数组中的每一个值都代表一个结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            nArr[i] = <span class="keyword">new</span> Node(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        HashMap&lt;Node, Node&gt; lMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        HashMap&lt;Node, Node&gt; rMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找每一个数左边离它最近的大的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nArr.length; i++) &#123;</span><br><span class="line">            Node cur = nArr[i];</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().value &lt; cur.value) &#123;</span><br><span class="line">                popStackSetValue(stack, lMap);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            popStackSetValue(stack, lMap);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找每一个数右边比它最近的大的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nArr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            Node cur = nArr[i];</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().value &lt; cur.value) &#123;</span><br><span class="line">                popStackSetValue(stack, rMap);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            popStackSetValue(stack, rMap);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始构造这棵树</span></span><br><span class="line">        Node head = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nArr.length; i++) &#123;</span><br><span class="line">            Node cur = nArr[i];</span><br><span class="line">            Node L = lMap.get(cur); <span class="comment">//左边离cur最近的</span></span><br><span class="line">            Node R = rMap.get(cur); <span class="comment">//右边离cur最近的</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (L == <span class="keyword">null</span> &amp;&amp; R == <span class="keyword">null</span>) &#123;</span><br><span class="line">                head = cur;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (L == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (R.left == <span class="keyword">null</span>) R.left = cur;</span><br><span class="line">                <span class="keyword">else</span> R.right = cur;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (R == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (L.left == <span class="keyword">null</span>) L.left = cur;</span><br><span class="line">                <span class="keyword">else</span> L.right = cur;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Node minNode = L.value &lt; R.value ? L : R;</span><br><span class="line">                <span class="keyword">if</span> (minNode.left == <span class="keyword">null</span>) minNode.left = cur;</span><br><span class="line">                <span class="keyword">else</span> minNode.right = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//弹出来一个数，并且得到它左/右边边最近的比他大的数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">popStackSetValue</span><span class="params">(Stack&lt;Node&gt; stack, HashMap&lt;Node, Node&gt; map)</span> </span>&#123;</span><br><span class="line">        Node top = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">            map.put(top, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(top, stack.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">getMaxTree2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        Node[] nArr = <span class="keyword">new</span> Node[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) nArr[i] = <span class="keyword">new</span> Node(arr[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nArr.length; i++) &#123;</span><br><span class="line">            heapfiyInsert(nArr, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nArr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * i + <span class="number">1</span> &lt; nArr.length) &#123;</span><br><span class="line">                nArr[i].left = nArr[<span class="number">2</span> * i + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * i + <span class="number">2</span> &lt; nArr.length) &#123;</span><br><span class="line">                nArr[i].right = nArr[<span class="number">2</span> * i + <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nArr[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapfiyInsert</span><span class="params">(Node[] nArr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (nArr[index].value &gt; nArr[(index - <span class="number">1</span>) / <span class="number">2</span>].value) &#123;</span><br><span class="line">            swap(nArr, index, (index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">            index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Node[] nArr, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        Node temp = nArr[a];</span><br><span class="line">        nArr[a] = nArr[b];</span><br><span class="line">        nArr[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTree</span><span class="params">(Node head, <span class="keyword">int</span> height, String to, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        printTree(head.right, height + <span class="number">1</span>, <span class="string">&quot;v&quot;</span>, len);</span><br><span class="line"></span><br><span class="line">        String val = to + head.value + to;  <span class="comment">//两边指示的字符</span></span><br><span class="line">        <span class="keyword">int</span> lenV = val.length();</span><br><span class="line">        <span class="keyword">int</span> lenL = (len - lenV) / <span class="number">2</span>;   <span class="comment">//左边的空格(分一半)</span></span><br><span class="line">        <span class="keyword">int</span> lenR = len - lenV - lenL;  <span class="comment">// 右边的空格</span></span><br><span class="line">        System.out.println(getSpace(len * height) + getSpace(lenL) + val + getSpace(lenR));</span><br><span class="line"></span><br><span class="line">        printTree(head.left, height + <span class="number">1</span>, <span class="string">&quot;^&quot;</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取指定的空格</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">getSpace</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        StringBuffer str = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) str.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] uniqueArr = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        Node head = getMaxTree(uniqueArr);</span><br><span class="line">        printTree(head, <span class="number">0</span>, <span class="string">&quot;H&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">        head = getMaxTree2(uniqueArr);</span><br><span class="line">        printTree(head, <span class="number">0</span>, <span class="string">&quot;H&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果</p>
<p><img src="images/ms1.png" alt="这里写图片描述"></p>
<p>这里没有用二叉树遍历来验证，直接用的直观打印二叉树的方法，上面打印二叉树的程序可以看<a href="https://blog.csdn.net/zxzxzx0119/article/details/81096554"><strong>这篇博客</strong></a>。</p>
]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>MonotoneStack</tag>
      </tags>
  </entry>
  <entry>
    <title>在一颗二叉树中寻找一个结点的后继结点(前驱结点)</title>
    <url>/2022/08/02/%E5%9C%A8%E4%B8%80%E9%A2%97%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%AF%BB%E6%89%BE%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9%E7%9A%84%E5%90%8E%E7%BB%A7%E7%BB%93%E7%82%B9(%E5%89%8D%E9%A9%B1%E7%BB%93%E7%82%B9)/</url>
    <content><![CDATA[<h2 id="在一颗二叉树中寻找一个结点的后继结点-前驱结点"><a href="#在一颗二叉树中寻找一个结点的后继结点-前驱结点" class="headerlink" title="在一颗二叉树中寻找一个结点的后继结点(前驱结点)"></a>在一颗二叉树中寻找一个结点的后继结点(前驱结点)</h2><ul>
<li>找后继结点</li>
<li>找前驱结点</li>
</ul>
<hr>
<h3 id="找后继结点"><a href="#找后继结点" class="headerlink" title="找后继结点"></a>找后继结点</h3><p> 首先知道什么是后继结点，就是二叉树中序遍历的序列中，某个结点紧随的那个结点比如下面的二叉树以及对应的中序遍历顺序。</p>
<p><img src="images/houji1.png" alt="这里写图片描述"></p>
<p>则<code>4</code>的后继是<code>2</code> ，<code>2</code>的后继是<code>5</code>，<code>7</code>的后继是<code>null</code>。</p>
<p>在树的结构中，每个结点有一个指向父亲的域<code>parent</code>，看如下结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line">    <span class="keyword">public</span> Node parent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>那么如何快速的寻找当前结点<code>node</code>后继结点呢? 其实只需要分为两种情况</p>
<ul>
<li>第一，如果<code>node</code>结点有右子树，那么就是右子树上<strong>最左</strong>的结点，例如上图的<code>２</code>的右子树上的最左结点是<code>5</code>，<code>5</code>的右子树上最左的结点是<code>8</code>，<code>1</code>的右子树上最左的结点是<code>9</code>，<code>3</code>的右子树上最左的结点是<code>7</code>。</li>
<li>第二，如果<code>node</code>结点没有右子树，那么要分两种情况 : <font color = blue><strong>a</strong>. 看当前结点<code>node</code> 是不是它父亲(node.parent)的左孩子，如果是，那么它父亲(<code>node.parent</code>)就是它的后继；</font><font color = #ff00ff><strong>b</strong>.如果当前结点是它父亲的右孩子(<code>node.parent.right == node</code>)，那么就向上不停的寻找它的后继结点，即当前结点为<code>node</code>，它的父亲为parent，如果<code>node</code>还是<code>parent</code>的右孩子，就令<code>node= parent，parent = parent.parent</code>，一直向上，直到<code>parent.left = node</code>，就停止，此时<code>parent</code>就是当初要找的结点的后继。</li>
</ul>
<p>(1) 对于上面的第二种情况看上面的例子，首先<code>a</code>情况</p>
<p><img src="images/houji2.png" alt="这里写图片描述"></p>
<p>(2) 然后再看第二种情况的<code>b</code> ，也就是往上找后继的过程</p>
<p><img src="images/houji3.png" alt="这里写图片描述"></p>
<h3 id="找前驱结点"><a href="#找前驱结点" class="headerlink" title="找前驱结点"></a>找前驱结点</h3><p> 这个和找后继是同理的:  </p>
<ul>
<li>当一个结点有左子树的时候，就是最左子树的最右结点；</li>
<li>没有左子树的时候，<font color = blue><strong>a.</strong> 看当前结点<code>node </code>是不是它父亲(<code>node.parent</code>)的<strong>右</strong>孩子，如果是，那么它父亲(<code>node.parent</code>)就是它的前驱；</font><font color = #ff00ff><strong>b</strong>. 如果当前结点是它父亲的左孩子(<code>node.parent.left == node</code>)，那么就向上不停的寻找它的前驱结点，即当前结点为<code>node</code>，它的父亲为<code>parent</code>，如果<code>node</code>还是<code>parent</code>的左孩子，就令<code>node= parent，parent = parent.parent</code>，一直向上，直到<code>parent.right = node</code>，就停止，此时<code>parent</code>就是当初要找的结点的前驱。</li>
</ul>
<h3 id="完整的测试代码如下"><a href="#完整的测试代码如下" class="headerlink" title="完整的测试代码如下"></a>完整的测试代码如下</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 寻找结点的后继和前驱结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuccessorNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line">        <span class="keyword">public</span> Node parent;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//寻找某个结点的后继结点</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">getSuccessorNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">return</span> getMostLeft(node.right);<span class="comment">//第一种情况　　结点的右子树为null</span></span><br><span class="line">        <span class="keyword">else</span> &#123;  <span class="comment">//第二种情况</span></span><br><span class="line">            Node parent = node.parent;</span><br><span class="line">            <span class="keyword">while</span> (parent != <span class="keyword">null</span> &amp;&amp; parent.left != node) &#123;</span><br><span class="line">                node = parent;</span><br><span class="line">                parent = node.parent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找到某个结点的最左边的结点</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">getMostLeft</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (node.left != <span class="keyword">null</span>)</span><br><span class="line">            node = node.left;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//寻找某个结点的前驱结点</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">getPrecursorNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.left!= <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> getMostRight(node.left);<span class="comment">//第一种情况　　结点的右子树为null</span></span><br><span class="line">        <span class="keyword">else</span> &#123;  <span class="comment">//第二种情况</span></span><br><span class="line">            Node parent = node.parent;</span><br><span class="line">            <span class="keyword">while</span> (parent != <span class="keyword">null</span> &amp;&amp; parent.right != node) &#123;</span><br><span class="line">                node = parent;</span><br><span class="line">                parent = node.parent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找到某个结点的最右边的结点</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">getMostRight</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (node.right != <span class="keyword">null</span>)</span><br><span class="line">            node = node.right;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先创建上图的树</span></span><br><span class="line">        Node head = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        head.left = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">        head.left.parent = head;</span><br><span class="line">        head.left.left = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">        head.left.left.parent = head.left;</span><br><span class="line">        head.left.right = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">        head.left.right.parent = head.left;</span><br><span class="line">        head.left.right.right = <span class="keyword">new</span> Node(<span class="number">8</span>);</span><br><span class="line">        head.left.right.right.parent = head.left.right;</span><br><span class="line">        head.right = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">        head.right.parent = head;</span><br><span class="line">        head.right.left = <span class="keyword">new</span> Node(<span class="number">6</span>);</span><br><span class="line">        head.right.left.parent = head.right;</span><br><span class="line">        head.right.left.left = <span class="keyword">new</span> Node(<span class="number">9</span>);</span><br><span class="line">        head.right.left.left.parent = head.right.left;</span><br><span class="line">        head.right.right = <span class="keyword">new</span> Node(<span class="number">7</span>);</span><br><span class="line">        head.right.right.parent = head.right;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------test Successor----------&quot;</span>);</span><br><span class="line">        Node node = head; <span class="comment">//测试1</span></span><br><span class="line">        System.out.println(node.value + <span class="string">&quot;&#x27;s next : &quot;</span> + getSuccessorNode(node).value);</span><br><span class="line"></span><br><span class="line">        node = head.left.left; <span class="comment">//测试4</span></span><br><span class="line">        System.out.println(node.value + <span class="string">&quot;&#x27;s next : &quot;</span> + getSuccessorNode(node).value);</span><br><span class="line"></span><br><span class="line">        node = head.left.right.right; <span class="comment">// 测试8</span></span><br><span class="line">        System.out.println(node.value + <span class="string">&quot;&#x27;s next : &quot;</span> + getSuccessorNode(node).value);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------test Precursor----------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        node = head; <span class="comment">//测试1</span></span><br><span class="line">        System.out.println(node.value + <span class="string">&quot;&#x27;s next : &quot;</span> + getPrecursorNode(node).value);</span><br><span class="line"></span><br><span class="line">        node = head.right.left.left; <span class="comment">// 测试9</span></span><br><span class="line">        System.out.println(node.value + <span class="string">&quot;&#x27;s next : &quot;</span> + getPrecursorNode(node).value);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="images/houji4.png" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>子数组累加和为aim(小于等于aim)的三个问题</title>
    <url>/2022/05/26/%E5%AD%90%E6%95%B0%E7%BB%84%E7%B4%AF%E5%8A%A0%E5%92%8C%E4%B8%BAaim(%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8Eaim)%E7%9A%84%E4%B8%89%E4%B8%AA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="子数组累加和为aim-小于等于aim-的三个问题"><a href="#子数组累加和为aim-小于等于aim-的三个问题" class="headerlink" title="子数组累加和为aim(小于等于aim)的三个问题"></a>子数组累加和为aim(小于等于aim)的三个问题</h3><ul>
<li>累加和<code> = aim</code>的最长子数组的长度(<strong>数组可<code>+</code>,<code>-</code>,<code>0</code></strong>)；</li>
<li>累加和<code> = aim</code>的最长子数组的长度(<strong>数组<code>+</code></strong>)(只有正数)；</li>
<li>累加和<code> &lt;= aim</code>的最长子数组的长度(<strong>数组可<code>+</code>,<code>-</code>,<code>0</code></strong>)；</li>
</ul>
<hr>
<h3 id="累加和-aim的最长子数组的长度-数组可-0-；"><a href="#累加和-aim的最长子数组的长度-数组可-0-；" class="headerlink" title="累加和 = aim的最长子数组的长度(数组可+,-,0)；"></a>累加和<code> = aim</code>的最长子数组的长度(<strong>数组可<code>+</code>,<code>-</code>,<code>0</code></strong>)；</h3><p>这个题目使用<code>HashMap</code>来存储前面出现过的累加和的下标，具体过程如下: </p>
<ul>
<li>使用变量<code>sum</code>表示从<code>0</code>位置开始一直加到i位置所有元素的累加和；</li>
<li><code>HashMap</code>中<code>key</code>表示从<code>arr</code>最左边开始累加过程中出现过的<code>sum</code>值，<code>value</code>表示的是<code>sum</code>值出现最早的位置；、</li>
<li>假设当前元素为<code>arr[i]</code>，则<code>sum += arr[i]</code>，之前所有累加和为<code>sum</code> ，查看<code>map</code>中是否有<code>sum - aim</code>这个值，如果有，且对应<code>value</code>为<code>j</code>，那么就找到一个子数组累加和为<code>aim</code>的，且长度为 <code>i -  j  + 1</code>；</li>
<li>检查现在的<code>sum </code>是否在<code>map</code>中出现，如果不存在，说明此时是第一次出现的，把<code>(sum,i)</code>加入到<code>map</code>中；</li>
<li>继续遍历数组；</li>
</ul>
<p><font color = red> 很重要的一个地方就是一开始<code>map</code>中要存<code>(0,-1)</code>这个值，直观理解是一个数也没有的时候也可以累加出<code>0</code></font><br>看下面例子:<br><code>[1,2,3,3] ， aim = 6</code>；<br>如果没有存<code>(0,-1)</code>，累加到下标为<code>2</code>的时候，<code>sum = 6</code> 此时，<code>sum - aim = 6 - 6 =  0</code>，但是没有<code>0</code>这个累加和，就会忽略； </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**　O(n)时间 O(n)空间 */</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxLength</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> aim)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length== <span class="number">0</span> )<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       HashMap&lt;Integer,Integer&gt;map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;(); <span class="comment">//表示key这个累加和最早出现在value位置</span></span><br><span class="line">       map.put(<span class="number">0</span>,-<span class="number">1</span>);     <span class="comment">//这个很重要</span></span><br><span class="line">       <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">           sum += arr[i];</span><br><span class="line">           <span class="keyword">if</span>(map.containsKey(sum - aim))&#123; <span class="comment">//如果之前出现了</span></span><br><span class="line">               res = Math.max(res,i - map.get(sum - aim));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(!map.containsKey(sum))&#123;</span><br><span class="line">               map.put(sum,i);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>问题变式: 给定一个数组，求正数和负数个数相等最长子数组长度。<br>解: 把正数变成<code>1</code>，负数变成<code>-1</code>即可。</p>
<p>还有一个扩展问题: </p>
<p>题目: </p>
<blockquote>
<p>定义数组的异或和的概念:<br>数组中所有的数异或起来，得到的结果叫做数组的异或和，比如数组<code>&#123;3, 2, 1&#125;</code>的异或和是: <code>3 ^ 2 ^ 1 = 0 </code>。<br>给定一个数组<code>arr</code>，你可以任意把<code>arr</code>分成很多不相容的子数组，你的目的是: <font color = red>分出来的子数组中，异或和为<code>0</code>的子数组最多。<br>请返回: 分出来的子数组中，异或和为<code>0</code>的子数组最多是多少?  </p>
</blockquote>
<p>解析: 可以利用这个思想找到<strong>最晚出现和<code>0~i</code>内异或和(假设为<code>xor</code>)同样异或和的更小的范围内最晚出现的位置，因为最后一个部分是异或和为<code>0</code>，且<code>xor^0 = xor</code>。</strong><br><img src="images/tp1.png" alt="这里写图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * dp[i] = max(dp[i-1],dp[k] + 1) k表示的是i 如果是最优划分中的最后一个部分的最后一个数的话，k是那个部分的开始的地方的前一个</span></span><br><span class="line"><span class="comment">   * 从 0~i-1中异或还是  xor的最晚的位置  :</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxEor</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">      HashMap&lt;Integer,Integer&gt;map = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//存放某个异或和最晚出现的位置</span></span><br><span class="line">      <span class="keyword">int</span> res = <span class="number">0</span>,xor = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">      map.put(<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">          xor ^= arr[i];</span><br><span class="line">          <span class="keyword">if</span>(map.containsKey(xor))&#123;<span class="comment">// 找到上一个异或和为xor的最晚出现的位置　　　因为xor^0 = xor</span></span><br><span class="line">              <span class="keyword">int</span> k = map.get(xor); <span class="comment">//k</span></span><br><span class="line">              dp[i] = k == -<span class="number">1</span> ? <span class="number">1</span> : dp[k] + <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">              dp[i] = Math.max(dp[i],dp[i-<span class="number">1</span>]);</span><br><span class="line">          &#125;</span><br><span class="line">          map.put(xor,i); <span class="comment">//每次都要put进去</span></span><br><span class="line">          res = Math.max(dp[i],res);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="累加和-aim的最长子数组的长度-数组-只有正数-；"><a href="#累加和-aim的最长子数组的长度-数组-只有正数-；" class="headerlink" title="累加和 = aim的最长子数组的长度(数组+)(只有正数)；"></a>累加和<code> = aim</code>的最长子数组的长度(<strong>数组<code>+</code></strong>)(只有正数)；</h3><p>这个和上面唯一的不同就是数组中只有正数，这里使用类似窗口移动的做法，给出两个指针，<code>L、R</code>表示窗口的左右边界 ，<code>sum</code>表示的是<code>arr[L,R]</code>之间的累加和，<code>L</code>，<code>R</code>一直往右动。</p>
<ul>
<li>如果窗口内<code>sum &lt; aim</code>，<code>R</code>就往右扩，并且<code>sum += arr[R]</code>；</li>
<li>如果窗口内<code>sum &gt; aim</code>，<code>L</code> 就往右扩，并且<code>sum -= arr[L]</code>；</li>
<li>如果窗口内<code>sum = aim</code>， 就说明这个窗口内累加和为<code>sum</code> ，此时记录最大值即可；</li>
</ul>
<p><img src="images/tp2.png" alt="这里写图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> aim)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>,R = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, sum = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span>(R &lt; arr.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == aim)&#123;</span><br><span class="line">            res = Math.max(res,R - L + <span class="number">1</span>);</span><br><span class="line">            sum -= arr[L++];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; aim)&#123;<span class="comment">//小于等于就往右边扩</span></span><br><span class="line">            <span class="keyword">if</span>(++R == arr.length) <span class="keyword">break</span>;</span><br><span class="line">            sum += arr[R];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;           <span class="comment">// 大于就往左边扩  sum &gt; aim</span></span><br><span class="line">            sum -= arr[L++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="累加和-lt-aim的最长子数组的长度-数组可-0-；"><a href="#累加和-lt-aim的最长子数组的长度-数组可-0-；" class="headerlink" title="累加和 &lt;= aim的最长子数组的长度(数组可+,-,0)；"></a>累加和<code> &lt;= aim</code>的最长子数组的长度(<strong>数组可<code>+</code>,<code>-</code>,<code>0</code></strong>)；</h3><p>两个数组<code>sum</code>和<code>ends</code>，<code>sum[i]</code>表示的是以<code>arr[i]</code>开头(必须包含<code>arr[i]</code>)的所有子数组的最小累加和，对应的<code>ends[i]</code>表示的是取得这个最小累加和的右边界。 一开始先求出<code>sums</code>数组和<code>ends[]</code>数组。<br><img src="images/tp3.png" alt="这里写图片描述"></p>
<p>这个题目最精华的是左右边界不回退，就是说，如果从<code>0</code>位置扩到<code>T</code>区间，<code>T+1</code>区间不能扩了，此时不是回到<code>1</code>位置开始扩，而是舍弃<code>0</code>位置，看能不能由于舍弃<code>0</code>位置把<code>T+1</code>位置加进来：</p>
<p><img src="images/tp4.png" alt="这里写图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxLength2</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> aim)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span>[] sums = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length]; <span class="comment">//以arr[i]开头所有子数组的最小累加和</span></span><br><span class="line">     <span class="keyword">int</span>[] ends = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length]; <span class="comment">//取得最小累加和的最右边界</span></span><br><span class="line">     sums[arr.length-<span class="number">1</span>] = arr[arr.length-<span class="number">1</span>];</span><br><span class="line">     ends[arr.length-<span class="number">1</span>] = arr.length-<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = arr.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123; <span class="comment">//求出sums数组和ends数组</span></span><br><span class="line">         <span class="keyword">if</span>(sums[i+<span class="number">1</span>] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">             sums[i] = arr[i] + sums[i+<span class="number">1</span>];</span><br><span class="line">             ends[i] = ends[i+<span class="number">1</span>];</span><br><span class="line">         &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">             sums[i] = arr[i];</span><br><span class="line">             ends[i] = i;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">//目前的累加和  sum -&gt; R</span></span><br><span class="line">     <span class="keyword">int</span> R = <span class="number">0</span>;<span class="comment">//每一次扩到的右边界</span></span><br><span class="line">     <span class="keyword">int</span> res = <span class="number">0</span>; <span class="comment">//答案</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; arr.length; start++)&#123;<span class="comment">//每一次开头</span></span><br><span class="line">         <span class="keyword">while</span>(R &lt; arr.length &amp;&amp; sum + sums[R] &lt;= aim)&#123;<span class="comment">//一整块一整块的扩</span></span><br><span class="line">             sum += sums[R];</span><br><span class="line">             R = ends[R] + <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         sum -= R &gt; start ? arr[start] : <span class="number">0</span>;<span class="comment">//如果R&gt;start，下面start要++了，窗口内减去arr[start]</span></span><br><span class="line">         res = Math.max(res,R - start);<span class="comment">//窗口是start ~ R-1  ,所以是长度为R-start</span></span><br><span class="line">         R = Math.max(R,start + <span class="number">1</span>);  <span class="comment">//有没有可能扩不出去</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>TwoPointer</tag>
      </tags>
  </entry>
  <entry>
    <title>如何直观的打印一颗二叉树</title>
    <url>/2022/07/27/%E5%A6%82%E4%BD%95%E7%9B%B4%E8%A7%82%E7%9A%84%E6%89%93%E5%8D%B0%E4%B8%80%E9%A2%97%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="如何直观的打印一颗二叉树"><a href="#如何直观的打印一颗二叉树" class="headerlink" title="如何直观的打印一颗二叉树"></a>如何直观的打印一颗二叉树</h2><p> 打印的结果是需要<font color = red>顺时针旋转<code>90</code>度</font>的，如下面的结果打印出来是这样的。</p>
<p><img src="images/print1.png" alt="在这里插入图片描述"></p>
<p><img src="images/print2.png" alt="这里写图片描述"></p>
<p>如何打印呢?  需要处理以下四个问题： </p>
<ul>
<li>遍历树的顺序是　<font color= red>右子树-&gt;根-&gt;左子树；</li>
<li>因为要避免数字长度影响对齐的因素，所以两边补上空格(有一个总长度可以自己确定)；</li>
<li><font color  = blue>在结点的两边加上特定的字符串标记区分孩子和父亲以及位置</font>，使用 <code>H</code>、 <code>^</code>、 <code>v</code>  这个几个标记</li>
<li>和高度有关系的  <code>height * len</code>， 打印相应前面的空格长度；</li>
</ul>
<hr>
<h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintBinaryTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head      传入的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> height　　层数(根节点为0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> to       表示的特定节点  H表示根节点   ^表示父亲节点在左上方　v表示父亲节点在左下方</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len　　　 指定每一个节点打印的宽度(总宽度)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTree</span><span class="params">(Node head,<span class="keyword">int</span> height,String to,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        printTree(head.right,height + <span class="number">1</span>,<span class="string">&quot;v&quot;</span>,len);  <span class="comment">// 递归右子树</span></span><br><span class="line"></span><br><span class="line">        String val = to + head.value + to;   <span class="comment">// 加上两边指示的字符</span></span><br><span class="line">        <span class="keyword">int</span> lenV = val.length();</span><br><span class="line">        <span class="keyword">int</span> lenL = (len - lenV)/<span class="number">2</span>;    <span class="comment">//  左边的空格  ((总长度-值所占长度)，然后分一半)</span></span><br><span class="line">        <span class="keyword">int</span> lenR = len - lenV - lenL; <span class="comment">//  右边的空格  (总-值-左边空格长度)</span></span><br><span class="line">        System.out.println( getSpace(len * height) + getSpace(lenL) + val + getSpace(lenR)); <span class="comment">// len*length是对应的层数对应的空格</span></span><br><span class="line"></span><br><span class="line">        printTree(head.left,height + <span class="number">1</span>,<span class="string">&quot;^&quot;</span>,len);  <span class="comment">// 递归左子树</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取指定的空格</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">getSpace</span><span class="params">(<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        StringBuffer str = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            str.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *              1</span></span><br><span class="line"><span class="comment">         *            2   3</span></span><br><span class="line"><span class="comment">         *          4    5 6</span></span><br><span class="line"><span class="comment">         *            7</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node head = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        head.left = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">        head.right = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">        head.left.left = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">        head.right.left = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">        head.right.right = <span class="keyword">new</span> Node(<span class="number">6</span>);</span><br><span class="line">        head.left.left.right = <span class="keyword">new</span> Node(<span class="number">7</span>);</span><br><span class="line">        printTree(head,<span class="number">0</span>,<span class="string">&quot;H&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>将单链表按某值划分成左边小，中间相等，右边大的形式</title>
    <url>/2022/09/16/%E5%B0%86%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8C%89%E6%9F%90%E5%80%BC%E5%88%92%E5%88%86%E6%88%90%E5%B7%A6%E8%BE%B9%E5%B0%8F%EF%BC%8C%E4%B8%AD%E9%97%B4%E7%9B%B8%E7%AD%89%EF%BC%8C%E5%8F%B3%E8%BE%B9%E5%A4%A7%E7%9A%84%E5%BD%A2%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="将单链表按某值划分成左边小，中间相等，右边大的形式"><a href="#将单链表按某值划分成左边小，中间相等，右边大的形式" class="headerlink" title="将单链表按某值划分成左边小，中间相等，右边大的形式"></a>将单链表按某值划分成左边小，中间相等，右边大的形式</h2><ul>
<li>普通方法，将链表节点放到数组然后partition</li>
<li>进阶方法，将链表划分成三个子链表，然后合并</li>
</ul>
<hr>
<h3 id="普通方法，将链表节点放到数组然后partition"><a href="#普通方法，将链表节点放到数组然后partition" class="headerlink" title="普通方法，将链表节点放到数组然后partition"></a>普通方法，将链表节点放到数组然后partition</h3><ul>
<li><p> 这个方法比较简单，直接将链表中的值保存到一个数组中，然后按照荷兰国旗的划分方式，将数组划分成左边小于那个数，中间等于那个数，右边大于那个数的形式，(荷兰国旗问题用于<a href="https://blog.csdn.net/zxzxzx0119/article/details/79826380#t8"><strong>快速排序</strong></a>中的<code>partition</code>过程)；</p>
</li>
<li><p>划分完之后，再把数组中的值用链表的形式连接起来。　但是这个方法需要额外的<code>O(n)</code>的空间复杂度，而且<code>partition</code>不能达到稳定性(就是会改变原来的相对顺序)；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通的需要额外空间O(n)且不能达到稳定性的　方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Node <span class="title">partitionList_1</span><span class="params">(Node head, <span class="keyword">int</span> pivot)</span> </span>&#123; <span class="comment">//pivot表示　枢轴；中心点；旋转运动</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        len++;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    Node[] nodeArr = <span class="keyword">new</span> Node[len];</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodeArr.length; i++) &#123;</span><br><span class="line">        nodeArr[i] = cur;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    arrPartition(nodeArr, pivot);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nodeArr.length; i++) &#123;</span><br><span class="line">        nodeArr[i - <span class="number">1</span>].next = nodeArr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    nodeArr[nodeArr.length - <span class="number">1</span>].next = <span class="keyword">null</span>;  <span class="comment">//一定要记得把最后一个指针指向null</span></span><br><span class="line">    <span class="keyword">return</span> nodeArr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组划分的paration</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arrPartition</span><span class="params">(Node[] nodeArr, <span class="keyword">int</span> pivot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> less = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> more = nodeArr.length;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur &lt; more) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodeArr[cur].value &lt; pivot) &#123;</span><br><span class="line">            swap(nodeArr, ++less, cur++);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeArr[cur].value &gt; pivot) &#123;</span><br><span class="line">            swap(nodeArr, --more, cur); <span class="comment">//注意放到大于区域的时候cur不能++</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换两个结点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Node[] arrNode, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    Node temp = arrNode[a];</span><br><span class="line">    arrNode[a] = arrNode[b];</span><br><span class="line">    arrNode[b] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="进阶方法，将链表划分成三个子链表，然后合并"><a href="#进阶方法，将链表划分成三个子链表，然后合并" class="headerlink" title="进阶方法，将链表划分成三个子链表，然后合并"></a>进阶方法，将链表划分成三个子链表，然后合并</h3><ul>
<li>这个方法是将原来的链表依次划分成三个链表，三个链表分别为<code>small</code>代表的是左边小于的部分，<code>equal</code>代表的是中间相等的部分，<code>big</code>代表的是右边的大于部分；</li>
<li>这三个链表都有自己的两个指针<code>Head</code>和<code>Tail</code>分别代表各自的头部和尾部，分成三个子链表之后，我们只需要遍历链表，然后和给定的值比较，按照条件，向三个链表中添加值就可以了，最后把三个链表连接起来就可以了；</li>
</ul>
<p>但是，这个题目要注意一些边界条件。具体看下图: </p>
<p><img src="images/l1.png" alt="这里写图片描述"></p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第二种　进阶的方法　不需要额外的空间复杂度，且能达到稳定性</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Node <span class="title">partitionList_2</span><span class="params">(Node head,<span class="keyword">int</span> piovt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Node sH = <span class="keyword">null</span>,sT = <span class="keyword">null</span>; <span class="comment">//小于部分链表的  head 和tail</span></span><br><span class="line">    Node eH = <span class="keyword">null</span>,eT = <span class="keyword">null</span>; <span class="comment">//等于部分链表的　head 和tail</span></span><br><span class="line">    Node bH = <span class="keyword">null</span>,bT = <span class="keyword">null</span>; <span class="comment">//大于部分链表的　head 和tail</span></span><br><span class="line"></span><br><span class="line">    Node next = <span class="keyword">null</span>;  <span class="comment">//用来保存下一个结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//划分到　三个不同的链表</span></span><br><span class="line">    <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        next = head.next;</span><br><span class="line">        head.next = <span class="keyword">null</span>; <span class="comment">//这个是为了链表拼接后　最后一个就不用再去赋值其next域为null 了</span></span><br><span class="line">        <span class="keyword">if</span>(head.value &lt; piovt)&#123;  <span class="comment">//向　small 部分　分布</span></span><br><span class="line">            <span class="keyword">if</span>(sH == <span class="keyword">null</span>)&#123; <span class="comment">//small部分的第一个结点</span></span><br><span class="line">                sH = head;</span><br><span class="line">                sT = head;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                sT.next = head; <span class="comment">//把head放到small最后一个</span></span><br><span class="line">                sT = head;  <span class="comment">//更新small部分的sT</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(head.value == piovt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(eH == <span class="keyword">null</span>)&#123;</span><br><span class="line">                eH = head;</span><br><span class="line">                eT = head;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                eT.next = head;</span><br><span class="line">                eT = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(bH == <span class="keyword">null</span>)&#123;</span><br><span class="line">                bH = head;</span><br><span class="line">                bT = head;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                bT.next = head;</span><br><span class="line">                bT = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将三个链表合并(注意边界的判断)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> != sT) &#123; <span class="comment">//合并small和equal部分</span></span><br><span class="line">        sT.next = eH;</span><br><span class="line">        eT = eT == <span class="keyword">null</span> ? sT : eT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> != eT)&#123;</span><br><span class="line">        eT.next = bH;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sH != <span class="keyword">null</span> ? sH : eH != <span class="keyword">null</span> ? eH : bH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后贴上测试完整代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将一个链表划分成　左边小于num,中间等于num,右边大于num</span></span><br><span class="line"><span class="comment"> * 方法1 : 先将链表存到一个数组中，然后使用　　和　荷兰国旗问题相同的方法进行　划分，然后再重新连成一个链表即可(缺点: 额外的空间复杂度和不能做到稳定性)</span></span><br><span class="line"><span class="comment"> * 方法2 : 使用有限的变量，small equal big 划分成三个链表，这三个链表都分别有自己的头部和尾部，每次一只需要往对应的链表加上相应的数即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmallerEqualBigger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通的需要额外空间O(n)且不能达到稳定性的　方法</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">partitionList_1</span><span class="params">(Node head,<span class="keyword">int</span> pivot)</span></span>&#123; <span class="comment">//pivot表示　枢轴；中心点；旋转运动</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Node[] nodeArr = <span class="keyword">new</span> Node[len];</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodeArr.length; i++)&#123;</span><br><span class="line">            nodeArr[i] = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        arrPartition(nodeArr,pivot);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nodeArr.length; i++)&#123;</span><br><span class="line">            nodeArr[i-<span class="number">1</span>].next = nodeArr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        nodeArr[nodeArr.length-<span class="number">1</span>].next = <span class="keyword">null</span>;  <span class="comment">//一定要记得把最后一个指针指向null</span></span><br><span class="line">        <span class="keyword">return</span> nodeArr[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组划分的paration</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arrPartition</span><span class="params">(Node[] nodeArr, <span class="keyword">int</span> pivot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> less = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> more = nodeArr.length;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur &lt; more)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nodeArr[cur].value &lt; pivot)&#123;</span><br><span class="line">                swap(nodeArr,++less,cur++);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nodeArr[cur].value &gt; pivot)&#123;</span><br><span class="line">                swap(nodeArr,--more,cur); <span class="comment">//注意放到大于区域的时候cur不能++</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换两个结点</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Node[] arrNode,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        Node temp = arrNode[a];</span><br><span class="line">        arrNode[a] = arrNode[b];</span><br><span class="line">        arrNode[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种　进阶的方法　不需要额外的空间复杂度，且能达到稳定性</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">partitionList_2</span><span class="params">(Node head,<span class="keyword">int</span> piovt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Node sH = <span class="keyword">null</span>,sT = <span class="keyword">null</span>; <span class="comment">//小于部分链表的  head 和tail</span></span><br><span class="line">        Node eH = <span class="keyword">null</span>,eT = <span class="keyword">null</span>; <span class="comment">//等于部分链表的　head 和tail</span></span><br><span class="line">        Node bH = <span class="keyword">null</span>,bT = <span class="keyword">null</span>; <span class="comment">//大于部分链表的　head 和tail</span></span><br><span class="line"></span><br><span class="line">        Node next = <span class="keyword">null</span>;  <span class="comment">//用来保存下一个结点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//划分到　三个不同的链表</span></span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            next = head.next;</span><br><span class="line">            head.next = <span class="keyword">null</span>; <span class="comment">//这个是为了链表拼接后　最后一个就不用再去赋值其next域为null 了</span></span><br><span class="line">            <span class="keyword">if</span>(head.value &lt; piovt)&#123;  <span class="comment">//向　small 部分　分布</span></span><br><span class="line">                <span class="keyword">if</span>(sH == <span class="keyword">null</span>)&#123; <span class="comment">//small部分的第一个结点</span></span><br><span class="line">                    sH = head;</span><br><span class="line">                    sT = head;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    sT.next = head; <span class="comment">//把head放到small最后一个</span></span><br><span class="line">                    sT = head;  <span class="comment">//更新small部分的sT</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(head.value == piovt)&#123;</span><br><span class="line">                <span class="keyword">if</span>(eH == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    eH = head;</span><br><span class="line">                    eT = head;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    eT.next = head;</span><br><span class="line">                    eT = head;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(bH == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    bH = head;</span><br><span class="line">                    bT = head;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    bT.next = head;</span><br><span class="line">                    bT = head;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将三个链表合并(注意边界的判断)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != sT) &#123; <span class="comment">//合并small和equal部分</span></span><br><span class="line">            sT.next = eH;</span><br><span class="line">            eT = eT == <span class="keyword">null</span> ? sT : eT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != eT)&#123;</span><br><span class="line">            eT.next = bH;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sH != <span class="keyword">null</span> ? sH : eH != <span class="keyword">null</span> ? eH : bH;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.print(node.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------测试第一种方法----------&quot;</span>);</span><br><span class="line">        Node head = <span class="keyword">new</span> Node(<span class="number">9</span>);</span><br><span class="line">        head.next = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">        head.next.next = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">        head.next.next.next = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">        head.next.next.next.next = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        printList(head);</span><br><span class="line">        head = partitionList_1(head,<span class="number">3</span>);</span><br><span class="line">        printList(head);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------测试第二种方法----------&quot;</span>);</span><br><span class="line">        Node head2 = <span class="keyword">new</span> Node(<span class="number">9</span>);</span><br><span class="line">        head2.next = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">        head2.next.next = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">        head2.next.next.next = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">        head2.next.next.next.next = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        printList(head2);</span><br><span class="line">        head2 = partitionList_2(head2,<span class="number">3</span>);</span><br><span class="line">        printList(head2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果</p>
<p><img src="images/l2.png" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title>最大值减去最小值小于等于aim的子数组数量(单调队列(最大值和最小值更新结构))</title>
    <url>/2022/10/05/%E6%9C%80%E5%A4%A7%E5%80%BC%E5%87%8F%E5%8E%BB%E6%9C%80%E5%B0%8F%E5%80%BC%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8Eaim%20%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0%E9%87%8F(%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97(%E6%9C%80%E5%A4%A7%E5%80%BC%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC%E6%9B%B4%E6%96%B0%E7%BB%93%E6%9E%84))/</url>
    <content><![CDATA[<h2 id="最大值减去最小值小于等于aim的子数组数量-单调队列-最大值和最小值更新结构"><a href="#最大值减去最小值小于等于aim的子数组数量-单调队列-最大值和最小值更新结构" class="headerlink" title="最大值减去最小值小于等于aim的子数组数量(单调队列(最大值和最小值更新结构))"></a>最大值减去最小值小于等于aim的子数组数量(单调队列(最大值和最小值更新结构))</h2><p><img src="images/ms6.png" alt="这里写图片描述"></p>
<p><font color = red>注意: 子数组必须是下标连续的，而且<code>i ~ i</code>自己也算一个子数组。</font></p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>这个题目也是使用单调队列(窗口内更新最大值和最小值)的结构来做，如果不懂单调队列先看<a href="https://blog.csdn.net/zxzxzx0119/article/details/81586455"><strong>这个博客</strong></a>。</p>
<p><font color = red><strong>先准备两个双端队列，分别是最大值更新结构和最小值更新结构：</strong></font></p>
<ul>
<li><strong>先生成两个双端队列<code>qmax</code>和<code>qmin</code>，当子数组为<code>arr[L...R]</code>时，<code>qmax</code>维护了窗口子数组<code>arr[L...R]</code>的最大值更新结构，<code>qmin</code>维护了窗口子数组<code>arr[L....R]</code>的最小值更新结构；</strong></li>
<li><strong>当子数组<code>arr[L....R]</code>向右扩一个位置变成<code>arr[L....R+1]</code>时，<code>qmax</code>和<code>qmin</code>可以在<code>O(1)</code>时间内完成更新；并且可以在<code>O(1)</code>时间内得到窗口的最大值和最小值；</strong></li>
<li><strong>当子数组<code>arr[L....R]</code>左边缩一个位置变成<code>arr[L+1....R]</code>是，<code>qmax</code>和<code>qmin</code>可以在<code>O(1)</code>时间内完成更新；并且可以在<code>O(1)</code>时间内得到窗口的最大值和最小值；</strong></li>
</ul>
<p>然后，我们需要证明两个结论: </p>
<p><img src="images/ms7.png" alt="这里写图片描述"></p>
<h4 id="下面看具体过程"><a href="#下面看具体过程" class="headerlink" title="下面看具体过程:"></a>下面看具体过程:</h4><ul>
<li>找到一个<code>L</code>，此时令<code>R</code>不断向右移动，表示<code>arr[L...R]</code>一直向右扩大，并不断更新<code>qmax</code>和<code>qmin</code>的结构，保证<code>qmax</code>和<code>qmin</code>始终维持动态窗口最大值和最小值的更新结构；</li>
<li>一旦出现<code>arr[L....R]</code>中出现<code>max - min &gt; aim</code>的情况，<code>R</code>向右扩的过程停止(<font color = red>上面证明结论的第二条</font>)，此时<code>arr[L....R-1]，arr[L....R-2]，arr[L....R-3]....arr[L,L]</code>都是满足条件的子数组(<font color = red>上面证明结论的第一条</font>)。也就是说，所以必须以<code>arr[L]</code>开头的子数组，总共<font color = red>有<code>R - L </code>个，<code>res += R-L</code></font>；</li>
<li>然后要<strong>注意两个队列中的过期的元素</strong>，也就是说队头的元素考虑完了之后<strong>要弹出</strong>；</li>
<li>然后，继续考虑下一个<code>L</code>，直到循环结束；</li>
</ul>
<p> <strong>由于<code>L,R</code>的值是一直增加的(不会减小)，且所有的下标最多进<code>qmax、qmin</code>一次，出<code>qmax、qmin</code>一次，时间复杂度为<code>O(n)</code>。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    LinkedList&lt;Integer&gt; qmax = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; qmin = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>, R = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; arr.length) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (R &lt; arr.length) &#123;<span class="comment">//这个While循环就是当L确定的时候，R往右扩到不能再扩</span></span><br><span class="line">            <span class="keyword">while</span> (!qmin.isEmpty() &amp;&amp; arr[qmin.peekLast()] &gt;= arr[R]) qmin.pollLast(); <span class="comment">//最小值更新结构</span></span><br><span class="line">            qmin.addLast(R);</span><br><span class="line">            <span class="keyword">while</span> (!qmax.isEmpty() &amp;&amp; arr[qmax.peekLast()] &lt;= arr[R]) qmax.pollLast();<span class="comment">//最大值更新结构</span></span><br><span class="line">            qmax.addLast(R);</span><br><span class="line">            <span class="comment">//直接取得最大值和最小值判断一下</span></span><br><span class="line">            <span class="keyword">if</span> (arr[qmax.getFirst()] - arr[qmin.getFirst()] &gt; aim) <span class="keyword">break</span>; <span class="comment">//直到扩到R不能再往右扩</span></span><br><span class="line">            R++; <span class="comment">//否则当L确定的是R就一直往右扩</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (qmin.peekFirst() == L) &#123; <span class="comment">//最小值的更新结构判断下标是否过期</span></span><br><span class="line">            qmin.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (qmax.peekFirst() == L) &#123;<span class="comment">//最大值的更新结构判断下标是否过期</span></span><br><span class="line">            qmax.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        res += R - L; <span class="comment">//一次性的就榨取了所有以L开头的子数组的数量</span></span><br><span class="line">        L++; <span class="comment">//换一个L开头</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>完整的测试代码如下(包括使用<code>O(n^3)</code>方法来测试我们的<code>O(n)</code>方法):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最大值减去最小值　&lt;= num 的子数组数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetNumOfMaxMinusMinSubArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ok(arr, i, j, aim)) res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">ok</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            max = Math.max(max, arr[i]);</span><br><span class="line">            min = Math.min(min, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max - min &lt;= aim;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        LinkedList&lt;Integer&gt; qmax = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        LinkedList&lt;Integer&gt; qmin = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>, R = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (L &lt; arr.length) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (R &lt; arr.length) &#123;<span class="comment">//这个While循环就是当L确定的时候，R往右扩到不能再扩</span></span><br><span class="line">                <span class="keyword">while</span> (!qmin.isEmpty() &amp;&amp; arr[qmin.peekLast()] &gt;= arr[R]) qmin.pollLast(); <span class="comment">//最小值更新结构</span></span><br><span class="line">                qmin.addLast(R);</span><br><span class="line">                <span class="keyword">while</span> (!qmax.isEmpty() &amp;&amp; arr[qmax.peekLast()] &lt;= arr[R]) qmax.pollLast();<span class="comment">//最大值更新结构</span></span><br><span class="line">                qmax.addLast(R);</span><br><span class="line">                <span class="comment">//直接取得最大值和最小值判断一下</span></span><br><span class="line">                <span class="keyword">if</span> (arr[qmax.getFirst()] - arr[qmin.getFirst()] &gt; aim) <span class="keyword">break</span>; <span class="comment">//直到扩到R不能再往右扩</span></span><br><span class="line">                R++; <span class="comment">//否则当L确定的是R就一直往右扩</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (qmin.peekFirst() == L) &#123; <span class="comment">//最小值的更新结构判断下标是否过期</span></span><br><span class="line">                qmin.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (qmax.peekFirst() == L) &#123;<span class="comment">//最大值的更新结构判断下标是否过期</span></span><br><span class="line">                qmax.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            res += R - L; <span class="comment">//一次性的就榨取了所有以L开头的子数组的数量</span></span><br><span class="line">            L++; <span class="comment">//换一个L开头</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成随机数组</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] generateRandomArray(<span class="keyword">int</span> size, <span class="keyword">int</span> value) &#123;  <span class="comment">//生成的数组的最大长度和</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>) ((size + <span class="number">1</span>) * Math.random())];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">            arr[i] = (<span class="keyword">int</span>) ((value + <span class="number">1</span>) * Math.random()) - (<span class="keyword">int</span>) (value * Math.random());</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组复制</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] arrayCopy(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) copy[i] = arr[i];</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印出数组</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> testTime = <span class="number">100</span>; <span class="comment">//测试100次</span></span><br><span class="line">        <span class="keyword">boolean</span> success = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testTime; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = <span class="number">7</span>, value = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">int</span> k = (<span class="keyword">int</span>) (<span class="number">10</span> * Math.random());</span><br><span class="line">            <span class="keyword">int</span>[] arr = generateRandomArray(size, value);</span><br><span class="line">            <span class="keyword">int</span>[] arr2 = arrayCopy(arr);</span><br><span class="line">            <span class="keyword">int</span> res1 = getNum(arr, k);</span><br><span class="line">            <span class="keyword">int</span> res2 = getNum2(arr2, k);</span><br><span class="line">            <span class="keyword">if</span> (res1 != res2) &#123;</span><br><span class="line">                printArray(arr);</span><br><span class="line">                System.out.println(k);</span><br><span class="line">                System.out.println(res1 + <span class="string">&quot; &quot;</span> + res2);</span><br><span class="line">                System.out.println(<span class="string">&quot;Wrong!&quot;</span>);</span><br><span class="line">                success = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (success) System.out.println(<span class="string">&quot;Nice!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>MonotoneStack</tag>
      </tags>
  </entry>
  <entry>
    <title>找到二叉树中的最大搜索二叉子树</title>
    <url>/2022/08/19/%E6%89%BE%E5%88%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E5%AD%90%E6%A0%91/</url>
    <content><![CDATA[<h2 id="找到二叉树中的最大搜索二叉子树"><a href="#找到二叉树中的最大搜索二叉子树" class="headerlink" title="找到二叉树中的最大搜索二叉子树"></a>找到二叉树中的最大搜索二叉子树</h2><ul>
<li>递归</li>
<li>技巧的写法</li>
<li>完整测试代码</li>
</ul>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><img src="images/tree3.png" alt="在这里插入图片描述"></p>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>解析:<br>这种题目的解题过程分为三步: </p>
<ul>
<li><strong>列出所有可能性</strong>；</li>
<li>**列出结点需要的信息，并整合信息(成一个结构体)**；</li>
<li><strong>改递归 ，先假设左和右都给我信息(黑盒)，然后怎么利用左边和右边的信息组出来我该返回的信息，最后<code>basecase</code>(边界)填什么</strong>；</li>
</ul>
<p>具体到这个题目：<br><font color = red>第一步，列出所有可能性</font>： </p>
<ul>
<li>第一种可能性，以<code>node</code>为头的结点的最大二叉搜索子树可能来自它左子树；</li>
<li>第二种可能性，以<code>node</code>为头的结点的最大二叉搜索子树可能来自它右子树；</li>
<li>第三种可能性，左树整体是搜索二叉树，右树整体也是搜索二叉树，而且左树的头是<code>node.left</code>，右树的头是<code>node.right</code>，且左树的最大值<code>&lt; node.value</code>，右树的最小值<code> &gt; node.value</code>，  <strong>那么以我为头的整棵树都是搜索二叉树；</strong></li>
</ul>
<p><font color = red>第二步，列出结点需要的信息:</font></p>
<ul>
<li>信息一: 左树最大搜索二叉树大小；</li>
<li>信息二: 右树最大搜索二叉树大小；</li>
<li>信息三: 左树上最大搜索二叉树的头部是什么；</li>
<li>信息四: 右树上最大搜索二叉树的头部是什么；</li>
<li>信息五: 左树上的最大值；</li>
<li>信息六: 右树上的最小值；</li>
</ul>
<p>整合成一个<code>Pair</code>结构: 信息一和信息二整合：<code>size</code> ，信息三和信息四整合 : <code>head</code>(结点类型)，以及信息五和信息六 ；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回的类型</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> size; <span class="comment">//左右子树的大小</span></span><br><span class="line">    <span class="keyword">public</span> Node root; <span class="comment">//左右子树的头</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> min;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后第三部就是改成递归，具体如下(是后序遍历的顺序(需要左右的信息来构造头部的信息)): </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回的类型</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> size; <span class="comment">//左右子树的大小</span></span><br><span class="line">    <span class="keyword">public</span> Node root; <span class="comment">//左右子树的头</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> min;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> max;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> size, Node root, <span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">        <span class="keyword">this</span>.min = min;</span><br><span class="line">        <span class="keyword">this</span>.max = max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Node <span class="title">biggestSubBST</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rec(head).root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Pair <span class="title">rec</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair(<span class="number">0</span>, <span class="keyword">null</span>, Integer.MAX_VALUE, Integer.MIN_VALUE);</span><br><span class="line">    Pair L = rec(head.left);</span><br><span class="line">    Pair R = rec(head.right);</span><br><span class="line">    <span class="keyword">int</span> msize =</span><br><span class="line">            (L.root == head.left &amp;&amp; R.root == head.right &amp;&amp; L.max &lt; head.value &amp;&amp; R.min &gt; head.value)</span><br><span class="line">                    ? L.size + R.size + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxSize = Math.max(Math.max(L.size, R.size), msize);</span><br><span class="line">    Node mroot = L.size &gt; R.size ? L.root : R.root;</span><br><span class="line">    <span class="keyword">if</span> (maxSize == msize) mroot = head;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Pair(maxSize, mroot, Math.min(head.value, Math.min(L.min, R.min)),</span><br><span class="line">            Math.max(head.value, Math.max(L.max, R.max)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="改造的写法"><a href="#改造的写法" class="headerlink" title="改造的写法"></a>改造的写法</h3><p>技巧的写法(使用一个数组来记录<code>size,min,max</code>):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Node <span class="title">biggestSubBST2</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] rec = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];  <span class="comment">//0 记录size 1记录min 2记录max</span></span><br><span class="line">    <span class="keyword">return</span> rec2(head, rec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Node <span class="title">rec2</span><span class="params">(Node head, <span class="keyword">int</span>[] rec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        rec[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        rec[<span class="number">1</span>] = Integer.MAX_VALUE;</span><br><span class="line">        rec[<span class="number">2</span>] = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node L = rec2(head.left, rec);</span><br><span class="line">    <span class="keyword">int</span> lsize = rec[<span class="number">0</span>], lmin = rec[<span class="number">1</span>], lmax = rec[<span class="number">2</span>];</span><br><span class="line">    Node R = rec2(head.right, rec);</span><br><span class="line">    <span class="keyword">int</span> rsize = rec[<span class="number">0</span>], rmin = rec[<span class="number">1</span>], rmax = rec[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> msize = (L == head.left &amp;&amp; R == head.right &amp;&amp; lmax &lt; head.value &amp;&amp; rmin &gt; head.value) ? lsize + rsize + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxSize = Math.max(msize, Math.max(lsize, rsize));</span><br><span class="line">    Node root = lsize &gt; rsize ? L : R;</span><br><span class="line">    <span class="keyword">if</span> (msize == maxSize) root = head;</span><br><span class="line">    rec[<span class="number">0</span>] = maxSize;</span><br><span class="line">    rec[<span class="number">1</span>] = Math.min(head.value, Math.min(lmin, rmin));</span><br><span class="line">    rec[<span class="number">2</span>] = Math.max(head.value, Math.max(lmax, rmax));</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完整测试代码-测试样例"><a href="#完整测试代码-测试样例" class="headerlink" title="完整测试代码(测试样例)"></a>完整测试代码(测试样例)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一棵树中最大的二叉搜索子树的大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BiggestSubBST</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回的类型</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> size; <span class="comment">//左右子树的大小</span></span><br><span class="line">        <span class="keyword">public</span> Node root; <span class="comment">//左右子树的头</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> min;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> max;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> size, Node root, <span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.size = size;</span><br><span class="line">            <span class="keyword">this</span>.root = root;</span><br><span class="line">            <span class="keyword">this</span>.min = min;</span><br><span class="line">            <span class="keyword">this</span>.max = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">biggestSubBST</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rec(head).root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Pair <span class="title">rec</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Pair(<span class="number">0</span>, <span class="keyword">null</span>, Integer.MAX_VALUE, Integer.MIN_VALUE);</span><br><span class="line">        Pair L = rec(head.left);</span><br><span class="line">        Pair R = rec(head.right);</span><br><span class="line">        <span class="keyword">int</span> msize =</span><br><span class="line">                (L.root == head.left &amp;&amp; R.root == head.right &amp;&amp; L.max &lt; head.value &amp;&amp; R.min &gt; head.value)</span><br><span class="line">                        ? L.size + R.size + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxSize = Math.max(Math.max(L.size, R.size), msize);</span><br><span class="line">        Node mroot = L.size &gt; R.size ? L.root : R.root;</span><br><span class="line">        <span class="keyword">if</span> (maxSize == msize) mroot = head;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair(maxSize, mroot, Math.min(head.value, Math.min(L.min, R.min)),</span><br><span class="line">                Math.max(head.value, Math.max(L.max, R.max)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">biggestSubBST2</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] rec = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];  <span class="comment">//0 记录size 1记录min 2记录max</span></span><br><span class="line">        <span class="keyword">return</span> rec2(head, rec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">rec2</span><span class="params">(Node head, <span class="keyword">int</span>[] rec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            rec[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            rec[<span class="number">1</span>] = Integer.MAX_VALUE;</span><br><span class="line">            rec[<span class="number">2</span>] = Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node L = rec2(head.left, rec);</span><br><span class="line">        <span class="keyword">int</span> lsize = rec[<span class="number">0</span>], lmin = rec[<span class="number">1</span>], lmax = rec[<span class="number">2</span>];</span><br><span class="line">        Node R = rec2(head.right, rec);</span><br><span class="line">        <span class="keyword">int</span> rsize = rec[<span class="number">0</span>], rmin = rec[<span class="number">1</span>], rmax = rec[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> msize = (L == head.left &amp;&amp; R == head.right &amp;&amp; lmax &lt; head.value &amp;&amp; rmin &gt; head.value) ? lsize + rsize + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxSize = Math.max(msize, Math.max(lsize, rsize));</span><br><span class="line">        Node root = lsize &gt; rsize ? L : R;</span><br><span class="line">        <span class="keyword">if</span> (msize == maxSize) root = head;</span><br><span class="line">        rec[<span class="number">0</span>] = maxSize;</span><br><span class="line">        rec[<span class="number">1</span>] = Math.min(head.value, Math.min(lmin, rmin));</span><br><span class="line">        rec[<span class="number">2</span>] = Math.max(head.value, Math.max(lmax, rmax));</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node <span class="title">build</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= arr.length || arr[index] == -<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Node root = <span class="keyword">new</span> Node(arr[index]);</span><br><span class="line">        root.left = build(arr, index * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        root.right = build(arr, index * <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head   传入的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> height 　　层数(根节点为0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> to     表示的特定节点  H表示根节点   ^表示父亲节点在左上方　v表示父亲节点在左下方</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len    　　　指定每一个节点打印的宽度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTree</span><span class="params">(Node head, <span class="keyword">int</span> height, String to, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        printTree(head.right, height + <span class="number">1</span>, <span class="string">&quot;v&quot;</span>, len);</span><br><span class="line"></span><br><span class="line">        String val = to + head.value + to;  <span class="comment">//两边指示的字符</span></span><br><span class="line">        <span class="keyword">int</span> lenV = val.length();</span><br><span class="line">        <span class="keyword">int</span> lenL = (len - lenV) / <span class="number">2</span>;  <span class="comment">//左边的空格(分一半)</span></span><br><span class="line">        <span class="keyword">int</span> lenR = len - lenV - lenL; <span class="comment">// 右边的空格</span></span><br><span class="line">        System.out.println(getSpace(len * height) + getSpace(lenL) + val + getSpace(lenR));</span><br><span class="line"></span><br><span class="line">        printTree(head.left, height + <span class="number">1</span>, <span class="string">&quot;^&quot;</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取指定的空格</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">getSpace</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        StringBuffer str = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) str.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">6</span>, <span class="number">1</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">13</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">4</span>, <span class="number">14</span>, <span class="number">20</span>, <span class="number">16</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">15</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        Node head = build(arr, <span class="number">0</span>);</span><br><span class="line">        printTree(head, <span class="number">0</span>, <span class="string">&quot;H&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        System.out.println(biggestSubBST(head).value);</span><br><span class="line">        System.out.println(biggestSubBST2(head).value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>二叉树打印见<a href="https://blog.csdn.net/zxzxzx0119/article/details/81096554">这个博客</a><br>测试效果:<br><img src="images/tree4.png" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo必知必会</title>
    <url>/2023/12/30/Dubbo/</url>
    <content><![CDATA[<h2 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h2><h4 id="1-什么是Dubbo"><a href="#1-什么是Dubbo" class="headerlink" title="1.什么是Dubbo?"></a>1.什么是Dubbo?</h4><p>Dubbo是基于Java的高性能轻量级的RPC分布式服务框架，现已成为 Apache 基金会孵化项目。</p>
<p>官网：<a href="http://dubbo.apache.org/en-us/">http://dubbo.apache.org/en-us/</a></p>
<h4 id="2-为什么要使用Dubbo"><a href="#2-为什么要使用Dubbo" class="headerlink" title="2.为什么要使用Dubbo?"></a>2.为什么要使用Dubbo?</h4><p>背景:</p>
<p>随着互联网的快速发展，Web应用程序的规模不断扩大，最后我们发现传统的垂直体系结构（整体式）已无法解决。分布式服务体系结构和流计算体系结构势在必行，迫切需要一个治理系统来确保体系结构的有序发展。</p>
<ul>
<li>开源免费</li>
<li>一些核心业务被提取并作为独立的服务提供服务，逐渐形成一个稳定的服务中心，这样前端应用程序就可以更好地响应变化多端的市场需求</li>
<li>分布式框架能承受更大规模的流量</li>
<li>内部基于netty性能高</li>
</ul>
<h4 id="3-Dubbo提供了哪3个关键功能？"><a href="#3-Dubbo提供了哪3个关键功能？" class="headerlink" title="3.Dubbo提供了哪3个关键功能？"></a>3.Dubbo提供了哪3个关键功能？</h4><p>基于接口的远程调用</p>
<p>容错和负载均衡</p>
<p>自动服务注册和发现</p>
<h4 id="4-你知道哪些机构在用Dubbo吗？"><a href="#4-你知道哪些机构在用Dubbo吗？" class="headerlink" title="4.你知道哪些机构在用Dubbo吗？"></a>4.你知道哪些机构在用Dubbo吗？</h4><p><img src="https://gitee.com/yizhibuerdai/Imagetools/raw/master/images/image-20200423105332840.png" alt="image-20200423105332840"></p>
<h4 id="5-Dubbo服务的关键节点有哪些"><a href="#5-Dubbo服务的关键节点有哪些" class="headerlink" title="5.Dubbo服务的关键节点有哪些?"></a>5.Dubbo服务的关键节点有哪些?</h4><p><img src="https://gitee.com/yizhibuerdai/Imagetools/raw/master/images/image-20200423105925624.png" alt="image-20200423105925624"></p>
<h4 id="6-说一下Dubbo服务注册流程"><a href="#6-说一下Dubbo服务注册流程" class="headerlink" title="6.说一下Dubbo服务注册流程?"></a>6.说一下Dubbo服务注册流程?</h4><ol>
<li>服务容器负责启动，加载，运行服务提供者。</li>
<li>服务提供者在启动时，向注册中心注册自己提供的服务。</li>
<li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li>
<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>
<li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>
<li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li>
</ol>
<h4 id="7-能画一下服务注册流程图吗？"><a href="#7-能画一下服务注册流程图吗？" class="headerlink" title="7.能画一下服务注册流程图吗？"></a>7.能画一下服务注册流程图吗？</h4><p><img src="https://gitee.com/yizhibuerdai/Imagetools/raw/master/images/image-20200423110344448.png" alt="image-20200423110344448"></p>
<h4 id="8-Dubbo架构的特点？"><a href="#8-Dubbo架构的特点？" class="headerlink" title="8.Dubbo架构的特点？"></a>8.Dubbo架构的特点？</h4><p>连通性、健壮性、伸缩性、以及向未来架构的升级性。</p>
<h4 id="9-对jdk的最小版本需求？"><a href="#9-对jdk的最小版本需求？" class="headerlink" title="9.对jdk的最小版本需求？"></a>9.对jdk的最小版本需求？</h4><p>jdk1.6+</p>
<h4 id="10-注册中心的选择？"><a href="#10-注册中心的选择？" class="headerlink" title="10.注册中心的选择？"></a>10.注册中心的选择？</h4><p>一般来说选中Zookeeper更稳定更合适。</p>
<p>除了Zookeeper还有Redis注册中心、Multicast注册中心、Simple注册中心。</p>
<h4 id="11-Dubbo的核心配置？用途？"><a href="#11-Dubbo的核心配置？用途？" class="headerlink" title="11.Dubbo的核心配置？用途？"></a>11.Dubbo的核心配置？用途？</h4><p><img src="https://gitee.com/yizhibuerdai/Imagetools/raw/master/images/image-20200423111538534.png" alt="image-20200423111538534"></p>
<h4 id="12-配置优先级规则？"><a href="#12-配置优先级规则？" class="headerlink" title="12.配置优先级规则？"></a>12.配置优先级规则？</h4><p><img src="https://gitee.com/yizhibuerdai/Imagetools/raw/master/images/image-20200423112118958.png" alt="image-20200423112118958"></p>
<p>优先级从高到低：</p>
<ul>
<li>JVM -D参数，当你部署或者启动应用时，它可以轻易地重写配置，比如，改变dubbo协议端口；</li>
<li>XML, XML中的当前配置会重写dubbo.properties中的；</li>
<li>Properties，默认配置，仅仅作用于以上两者没有配置时。</li>
</ul>
<h4 id="13-如何用代码方式绕过注册中心点对点直连？"><a href="#13-如何用代码方式绕过注册中心点对点直连？" class="headerlink" title="13.如何用代码方式绕过注册中心点对点直连？"></a>13.如何用代码方式绕过注册中心点对点直连？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">…</span><br><span class="line"> </span><br><span class="line">ReferenceConfig&lt;XxxService&gt; reference = <span class="keyword">new</span> ReferenceConfig&lt;XxxService&gt;(); <span class="comment">// 此实例很重，封装了与注册中心的连接以及与提供者的连接，请自行缓存，否则可能造成内存和连接泄漏</span></span><br><span class="line"><span class="comment">// 如果点对点直连，可以用reference.setUrl()指定目标地址，设置url后将绕过注册中心，</span></span><br><span class="line"><span class="comment">// 其中，协议对应provider.setProtocol()的值，端口对应provider.setPort()的值，</span></span><br><span class="line"><span class="comment">// 路径对应service.setPath()的值，如果未设置path，缺省path为接口名</span></span><br><span class="line">reference.setUrl(<span class="string">&quot;dubbo://10.20.130.230:20880/com.xxx.XxxService&quot;</span>); </span><br><span class="line"> </span><br><span class="line">…</span><br></pre></td></tr></table></figure>

<h4 id="14-Dubbo配置来源有几种？分别是？"><a href="#14-Dubbo配置来源有几种？分别是？" class="headerlink" title="14.Dubbo配置来源有几种？分别是？"></a>14.Dubbo配置来源有几种？分别是？</h4><p>4种</p>
<ul>
<li>JVM System Properties，-D参数</li>
<li>Externalized Configuration，外部化配置</li>
<li>ServiceConfig、ReferenceConfig等编程接口采集的配置</li>
<li>本地配置文件dubbo.properties</li>
</ul>
<h4 id="15-如何禁用某个服务的启动检查？"><a href="#15-如何禁用某个服务的启动检查？" class="headerlink" title="15.如何禁用某个服务的启动检查？"></a>15.如何禁用某个服务的启动检查？</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span> = <span class="string">&quot;com.foo.BarService&quot;</span> <span class="attr">check</span> = <span class="string">&quot;false&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="16-Dubbo-负载均衡策略？默认是？"><a href="#16-Dubbo-负载均衡策略？默认是？" class="headerlink" title="16.Dubbo 负载均衡策略？默认是？"></a>16.Dubbo 负载均衡策略？默认是？</h4><ul>
<li><p>随机负载平衡(默认)</p>
</li>
<li><p>RoundRobin负载平衡</p>
</li>
<li><p>最小活动负载平衡</p>
</li>
<li><p>一致的哈希负载平衡</p>
</li>
</ul>
<h4 id="17-上线兼容老版本？"><a href="#17-上线兼容老版本？" class="headerlink" title="17.上线兼容老版本？"></a>17.上线兼容老版本？</h4><p>多版本号(version)</p>
<h4 id="18-开发测试环境，想绕过注册中心如何配置？"><a href="#18-开发测试环境，想绕过注册中心如何配置？" class="headerlink" title="18.开发测试环境，想绕过注册中心如何配置？"></a>18.开发测试环境，想绕过注册中心如何配置？</h4><ul>
<li>xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;xxxService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.alibaba.xxx.XxxService&quot;</span> <span class="attr">url</span>=<span class="string">&quot;dubbo://localhost:20890&quot;</span> /&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>-D</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">java <span class="literal">-Dcom</span>.alibaba.xxx.XxxService=dubbo://localhost:<span class="number">20890</span></span><br></pre></td></tr></table></figure></li>
<li><p>.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">java</span> <span class="string">-Ddubbo.resolve.file=xxx.properties</span></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">com.alibaba.xxx.XxxService</span>=<span class="string">dubbo://localhost:20890</span></span><br></pre></td></tr></table></figure>

<h4 id="19-集群容错几种方法？"><a href="#19-集群容错几种方法？" class="headerlink" title="19.集群容错几种方法？"></a>19.集群容错几种方法？</h4><p><img src="https://gitee.com/yizhibuerdai/Imagetools/raw/master/images/image-20200423121735540.png" alt="image-20200423121735540"></p>
<h4 id="20-Dubbo有几种配置方式？"><a href="#20-Dubbo有几种配置方式？" class="headerlink" title="20.Dubbo有几种配置方式？"></a>20.Dubbo有几种配置方式？</h4><ol>
<li>Spring</li>
<li>Java API </li>
</ol>
<h4 id="21-Dubbo有哪些协议？推荐？"><a href="#21-Dubbo有哪些协议？推荐？" class="headerlink" title="21.Dubbo有哪些协议？推荐？"></a>21.Dubbo有哪些协议？推荐？</h4><ul>
<li> dubbo://(推荐)</li>
<li> rmi://</li>
<li> hessian://</li>
<li> http://</li>
<li> webservice://</li>
<li> thrift://</li>
<li> memcached://</li>
<li> redis://</li>
<li> rest://</li>
</ul>
<h4 id="22-Dubbo使用什么通信框架"><a href="#22-Dubbo使用什么通信框架" class="headerlink" title="22.Dubbo使用什么通信框架?"></a>22.Dubbo使用什么通信框架?</h4><p>dubbo使用netty。</p>
<h4 id="23-dubbo协议默认端口号？http协议默认端口？hessian-rmi"><a href="#23-dubbo协议默认端口号？http协议默认端口？hessian-rmi" class="headerlink" title="23.dubbo协议默认端口号？http协议默认端口？hessian?rmi?"></a>23.dubbo协议默认端口号？http协议默认端口？hessian?rmi?</h4><ul>
<li>dubbo:20880</li>
<li>http:80</li>
<li>hessian:80</li>
<li>rmi:80</li>
</ul>
<h4 id="24-Dubbo默认序列化框架-其他的你还知道？"><a href="#24-Dubbo默认序列化框架-其他的你还知道？" class="headerlink" title="24.Dubbo默认序列化框架?其他的你还知道？"></a>24.Dubbo默认序列化框架?其他的你还知道？</h4><ul>
<li>dubbo协议缺省为hessian2</li>
<li>rmi协议缺省为java</li>
<li>http协议缺省为json</li>
</ul>
<h4 id="25-一个服务有多重实现时，如何处理？"><a href="#25-一个服务有多重实现时，如何处理？" class="headerlink" title="25.一个服务有多重实现时，如何处理？"></a>25.一个服务有多重实现时，如何处理？</h4><p>可以用group分组，服务提供方和消费放都指定同一个group。</p>
<h4 id="26-Dubbo服务调用默认是阻塞的？还有其他的？"><a href="#26-Dubbo服务调用默认是阻塞的？还有其他的？" class="headerlink" title="26.Dubbo服务调用默认是阻塞的？还有其他的？"></a>26.Dubbo服务调用默认是阻塞的？还有其他的？</h4><p>默认是同步等待结果阻塞的，同时也支持异步调用。</p>
<p>Dubbo 是基于 NIO 的非阻塞实现并行调用，客户端不需要启动多线程即可完成并行调用多个远程服务，相对多线程开销较小，异步调用会返回一个 Future 对象。</p>
<h4 id="27-Dubbo服务追踪解决方案"><a href="#27-Dubbo服务追踪解决方案" class="headerlink" title="27.Dubbo服务追踪解决方案?"></a>27.Dubbo服务追踪解决方案?</h4><ul>
<li>Zipkin  </li>
<li>Pinpoint</li>
<li>SkyWalking</li>
</ul>
<h4 id="28-Dubbo不维护了吗？Dubbo和Dubbox有什么区别？"><a href="#28-Dubbo不维护了吗？Dubbo和Dubbox有什么区别？" class="headerlink" title="28.Dubbo不维护了吗？Dubbo和Dubbox有什么区别？"></a>28.Dubbo不维护了吗？Dubbo和Dubbox有什么区别？</h4><p>现在进入了Apache,由apache维护。</p>
<p>Dubbox是当当的扩展项目。</p>
<h4 id="29-Dubbox有什么新功能？"><a href="#29-Dubbox有什么新功能？" class="headerlink" title="29.Dubbox有什么新功能？"></a>29.Dubbox有什么新功能？</h4><ul>
<li><p>支持REST风格远程调用（HTTP + JSON/XML)</p>
</li>
<li><p>支持基于Kryo和FST的Java高效序列化实现</p>
</li>
<li><p>支持基于嵌入式Tomcat的HTTP remoting体系</p>
</li>
<li><p>升级Spring</p>
</li>
<li><p>升级ZooKeeper客户端</p>
</li>
</ul>
<h4 id="30-io线程池大小默认？"><a href="#30-io线程池大小默认？" class="headerlink" title="30.io线程池大小默认？"></a>30.io线程池大小默认？</h4><p>cpu个数 + 1</p>
<h4 id="31-dubbo-协议适合什么样的服务调用？"><a href="#31-dubbo-协议适合什么样的服务调用？" class="headerlink" title="31.dubbo://协议适合什么样的服务调用？"></a>31.dubbo://协议适合什么样的服务调用？</h4><p>采用单一长链接和NIO异步通讯，适用于小数量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。</p>
<p>不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。</p>
<p><img src="https://gitee.com/yizhibuerdai/Imagetools/raw/master/images/image-20200423154308365.png" alt="image-20200423154308365"></p>
<h4 id="32-自动剔除服务什么原理？"><a href="#32-自动剔除服务什么原理？" class="headerlink" title="32.自动剔除服务什么原理？"></a>32.自动剔除服务什么原理？</h4><p>zookeeper临时节点，会话保持原理。</p>
<h4 id="33-从-2-0-5-版本开始，dubbo支持通过x命令来进行服务治理"><a href="#33-从-2-0-5-版本开始，dubbo支持通过x命令来进行服务治理" class="headerlink" title="33.从 2.0.5 版本开始，dubbo支持通过x命令来进行服务治理?"></a>33.从 <code>2.0.5</code> 版本开始，dubbo支持通过x命令来进行服务治理?</h4><p>telnet</p>
<h4 id="34-如何用命令查看服务列表？"><a href="#34-如何用命令查看服务列表？" class="headerlink" title="34.如何用命令查看服务列表？"></a>34.如何用命令查看服务列表？</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">telnet localhost <span class="number">20880</span></span><br></pre></td></tr></table></figure>

<p>进入命令行。然后执行 ls相关命令:</p>
<ul>
<li><code>ls</code>: 显示服务列表</li>
<li><code>ls -l</code>: 显示服务详细信息列表</li>
<li><code>ls XxxService</code>: 显示服务的方法列表</li>
<li><code>ls -l XxxService</code>: 显示服务的方法详细信息列表</li>
</ul>
<h4 id="35-Dubbo框架设计是怎样的？"><a href="#35-Dubbo框架设计是怎样的？" class="headerlink" title="35.Dubbo框架设计是怎样的？"></a>35.Dubbo框架设计是怎样的？</h4><p><img src="https://gitee.com/yizhibuerdai/Imagetools/raw/master/images/image-20200423162348971.png" alt="image-20200423162348971"></p>
<p>各层说明:</p>
<ul>
<li><strong>config 配置层</strong>：对外配置接口，以 <code>ServiceConfig</code>, <code>ReferenceConfig</code> 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类</li>
<li><strong>proxy 服务代理层</strong>：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 <code>ServiceProxy</code> 为中心，扩展接口为 <code>ProxyFactory</code></li>
<li><strong>registry 注册中心层</strong>：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 <code>RegistryFactory</code>, <code>Registry</code>, <code>RegistryService</code></li>
<li><strong>cluster 路由层</strong>：封装多个提供者的路由及负载均衡，并桥接注册中心，以 <code>Invoker</code> 为中心，扩展接口为 <code>Cluster</code>, <code>Directory</code>, <code>Router</code>, <code>LoadBalance</code></li>
<li><strong>monitor 监控层</strong>：RPC 调用次数和调用时间监控，以 <code>Statistics</code> 为中心，扩展接口为 <code>MonitorFactory</code>, <code>Monitor</code>, <code>MonitorService</code></li>
<li><strong>protocol 远程调用层</strong>：封装 RPC 调用，以 <code>Invocation</code>, <code>Result</code> 为中心，扩展接口为 <code>Protocol</code>, <code>Invoker</code>, <code>Exporter</code></li>
<li><strong>exchange 信息交换层</strong>：封装请求响应模式，同步转异步，以 <code>Request</code>, <code>Response</code> 为中心，扩展接口为 <code>Exchanger</code>, <code>ExchangeChannel</code>, <code>ExchangeClient</code>, <code>ExchangeServer</code></li>
<li><strong>transport 网络传输层</strong>：抽象 mina 和 netty 为统一接口，以 <code>Message</code> 为中心，扩展接口为 <code>Channel</code>, <code>Transporter</code>, <code>Client</code>, <code>Server</code>, <code>Codec</code></li>
<li><strong>serialize 数据序列化层</strong>：可复用的一些工具，扩展接口为 <code>Serialization</code>, <code>ObjectInput</code>, <code>ObjectOutput</code>, <code>ThreadPool</code></li>
</ul>
<h4 id="36-你读过Dubbo的源码吗？"><a href="#36-你读过Dubbo的源码吗？" class="headerlink" title="36.你读过Dubbo的源码吗？"></a>36.你读过Dubbo的源码吗？</h4><p>这个问题其实面试中如果问dubbo的话，基本就会带这个问题。有时间的话，大家可以下载源码，读一读，如果大家有兴趣的话，我会出后续文章。</p>
<p>参考：<a href="http://dubbo.apache.org/en-us/">http://dubbo.apache.org/en-us/</a></p>
<p><img src="https://gitee.com/yizhibuerdai/Imagetools/raw/master/images/common1.png" alt="WechatIMG360"></p>
]]></content>
      <categories>
        <category>Middleware</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>Class文件的组成结构</title>
    <url>/2023/03/01/Class%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="Class-文件的组成结构"><a href="#Class-文件的组成结构" class="headerlink" title="Class 文件的组成结构"></a>Class 文件的组成结构</h1><p>Class 文件是一组以 8 位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在 Class 文件中，中间没有任何分隔符。Java 虚拟机规范规定 Class 文件采用一种类似 C 语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表，我们之后也主要对这两种类型的数据类型进行解析。</p>
<ul>
<li><strong>无符号数：</strong> 无符号数属于基本数据类型，以 u1、u2、u4、u8 分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数，可以用它来描述数字、索引引用、数量值或 utf-8 编码的字符串值。</li>
<li><strong>表：</strong> 表是由多个无符号数或其他表为数据项构成的复合数据类型，名称上都以 <code>_info</code> 结尾。</li>
</ul>
<h2 id="Class-文件的头-8-个字节"><a href="#Class-文件的头-8-个字节" class="headerlink" title="Class 文件的头 8 个字节"></a>Class 文件的头 8 个字节</h2><p>Class 文件的头 8 个字节是魔数和版本号，其中头 4 个字节是魔数，也就是 <code>0xCAFEBABE</code>，它可以用来确定这个文件是否为一个能被虚拟机接受的 Class 文件（这通过扩展名来识别文件类型要安全，毕竟扩展名是可以随便修改的）。</p>
<p>后 4 个字节则是当前 Class 文件的版本号，其中第 5、6 个字节是次版本号，第 7、8 个字节是主版本号。</p>
<h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>从第 9 个字节开始，就是常量池的入口，常量池是 Class 文件中：</p>
<ul>
<li>与其他项目关联最多的的数据类型；</li>
<li>占用 Class 文件空间最大的数据项目；</li>
<li>Class 文件中第一个出现的表类型数据项目。</li>
</ul>
<p>常量池的开始的两个字节，也就是第 9、10 个字节，放置一个 u2 类型的数据，标识常量池中常量的数量 cpc (constant_pool_count)，这个计数值有一个十分特殊的地方，就是它是从 1 开始而不是从 0 开始的，也就是说如果 cpc = 22，那么代表常量池中有 21 项常量，索引值为 1 ~ 21，第 0 项常量被空出来，为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”时，将让这个索引值指向 0 即可。</p>
<p>常量池中记录的是代码出现过的所有 token（类名，成员变量名等，也是我们接下来要修改的地方）以及符号引用（方法引用，成员变量引用等），主要包括以下两大类常量：</p>
<ul>
<li><strong>字面量：</strong> 接近于 Java 语言层面的常量概念，包括<ul>
<li>文本字符串</li>
<li>声明为 final 的常量值</li>
</ul>
</li>
<li><strong>符号引用：</strong> 以一组符号来描述所引用的目标，包括<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
</li>
</ul>
<p>常量池中的每一项常量都通过一个表来存储。目前一共有 14 种常量，不过麻烦的地方就在于，这 14 种常量类型每一种都有自己的结构，我们在这里只详细介绍两种：CONSTANT_Class_info 和 CONSTANT_Utf8_info。</p>
<p>CONSTANT_Class_info 的存储结构为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">... [ tag=<span class="number">7</span> ] [ name_index ] ...</span><br><span class="line">... [  <span class="number">1</span>位  ] [     <span class="number">2</span>位    ] ...</span><br></pre></td></tr></table></figure>

<p>其中，tag 是标志位，用来区分常量类型的，tag = 7 就表示接下来的这个表是一个 CONSTANT_Class_info，name_index 是一个索引值，指向常量池中的一个 CONSTANT_Utf8_info 类型的常量所在的索引值，CONSTANT_Utf8_info 类型常量一般被用来描述类的全限定名、方法名和字段名。它的存储结构如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">... [ tag=<span class="number">1</span> ] [ 当前常量的长度 len ] [ 常量的符号引用的字符串值 ] ...</span><br><span class="line">... [  <span class="number">1</span>位  ] [        <span class="number">2</span>位        ] [         len位         ] ...</span><br></pre></td></tr></table></figure>

<p>后面还没看，先简单介绍到这里……</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Git必知必会</title>
    <url>/2023/12/15/Git/</url>
    <content><![CDATA[<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h4 id="1-什么是Git？"><a href="#1-什么是Git？" class="headerlink" title="1.什么是Git？"></a>1.什么是Git？</h4><p>我建议你先通过了解 git 的架构再来回答这个问题，如下图所示，试着解释一下这个图：</p>
<ul>
<li>Git 是分布式版本控制系统（DVCS）。它可以跟踪文件的更改，并允许你恢复到任何特定版本的更改。</li>
<li>与 SVN 等其他版本控制系统（VCS）相比，其分布式架构具有许多优势，一个主要优点是它不依赖于中央服务器来存储项目文件的所有版本。</li>
<li>每个开发人员都可以“克隆”我在图中用“Local repository”标注的存储库的副本，并且在他的硬盘驱动器上具有项目的完整历史记录，因此当服务器中断时，你需要的所有恢复数据都在你队友的本地 Git 存储库中。</li>
<li>还有一个中央云存储库，开发人员可以向其提交更改，并与其他团队成员进行共享，如图所示，所有协作者都在提交更改“远程存储库”。</li>
</ul>
<h4 id="2-Git-工作流程"><a href="#2-Git-工作流程" class="headerlink" title="2.Git 工作流程"></a>2.Git 工作流程</h4><p>本章节我们将为大家介绍 Git 的工作流程。</p>
<p>一般工作流程如下：</p>
<ul>
<li>克隆 Git 资源作为工作目录。</li>
<li>在克隆的资源上添加或修改文件。</li>
<li>如果其他人修改了，你可以更新资源。</li>
<li>在提交前查看修改。</li>
<li>提交修改。</li>
<li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。</li>
</ul>
<p>下图展示了 Git 的工作流程：</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2015/02/git-process.png" alt="img"></p>
<h4 id="3-在-Git-中提交的命令是什么？"><a href="#3-在-Git-中提交的命令是什么？" class="headerlink" title="3.在 Git 中提交的命令是什么？"></a>3.在 Git 中提交的命令是什么？</h4><p>用于写入提交的命令是 **<code>git commit -a</code>**。</p>
<p>现在解释一下 <code>-a</code> 标志， 通过在命令行上加 <code>-a</code> 指示 git 提交已修改的所有被跟踪文件的新内容。还要提一下，如果你是第一次需要提交新文件，可以在在 <code>git commit -a</code> 之前先 **<code>git add &lt;file&gt;</code>**。</p>
<h4 id="4-什么是-Git-中的“裸存储库”？"><a href="#4-什么是-Git-中的“裸存储库”？" class="headerlink" title="4.什么是 Git 中的“裸存储库”？"></a>4.什么是 Git 中的“裸存储库”？</h4><p>你应该说明 “工作目录” 和 “裸存储库” 之间的区别。</p>
<p>Git 中的 “裸” 存储库只包含版本控制信息而没有工作文件（没有工作树），并且它不包含特殊的 <code>.git</code> 子目录。相反，它直接在主目录本身包含 <code>.git</code> 子目录中的所有内容，其中工作目录包括：</p>
<ol>
<li>一个 <code>.git</code> 子目录，其中包含你的仓库所有相关的 Git 修订历史记录。</li>
<li>工作树，或签出的项目文件的副本。</li>
</ol>
<h4 id="5-Git-是用什么语言编写的？"><a href="#5-Git-是用什么语言编写的？" class="headerlink" title="5.Git 是用什么语言编写的？"></a>5.Git 是用什么语言编写的？</h4><p>你需要说明使用它的原因，而不仅仅是说出语言的名称。我建议你这样回答：</p>
<p>Git使用 C 语言编写。 GIT 很快，C 语言通过减少运行时的开销来做到这一点。</p>
<h4 id="6-在Git中，你如何还原已经-push-并公开的提交？"><a href="#6-在Git中，你如何还原已经-push-并公开的提交？" class="headerlink" title="6.在Git中，你如何还原已经 push 并公开的提交？"></a>6.在Git中，你如何还原已经 push 并公开的提交？</h4><p>There can be two answers to this question and make sure that you include both because any of the below options can be used depending on the situation: 1<br>这个问题可以有两个答案，你回答时也要保包含这两个答案，因为根据具体情况可以使用以下选项：</p>
<ul>
<li>删除或修复新提交中的错误文件，并将其推送到远程存储库。这是修复错误的最自然方式。对文件进行必要的修改后，将其提交到我将使用的远程存储库</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;commit message&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建一个新的提交，撤消在错误提交中所做的所有更改。可以使用命令：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git revert &lt;name of bad commit&gt;</span><br></pre></td></tr></table></figure>



<h4 id="7-git-pull-和-git-fetch-有什么区别？"><a href="#7-git-pull-和-git-fetch-有什么区别？" class="headerlink" title="7.git pull 和 git fetch 有什么区别？"></a>7.git pull 和 git fetch 有什么区别？</h4><p><code>git pull</code> 命令从中央存储库中提取特定分支的新更改或提交，并更新本地存储库中的目标分支。</p>
<p><code>git fetch</code> 也用于相同的目的，但它的工作方式略有不同。当你执行 <code>git fetch</code> 时，它会从所需的分支中提取所有新提交，并将其存储在本地存储库中的新分支中。如果要在目标分支中反映这些更改，必须在 <code>git fetch</code> 之后执行<code>git merge</code>。只有在对目标分支和获取的分支进行合并后才会更新目标分支。为了方便起见，请记住以下等式：</p>
<center><h5>git pull = git fetch + git merge</h5></center>



<h4 id="8-git中的“staging-area”或“index”是什么？"><a href="#8-git中的“staging-area”或“index”是什么？" class="headerlink" title="8.git中的“staging area”或“index”是什么？"></a>8.git中的“staging area”或“index”是什么？</h4><p>For this answer try to explain the below diagram as you can see:<br>可以通过下图进行解释：</p>
<p>在完成提交之前，可以在称为“staging area”或“index”的中间区域中对其进行格式化和审查。从图中可以看出，每个更改首先在暂存区域中进行验证，我将其称为“stage file”，然后将更改提交到存储库。</p>
<p><img src="https://segmentfault.com/img/bVbtc0c?w=655&h=645" alt="clipboard.png"></p>
<h3 id="9-什么是-git-stash"><a href="#9-什么是-git-stash" class="headerlink" title="9.什么是 git stash?"></a>9.什么是 git stash?</h3><p>首先应该解释 git stash 的必要性。</p>
<p>通常情况下，当你一直在处理项目的某一部分时，如果你想要在某个时候切换分支去处理其他事情，事情会处于混乱的状态。问题是，你不想把完成了一半的工作的提交，以便你以后就可以回到当前的工作。解决这个问题的答案是 git stash。</p>
<p>再解释什么是git stash。</p>
<p>stash 会将你的工作目录，即修改后的跟踪文件和暂存的更改保存在一堆未完成的更改中，你可以随时重新应用这些更改。</p>
<h4 id="10-什么是git-stash-drop？"><a href="#10-什么是git-stash-drop？" class="headerlink" title="10.什么是git stash drop？"></a>10.什么是git stash drop？</h4><p>通过说明我们使用 <code>git stash drop</code> 的目的来回答这个问题。</p>
<p><code>git stash drop</code> 命令用于删除隐藏的项目。默认情况下，它将删除最后添加的存储项，如果提供参数的话，它还可以删除特定项。</p>
<p>下面举个例子。</p>
<p>如果要从隐藏项目列表中删除特定的存储项目，可以使用以下命令：</p>
<p><strong>git stash list：</strong>它将显示隐藏项目列表，如：</p>
<p>stash@{0}: WIP on master: 049d078 added the index file<br>stash@{1}: WIP on master: c264051 Revert “added file_size”<br>stash@{2}: WIP on master: 21d80a5 added number to log</p>
<p>如果要删除名为 stash@{0} 的项目，请使用命令 **git stash drop stash@{0}**。</p>
<h4 id="11-如何找到特定提交中已更改的文件列表？"><a href="#11-如何找到特定提交中已更改的文件列表？" class="headerlink" title="11.如何找到特定提交中已更改的文件列表？"></a>11.如何找到特定提交中已更改的文件列表？</h4><p>对于这个问题，不能仅仅是提供命令，还要解释这个命令究竟做了些什么。</p>
<p>要获取特定提交中已更改的列表文件，请使用以下命令：</p>
<p><strong>git diff-tree -r {hash}</strong></p>
<p>给定提交哈希，这将列出在该提交中更改或添加的所有文件。 <code>-r</code> 标志使命令列出单个文件，而不是仅将它们折叠到根目录名称中。</p>
<p>你还可以包括下面提到的内容，虽然它是可选的，但有助于给面试官留下深刻印象。</p>
<p>输出还将包含一些额外信息，可以通过包含两个标志把它们轻松的屏蔽掉：</p>
<p><strong>git diff-tree –no-commit-id –name-only -r {hash}</strong></p>
<p>这里 <code>-no-commit-id</code> 将禁止提交哈希值出现在输出中，而 <code>-name-only</code> 只会打印文件名而不是它们的路径。</p>
<h4 id="12-git-config-的功能是什么？"><a href="#12-git-config-的功能是什么？" class="headerlink" title="12.git config 的功能是什么？"></a>12.git config 的功能是什么？</h4><p>首先说明为什么我们需要 <code>git config</code>。</p>
<p>git 使用你的用户名将提交与身份相关联。 <code>git config</code> 命令可用来更改你的 git 配置，包括你的用户名。</p>
<p>下面用一个例子来解释。</p>
<p>假设你要提供用户名和电子邮件 ID 用来将提交与身份相关联，以便你可以知道是谁进行了特定提交。为此，我将使用：</p>
<p><strong>git config –global user.name “Your Name”:</strong> 此命令将添加用户名。</p>
<p><strong>git config –global user.email “Your E-mail Address”:</strong> 此命令将添加电子邮件ID。</p>
<h4 id="13-提交对象包含什么？"><a href="#13-提交对象包含什么？" class="headerlink" title="13.提交对象包含什么？"></a>13.提交对象包含什么？</h4><p>Commit 对象包含以下组件，你应该提到以下这三点：</p>
<ul>
<li>一组文件，表示给定时间点的项目状态</li>
<li>引用父提交对象</li>
<li>SHAI 名称，一个40个字符的字符串，提交对象的唯一标识。</li>
</ul>
<h4 id="14-Git的工作区域"><a href="#14-Git的工作区域" class="headerlink" title="14.Git的工作区域"></a>14.Git的工作区域</h4><p>对于任何一个文件，在 Git 内都只有三种区域：工作区，暂存区和本地仓库。</p>
<p><code>工作区：表示新增或修改了某个文件，但还没有提交保存；</code></p>
<p><code>暂存区：表示把已新增或修改的文件，放在下次提交时要保存的清单中;</code></p>
<p><code>本地仓库：文件已经被安全地保存在本地仓库中了。</code></p>
<h4 id="15-如果分支是否已合并为master，你可以通过什么手段知道？"><a href="#15-如果分支是否已合并为master，你可以通过什么手段知道？" class="headerlink" title="15.如果分支是否已合并为master，你可以通过什么手段知道？"></a>15.如果分支是否已合并为master，你可以通过什么手段知道？</h4><p>要知道某个分支是否已合并为master，你可以使用以下命令：</p>
<p><code>git branch –merged</code> 它列出了已合并到当前分支的分支。</p>
<p><code>git branch –no-merged</code> 它列出了尚未合并的分支。</p>
<h4 id="16-什么是SubGit？"><a href="#16-什么是SubGit？" class="headerlink" title="16.什么是SubGit？"></a>16.什么是SubGit？</h4><p>SubGit 是将 SVN 到 Git迁移的工具。它创建了一个可写的本地或远程 Subversion 存储库的 Git 镜像，并且只要你愿意，可以随意使用 Subversion 和 Git。</p>
<p>这样做有很多优点，比如你可以从 Subversion 快速一次性导入到 Git 或者在 Atlassian Bitbucket Server 中使用SubGit。我们可以用 SubGit 创建现有 Subversion 存储库的双向 Git-SVN 镜像。你可以在方便时 push 到 Git 或提交 Subversion。同步由 SubGit 完成。</p>
<h4 id="17-如何把本地仓库的内容推向一个空的远程仓库？"><a href="#17-如何把本地仓库的内容推向一个空的远程仓库？" class="headerlink" title="17. 如何把本地仓库的内容推向一个空的远程仓库？"></a>17. 如何把本地仓库的内容推向一个空的远程仓库？</h4><p>首先确保本地仓库与远程之间是连同的。如果提交失败，则需要进行下面的命令进行连通：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin XXXX</span><br></pre></td></tr></table></figure>

<p>注意：XXXX是你的远程仓库地址。 如果是第一次推送，则进行下面命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>注意：-u 是指定origin为默认主分支 之后的提交，只需要下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<h4 id="18-描述一下你所使用的分支策略？"><a href="#18-描述一下你所使用的分支策略？" class="headerlink" title="18.描述一下你所使用的分支策略？"></a>18.描述一下你所使用的分支策略？</h4><p>这个问题被要求用Git来测试你的分支经验，告诉他们你在以前的工作中如何使用分支以及它的用途是什么，你可以参考以下提到的要点：</p>
<ul>
<li><p>功能分支（Feature branching）</p>
<p>要素分支模型将特定要素的所有更改保留在分支内。当通过自动化测试对功能进行全面测试和验证时，该分支将合并到主服务器中。</p>
</li>
<li><p>任务分支（Task branching）</p>
<p>在此模型中，每个任务都在其自己的分支上实现，任务键包含在分支名称中。很容易看出哪个代码实现了哪个任务，只需在分支名称中查找任务键。</p>
</li>
<li><p>发布分支（Release branching）</p>
<p>一旦开发分支获得了足够的发布功能，你就可以克隆该分支来形成发布分支。创建该分支将会启动下一个发布周期，所以在此之后不能再添加任何新功能，只有错误修复，文档生成和其他面向发布的任务应该包含在此分支中。一旦准备好发布，该版本将合并到主服务器并标记版本号。此外，它还应该再将自发布以来已经取得的进展合并回开发分支。</p>
</li>
</ul>
<p>最后告诉他们分支策略因团队而异，所以我知道基本的分支操作，如删除、合并、检查分支等。</p>
<h4 id="19-Git-工作区、暂存区和版本库"><a href="#19-Git-工作区、暂存区和版本库" class="headerlink" title="19.Git 工作区、暂存区和版本库"></a>19.Git 工作区、暂存区和版本库</h4><p>我们先来理解下 Git 工作区、暂存区和版本库概念：</p>
<ul>
<li><strong>工作区：</strong>就是你在电脑里能看到的目录。</li>
<li><strong>暂存区：</strong>英文叫 stage 或 index。一般存放在 <strong>.git</strong> 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。</li>
<li><strong>版本库：</strong>工作区有一个隐藏目录 <strong>.git</strong>，这个不算工作区，而是 Git 的版本库。</li>
</ul>
<p>下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系：</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2015/02/1352126739_7909.jpg" alt="img"></p>
<ul>
<li>图中左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage/index），标记为 “master” 的是 master 分支所代表的目录树。</li>
<li>图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个”游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。</li>
<li>图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下，里面包含了创建的各种对象及内容。</li>
<li>当对工作区修改（或新增）的文件执行 <strong>git add</strong> 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。</li>
<li>当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。</li>
<li>当执行 <strong>git reset HEAD</strong> 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。</li>
<li>当执行 <strong>git rm –cached <file></strong> 命令时，会直接从暂存区删除文件，工作区则不做出改变。</li>
<li>当执行 <strong>git checkout .</strong> 或者 <strong>git checkout – <file></strong> 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。</li>
<li>当执行 <strong>git checkout HEAD .</strong> 或者 <strong>git checkout HEAD <file></strong> 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</li>
</ul>
<h4 id="20-打标签"><a href="#20-打标签" class="headerlink" title="20.打标签"></a>20.打标签</h4><p>   git tag -a 2.27 -m “release version 201606”<br>    git push origin –tags<br>    详解：git tag 是命令<br>        -a 0.1.3是增加 名为0.1.3的标签<br>        -m 后面跟着的是标签的注释    </p>
<pre><code> 打标签的操作发生在我们commit修改到本地仓库之后。完整的例子
    git add .
    git commit -m “fixed some bugs”
    git tag -a 0.1.3 -m “Release version 0.1.3″

分享提交标签到远程服务器上
   git push origin master
   git push origin --tags
   –tags参数表示提交所有tag至服务器端，普通的git push origin master操作不会推送标签到服务器端。

删除标签的命令
    git push origin local_branch:remote_branch
</code></pre>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://segmentfault.com/a/1190000019315509">https://segmentfault.com/a/1190000019315509</a></p>
<p><a href="https://www.runoob.com/git/">https://www.runoob.com/git/</a></p>
<p><a href="https://www.cnblogs.com/rebackl/p/12990881.html">https://www.cnblogs.com/rebackl/p/12990881.html</a></p>
<p><a href="https://blog.csdn.net/junwua/article/details/82906002">https://blog.csdn.net/junwua/article/details/82906002</a></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch必知必会</title>
    <url>/2023/12/30/Elasticsearch/</url>
    <content><![CDATA[<h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><h4 id="1-简单介绍下ES？"><a href="#1-简单介绍下ES？" class="headerlink" title="1.简单介绍下ES？"></a>1.简单介绍下ES？</h4><p>ES是一种存储和管理基于文档和半结构化数据的数据库（搜索引擎）。它提供实时搜索（ES最近几个版本才提供实时搜索，以前都是准实时）和分析结构化、半结构化文档、数据和地理空间信息数据。</p>
<h4 id="2-简单介绍当前可以下载的ES稳定版本？"><a href="#2-简单介绍当前可以下载的ES稳定版本？" class="headerlink" title="2.简单介绍当前可以下载的ES稳定版本？"></a>2.简单介绍当前可以下载的ES稳定版本？</h4><p>最新的稳定版本是7.10.0</p>
<h4 id="3-安装ES前需要安装哪种软件？"><a href="#3-安装ES前需要安装哪种软件？" class="headerlink" title="3.安装ES前需要安装哪种软件？"></a>3.安装ES前需要安装哪种软件？</h4><p>JDK 8或者 Java 1.8.0</p>
<h4 id="4-请介绍启动ES服务的步骤？"><a href="#4-请介绍启动ES服务的步骤？" class="headerlink" title="4.请介绍启动ES服务的步骤？"></a>4.请介绍启动ES服务的步骤？</h4><p><strong>A：</strong>启动步骤如下</p>
<p>Windows下进入ES文件夹的bin目录下，点击ElasticSearch.bat开始运行</p>
<p>打开本地9200端口<a href="http://localhost:9200/">http://localhost:9200</a>, 就可以使用ES了</p>
<h4 id="5-ES中的倒排索引是什么？"><a href="#5-ES中的倒排索引是什么？" class="headerlink" title="5.ES中的倒排索引是什么？"></a>5.ES中的倒排索引是什么？</h4><p>传统的检索方式是通过文章，逐个遍历找到对应关键词的位置。<br>倒排索引，是通过分词策略，形成了词和文章的映射关系表，也称倒排表，这种词典 + 映射表即为<strong>倒排索引</strong>。</p>
<p>其中词典中存储词元，倒排表中存储该词元在哪些文中出现的位置。<br>有了倒排索引，就能实现 O(1) 时间复杂度的效率检索文章了，极大的提高了检索效率。</p>
<p>加分项：<br>倒排索引的底层实现是基于：FST（Finite State Transducer）数据结构。</p>
<p>Lucene 从 4+ 版本后开始大量使用的数据结构是 FST。FST 有两个优点：<br>1）空间占用小。通过对词典中单词前缀和后缀的重复利用，压缩了存储空间；<br>2）查询速度快。O(len(str)) 的查询时间复杂度。</p>
<h4 id="6-ES是如何实现master选举的？"><a href="#6-ES是如何实现master选举的？" class="headerlink" title="6. ES是如何实现master选举的？"></a>6. ES是如何实现master选举的？</h4><p>前置条件：<br>1）只有是候选主节点（master：true）的节点才能成为主节点。<br>2）最小主节点数（min_master_nodes）的目的是防止脑裂。</p>
<p>Elasticsearch 的选主是 ZenDiscovery 模块负责的，主要包含 Ping（节点之间通过这个RPC来发现彼此）和 Unicast（单播模块包含一个主机列表以控制哪些节点需要 ping 通）这两部分；<br>获取主节点的核心入口为 findMaster，选择主节点成功返回对应 Master，否则返回 null。</p>
<p>选举流程大致描述如下：<br>第一步：确认候选主节点数达标，elasticsearch.yml 设置的值 discovery.zen.minimum_master_nodes;<br>第二步：对所有候选主节点根据nodeId字典排序，每次选举每个节点都把自己所知道节点排一次序，然后选出第一个（第0位）节点，暂且认为它是master节点。<br>第三步：如果对某个节点的投票数达到一定的值（候选主节点数n/2+1）并且该节点自己也选举自己，那这个节点就是master。否则重新选举一直到满足上述条件。</p>
<ul>
<li>补充：<ul>
<li>这里的 id 为 string 类型。</li>
<li>master 节点的职责主要包括集群、节点和索引的管理，不负责文档级别的管理；data 节点可以关闭 http 功能。</li>
</ul>
</li>
</ul>
<h4 id="7-如何解决ES集群的脑裂问题"><a href="#7-如何解决ES集群的脑裂问题" class="headerlink" title="7. 如何解决ES集群的脑裂问题"></a>7. 如何解决ES集群的脑裂问题</h4><p>所谓集群脑裂，是指 Elasticsearch 集群中的节点（比如共 20 个），其中的 10 个选了一个 master，另外 10 个选了另一个 master 的情况。</p>
<p>当集群 master 候选数量不小于 3 个时，可以通过设置最少投票通过数量（discovery.zen.minimum_master_nodes）超过所有候选节点一半以上来解决脑裂问题；<br>当候选数量为两个时，只能修改为唯一的一个 master 候选，其他作为 data 节点，避免脑裂问题。</p>
<h4 id="8-详细描述一下ES索引文档的过程？"><a href="#8-详细描述一下ES索引文档的过程？" class="headerlink" title="8. 详细描述一下ES索引文档的过程？"></a>8. 详细描述一下ES索引文档的过程？</h4><p>这里的索引文档应该理解为文档写入 ES，创建索引的过程。</p>
<p>第一步：客户端向集群某节点写入数据，发送请求。（如果没有指定路由/协调节点，请求的节点扮演协调节点的角色。）<br>第二步：协调节点接受到请求后，默认使用文档 ID 参与计算（也支持通过 routing），得到该文档属于哪个分片。随后请求会被转到另外的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bash# 路由算法：根据文档id或路由计算目标的分片id</span><br><span class="line">shard = hash(document_id) % (num_of_primary_shards)</span><br></pre></td></tr></table></figure>

<p>第三步：当分片所在的节点接收到来自协调节点的请求后，会将请求写入到 Memory Buffer，然后定时（默认是每隔 1 秒）写入到F ilesystem Cache，这个从 Momery Buffer 到 Filesystem Cache 的过程就叫做 refresh；<br>第四步：当然在某些情况下，存在 Memery Buffer 和 Filesystem Cache 的数据可能会丢失，ES 是通过 translog 的机制来保证数据的可靠性的。其实现机制是接收到请求后，同时也会写入到 translog 中，当 Filesystem cache 中的数据写入到磁盘中时，才会清除掉，这个过程叫做 flush；<br>第五步：在 flush 过程中，内存中的缓冲将被清除，内容被写入一个新段，段的 fsync 将创建一个新的提交点，并将内容刷新到磁盘，旧的 translog 将被删除并开始一个新的 translog。<br>第六步：flush 触发的时机是定时触发（默认 30 分钟）或者 translog 变得太大（默认为 512 M）时。</p>
<p><img src="https://www.wenyuanblog.com/medias/blogimages/elasticsearch_index_process.jpg" alt="elasticsearch_index_process.jpg"></p>
<ul>
<li>补充：关于 Lucene 的 Segement<ul>
<li>Lucene 索引是由多个段组成，段本身是一个功能齐全的倒排索引。</li>
<li>段是不可变的，允许 Lucene 将新的文档增量地添加到索引中，而不用从头重建索引。</li>
<li>对于每一个搜索请求而言，索引中的所有段都会被搜索，并且每个段会消耗 CPU 的时钟周、文件句柄和内存。这意味着段的数量越多，搜索性能会越低。</li>
<li>为了解决这个问题，Elasticsearch 会合并小段到一个较大的段，提交新的合并段到磁盘，并删除那些旧的小段。（段合并）</li>
</ul>
</li>
</ul>
<h4 id="9-详细描述一下ES更新和删除文档的过程？"><a href="#9-详细描述一下ES更新和删除文档的过程？" class="headerlink" title="9. 详细描述一下ES更新和删除文档的过程？"></a>9. 详细描述一下ES更新和删除文档的过程？</h4><p>删除和更新也都是写操作，但是 Elasticsearch 中的文档是不可变的，因此不能被删除或者改动以展示其变更。</p>
<p>磁盘上的每个段都有一个相应的 .del 文件。当删除请求发送后，文档并没有真的被删除，而是在 .del 文件中被标记为删除。该文档依然能匹配查询，但是会在结果中被过滤掉。当段合并时，在 .del 文件中被标记为删除的文档将不会被写入新段。</p>
<p>在新的文档被创建时，Elasticsearch 会为该文档指定一个版本号，当执行更新时，旧版本的文档在 .del 文件中被标记为删除，新版本的文档被索引到一个新段。旧版本的文档依然能匹配查询，但是会在结果中被过滤掉。</p>
<h4 id="10-详细描述一下ES搜索的过程？"><a href="#10-详细描述一下ES搜索的过程？" class="headerlink" title="10. 详细描述一下ES搜索的过程？"></a>10. 详细描述一下ES搜索的过程？</h4><p>搜索被执行成一个两阶段过程，即 Query Then Fetch；<br>Query阶段：<br>查询会广播到索引中每一个分片拷贝（主分片或者副本分片）。每个分片在本地执行搜索并构建一个匹配文档的大小为 from + size 的优先队列。PS：在搜索的时候是会查询Filesystem Cache的，但是有部分数据还在Memory Buffer，所以搜索是近实时的。<br>每个分片返回各自优先队列中 <strong>所有文档的 ID 和排序值</strong> 给协调节点，它合并这些值到自己的优先队列中来产生一个全局排序后的结果列表。<br>Fetch阶段：<br>协调节点辨别出哪些文档需要被取回并向相关的分片提交多个 GET 请求。每个分片加载并 丰富 文档，如果有需要的话，接着返回文档给协调节点。一旦所有的文档都被取回了，协调节点返回结果给客户端。</p>
<h4 id="11-索引是什么"><a href="#11-索引是什么" class="headerlink" title="11.索引是什么?"></a>11.索引是什么?</h4><p>ES集群包含多个索引，每个索引包含一种表，表包含多个文档，并且每个文档包含不同的属性。</p>
<h4 id="12-请解释什么是分片-SHARDs"><a href="#12-请解释什么是分片-SHARDs" class="headerlink" title="12.请解释什么是分片(SHARDs)?"></a>12.请解释什么是分片(SHARDs)?</h4><p>随着索引文件的增加，磁盘容量、处理能力都会变得不够，在这种情况下，将索引数据切分成小段，这就叫分片(SHARDS)。它的出现大大改进了数据查询的效率。</p>
<h4 id="13-什么是副本-REPLICA-他的作用是什么？"><a href="#13-什么是副本-REPLICA-他的作用是什么？" class="headerlink" title="13.什么是副本(REPLICA), 他的作用是什么？"></a>13.什么是副本(REPLICA), 他的作用是什么？</h4><p>副本是分片的完整拷贝，副本的作用是增加了查询的吞吐率和在极端负载情况下获得高可用的能力。副本有效的帮助处理用户请求。</p>
<h4 id="14-在ES集群中增加和创建索引的步骤是什么？"><a href="#14-在ES集群中增加和创建索引的步骤是什么？" class="headerlink" title="14.在ES集群中增加和创建索引的步骤是什么？"></a>14.在ES集群中增加和创建索引的步骤是什么？</h4><p>可以在Kibana中配置新的索引，进行Fields Mapping，设置索引别名。也可以通过HTTP请求来创建索引。</p>
<h4 id="15-ES支持哪些类型的查询？"><a href="#15-ES支持哪些类型的查询？" class="headerlink" title="15.ES支持哪些类型的查询？"></a>15.ES支持哪些类型的查询？</h4><p>主要分为匹配（文本）查询和基于Term的查询。</p>
<p>文本查询包括基本匹配，match phrase, multi-match, match phrase prefix, common terms, query-string, simple query string.</p>
<p>Term查询，比如term exists, type, term set, range, prefix, ids, wildcard, regexp, and fuzzy。</p>
<h4 id="16-Elasticsearch在部署时，对Linux的设置有哪些优化方法"><a href="#16-Elasticsearch在部署时，对Linux的设置有哪些优化方法" class="headerlink" title="16.Elasticsearch在部署时，对Linux的设置有哪些优化方法"></a>16.Elasticsearch在部署时，对Linux的设置有哪些优化方法</h4><p><code>面试官</code>：想了解对ES集群的运维能力。 <code>解答</code>：</p>
<ul>
<li>1）关闭缓存swap;</li>
<li>2）堆内存设置为：Min（节点内存/2, 32GB）;</li>
<li>3)设置最大文件句柄数；</li>
<li>4）线程池+队列大小根据业务需要做调整；</li>
<li>5）磁盘存储raid方式——存储有条件使用RAID10，增加单节点性能以及避免单节点存储故障。</li>
</ul>
<h4 id="17-什么是ElasticSearch中的编译器？"><a href="#17-什么是ElasticSearch中的编译器？" class="headerlink" title="17.什么是ElasticSearch中的编译器？"></a>17.什么是ElasticSearch中的编译器？</h4><p>编译器用于将字符串分解为术语或标记流。一个简单的编译器可能会将字符串拆分为任何遇到空格或标点的地方。Elasticsearch有许多内置标记器，可用于构建自定义分析器。</p>
<h4 id="18-拼写纠错是如何实现的？"><a href="#18-拼写纠错是如何实现的？" class="headerlink" title="18.拼写纠错是如何实现的？"></a>18.拼写纠错是如何实现的？</h4><p>1、拼写纠错是基于编辑距离来实现；编辑距离是一种标准的方法，它用来表示经过插入、删除和替换操作从一个字符串转换到另外一个字符串的最小操作步数；</p>
<p>2、编辑距离的计算过程：比如要计算 batyu 和 beauty 的编辑距离，先创建一个7×8 的表（batyu 长度为 5，coffee 长度为 6，各加 2），接着，在如下位置填入黑色数字。其他格的计算过程是取以下三个值的最小值：</p>
<p>如果最上方的字符等于最左方的字符，则为左上方的数字。否则为左上方的数字+1。（对于 3,3 来说为 0）</p>
<p>左方数字+1（对于 3,3 格来说为 2）</p>
<p>上方数字+1（对于 3,3 格来说为 2）</p>
<p>最终取右下角的值即为编辑距离的值 3。</p>
<p><img src="http://res.mianshigee.com/upload/article/20200307/v2-1f5084b94e47d417b3cebd615ef04647_1440w.jpg" alt="img"></p>
<p>对于拼写纠错，我们考虑构造一个度量空间（Metric Space），该空间内任何关</p>
<p>系满足以下三条基本条件：</p>
<p>d(x,y) = 0 – 假如 x 与 y 的距离为 0，则 x=y</p>
<p>d(x,y) = d(y,x) – x 到 y 的距离等同于 y 到 x 的距离</p>
<p>d(x,y) + d(y,z) &gt;= d(x,z) – 三角不等式</p>
<p>1、根据三角不等式，则满足与 query 距离在 n 范围内的另一个字符转 B，其与 A</p>
<p>的距离最大为 d+n，最小为 d-n。</p>
<p>2、BK 树的构造就过程如下：每个节点有任意个子节点，每条边有个值表示编辑距离。所有子节点到父节点的边上标注 n 表示编辑距离恰好为 n。比如，我们有棵树父节点是”book”和两个子节点”cake”和”books”，”book”到”books”的边标号 1，”book”到”cake”的边上标号 4。从字典里构造好树后，无论何</p>
<p>时你想插入新单词时，计算该单词与根节点的编辑距离，并且查找数值为d(neweord, root)的边。递归得与各子节点进行比较，直到没有子节点，你就可以创建新的子节点并将新单词保存在那。比如，插入”boo”到刚才上述例子的树中，我们先检查根节点，查找 d(“book”, “boo”) = 1 的边，然后检查标号为1 的边的子节点，得到单词”books”。我们再计算距离 d(“books”, “boo”)=2，则将新单词插在”books”之后，边标号为 2。</p>
<p>3、查询相似词如下：计算单词与根节点的编辑距离 d，然后递归查找每个子节点标号为 d-n 到 d+n（包含）的边。假如被检查的节点与搜索单词的距离 d 小于 n，则返回该节点并继续查询。比如输入 cape 且最大容忍距离为 1，则先计算和根的编辑距离 d(“book”, “cape”)=4，然后接着找和根节点之间编辑距离为 3 到5 的，这</p>
<p>个就找到了 cake 这个节点，计算 d(“cake”, “cape”)=1，满足条件所以返回 <strong>cake</strong>，然后再找和 cake 节点编辑距离是 0 到 2 的，分别找到 cape 和cart 节点，这样就得到 <strong>cape</strong> 这个满足条件的结果。</p>
<p><img src="http://res.mianshigee.com/upload/article/20200307/v2-d5426155b3c3c0a7e49123954f96e347_1440w.jpg" alt="img"></p>
<h4 id="19-ElasticSearch中的分析器是什么？"><a href="#19-ElasticSearch中的分析器是什么？" class="headerlink" title="19.ElasticSearch中的分析器是什么？"></a>19.ElasticSearch中的分析器是什么？</h4><p>在ElasticSearch中索引数据时，数据由为索引定义的Analyzer在内部进行转换。 分析器由一个Tokenizer和零个或多个TokenFilter组成。编译器可以在一个或多个CharFilter之前。分析模块允许您在逻辑名称下注册分析器，然后可以在映射定义或某些API中引用它们。</p>
<p>Elasticsearch附带了许多可以随时使用的预建分析器。或者，您可以组合内置的字符过滤器，编译器和过滤器器来创建自定义分析器。</p>
<h4 id="20-是否了解字典树？"><a href="#20-是否了解字典树？" class="headerlink" title="20.是否了解字典树？"></a>20.是否了解字典树？</h4><p>常用字典数据结构如下所示：</p>
<p><img src="http://res.mianshigee.com/upload/article/20200307/v2-aa1a57bbbcbbf04ef089d6681d662ffe_1440w.jpg" alt="img"></p>
<p>Trie 的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。它有 3 个基本性质：</p>
<p>1、根节点不包含字符，除根节点外每一个节点都只包含一个字符。</p>
<p>2、从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</p>
<p>3、每个节点的所有子节点包含的字符都不相同。</p>
<p><img src="http://res.mianshigee.com/upload/article/20200307/v2-df4c8cd2e2b1dad444a50bab3f6d9bb2_1440w.jpg" alt="img"></p>
<p>1、可以看到，trie 树每一层的节点数是 26^i 级别的。所以为了节省空间，我们还可以用动态链表，或者用数组来模拟动态。而空间的花费，不会超过单词数×单词长度。</p>
<p>2、实现：对每个结点开一个字母集大小的数组，每个结点挂一个链表，使用左儿子右兄弟表示法记录这棵树；</p>
<p>3、对于中文的字典树，每个节点的子节点用一个哈希表存储，这样就不用浪费太大的空间，而且查询速度上可以保留哈希的复杂度 O(1)。</p>
<h4 id="21-在并发情况下，ES如果保证读写一致？"><a href="#21-在并发情况下，ES如果保证读写一致？" class="headerlink" title="21. 在并发情况下，ES如果保证读写一致？"></a>21. 在并发情况下，ES如果保证读写一致？</h4><p>可以通过版本号使用乐观并发控制，以确保新版本不会被旧版本覆盖，由应用层来处理具体的冲突；<br>另外对于写操作，一致性级别支持quorum/one/all，默认为quorum，即只有当大多数分片可用时才允许写操作。但即使大多数可用，也可能存在因为网络等原因导致写入副本失败，这样该副本被认为故障，分片将会在一个不同的节点上重建。<br>对于读操作，可以设置replication为sync(默认)，这使得操作在主分片和副本分片都完成后才会返回；如果设置replication为async时，也可以通过设置搜索请求参数_preference为primary来查询主分片，确保文档是最新版本。</p>
<h4 id="22-ES对于大数据量（上亿量级）的聚合如何实现？"><a href="#22-ES对于大数据量（上亿量级）的聚合如何实现？" class="headerlink" title="22. ES对于大数据量（上亿量级）的聚合如何实现？"></a>22. ES对于大数据量（上亿量级）的聚合如何实现？</h4><p>Elasticsearch 提供的首个近似聚合是cardinality 度量。它提供一个字段的基数，即该字段的distinct或者unique值的数目。它是基于HLL算法的。HLL 会先对我们的输入作哈希运算，然后根据哈希运算的结果中的 bits 做概率估算从而得到基数。其特点是：可配置的精度，用来控制内存的使用（更精确 ＝ 更多内存）；小的数据集精度是非常高的；我们可以通过配置参数，来设置去重需要的固定内存使用量。无论数千还是数十亿的唯一值，内存使用量只与你配置的精确度相关。</p>
<h4 id="23-对于GC方面，在使用ES时要注意什么？"><a href="#23-对于GC方面，在使用ES时要注意什么？" class="headerlink" title="23. 对于GC方面，在使用ES时要注意什么？"></a>23. 对于GC方面，在使用ES时要注意什么？</h4><p>1）倒排词典的索引需要常驻内存，无法GC，需要监控data node上segment memory增长趋势。<br>2）各类缓存，field cache, filter cache, indexing cache, bulk queue等等，要设置合理的大小，并且要应该根据最坏的情况来看heap是否够用，也就是各类缓存全部占满的时候，还有heap空间可以分配给其他任务吗？避免采用clear cache等“自欺欺人”的方式来释放内存。<br>3）避免返回大量结果集的搜索与聚合。确实需要大量拉取数据的场景，可以采用scan &amp; scroll api来实现。<br>4）cluster stats驻留内存并无法水平扩展，超大规模集群可以考虑分拆成多个集群通过tribe node连接。<br>5）想知道heap够不够，必须结合实际应用场景，并对集群的heap使用情况做持续的监控。</p>
<h4 id="24-说说你们公司ES的集群架构，索引数据大小，分片有多少，以及一些调优手段？"><a href="#24-说说你们公司ES的集群架构，索引数据大小，分片有多少，以及一些调优手段？" class="headerlink" title="24. 说说你们公司ES的集群架构，索引数据大小，分片有多少，以及一些调优手段？"></a>24. 说说你们公司ES的集群架构，索引数据大小，分片有多少，以及一些调优手段？</h4><p>根据实际情况回答即可，如果是我的话会这么回答：<br>我司有多个ES集群，下面列举其中一个。该集群有20个节点，根据数据类型和日期分库，每个索引根据数据量分片，比如日均1亿+数据的，控制单索引大小在200GB以内。　<br>下面重点列举一些调优策略，仅是我做过的，不一定全面，如有其它建议或者补充欢迎留言。<br>部署层面：<br>1）最好是64GB内存的物理机器，但实际上32GB和16GB机器用的比较多，但绝对不能少于8G，除非数据量特别少，这点需要和客户方面沟通并合理说服对方。<br>2）多个内核提供的额外并发远胜过稍微快一点点的时钟频率。<br>3）尽量使用SSD，因为查询和索引性能将会得到显著提升。<br>4）避免集群跨越大的地理距离，一般一个集群的所有节点位于一个数据中心中。<br>5）设置堆内存：节点内存/2，不要超过32GB。一般来说设置export ES_HEAP_SIZE=32g环境变量，比直接写-Xmx32g -Xms32g更好一点。<br>6）关闭缓存swap。内存交换到磁盘对服务器性能来说是致命的。如果内存交换到磁盘上，一个100微秒的操作可能变成10毫秒。 再想想那么多10微秒的操作时延累加起来。不难看出swapping对于性能是多么可怕。<br>7）增加文件描述符，设置一个很大的值，如65535。Lucene使用了大量的文件，同时，Elasticsearch在节点和HTTP客户端之间进行通信也使用了大量的套接字。所有这一切都需要足够的文件描述符。<br>8）不要随意修改垃圾回收器（CMS）和各个线程池的大小。<br>9）通过设置gateway.recover_after_nodes、gateway.expected_nodes、gateway.recover_after_time可以在集群重启的时候避免过多的分片交换，这可能会让数据恢复从数个小时缩短为几秒钟。<br>索引层面：<br>1）使用批量请求并调整其大小：每次批量数据 5–15 MB 大是个不错的起始点。<br>2）段合并：Elasticsearch默认值是20MB/s，对机械磁盘应该是个不错的设置。如果你用的是SSD，可以考虑提高到100-200MB/s。如果你在做批量导入，完全不在意搜索，你可以彻底关掉合并限流。另外还可以增加 index.translog.flush_threshold_size 设置，从默认的512MB到更大一些的值，比如1GB，这可以在一次清空触发的时候在事务日志里积累出更大的段。<br>3）如果你的搜索结果不需要近实时的准确度，考虑把每个索引的index.refresh_interval 改到30s。<br>4）如果你在做大批量导入，考虑通过设置index.number_of_replicas: 0 关闭副本。<br>5）需要大量拉取数据的场景，可以采用scan &amp; scroll api来实现，而不是from/size一个大范围。<br>存储层面：<br>1）基于数据+时间滚动创建索引，每天递增数据。控制单个索引的量，一旦单个索引很大，存储等各种风险也随之而来，所以要提前考虑+及早避免。<br>2）冷热数据分离存储，热数据（比如最近3天或者一周的数据），其余为冷数据。对于冷数据不会再写入新数据，可以考虑定期force_merge加shrink压缩操作，节省存储空间和检索效率。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://zhuanlan.zhihu.com/p/265399976">https://zhuanlan.zhihu.com/p/265399976</a></p>
<p><a href="https://www.wenyuanblog.com/blogs/elasticsearch-interview-questions.html">https://www.wenyuanblog.com/blogs/elasticsearch-interview-questions.html</a></p>
<p><a href="http://www.mianshigee.com/question">http://www.mianshigee.com/question</a></p>
]]></content>
      <categories>
        <category>Middleware</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Filter</title>
    <url>/2023/07/02/Filter/</url>
    <content><![CDATA[<h1 id="过滤器笔记"><a href="#过滤器笔记" class="headerlink" title="过滤器笔记"></a>过滤器笔记</h1><h2 id="1、过滤器三要素"><a href="#1、过滤器三要素" class="headerlink" title="1、过滤器三要素"></a>1、过滤器三要素</h2><ul>
<li>拦截：一个请求必须先把它拦住，才能做后续处理</li>
<li>过滤：预设的检查条件，满足条件才可以放行</li>
<li>放行：对于满足要求的请求，放它过去，让它原本要访问什么资源就继续还是访问那个资源</li>
</ul>
<h2 id="2、过滤器生命周期"><a href="#2、过滤器生命周期" class="headerlink" title="2、过滤器生命周期"></a>2、过滤器生命周期</h2><table>
<thead>
<tr>
<th>生命周期环节</th>
<th>调用的方法</th>
<th>时机</th>
<th>次数</th>
</tr>
</thead>
<tbody><tr>
<td>创建对象</td>
<td>无参构造器</td>
<td><strong>默认：Web应用启动时</strong></td>
<td>一次</td>
</tr>
<tr>
<td>初始化</td>
<td>init(FilterConfig filterConfig)</td>
<td>创建对象后</td>
<td>一次</td>
</tr>
<tr>
<td>处理请求</td>
<td>doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</td>
<td>接收到请求后</td>
<td>多次</td>
</tr>
<tr>
<td>清理操作</td>
<td>destroy()</td>
<td>Web应用卸载之前</td>
<td>一次</td>
</tr>
</tbody></table>
<h2 id="3、拦截请求时的匹配规则"><a href="#3、拦截请求时的匹配规则" class="headerlink" title="3、拦截请求时的匹配规则"></a>3、拦截请求时的匹配规则</h2><ul>
<li>精确匹配</li>
<li>模糊匹配★<ul>
<li>前杠后星：/user/*</li>
<li>前星后缀：*.html</li>
</ul>
</li>
<li>根据Servlet名称匹配</li>
</ul>
<h2 id="4、Filter链"><a href="#4、Filter链" class="headerlink" title="4、Filter链"></a>4、Filter链</h2><ul>
<li>概念：拦截同一资源的多个Filter</li>
<li>执行顺序：由web.xml中filter-mapping配置的顺序决定</li>
<li>chain.doFilter(req,resp)：将请求放行到Filter链中的一下一个Filter，如果当前Filter已经是最后一个了，那么直接放行这个请求去访问原本要访问的资源</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM常见参数设置</title>
    <url>/2023/05/04/JVM%E5%B8%B8%E8%A7%81%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="JVM-常见参数设置"><a href="#JVM-常见参数设置" class="headerlink" title="JVM 常见参数设置"></a>JVM 常见参数设置</h1><!-- TOC -->

<ul>
<li><a href="#jvm-%E5%B8%B8%E8%A7%81%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE">JVM 常见参数设置</a><ul>
<li><a href="#%E5%86%85%E5%AD%98%E8%AE%BE%E7%BD%AE">内存设置</a><ul>
<li><a href="#%E5%8F%82%E6%95%B0">参数</a></li>
<li><a href="#%E8%AE%BE%E7%BD%AE%E7%BB%8F%E9%AA%8C">设置经验</a></li>
</ul>
</li>
<li><a href="#%E6%94%B6%E9%9B%86%E5%99%A8%E8%AE%BE%E7%BD%AE">收集器设置</a><ul>
<li><a href="#%E5%8F%82%E6%95%B0-1">参数</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h2 id="内存设置"><a href="#内存设置" class="headerlink" title="内存设置"></a>内存设置</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>-Xms</code>：初始堆大小，JVM 启动的时候，给定堆空间大小。</li>
<li><code>-Xmx</code>：最大堆大小，如果初始堆空间不足的时候，最大可以扩展到多少。</li>
<li><code>-Xmn</code>：设置年轻代大小。<code>整个堆大小 = 年轻代大小 + 年老代大小 + 持久代大小</code>。持久代一般固定大小为 64M，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun 官方推荐配置为整个堆的 3/8。</li>
<li><code>-Xss</code>： 设置每个线程的 Java 栈大小。JDK 5 后每个线程 Java 栈大小为 1M。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在 3000~5000 左右。</li>
<li><code>-XX:NewRatio=n</code>：设置年轻代和年老代的比值。如为 3，表示年轻代与年老代比值为 1:3。</li>
<li><code>-XX:MaxTenuringThreshold</code>：设置垃圾最大年龄。如果设置为 0 的话，则年轻代对象不经过 Survivor 区，直接进入年老代。对于年老代比较多的应用（即 Minor GC 过后有大量对象存活的应用），可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在 Survivor 区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概率。</li>
</ul>
<h3 id="设置经验"><a href="#设置经验" class="headerlink" title="设置经验"></a>设置经验</h3><ul>
<li><p>开发过程的测试应用，要求物理内存大于 4G</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Xmx3550m</span><br><span class="line">-Xms3550m </span><br><span class="line">-Xmn2g</span><br><span class="line">-Xss128k</span><br></pre></td></tr></table></figure></li>
<li><p>高并发本地测试使用，大对象相对较多（如 IO 流）</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Xmx3550m</span><br><span class="line">-Xms3550m</span><br><span class="line">-Xss128k</span><br><span class="line">-XX:NewRatio&#x3D;4</span><br><span class="line">-XX:SurvivorRatio&#x3D;4</span><br><span class="line">-XX:MaxPermSize&#x3D;160m</span><br><span class="line">-XX:MaxTenuringThreshold&#x3D;0</span><br></pre></td></tr></table></figure></li>
<li><p>环境： 16G 物理内存，高并发服务，重量级对象中等（线程池，连接池等），常用对象比例为 40%（即运行过程中产生的对象 40% 是生命周期较长的）</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Xmx10G</span><br><span class="line">-Xms10G</span><br><span class="line">-Xss1M</span><br><span class="line">-XX:NewRatio&#x3D;3</span><br><span class="line">-XX:SurvivorRatio&#x3D;4 </span><br><span class="line">-XX:MaxPermSize&#x3D;2048m</span><br><span class="line">-XX:MaxTenuringThreshold&#x3D;5</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="收集器设置"><a href="#收集器设置" class="headerlink" title="收集器设置"></a>收集器设置</h2><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><ul>
<li>收集器设置<ul>
<li><code>-XX:+UseSerialGC</code>：设置串行收集器，年轻带收集器。</li>
<li><code>-XX:+UseParallelGC</code>：设置并行收集器。</li>
<li><code>-XX:+UseParNewGC</code>：设置年轻代为并行收集。可与 CMS 收集同时使用。JDK 5.0 以上，JVM 会根据系统配置自行设置，所以无需再设置此值。</li>
<li><code>-XX:+UseParallelOldGC</code>：设置并行年老代收集器，JDK6.0 支持对年老代并行收集。</li>
<li><code>-XX:+UseConcMarkSweepGC</code>：设置年老代并发收集器，测试中配置这个以后，<code>-XX:NewRatio</code> 的配置失效，原因不明。所以，此时年轻代大小最好用 <code>-Xmn</code> 设置。</li>
<li><code>-XX:+UseG1GC</code>：设置 G1 收集器。</li>
</ul>
</li>
<li>并行收集器参数设置<ul>
<li><code>-XX:ParallelGCThreads=n</code>：设置并行收集器收集时最大线程数使用的 CPU 数。并行收集线程数。</li>
<li><code>-XX:MaxGCPauseMillis=n</code>：设置并行收集最大暂停时间，单位毫秒。</li>
<li><code>-XX:GCTimeRatio=n</code>：设置垃圾回收时间占程序运行时间的百分比。</li>
<li><code>-XX:+UseAdaptiveSizePolicy</code>：设置此选项后，并行收集器会自动选择年轻代区大小和相应的 Survivor 区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。</li>
<li><code>-XX:CMSFullGCsBeforeCompaction=n</code>：由于 CMS 不对内存空间进行压缩、整理，所以运行一段时间以后会产生”碎片”，使得运行效率降低。此值设置运行多少次 GC 以后对内存空间进行压缩、整理。</li>
<li><code>-XX:+UseCMSCompactAtFullCollection</code>：打开对年老代的压缩。可能会影响性能，但是可以消除碎片。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存分配策略</title>
    <url>/2023/02/26/Java%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h1 id="Java-内存分配策略"><a href="#Java-内存分配策略" class="headerlink" title="Java 内存分配策略"></a>Java 内存分配策略</h1><p><img src="./pic/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5.png" alt="内存分配与回收策略.png"></p>
<!-- TOC -->

<ul>
<li><a href="#java-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5">Java 内存分配策略</a><ul>
<li><a href="#%E4%BC%98%E5%85%88%E5%9C%A8-eden-%E5%8C%BA%E5%88%86%E9%85%8D">优先在 Eden 区分配</a></li>
<li><a href="#%E5%A4%A7%E5%AF%B9%E8%B1%A1%E7%9B%B4%E6%8E%A5%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3">大对象直接进入老年代</a></li>
<li><a href="#%E9%95%BF%E6%9C%9F%E5%AD%98%E6%B4%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B0%86%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3">长期存活的对象将进入老年代</a></li>
<li><a href="#%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D">空间分配担保</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<blockquote>
<p><strong>新生代和老年代的 GC 操作</strong></p>
<ul>
<li>新生代 GC 操作：Minor GC<ul>
<li>发生的非常频繁，速度较块。</li>
</ul>
</li>
<li>老年代 GC 操作：Full GC / Major GC<ul>
<li>经常伴随着至少一次的 Minor GC；</li>
<li>速度一般比 Minor GC 慢上 10 倍以上。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="优先在-Eden-区分配"><a href="#优先在-Eden-区分配" class="headerlink" title="优先在 Eden 区分配"></a>优先在 Eden 区分配</h2><ul>
<li>Eden 空间不够将会触发一次 Minor GC；</li>
<li>虚拟机参数：<ul>
<li><code>-Xmx</code>：Java 堆的最大值；</li>
<li><code>-Xms</code>：Java 堆的最小值；</li>
<li><code>-Xmn</code>：新生代大小；</li>
<li><code>-XX:SurvivorRatio=8</code>：Eden 区 / Survivor 区 = 8 : 1</li>
</ul>
</li>
</ul>
<h2 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h2><ul>
<li><strong>大对象定义：</strong> 需要大量连续内存空间的 Java 对象。例如那种很长的字符串或者数组。</li>
<li><strong>设置对象直接进入老年代大小限制：</strong><ul>
<li><code>-XX:PretenureSizeThreshold</code>：单位是字节；<ul>
<li>只对 Serial 和 ParNew 两款收集器有效。</li>
</ul>
</li>
<li><strong>目的：</strong> 因为新生代采用的是复制算法收集垃圾，大对象直接进入老年代可以避免在 Eden 区和 Survivor 区发生大量的内存复制。</li>
</ul>
</li>
</ul>
<h2 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h2><ul>
<li><strong>固定对象年龄判定：</strong> 虚拟机给每个对象定义一个年龄计数器，对象每在 Survivor 中熬过一次 Minor GC，年龄 +1，达到 <code>-XX:MaxTenuringThreshold</code> 设定值后，会被晋升到老年代，<code>-XX:MaxTenuringThreshold</code> 默认为 15；</li>
<li><strong>动态对象年龄判定：</strong> Survivor 中有相同年龄的对象的空间总和大于 Survivor 空间的一半，那么，年龄大于或等于该年龄的对象直接晋升到老年代。</li>
</ul>
<h2 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h2><p>我们知道，新生代采用的是复制算法清理内存，每一次 Minor GC，虚拟机会将 Eden 区和其中一块 Survivor 区的存活对象复制到另一块 Survivor 区，但 <strong>当出现大量对象在一次 Minor GC 后仍然存活的情况时，Survivor 区可能容纳不下这么多对象，此时，就需要老年代进行分配担保，即将 Survivor 无法容纳的对象直接进入老年代。</strong></p>
<p>这么做有一个前提，就是老年代得装得下这么多对象。可是在一次 GC 操作前，虚拟机并不知道到底会有多少对象存活，所以空间分配担保有这样一个判断流程：</p>
<ul>
<li>发生 Minor GC 前，虚拟机先检查老年代的最大可用连续空间是否大于新生代所有对象的总空间；<ul>
<li>如果大于，Minor GC 一定是安全的；</li>
<li>如果小于，虚拟机会查看 HandlePromotionFailure 参数，看看是否允许担保失败；<ul>
<li>允许失败：尝试着进行一次 Minor GC；</li>
<li>不允许失败：进行一次 Full GC；</li>
</ul>
</li>
</ul>
</li>
<li>不过 JDK 6 Update 24 后，HandlePromotionFailure 参数就没有用了，规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行 Minor GC，否则将进行 Full GC。</li>
</ul>
<h2 id="Metaspace-元空间与-PermGen-永久代"><a href="#Metaspace-元空间与-PermGen-永久代" class="headerlink" title="Metaspace 元空间与 PermGen 永久代"></a>Metaspace 元空间与 PermGen 永久代</h2><p>Java 8 彻底将永久代 (PermGen) 移除出了 HotSpot JVM，将其原有的数据迁移至 Java Heap 或 Metaspace。</p>
<p><strong>移除 PermGen 的原因：</strong></p>
<ul>
<li>PermGen 内存经常会溢出，引发恼人的 java.lang.OutOfMemoryError: PermGen，因此 JVM 的开发者希望这一块内存可以更灵活地被管理，不要再经常出现这样的 OOM；</li>
<li>移除 PermGen 可以促进 HotSpot JVM 与 JRockit VM 的融合，因为 JRockit 没有永久代。</li>
</ul>
<p><strong>移除 PermGen 后，方法区和字符串常量的位置：</strong></p>
<ul>
<li>方法区：移至 Metaspace；</li>
<li>字符串常量：移至 Java Heap。</li>
</ul>
<p><strong>Metaspace 的位置：</strong> 本地堆内存(native heap)。</p>
<p><strong>Metaspace 的优点：</strong> 永久代 OOM 问题将不复存在，因为默认的类的元数据分配只受本地内存大小的限制，也就是说本地内存剩余多少，理论上 Metaspace 就可以有多大；</p>
<p><strong>JVM参数：</strong></p>
<ul>
<li><code>-XX:MetaspaceSize</code>：分配给类元数据空间（以字节计）的初始大小，为估计值。MetaspaceSize的值设置的过大会延长垃圾回收时间。垃圾回收过后，引起下一次垃圾回收的类元数据空间的大小可能会变大。</li>
<li><code>-XX:MaxMetaspaceSize</code>：分配给类元数据空间的最大值，超过此值就会触发Full GC，取决于系统内存的大小。JVM会动态地改变此值。</li>
<li><code>-XX:MinMetaspaceFreeRatio</code>：一次GC以后，为了避免增加元数据空间的大小，空闲的类元数据的容量的最小比例，不够就会导致垃圾回收。</li>
<li><code>-XX:MaxMetaspaceFreeRatio</code>：一次GC以后，为了避免增加元数据空间的大小，空闲的类元数据的容量的最大比例，不够就会导致垃圾回收。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存区域详解</title>
    <url>/2023/01/31/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="Java-内存区域详解"><a href="#Java-内存区域详解" class="headerlink" title="Java 内存区域详解"></a>Java 内存区域详解</h1><!-- TOC -->

<ul>
<li><a href="#java-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AF%A6%E8%A7%A3">Java 内存区域详解</a><ul>
<li><a href="#jvm-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F">JVM 运行时的数据区域</a><ul>
<li><a href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8">程序计数器</a></li>
<li><a href="#java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88">Java 虚拟机栈</a></li>
<li><a href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88">本地方法栈</a></li>
<li><a href="#java-%E5%A0%86">Java 堆</a></li>
<li><a href="#%E6%96%B9%E6%B3%95%E5%8C%BA">方法区</a></li>
<li><a href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98">直接内存</a></li>
</ul>
</li>
<li><a href="#hotspot-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A0%86%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1">HotSpot 虚拟机堆中的对象</a><ul>
<li><a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E9%81%87%E5%88%B0%E4%B8%80%E6%9D%A1-new-%E6%8C%87%E4%BB%A4%E6%97%B6">对象的创建（遇到一条 new 指令时）</a></li>
<li><a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80">对象的内存布局</a></li>
<li><a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE">对象的访问</a><ul>
<li><a href="#%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE">句柄访问</a></li>
<li><a href="#%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE">直接指针访问</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h2 id="JVM-运行时的数据区域"><a href="#JVM-运行时的数据区域" class="headerlink" title="JVM 运行时的数据区域"></a>JVM 运行时的数据区域</h2><p>首先获取一个直观的认识：</p>
<p><img src="./pic/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png" alt="JVM运行时的数据区域.png"></p>
<p>总共也就这么 5 个区（直接内存不属于 JVM 运行时数据区的一部分），除了程序计数器其他的地方都有可能出现 OOM (OutOfMemoryError)，其中像是程序计数器和两个栈（Java 虚拟机栈 &amp; 本地方法栈）都是每个线程要有一个的，所以肯定是线程隔离的。而其他 2 个区就是线程共享的了，也就是说，如果有多个线程要同时访问这两个区的数据，是会出现线程安全问题的。接下来，我们将对这些区域进行详细的介绍。</p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><ul>
<li>当前线程所执行的字节码的行号指示器，字节码解释器工作时就是通过改变这个计数器的值来确定下一条要执行的字节码指令的位置</li>
<li>执行 Java 方法和 native 方法时的区别：<ul>
<li>执行 Java 方法时：记录虚拟机正在执行的字节码指令地址；</li>
<li>执行 native 方法时：无定义；</li>
</ul>
</li>
<li>是 5 个区域中唯一不会出现 OOM 的区域。</li>
</ul>
<h3 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h3><ul>
<li>Java 方法执行的内存模型，每个方法执行的过程，就是它所对应的栈帧在虚拟机栈中入栈到出栈的过程；</li>
<li>服务于 Java 方法；</li>
<li>可能抛出的异常：<ul>
<li>OutOfMemoryError（在虚拟机栈可以动态扩展的情况下，扩展时无法申请到足够的内存）；</li>
<li>StackOverflowError（线程请求的栈深度 &gt; 虚拟机所允许的深度）；</li>
</ul>
</li>
<li>虚拟机参数设置：<code>-Xss</code>.</li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><ul>
<li>服务于 native 方法；</li>
<li>可能抛出的异常：与 Java 虚拟机栈一样。</li>
</ul>
<h3 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h3><ul>
<li>唯一的目的：存放对象实例；</li>
<li>垃圾收集器管理的主要区域；</li>
<li>可以处于物理上不连续的内存空间中；</li>
<li>可能抛出的异常：<ul>
<li>OutOfMemoryError（堆中没有内存可以分配给新创建的实例，并且堆也无法再继续扩展了）。</li>
</ul>
</li>
<li>虚拟机参数设置：<ul>
<li>最大值：<code>-Xmx</code></li>
<li>最小值：<code>-Xms</code></li>
<li>两个参数设置成相同的值可避免堆自动扩展。</li>
</ul>
</li>
</ul>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><ul>
<li>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据；    <ul>
<li>类信息：即 Class 类，如类名、访问修饰符、常量池、字段描述、方法描述等。</li>
</ul>
</li>
<li>垃圾收集行为在此区域很少发生；<ul>
<li>不过也不能不清理，对于经常动态生成大量 Class 的应用，如 Spring 等，需要特别注意类的回收状况。</li>
</ul>
</li>
<li>运行时常量池也是方法区的一部分；<ul>
<li>Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项是常量池，用于存放编译器生成的各种字面量（就是代码中定义的 static final 常量）和符号引用，这部分信息就存储在运行时常量池中。</li>
</ul>
</li>
<li>可能抛出的异常：<ul>
<li>OutOfMemoryError（方法区无法满足内存分配需求时）。</li>
</ul>
</li>
</ul>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><ul>
<li>JDK 1.4 的 NIO 类可以使用 native 函数库直接分配堆外内存，这是一种基于通道与缓冲区的 I/O 方式，它在 Java 堆中存储一个 DirectByteBuffer 对象作为堆外内存的引用，这样就可以对堆外内存进行操作了。因为可以避免 Java 堆和 Native 堆之间来回复制数据，在一些场景可以带来显著的性能提高。</li>
<li>虚拟机参数设置：<code>-XX:MaxDirectMemorySize</code><ul>
<li>默认等于 Java 堆最大值，即 <code>-Xmx</code> 指定的值。</li>
</ul>
</li>
<li>将直接内存放在这里讲解的原因是它也可能会出现 OutOfMemoryError；<ul>
<li>服务器管理员在配置 JVM 参数时，会根据机器的实际内存设置 <code>-Xmx</code> 等信息，但经常会忽略直接内存（默认等于 <code>-Xmx</code> 设置值），这可能会使得各个内存区域的总和大于物理内存限制，从而导致动态扩展时出现 OOM。</li>
</ul>
</li>
</ul>
<h2 id="HotSpot-虚拟机堆中的对象"><a href="#HotSpot-虚拟机堆中的对象" class="headerlink" title="HotSpot 虚拟机堆中的对象"></a>HotSpot 虚拟机堆中的对象</h2><p>这一小节将对 JVM 对 Java 堆中的对象的创建、布局和访问的全过程进行讲解。</p>
<h3 id="对象的创建（遇到一条-new-指令时）"><a href="#对象的创建（遇到一条-new-指令时）" class="headerlink" title="对象的创建（遇到一条 new 指令时）"></a>对象的创建（遇到一条 new 指令时）</h3><ol>
<li>检查这个指令的参数能否在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，先把这个类加载进内存；</li>
<li>类加载检查通过后，虚拟机将为新对象分配内存，此时已经可以确定存储这个对象所需的内存大小；</li>
<li>在堆中为新对象分配可用内存；</li>
<li>将分配到的内存初始化；</li>
<li>设置对象头中的数据；</li>
<li>此时，从虚拟机的角度看，对象已经创建好了，但从 Java 程序的角度看，对象创建才刚刚开始，构造函数还没有执行。</li>
</ol>
<p>第 3 步，在堆中为新对象分配可用内存时，会涉及到以下两个问题：</p>
<p><strong>如何在堆中为新对象划分可用的内存？</strong></p>
<ul>
<li>指针碰撞（内存分配规整）<ul>
<li>用过的内存放一边，没用过的内存放一边，中间用一个指针分隔；</li>
<li>分配内存的过程就是将指针向没用过的内存那边移动所需的长度；</li>
</ul>
</li>
<li>空闲列表（内存分配不规整）<ul>
<li>维护一个列表，记录哪些内存块是可用的；</li>
<li>分配内存时，从列表上选取一块足够大的空间分给对象，并更新列表上的记录；</li>
</ul>
</li>
</ul>
<p><strong>如何处理多线程创建对象时，划分内存的指针的同步问题？</strong></p>
<ul>
<li>对分配内存空间的动作进行同步处理（CAS）；</li>
<li>把内存分配动作按照线程划分在不同的空间之中进行；<ul>
<li>每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）；</li>
<li>哪个线程要分配内存就在哪个线程的 TLAB 上分配，TLAB 用完需要分配新的 TLAB 时，才需要同步锁定；</li>
<li>通过 <code>-XX:+/-UseTLAB</code> 参数设定是否使用 TLAB。</li>
</ul>
</li>
</ul>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><ul>
<li>对象头：<ul>
<li>第一部分：存储对象自身运行时的数据，HashCode、GC分代年龄等（Mark Word）；</li>
<li>第二部分：类型指针，指向它的类元数据的指针，虚拟机通过这个指针来判断这个对象是哪个类的实例（HotSpot 采用的是直接指针的方式访问对象的）；</li>
<li>如果是个数组对象，对象头中还有一块用于记录数组长度的数据。</li>
</ul>
</li>
<li>实例数据：<ul>
<li>默认分配顺序：longs/doubles、ints、shorts/chars、bytes/booleans、oops (Ordinary Object Pointers)，相同宽度的字段会被分配在一起，除了 oops，其他的长度由长到短；</li>
<li>默认分配顺序下，父类字段会被分配在子类字段前面。</li>
</ul>
</li>
</ul>
<p><em>注：HotSpot VM要求对象的起始地址必须是8字节的整数倍，所以不够要补齐。</em></p>
<h3 id="对象的访问"><a href="#对象的访问" class="headerlink" title="对象的访问"></a>对象的访问</h3><p>Java 程序需要通过虚拟机栈上的 reference 数据来操作堆上的具体对象，reference 数据是一个指向对象的引用，不过如何通过这个引用定位到具体的对象，目前主要有以下两种访问方式：句柄访问和直接指针访问。</p>
<h4 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h4><p>句柄访问会在 Java 堆中划分一块内存作为句柄池，每一个句柄存放着到对象实例数据和对象类型数据的指针。</p>
<p>优势：对象移动的时候（这在垃圾回收时十分常见）只需改变句柄池中对象实例数据的指针，不需要修改reference本身。</p>
<p><img src="./pic/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D_%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE.png" alt="对象的访问定位_句柄访问.png"></p>
<h4 id="直接指针访问"><a href="#直接指针访问" class="headerlink" title="直接指针访问"></a>直接指针访问</h4><p>直接指针访问方式在 Java 堆对象的实例数据中存放了一个指向对象类型数据的指针，在 HotSpot 中，这个指针会被存放在对象头中。</p>
<p>优势：减少了一次指针定位对象实例数据的开销，速度更快。</p>
<p><img src="./pic/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D_%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE.png" alt="对象的访问定位_直接指针访问.png"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java运行期优化</title>
    <url>/2023/06/01/Java%E8%BF%90%E8%A1%8C%E6%9C%9F%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="运行期优化"><a href="#运行期优化" class="headerlink" title="运行期优化"></a>运行期优化</h1><p><img src="./pic/%E8%BF%90%E8%A1%8C%E6%9C%9F%E4%BC%98%E5%8C%96.png" alt="运行期优化.png"></p>
<p>我们知道，Java 是解释执行的，可是解释执行毕竟还是有点慢的，这也使得 Java 一直被认为是效率低下的语言……，不过随着即时编译技术的发展，Java 的运行速度得到了很大的提升，在本篇文章中，我们将会对 Java 的运行期优化，也就是即时编译 (Just In Time, JIT) 时进行的优化进行详细的讲解，我们先来看看什么是即时编译。</p>
<!-- TOC -->

<ul>
<li><a href="#%E8%BF%90%E8%A1%8C%E6%9C%9F%E4%BC%98%E5%8C%96">运行期优化</a><ul>
<li><a href="#%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91">即时编译</a></li>
<li><a href="#hotspot-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E7%9A%84%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8%E8%BF%90%E4%BD%9C%E8%BF%87%E7%A8%8B">HotSpot 虚拟机内的即时编译器运作过程</a><ul>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E8%A7%A3%E9%87%8A%E5%99%A8%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E5%B9%B6%E5%AD%98%E7%9A%84%E6%9E%B6%E6%9E%84">为什么要使用解释器与编译器并存的架构？</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A6%81%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AA%E4%B8%8D%E5%90%8C%E7%9A%84-jit-%E7%BC%96%E8%AF%91%E5%99%A8">为什么虚拟机要实现两个不同的 JIT 编译器？</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%88%86%E5%B1%82%E7%BC%96%E8%AF%91">什么是虚拟机的分层编译？</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%83%AD%E7%82%B9%E4%BB%A3%E7%A0%81%E8%A7%A6%E5%8F%91%E7%BC%96%E8%AF%91">如何判断热点代码，触发编译？</a><ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%83%AD%E7%82%B9%E4%BB%A3%E7%A0%81">什么是热点代码？</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-%E5%A4%9A%E6%AC%A1-%E6%89%A7%E8%A1%8C">什么是 “多次” 执行？</a></li>
<li><a href="#hotspot-%E4%B8%AD%E6%AF%8F%E4%B8%AA%E6%96%B9%E6%B3%95%E7%9A%84-2-%E4%B8%AA%E8%AE%A1%E6%95%B0%E5%99%A8">HotSpot 中每个方法的 2 个计数器</a></li>
<li><a href="#hotspot-%E7%83%AD%E7%82%B9%E4%BB%A3%E7%A0%81%E6%8E%A2%E6%B5%8B%E6%B5%81%E7%A8%8B">HotSpot 热点代码探测流程</a></li>
</ul>
</li>
<li><a href="#%E7%83%AD%E7%82%B9%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E7%9A%84%E8%BF%87%E7%A8%8B">热点代码编译的过程？</a></li>
</ul>
</li>
<li><a href="#%E7%BB%8F%E5%85%B8%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D">经典优化技术介绍</a><ul>
<li><a href="#%E5%85%AC%E5%85%B1%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B6%88%E9%99%A4%E8%AF%AD%E8%A8%80%E6%97%A0%E5%85%B3">公共子表达式消除【语言无关】</a></li>
<li><a href="#%E6%95%B0%E7%BB%84%E8%8C%83%E5%9B%B4%E6%A3%80%E6%9F%A5%E6%B6%88%E9%99%A4%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3">数组范围检查消除【语言相关】</a></li>
<li><a href="#%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94%E6%9C%80%E9%87%8D%E8%A6%81">方法内联【最重要】</a></li>
<li><a href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E6%9C%80%E5%89%8D%E6%B2%BF">逃逸分析【最前沿】</a><ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E8%A1%8C%E4%B8%BA">基本行为</a></li>
<li><a href="#%E5%AF%B9%E4%BA%8E%E4%B8%8D%E4%BC%9A%E9%80%83%E9%80%B8%E5%88%B0%E6%96%B9%E6%B3%95%E6%88%96%E7%BA%BF%E7%A8%8B%E5%A4%96%E7%9A%84%E5%AF%B9%E8%B1%A1%E8%83%BD%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96">对于不会逃逸到方法或线程外的对象能进行优化</a></li>
<li><a href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%82%E6%95%B0">虚拟机参数</a></li>
</ul>
</li>
<li><a href="#%E4%B8%80%E4%B8%AA%E4%BC%98%E5%8C%96%E7%9A%84%E4%BE%8B%E5%AD%90">一个优化的例子</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h2 id="即时编译"><a href="#即时编译" class="headerlink" title="即时编译"></a>即时编译</h2><p><strong>什么是即时编译？</strong></p>
<ul>
<li>当虚拟机发现某个方法或某段代码运行的特别频繁时，会把这段代码认为成热点代码；</li>
<li>在运行时，虚拟机会将这段代码编译成平台相关的机器码，并进行各种层次的优化。</li>
</ul>
<h2 id="HotSpot-虚拟机内的即时编译器运作过程"><a href="#HotSpot-虚拟机内的即时编译器运作过程" class="headerlink" title="HotSpot 虚拟机内的即时编译器运作过程"></a>HotSpot 虚拟机内的即时编译器运作过程</h2><p>我们主要通过以下 5 个问题来了解 HotSpot 虚拟机的即时编译器。</p>
<h3 id="为什么要使用解释器与编译器并存的架构？"><a href="#为什么要使用解释器与编译器并存的架构？" class="headerlink" title="为什么要使用解释器与编译器并存的架构？"></a>为什么要使用解释器与编译器并存的架构？</h3><ul>
<li>解释器的优点：可以提高程序的响应速度（省去了编译的时间），并且节约内存。</li>
<li>编译器的优点：可以提高执行效率。</li>
<li>虚拟机参数设置：<ul>
<li>强制运行于解析模式：<code>-Xint</code>，编译器完全不工作；</li>
<li>强制运行于编译模式：<code>-Xcomp</code>，当编译器编译失败时，解释执行还是会介入的。</li>
</ul>
</li>
</ul>
<h3 id="为什么虚拟机要实现两个不同的-JIT-编译器？"><a href="#为什么虚拟机要实现两个不同的-JIT-编译器？" class="headerlink" title="为什么虚拟机要实现两个不同的 JIT 编译器？"></a>为什么虚拟机要实现两个不同的 JIT 编译器？</h3><ul>
<li>Client Compiler（C1）：不激进优化；</li>
<li>Server Compiler（C2）：激进优化，如果激进优化不成立，再退回为解释执行或者 C1 编译器执行。</li>
</ul>
<h3 id="什么是虚拟机的分层编译？"><a href="#什么是虚拟机的分层编译？" class="headerlink" title="什么是虚拟机的分层编译？"></a>什么是虚拟机的分层编译？</h3><p>分层编译就是根据编译器编译、优化的规模与耗时，划分出不同的编译层次，在代码运行的过程中，可以动态的选择将某一部分代码片段提升一个编译层次或者降低一个编译层次。</p>
<p>C1 与 C2 编译器会同时工作，许多代码可能会被多次编译。</p>
<p><strong>目的：</strong> 在程序的启动响应时间和运行效率间达到平衡。</p>
<p><strong>编译层次的划分：</strong></p>
<ul>
<li>第 0 层：解释执行，不开启性能监控；</li>
<li>第 1 层：将字节编译为机器码，但不进行激进优化，有必要时会加入性能监控；</li>
<li>第 2 层及以上：将字节编译为机器码，会根据性能监控信息进行激进优化。</li>
</ul>
<h3 id="如何判断热点代码，触发编译？"><a href="#如何判断热点代码，触发编译？" class="headerlink" title="如何判断热点代码，触发编译？"></a>如何判断热点代码，触发编译？</h3><h4 id="什么是热点代码？"><a href="#什么是热点代码？" class="headerlink" title="什么是热点代码？"></a>什么是热点代码？</h4><ul>
<li>被多次调用的方法；</li>
<li>被多次执行的循环体；<ul>
<li>虽然被判断为热点代码的是循环体，不过因为虚拟机的即时编译是以方法为单位的，所以编译器还是会将循环体所在的方法整个作为编译对象。</li>
</ul>
</li>
</ul>
<p>我们发现，判断热点代码的一个要点就是： <strong>多次执行</strong> 。那么虚拟机是如何知道一个方法或者一个循环体被多次执行的呢？</p>
<h4 id="什么是-“多次”-执行？"><a href="#什么是-“多次”-执行？" class="headerlink" title="什么是 “多次” 执行？"></a>什么是 “多次” 执行？</h4><ul>
<li><strong>基于采样的热点探测</strong><ul>
<li>虚拟机周期检查各个线程的栈顶，如果发现一个方法经常出现在栈顶，则该方法为热点方法。</li>
<li><strong>优点：</strong> 容易获取方法的调用关系，且简单高效。</li>
<li><strong>缺点：</strong> 无法精准的判断一个方法的热度，并且容易受到线程阻塞的影响，如果一个方法由于它所在的线程被阻塞的缘故而一直出现在栈顶，我们并不能认为这个方法被调用的十分频繁。</li>
</ul>
</li>
<li><strong>基于计数器的热点探测</strong><ul>
<li>虚拟机为每一个方法（或代码块）建立一个计数器，一旦执行次数超过一定阈值，就将其判为热点代码。</li>
<li><strong>优点：</strong> 精确严谨。</li>
<li><strong>缺点：</strong> 不能直接获取方法的调用关系，且实现复杂。</li>
<li>HotSpot 使用的是这个，并且还为每个方法建立了两个计数器。</li>
</ul>
</li>
</ul>
<h4 id="HotSpot-中每个方法的-2-个计数器"><a href="#HotSpot-中每个方法的-2-个计数器" class="headerlink" title="HotSpot 中每个方法的 2 个计数器"></a>HotSpot 中每个方法的 2 个计数器</h4><ul>
<li><strong>方法调用计数器</strong><ul>
<li>统计方法被调用的次数，处理多次调用的方法的。</li>
<li>默认统计的不是方法调用的绝对次数，而是方法在一段时间内被调用的次数，如果超过这个时间限制还没有达到判为热点代码的阈值，则该方法的调用计数器值减半。<ul>
<li>关闭热度衰减：<code>-XX: -UseCounterDecay</code>（此时方法计数器统计的是方法被调用的绝对次数）；</li>
<li>设置半衰期时间：<code>-XX: CounterHalfLifeTime</code>（单位是秒）；</li>
<li>热度衰减过程是在 GC 时顺便进行。</li>
</ul>
</li>
</ul>
</li>
<li><strong>回边计数器</strong><ul>
<li>统计一个方法中 “回边” 的次数，处理多次执行的循环体的。<ul>
<li>回边：在字节码中遇到控制流向后跳转的指令（不是所有循环体都是回边，空循环体是自己跳向自己，没有向后跳，不算回边）。</li>
</ul>
</li>
<li>调整回边计数器阈值：<code>-XX: OnStackReplacePercentage</code>（OSR比率）<ul>
<li>Client 模式：<code>回边计数器的阈值 = 方法调用计数器阈值 * OSR比率 / 100</code>；</li>
<li>Server 模式：<code>回边计数器的阈值 = 方法调用计数器阈值 * ( OSR比率 - 解释器监控比率 ) / 100</code>；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="HotSpot-热点代码探测流程"><a href="#HotSpot-热点代码探测流程" class="headerlink" title="HotSpot 热点代码探测流程"></a>HotSpot 热点代码探测流程</h4><p><img src="./pic/%E5%9F%BA%E4%BA%8E%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9A%84%E7%83%AD%E7%82%B9%E4%BB%A3%E7%A0%81%E6%8E%A2%E6%B5%8B%E6%B5%81%E7%A8%8B.png" alt="基于计数器的热点代码探测流程.png"></p>
<h3 id="热点代码编译的过程？"><a href="#热点代码编译的过程？" class="headerlink" title="热点代码编译的过程？"></a>热点代码编译的过程？</h3><p>虚拟机在代码编译未完成时会按照解释方式继续执行，编译动作在后台的编译线程执行。</p>
<p>禁止后台编译：<code>-XX: -BackgroundCompilation</code>，打开后这个开关参数后，交编译请求的线程会等待编译完成，然后执行编译器输出的本地代码。</p>
<h2 id="经典优化技术介绍"><a href="#经典优化技术介绍" class="headerlink" title="经典优化技术介绍"></a>经典优化技术介绍</h2><p><strong>Content：</strong></p>
<ul>
<li>公共子表达式消除【语言无关】</li>
<li>数组范围检查消除【语言相关】</li>
<li>方法内联【最重要】</li>
<li>逃逸分析【最前沿】</li>
</ul>
<h3 id="公共子表达式消除【语言无关】"><a href="#公共子表达式消除【语言无关】" class="headerlink" title="公共子表达式消除【语言无关】"></a>公共子表达式消除【语言无关】</h3><p>如果一个表达式 E 已经计算过了，并且从先前的计算到现在，E 中所有变量值都没有发生变化，则 E 为公共子表达式，无需再次计算，直接用之前的结果替换。</p>
<h3 id="数组范围检查消除【语言相关】"><a href="#数组范围检查消除【语言相关】" class="headerlink" title="数组范围检查消除【语言相关】"></a>数组范围检查消除【语言相关】</h3><p>在循环中使用循环变量访问数组，如果可以判断循环变量的范围在数组的索引范围内，则可以消除整个循环的数组范围检查</p>
<h3 id="方法内联【最重要】"><a href="#方法内联【最重要】" class="headerlink" title="方法内联【最重要】"></a>方法内联【最重要】</h3><p>目的是：去除方法调用的成本（如建立栈帧等），并为其他优化建立良好的基础，所以一般将方法内两放在优化序列最前端，因为它对其他优化有帮助。</p>
<blockquote>
<p><strong>类型继承关系分析（Class Hierarchy Analysis，CHA）</strong></p>
<p>用于确定在目前已加载的类中，某个接口是否有多于一种的实现，某个类是否存在子类、子类是否为抽象类等。</p>
</blockquote>
<ul>
<li><strong>对于非虚方法：</strong><ul>
<li>直接进行内联，其调用方法的版本在编译时已经确定，是根据变量的静态类型决定的。</li>
</ul>
</li>
<li><strong>对于虚方法：</strong> （激进优化，要预留“逃生门”）<ul>
<li>向 CHA 查询此方法在当前程序下是否有多个目标可选择；<ul>
<li>只有一个目标版本：<ul>
<li>先对这唯一的目标进行内联；</li>
<li>如果之后的执行中，虚拟机没有加载到会令这个方法接收者的继承关系发生改变的新类，则该内联代码可以一直使用；</li>
<li>如果加载到导致继承关系发生变化的新类，就抛弃已编译的代码。</li>
</ul>
</li>
<li>有多个目标版本：<ul>
<li>使用内联缓存，未发生方法调用前，内联缓存为空；</li>
<li>第一次调用发生后，记录调用方法的对象的版本信息；</li>
<li>之后的每次调用都要先与内联缓存中的对象版本信息进行比较；<ul>
<li>版本信息一样，继续使用内联代码；</li>
<li>版本信息不一样，说明程序使用了虚方法的多态特性，这时取消内联，查找虚方法进行方法分派。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="逃逸分析【最前沿】"><a href="#逃逸分析【最前沿】" class="headerlink" title="逃逸分析【最前沿】"></a>逃逸分析【最前沿】</h3><h4 id="基本行为"><a href="#基本行为" class="headerlink" title="基本行为"></a>基本行为</h4><p>分析对象的作用域，看它有没有能在当前作用域之外使用：</p>
<ul>
<li>方法逃逸：对象在方法中定义之后，能被外部方法引用，如作为参数传递到了其他方法中。</li>
<li>线程逃逸：赋值给 static 变量，或可以在其他线程中访问的实例变量。</li>
</ul>
<h4 id="对于不会逃逸到方法或线程外的对象能进行优化"><a href="#对于不会逃逸到方法或线程外的对象能进行优化" class="headerlink" title="对于不会逃逸到方法或线程外的对象能进行优化"></a>对于不会逃逸到方法或线程外的对象能进行优化</h4><ul>
<li><strong>栈上分配：</strong> 对于不会逃逸到方法外的对象，可以在栈上分配内存，这样这个对象所占用的空间可以随栈帧出栈而销毁，减小 GC 的压力。</li>
<li><strong>标量替换（重要）：</strong><ul>
<li>标量：基本数据类型和 reference。</li>
<li>不创建对象，而是将对象拆分成一个一个标量，然后直接在栈上分配，是栈上分配的一种实现方式。</li>
<li>HotSpot 使用的是标量替换而不是栈上分配，因为实现栈上分配需要更改大量假设了 “对象只能在堆中分配” 的代码。</li>
</ul>
</li>
<li><strong>锁消除：</strong> 不会逃逸到线程外的方法不需要进行同步。</li>
</ul>
<h4 id="虚拟机参数"><a href="#虚拟机参数" class="headerlink" title="虚拟机参数"></a>虚拟机参数</h4><ul>
<li>开启逃逸分析：<code>-XX: +DoEscapeAnalysis</code></li>
<li>开启标量替换：<code>-XX: +EliminateAnalysis</code></li>
<li>开启锁消除：<code>-XX: +EliminateLocks</code></li>
<li>查看分析结果：<code>-XX: PrintEscapeAnalysis</code></li>
<li>查看标量替换情况：<code>-XX: PrintEliminateAllocations</code></li>
</ul>
<h3 id="一个优化的例子"><a href="#一个优化的例子" class="headerlink" title="一个优化的例子"></a>一个优化的例子</h3><p><strong>原始代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y = b.get();</span><br><span class="line">    <span class="comment">// ...do stuff...</span></span><br><span class="line">    z = b.get();</span><br><span class="line">    sum = y + z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第一步优化：</strong> 方法内联（一般放在优化序列最前端，因为对其他优化有帮助）</p>
<p><strong>目的：</strong></p>
<ul>
<li>去除方法调用的成本（如建立栈帧等）</li>
<li>为其他优化建立良好的基础</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y = b.value;</span><br><span class="line">    <span class="comment">// ...do stuff...</span></span><br><span class="line">    z = b.value;</span><br><span class="line">    sum = y + z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二步优化：</strong> 公共子表达式消除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y = b.value;</span><br><span class="line">    <span class="comment">// ...do stuff...  // 因为这部分并没有改变 b.value 的值</span></span><br><span class="line">                       <span class="comment">// 如果把 b.value 看成一个表达式，就是公共表达式消除</span></span><br><span class="line">    z = y;             <span class="comment">// 把这一步的 b.value 替换成 y</span></span><br><span class="line">    sum = y + z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第三步优化：</strong> 复写传播</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y = b.value;</span><br><span class="line">    <span class="comment">// ...do stuff...</span></span><br><span class="line">    y = y;             <span class="comment">// z 变量与以相同，完全没有必要使用一个新的额外变量</span></span><br><span class="line">                       <span class="comment">// 所以将 z 替换为 y</span></span><br><span class="line">    sum = y + z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第四步优化：</strong> 无用代码消除</p>
<blockquote>
<p><strong>无用代码：</strong></p>
<ul>
<li>永远不会执行的代码</li>
<li>完全没有意义的代码</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y = b.value;</span><br><span class="line">    <span class="comment">// ...do stuff...</span></span><br><span class="line">    <span class="comment">// y = y; 这句没有意义的，去除</span></span><br><span class="line">    sum = y + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka必知必会</title>
    <url>/2024/01/06/Kafka/</url>
    <content><![CDATA[<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><h4 id="1-什么是kafka"><a href="#1-什么是kafka" class="headerlink" title="1.什么是kafka?"></a>1.什么是kafka?</h4><p>Apache Kafka是由Apache开发的一种发布订阅消息系统。</p>
<h4 id="2-kafka的3个关键功能？"><a href="#2-kafka的3个关键功能？" class="headerlink" title="2.kafka的3个关键功能？"></a>2.kafka的3个关键功能？</h4><ul>
<li>发布和订阅记录流，类似于消息队列或企业消息传递系统。</li>
<li>以容错的持久方式存储记录流。</li>
<li>处理记录流。</li>
</ul>
<h4 id="3-kafka通常用于两大类应用？"><a href="#3-kafka通常用于两大类应用？" class="headerlink" title="3.kafka通常用于两大类应用？"></a>3.kafka通常用于两大类应用？</h4><ul>
<li>建立实时流数据管道，以可靠地在系统或应用程序之间获取数据</li>
<li>构建实时流应用程序，以转换或响应数据流</li>
</ul>
<h4 id="4-kafka特性"><a href="#4-kafka特性" class="headerlink" title="4.kafka特性?"></a>4.kafka特性?</h4><ol>
<li>消息持久化</li>
<li>高吞吐量</li>
<li>扩展性</li>
<li>多客户端支持</li>
<li>Kafka Streams</li>
<li>安全机制</li>
<li>数据备份</li>
<li>轻量级</li>
<li>消息压缩</li>
</ol>
<h4 id="5-kafka的5个核心Api"><a href="#5-kafka的5个核心Api" class="headerlink" title="5.kafka的5个核心Api?"></a>5.kafka的5个核心Api?</h4><ul>
<li><p> Producer API </p>
</li>
<li><p> Consumer API</p>
</li>
<li><p> Streams API </p>
</li>
<li><p> Connector API </p>
</li>
<li><p> Admin API </p>
</li>
</ul>
<h4 id="6-什么是Broker（代理）"><a href="#6-什么是Broker（代理）" class="headerlink" title="6.什么是Broker（代理）?"></a>6.什么是Broker（代理）?</h4><p>Kafka集群中，一个kafka实例被称为一个代理(Broker)节点。</p>
<h4 id="7-什么是Producer（生产者）"><a href="#7-什么是Producer（生产者）" class="headerlink" title="7.什么是Producer（生产者）?"></a>7.什么是Producer（生产者）?</h4><p>消息的生产者被称为Producer。</p>
<p>Producer将消息发送到集群指定的主题中存储，同时也自定义算法决定将消息记录发送到哪个分区?</p>
<h4 id="8-什么是Consumer（消费者）"><a href="#8-什么是Consumer（消费者）" class="headerlink" title="8.什么是Consumer（消费者）?"></a>8.什么是Consumer（消费者）?</h4><p>消息的消费者，从kafka集群中指定的主题读取消息。</p>
<h4 id="9-什么是Topic（主题）"><a href="#9-什么是Topic（主题）" class="headerlink" title="9.什么是Topic（主题）?"></a>9.什么是Topic（主题）?</h4><p>主题，kafka通过不同的主题却分不同的业务类型的消息记录。</p>
<h4 id="10-什么是Partition（分区）"><a href="#10-什么是Partition（分区）" class="headerlink" title="10.什么是Partition（分区）?"></a>10.什么是Partition（分区）?</h4><p>每一个Topic可以有一个或者多个分区(Partition)。</p>
<h4 id="11-分区和代理节点的关系？"><a href="#11-分区和代理节点的关系？" class="headerlink" title="11.分区和代理节点的关系？"></a>11.分区和代理节点的关系？</h4><p>一个分区只对应一个Broker,一个Broker可以管理多个分区。</p>
<h4 id="12-什么是副本-Replication"><a href="#12-什么是副本-Replication" class="headerlink" title="12.什么是副本(Replication)?"></a>12.什么是副本(Replication)?</h4><p>每个主题在创建时会要求制定它的副本数（默认1）。</p>
<h4 id="13-什么是记录-Record"><a href="#13-什么是记录-Record" class="headerlink" title="13.什么是记录(Record)?"></a>13.什么是记录(Record)?</h4><p>实际写入到kafka集群并且可以被消费者读取的数据。</p>
<p>每条记录包含一个键、值和时间戳。</p>
<h4 id="14-kafka适合哪些场景？"><a href="#14-kafka适合哪些场景？" class="headerlink" title="14.kafka适合哪些场景？"></a>14.kafka适合哪些场景？</h4><p>日志收集、消息系统、活动追踪、运营指标、流式处理、时间源等。</p>
<h4 id="15-kafka磁盘选用上？"><a href="#15-kafka磁盘选用上？" class="headerlink" title="15.kafka磁盘选用上？"></a>15.kafka磁盘选用上？</h4><p>SSD的性能比普通的磁盘好，这个大家都知道，实际中我们用普通磁盘即可。它使用的方式多是顺序读写操作，一定程度上规避了机械磁盘最大的劣势，即随机读写操作慢，因此SSD的没有太大优势。</p>
<h4 id="16-使用RAID的优势"><a href="#16-使用RAID的优势" class="headerlink" title="16.使用RAID的优势?"></a>16.使用RAID的优势?</h4><ul>
<li>提供冗余的磁盘存储空间</li>
<li>提供负载均衡</li>
</ul>
<h4 id="17-磁盘容量规划需要考虑到几个因素？"><a href="#17-磁盘容量规划需要考虑到几个因素？" class="headerlink" title="17.磁盘容量规划需要考虑到几个因素？"></a>17.磁盘容量规划需要考虑到几个因素？</h4><ul>
<li>新增消息数</li>
<li>消息留存时间</li>
<li>平均消息大小</li>
<li>备份数</li>
<li>是否启用压缩</li>
</ul>
<h4 id="18-Broker使用单个？多个文件目录路径参数？"><a href="#18-Broker使用单个？多个文件目录路径参数？" class="headerlink" title="18.Broker使用单个？多个文件目录路径参数？"></a>18.Broker使用单个？多个文件目录路径参数？</h4><p>log.dirs 多个</p>
<p>log.dir 单个</p>
<h4 id="19-一般来说选择哪个参数配置路径？好处？"><a href="#19-一般来说选择哪个参数配置路径？好处？" class="headerlink" title="19.一般来说选择哪个参数配置路径？好处？"></a>19.一般来说选择哪个参数配置路径？好处？</h4><p>log.dirs</p>
<p>好处:</p>
<p>提升读写性能，多块物理磁盘同时读写高吞吐。</p>
<p>故障转移。一块磁盘挂了转移到另一个上。</p>
<h4 id="20-自动创建主题的相关参数是"><a href="#20-自动创建主题的相关参数是" class="headerlink" title="20.自动创建主题的相关参数是?"></a>20.自动创建主题的相关参数是?</h4><p>auto.create.topics.enable</p>
<h4 id="21-解决kafka消息丢失问题？"><a href="#21-解决kafka消息丢失问题？" class="headerlink" title="21.解决kafka消息丢失问题？"></a>21.解决kafka消息丢失问题？</h4><ul>
<li>不要使用 producer.send(msg)，而要使用 producer.send(msg, callback)。</li>
<li>设置 acks = all。</li>
<li>设置 retries 为一个较大的值。</li>
<li>设置 unclean.leader.election.enable = false。</li>
<li>设置 replication.factor &gt;= 3。</li>
<li>设置 min.insync.replicas &gt; 1。</li>
<li>确保 replication.factor &gt; min.insync.replicas。</li>
<li>确保消息消费完成再提交。</li>
</ul>
<h4 id="22-如何自定分区策略？"><a href="#22-如何自定分区策略？" class="headerlink" title="22.如何自定分区策略？"></a>22.如何自定分区策略？</h4><p>显式地配置生产者端的参数partitioner.class</p>
<p>参数为你实现类的 全限定类名，一般来说实现partition方法即可。</p>
<h4 id="23-kafka压缩消息可能发生的地方？"><a href="#23-kafka压缩消息可能发生的地方？" class="headerlink" title="23.kafka压缩消息可能发生的地方？"></a>23.kafka压缩消息可能发生的地方？</h4><p>Producer 、Broker。</p>
<h4 id="24-kafka消息重复问题？"><a href="#24-kafka消息重复问题？" class="headerlink" title="24.kafka消息重复问题？"></a>24.kafka消息重复问题？</h4><p>做好幂等。</p>
<p>数据库方面可以（唯一键和主键）避免重复。</p>
<p>在业务上做控制。</p>
<h4 id="25-你知道的kafka监控工具？"><a href="#25-你知道的kafka监控工具？" class="headerlink" title="25.你知道的kafka监控工具？"></a>25.你知道的kafka监控工具？</h4><ul>
<li>JMXTool 工具</li>
<li>Kafka Manager</li>
<li>Burrow</li>
<li>JMXTrans + InfluxDB + Grafana</li>
<li>Confluent Control Center</li>
</ul>
<h4 id="26-kafka-follower如何与leader同步数据"><a href="#26-kafka-follower如何与leader同步数据" class="headerlink" title="26.kafka follower如何与leader同步数据"></a>26.kafka follower如何与leader同步数据</h4><p>Kafka的复制机制既不是完全的同步复制，也不是单纯的异步复制。完全同步复制要求All Alive Follower都复制完，这条消息才会被认为commit，这种复制方式极大的影响了吞吐率。而异步复制方式下，Follower异步的从Leader复制数据，数据只要被Leader写入log就被认为已经commit，这种情况下，如果leader挂掉，会丢失数据，kafka使用ISR的方式很好的均衡了确保数据不丢失以及吞吐率。Follower可以批量的从Leader复制数据，而且Leader充分利用磁盘顺序读以及send file(zero copy)机制，这样极大的提高复制性能，内部批量写磁盘，大幅减少了Follower与Leader的消息量差。</p>
<h4 id="27-什么情况下一个-broker-会从-isr中踢出去"><a href="#27-什么情况下一个-broker-会从-isr中踢出去" class="headerlink" title="27.什么情况下一个 broker 会从 isr中踢出去"></a>27.什么情况下一个 broker 会从 isr中踢出去</h4><p>leader会维护一个与其基本保持同步的Replica列表，该列表称为ISR(in-sync Replica)，每个Partition都会有一个ISR，而且是由leader动态维护 ，如果一个follower比一个leader落后太多，或者超过一定时间未发起数据复制请求，则leader将其重ISR中移除 。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h4><p>《Kafka并不难学》</p>
<p>《kafka入门与实践》</p>
<p>极客时间：Kafka核心技术与实战</p>
<p><a href="http://kafka.apache.org/">http://kafka.apache.org/</a></p>
<p><a href="https://blog.csdn.net/qq_28900249/article/details/90346599">https://blog.csdn.net/qq_28900249/article/details/90346599</a></p>
<p><img src="https://gitee.com/yizhibuerdai/Imagetools/raw/master/images/common1.png" alt="WechatIMG360"></p>
]]></content>
      <categories>
        <category>Message Queues</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC核心技术</title>
    <url>/2023/06/18/JDBC%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="JDBC核心技术"><a href="#JDBC核心技术" class="headerlink" title="JDBC核心技术"></a>JDBC核心技术</h1><hr>
<h2 id="第1章：JDBC概述"><a href="#第1章：JDBC概述" class="headerlink" title="第1章：JDBC概述"></a>第1章：JDBC概述</h2><h3 id="1-1-数据的持久化"><a href="#1-1-数据的持久化" class="headerlink" title="1.1 数据的持久化"></a>1.1 数据的持久化</h3><ul>
<li><p>持久化(persistence)：<strong>把数据保存到可掉电式存储设备中以供之后使用</strong>。大多数情况下，特别是企业级应用，<strong>数据持久化意味着将内存中的数据保存到硬盘</strong>上加以”固化”<strong>，而持久化的实现过程大多通过各种关系数据库来完成</strong>。</p>
</li>
<li><p>持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。</p>
<p><img src="assets/1566741430592.png" alt="1566741430592"> </p>
</li>
</ul>
<h3 id="1-2-Java中的数据存储技术"><a href="#1-2-Java中的数据存储技术" class="headerlink" title="1.2 Java中的数据存储技术"></a>1.2 Java中的数据存储技术</h3><ul>
<li><p>在Java中，数据库存取技术可分为如下几类：</p>
<ul>
<li><p><strong>JDBC</strong>直接访问数据库</p>
</li>
<li><p>JDO (Java Data Object )技术</p>
</li>
<li><p><strong>第三方O/R工具</strong>，如Hibernate, Mybatis 等</p>
</li>
</ul>
</li>
<li><p>JDBC是java访问数据库的基石，JDO、Hibernate、MyBatis等只是更好的封装了JDBC。</p>
</li>
</ul>
<h3 id="1-3-JDBC介绍"><a href="#1-3-JDBC介绍" class="headerlink" title="1.3 JDBC介绍"></a>1.3 JDBC介绍</h3><ul>
<li>JDBC(Java Database Connectivity)是一个<strong>独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口</strong>（一组API），定义了用来访问数据库的标准Java类库，（<strong>java.sql,javax.sql</strong>）使用这些类库可以以一种<strong>标准</strong>的方法、方便地访问数据库资源。</li>
<li>JDBC为访问不同的数据库提供了一种<strong>统一的途径</strong>，为开发者屏蔽了一些细节问题。</li>
<li>JDBC的目标是使Java程序员使用JDBC可以连接任何<strong>提供了JDBC驱动程序</strong>的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。</li>
<li>如果没有JDBC，那么Java程序访问数据库时是这样的：</li>
</ul>
<p><img src="assets/1555575760234.png" alt="1555575760234"></p>
<hr>
<ul>
<li>有了JDBC，Java程序访问数据库时是这样的：</li>
</ul>
<p><img src="assets/1555575981203.png" alt="1555575981203"></p>
<hr>
<ul>
<li>总结如下：</li>
</ul>
<p><img src="assets/1566741692804.png" alt="1566741692804"></p>
<h3 id="1-4-JDBC体系结构"><a href="#1-4-JDBC体系结构" class="headerlink" title="1.4 JDBC体系结构"></a>1.4 JDBC体系结构</h3><ul>
<li>JDBC接口（API）包括两个层次：<ul>
<li><strong>面向应用的API</strong>：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。</li>
<li> <strong>面向数据库的API</strong>：Java Driver API，供开发商开发数据库驱动程序用。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>JDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。</strong></p>
<p><strong>不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。                                                                ————面向接口编程</strong></p>
</blockquote>
<h3 id="1-5-JDBC程序编写步骤"><a href="#1-5-JDBC程序编写步骤" class="headerlink" title="1.5 JDBC程序编写步骤"></a>1.5 JDBC程序编写步骤</h3><p><img src="assets/1565969323908.png" alt="1565969323908"></p>
<blockquote>
<p>补充：ODBC(<strong>Open Database Connectivity</strong>，开放式数据库连接)，是微软在Windows平台下推出的。使用者在程序中只需要调用ODBC API，由 ODBC 驱动程序将调用转换成为对特定的数据库的调用请求。</p>
</blockquote>
<h2 id="第2章：获取数据库连接"><a href="#第2章：获取数据库连接" class="headerlink" title="第2章：获取数据库连接"></a>第2章：获取数据库连接</h2><h3 id="2-1-要素一：Driver接口实现类"><a href="#2-1-要素一：Driver接口实现类" class="headerlink" title="2.1 要素一：Driver接口实现类"></a>2.1 要素一：Driver接口实现类</h3><h4 id="2-1-1-Driver接口介绍"><a href="#2-1-1-Driver接口介绍" class="headerlink" title="2.1.1 Driver接口介绍"></a>2.1.1 Driver接口介绍</h4><ul>
<li><p>java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。</p>
</li>
<li><p>在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现。</p>
<ul>
<li>Oracle的驱动：<strong>oracle.jdbc.driver.OracleDriver</strong></li>
<li>mySql的驱动： <strong>com.mysql.jdbc.Driver</strong></li>
</ul>
</li>
</ul>
<p><img src="assets/1555576157618.png" alt="1555576157618"></p>
<p><img src="assets/1555576170074.png" alt="1555576170074"></p>
<ul>
<li>将上述jar包拷贝到Java工程的一个目录中，习惯上新建一个lib文件夹。</li>
</ul>
<p> <img src="assets/1566134718955.png" alt="1566134718955"></p>
<p>在驱动jar上右键–&gt;Build Path–&gt;Add to Build Path</p>
<p> <img src="assets/1566134781682.png" alt="1566134781682"></p>
<p>注意：如果是Dynamic Web Project（动态的web项目）话，则是把驱动jar放到WebContent（有的开发工具叫WebRoot）目录中的WEB-INF目录中的lib目录下即可</p>
<p> <img src="assets/1566135290460.png" alt="1566135290460"></p>
<h4 id="2-1-2-加载与注册JDBC驱动"><a href="#2-1-2-加载与注册JDBC驱动" class="headerlink" title="2.1.2 加载与注册JDBC驱动"></a>2.1.2 加载与注册JDBC驱动</h4><ul>
<li><p>加载驱动：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名</p>
<ul>
<li><strong>Class.forName(“com.mysql.jdbc.Driver”);</strong></li>
</ul>
</li>
<li><p>注册驱动：DriverManager 类是驱动程序管理器类，负责管理驱动程序</p>
<ul>
<li><p><strong>使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来注册驱动</strong></p>
</li>
<li><p>通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类<strong>都</strong>包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例。下图是MySQL的Driver实现类的源码：</p>
<p><img src="assets/1566136831283.png" alt="1566136831283"></p>
</li>
</ul>
</li>
</ul>
<h3 id="2-2-要素二：URL"><a href="#2-2-要素二：URL" class="headerlink" title="2.2 要素二：URL"></a>2.2 要素二：URL</h3><ul>
<li><p>JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。</p>
</li>
<li><p>JDBC URL的标准由三部分组成，各部分间用冒号分隔。 </p>
<ul>
<li><strong>jdbc:子协议:子名称</strong></li>
<li><strong>协议</strong>：JDBC URL中的协议总是jdbc </li>
<li><strong>子协议</strong>：子协议用于标识一个数据库驱动程序</li>
<li><strong>子名称</strong>：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了<strong>定位数据库</strong>提供足够的信息。包含<strong>主机名</strong>(对应服务端的ip地址)<strong>，端口号，数据库名</strong></li>
</ul>
</li>
<li><p>举例：</p>
<p><img src="assets/1555576477107.png" alt="1555576477107"></p>
</li>
<li><p><strong>几种常用数据库的 JDBC URL</strong></p>
<ul>
<li><p>MySQL的连接URL编写方式：</p>
<ul>
<li>jdbc:mysql://主机名称:mysql服务端口号/数据库名称?参数=值&amp;参数=值</li>
<li>jdbc:mysql://localhost:3306/atguigu</li>
<li>jdbc:mysql://localhost:3306/atguigu**?useUnicode=true&amp;characterEncoding=utf8**（如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集）</li>
<li>jdbc:mysql://localhost:3306/atguigu?user=root&amp;password=123456</li>
</ul>
</li>
<li><p>Oracle 9i的连接URL编写方式：</p>
<ul>
<li>jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称</li>
<li>jdbc:oracle:thin:@localhost:1521:atguigu</li>
</ul>
</li>
<li><p>SQLServer的连接URL编写方式：</p>
<ul>
<li><p>jdbc:sqlserver://主机名称:sqlserver服务端口号:DatabaseName=数据库名称</p>
</li>
<li><p>jdbc:sqlserver://localhost:1433:DatabaseName=atguigu</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-3-要素三：用户名和密码"><a href="#2-3-要素三：用户名和密码" class="headerlink" title="2.3 要素三：用户名和密码"></a>2.3 要素三：用户名和密码</h3><ul>
<li>user,password可以用“属性名=属性值”方式告诉数据库</li>
<li>可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接</li>
</ul>
<h3 id="2-4-数据库连接方式举例"><a href="#2-4-数据库连接方式举例" class="headerlink" title="2.4 数据库连接方式举例"></a>2.4 数据库连接方式举例</h3><h4 id="2-4-1-连接方式一"><a href="#2-4-1-连接方式一" class="headerlink" title="2.4.1 连接方式一"></a>2.4.1 连接方式一</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.提供java.sql.Driver接口实现类的对象</span></span><br><span class="line">           Driver driver = <span class="keyword">null</span>;</span><br><span class="line">           driver = <span class="keyword">new</span> com.mysql.jdbc.Driver();</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.提供url，指明具体操作的数据</span></span><br><span class="line">           String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//3.提供Properties的对象，指明用户名和密码</span></span><br><span class="line">           Properties info = <span class="keyword">new</span> Properties();</span><br><span class="line">           info.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">           info.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;abc123&quot;</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//4.调用driver的connect()，获取连接</span></span><br><span class="line">           Connection conn = driver.connect(url, info);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：上述代码中显式出现了第三方数据库的API</p>
</blockquote>
<h4 id="2-4-2-连接方式二"><a href="#2-4-2-连接方式二" class="headerlink" title="2.4.2 连接方式二"></a>2.4.2 连接方式二</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.实例化Driver</span></span><br><span class="line">           String className = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line">           Class clazz = Class.forName(className);</span><br><span class="line">           Driver driver = (Driver) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.提供url，指明具体操作的数据</span></span><br><span class="line">           String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//3.提供Properties的对象，指明用户名和密码</span></span><br><span class="line">           Properties info = <span class="keyword">new</span> Properties();</span><br><span class="line">           info.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">           info.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;abc123&quot;</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//4.调用driver的connect()，获取连接</span></span><br><span class="line">           Connection conn = driver.connect(url, info);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：相较于方式一，这里使用反射实例化Driver，不在代码中体现第三方数据库的API。体现了面向接口编程思想。</p>
</blockquote>
<h4 id="2-4-3-连接方式三"><a href="#2-4-3-连接方式三" class="headerlink" title="2.4.3 连接方式三"></a>2.4.3 连接方式三</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.数据库连接的4个基本要素：</span></span><br><span class="line">           String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line">           String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">           String password = <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line">           String driverName = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.实例化Driver</span></span><br><span class="line">           Class clazz = Class.forName(driverName);</span><br><span class="line">           Driver driver = (Driver) clazz.newInstance();</span><br><span class="line">           <span class="comment">//3.注册驱动</span></span><br><span class="line">           DriverManager.registerDriver(driver);</span><br><span class="line">           <span class="comment">//4.获取连接</span></span><br><span class="line">           Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：使用DriverManager实现数据库的连接。体会获取连接必要的4个基本要素。</p>
</blockquote>
<h4 id="2-4-4-连接方式四"><a href="#2-4-4-连接方式四" class="headerlink" title="2.4.4 连接方式四"></a>2.4.4 连接方式四</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.数据库连接的4个基本要素：</span></span><br><span class="line">           String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line">           String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">           String password = <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line">           String driverName = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.加载驱动 （①实例化Driver ②注册驱动）</span></span><br><span class="line">           Class.forName(driverName);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment">//Driver driver = (Driver) clazz.newInstance();</span></span><br><span class="line">           <span class="comment">//3.注册驱动</span></span><br><span class="line">           <span class="comment">//DriverManager.registerDriver(driver);</span></span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">           可以注释掉上述代码的原因，是因为在mysql的Driver类中声明有：</span></span><br><span class="line"><span class="comment">           static &#123;</span></span><br><span class="line"><span class="comment">               try &#123;</span></span><br><span class="line"><span class="comment">                   DriverManager.registerDriver(new Driver());</span></span><br><span class="line"><span class="comment">               &#125; catch (SQLException var1) &#123;</span></span><br><span class="line"><span class="comment">                   throw new RuntimeException(&quot;Can&#x27;t register driver!&quot;);</span></span><br><span class="line"><span class="comment">               &#125;</span></span><br><span class="line"><span class="comment">           &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment">//3.获取连接</span></span><br><span class="line">           Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：不必显式的注册驱动了。因为在DriverManager的源码中已经存在静态代码块，实现了驱动的注册。</p>
</blockquote>
<h4 id="2-4-5-连接方式五-最终版"><a href="#2-4-5-连接方式五-最终版" class="headerlink" title="2.4.5 连接方式五(最终版)"></a>2.4.5 连接方式五(最终版)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">testConnection5</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   	<span class="comment">//1.加载配置文件</span></span><br><span class="line">       InputStream is = ConnectionTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">       Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">       pros.load(is);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//2.读取配置信息</span></span><br><span class="line">       String user = pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">       String password = pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">       String url = pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">       String driverClass = pros.getProperty(<span class="string">&quot;driverClass&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//3.加载驱动</span></span><br><span class="line">       Class.forName(driverClass);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//4.获取连接</span></span><br><span class="line">       Connection conn = DriverManager.getConnection(url,user,password);</span><br><span class="line">       System.out.println(conn);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>其中，配置文件声明在工程的src目录下：【jdbc.properties】</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">abc123</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line"><span class="attr">driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：使用配置文件的方式保存配置信息，在代码中加载配置文件</p>
<p><strong>使用配置文件的好处：</strong></p>
<p>①实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码<br>②如果修改了配置信息，省去重新编译的过程。</p>
</blockquote>
<h2 id="第3章：使用PreparedStatement实现CRUD操作"><a href="#第3章：使用PreparedStatement实现CRUD操作" class="headerlink" title="第3章：使用PreparedStatement实现CRUD操作"></a>第3章：使用PreparedStatement实现CRUD操作</h2><h3 id="3-1-操作和访问数据库"><a href="#3-1-操作和访问数据库" class="headerlink" title="3.1 操作和访问数据库"></a>3.1 操作和访问数据库</h3><ul>
<li><p>数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。其实一个数据库连接就是一个Socket连接。</p>
</li>
<li><p>在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式：</p>
<ul>
<li>Statement：用于执行静态 SQL 语句并返回它所生成结果的对象。 </li>
<li>PrepatedStatement：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。</li>
<li>CallableStatement：用于执行 SQL 存储过程</li>
</ul>
<p><img src="assets/1566573842140.png" alt="1566573842140"></p>
</li>
</ul>
<h3 id="3-2-使用Statement操作数据表的弊端"><a href="#3-2-使用Statement操作数据表的弊端" class="headerlink" title="3.2 使用Statement操作数据表的弊端"></a>3.2 使用Statement操作数据表的弊端</h3><ul>
<li><p>通过调用 Connection 对象的 createStatement() 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。</p>
</li>
<li><p>Statement 接口中定义了下列方法用于执行 SQL 语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> excuteUpdate(String <span class="keyword">sql</span>)：执行更新操作<span class="keyword">INSERT</span>、UPDATE、<span class="keyword">DELETE</span></span><br><span class="line">ResultSet executeQuery(String <span class="keyword">sql</span>)：执行查询操作<span class="keyword">SELECT</span></span><br></pre></td></tr></table></figure></li>
<li><p>但是使用Statement操作数据表存在弊端：</p>
<ul>
<li><strong>问题一：存在拼串操作，繁琐</strong></li>
<li><strong>问题二：存在SQL注入问题</strong></li>
</ul>
</li>
<li><p>SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令(如：SELECT user, password FROM user_table WHERE user=’a’ OR 1 = ‘ AND password = ‘ OR ‘1’ = ‘1’) ，从而利用系统的 SQL 引擎完成恶意行为的做法。</p>
</li>
<li><p>对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了。</p>
</li>
<li><p>代码演示：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatementTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用Statement的弊端：需要拼写sql语句，并且存在SQL注入的问题</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLogin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">		System.out.print(<span class="string">&quot;用户名：&quot;</span>);</span><br><span class="line">		String userName = scan.nextLine();</span><br><span class="line">		System.out.print(<span class="string">&quot;密   码：&quot;</span>);</span><br><span class="line">		String password = scan.nextLine();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// SELECT user,password FROM user_table WHERE USER = &#x27;1&#x27; or &#x27; AND PASSWORD = &#x27;=&#x27;1&#x27; or &#x27;1&#x27; = &#x27;1&#x27;;</span></span><br><span class="line">		String sql = <span class="string">&quot;SELECT user,password FROM user_table WHERE USER = &#x27;&quot;</span> + userName + <span class="string">&quot;&#x27; AND PASSWORD = &#x27;&quot;</span> + password</span><br><span class="line">				+ <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">		User user = get(sql, User.class);</span><br><span class="line">		<span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;登陆成功!&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;用户名或密码错误！&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用Statement实现对数据表的查询操作</span></span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(String sql, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">		T t = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		Connection conn = <span class="keyword">null</span>;</span><br><span class="line">		Statement st = <span class="keyword">null</span>;</span><br><span class="line">		ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 1.加载配置文件</span></span><br><span class="line">			InputStream is = StatementTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">			Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">			pros.load(is);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 2.读取配置信息</span></span><br><span class="line">			String user = pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">			String password = pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">			String url = pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">			String driverClass = pros.getProperty(<span class="string">&quot;driverClass&quot;</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 3.加载驱动</span></span><br><span class="line">			Class.forName(driverClass);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 4.获取连接</span></span><br><span class="line">			conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">			st = conn.createStatement();</span><br><span class="line"></span><br><span class="line">			rs = st.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 获取结果集的元数据</span></span><br><span class="line">			ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 获取结果集的列数</span></span><br><span class="line">			<span class="keyword">int</span> columnCount = rsmd.getColumnCount();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line"></span><br><span class="line">				t = clazz.newInstance();</span><br><span class="line"></span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnCount; i++) &#123;</span><br><span class="line">					<span class="comment">// //1. 获取列的名称</span></span><br><span class="line">					<span class="comment">// String columnName = rsmd.getColumnName(i+1);</span></span><br><span class="line"></span><br><span class="line">					<span class="comment">// 1. 获取列的别名</span></span><br><span class="line">					String columnName = rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 2. 根据列名获取对应数据表中的数据</span></span><br><span class="line">					Object columnVal = rs.getObject(columnName);</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 3. 将数据表中得到的数据，封装进对象</span></span><br><span class="line">					Field field = clazz.getDeclaredField(columnName);</span><br><span class="line">					field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">					field.set(t, columnVal);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">// 关闭资源</span></span><br><span class="line">			<span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					rs.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (st != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					st.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					conn.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上：</p>
<p><img src="assets/1566569819744.png" alt="1566569819744"></p>
<h3 id="3-3-PreparedStatement的使用"><a href="#3-3-PreparedStatement的使用" class="headerlink" title="3.3 PreparedStatement的使用"></a>3.3 PreparedStatement的使用</h3><h4 id="3-3-1-PreparedStatement介绍"><a href="#3-3-1-PreparedStatement介绍" class="headerlink" title="3.3.1 PreparedStatement介绍"></a>3.3.1 PreparedStatement介绍</h4><ul>
<li><p>可以通过调用 Connection 对象的 <strong>preparedStatement(String sql)</strong> 方法获取 PreparedStatement 对象</p>
</li>
<li><p><strong>PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句</strong></p>
</li>
<li><p>PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值</p>
</li>
</ul>
<h4 id="3-3-2-PreparedStatement-vs-Statement"><a href="#3-3-2-PreparedStatement-vs-Statement" class="headerlink" title="3.3.2 PreparedStatement vs Statement"></a>3.3.2 PreparedStatement vs Statement</h4><ul>
<li><p>代码的可读性和可维护性。</p>
</li>
<li><p><strong>PreparedStatement 能最大可能提高性能：</strong></p>
<ul>
<li>DBServer会对<strong>预编译</strong>语句提供性能优化。因为预编译语句有可能被重复调用，所以<u>语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。</u></li>
<li>在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样<u>每执行一次都要对传入的语句编译一次。</u></li>
<li>(语法检查，语义检查，翻译成二进制命令，缓存)</li>
</ul>
</li>
<li><p>PreparedStatement 可以防止 SQL 注入 </p>
</li>
</ul>
<h4 id="3-3-3-Java与SQL对应数据类型转换表"><a href="#3-3-3-Java与SQL对应数据类型转换表" class="headerlink" title="3.3.3 Java与SQL对应数据类型转换表"></a>3.3.3 Java与SQL对应数据类型转换表</h4><table>
<thead>
<tr>
<th>Java类型</th>
<th>SQL类型</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>BIT</td>
</tr>
<tr>
<td>byte</td>
<td>TINYINT</td>
</tr>
<tr>
<td>short</td>
<td>SMALLINT</td>
</tr>
<tr>
<td>int</td>
<td>INTEGER</td>
</tr>
<tr>
<td>long</td>
<td>BIGINT</td>
</tr>
<tr>
<td>String</td>
<td>CHAR,VARCHAR,LONGVARCHAR</td>
</tr>
<tr>
<td>byte   array</td>
<td>BINARY  ,    VAR BINARY</td>
</tr>
<tr>
<td>java.sql.Date</td>
<td>DATE</td>
</tr>
<tr>
<td>java.sql.Time</td>
<td>TIME</td>
</tr>
<tr>
<td>java.sql.Timestamp</td>
<td>TIMESTAMP</td>
</tr>
</tbody></table>
<h4 id="3-3-4-使用PreparedStatement实现增、删、改操作"><a href="#3-3-4-使用PreparedStatement实现增、删、改操作" class="headerlink" title="3.3.4 使用PreparedStatement实现增、删、改操作"></a>3.3.4 使用PreparedStatement实现增、删、改操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通用的增、删、改操作（体现一：增、删、改 ； 体现二：针对于不同的表）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String sql,Object ... args)</span></span>&#123;</span><br><span class="line">	Connection conn = <span class="keyword">null</span>;</span><br><span class="line">	PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//1.获取数据库的连接</span></span><br><span class="line">		conn = JDBCUtils.getConnection();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2.获取PreparedStatement的实例 (或：预编译sql语句)</span></span><br><span class="line">		ps = conn.prepareStatement(sql);</span><br><span class="line">		<span class="comment">//3.填充占位符</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; args.length;i++)&#123;</span><br><span class="line">			ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//4.执行sql语句</span></span><br><span class="line">		ps.execute();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">		<span class="comment">//5.关闭资源</span></span><br><span class="line">		JDBCUtils.closeResource(conn, ps);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-3-5-使用PreparedStatement实现查询操作"><a href="#3-3-5-使用PreparedStatement实现查询操作" class="headerlink" title="3.3.5 使用PreparedStatement实现查询操作"></a>3.3.5 使用PreparedStatement实现查询操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通用的针对于不同表的查询:返回一个对象 (version 1.0)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getInstance</span><span class="params">(Class&lt;T&gt; clazz, String sql, Object... args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Connection conn = <span class="keyword">null</span>;</span><br><span class="line">	PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">	ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 1.获取数据库连接</span></span><br><span class="line">		conn = JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2.预编译sql语句，得到PreparedStatement对象</span></span><br><span class="line">		ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 3.填充占位符</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">			ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 4.执行executeQuery(),得到结果集：ResultSet</span></span><br><span class="line">		rs = ps.executeQuery();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 5.得到结果集的元数据：ResultSetMetaData</span></span><br><span class="line">		ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 6.1通过ResultSetMetaData得到columnCount,columnLabel；通过ResultSet得到列值</span></span><br><span class="line">		<span class="keyword">int</span> columnCount = rsmd.getColumnCount();</span><br><span class="line">		<span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">			T t = clazz.newInstance();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnCount; i++) &#123;<span class="comment">// 遍历每一个列</span></span><br><span class="line"></span><br><span class="line">				<span class="comment">// 获取列值</span></span><br><span class="line">				Object columnVal = rs.getObject(i + <span class="number">1</span>);</span><br><span class="line">				<span class="comment">// 获取列的别名:列的别名，使用类的属性名充当</span></span><br><span class="line">				String columnLabel = rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line">				<span class="comment">// 6.2使用反射，给对象的相应属性赋值</span></span><br><span class="line">				Field field = clazz.getDeclaredField(columnLabel);</span><br><span class="line">				field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">				field.set(t, columnVal);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> t;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="comment">// 7.关闭资源</span></span><br><span class="line">		JDBCUtils.closeResource(conn, ps, rs);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：使用PreparedStatement实现的查询操作可以替换Statement实现的查询操作，解决Statement拼串和SQL注入问题。</p>
</blockquote>
<h3 id="3-4-ResultSet与ResultSetMetaData"><a href="#3-4-ResultSet与ResultSetMetaData" class="headerlink" title="3.4 ResultSet与ResultSetMetaData"></a>3.4 ResultSet与ResultSetMetaData</h3><h4 id="3-4-1-ResultSet"><a href="#3-4-1-ResultSet" class="headerlink" title="3.4.1 ResultSet"></a>3.4.1 ResultSet</h4><ul>
<li><p>查询需要调用PreparedStatement 的 executeQuery() 方法，查询结果是一个ResultSet 对象</p>
</li>
<li><p>ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商提供实现</p>
</li>
<li><p>ResultSet 返回的实际上就是一张数据表。有一个指针指向数据表的第一条记录的前面。</p>
</li>
<li><p>ResultSet 对象维护了一个指向当前数据行的<strong>游标</strong>，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行。调用 next()方法检测下一行是否有效。若有效，该方法返回 true，且指针下移。相当于Iterator对象的 hasNext() 和 next() 方法的结合体。</p>
</li>
<li><p>当指针指向一行时, 可以通过调用 getXxx(int index) 或 getXxx(int columnName) 获取每一列的值。</p>
<ul>
<li>例如: getInt(1), getString(“name”)</li>
<li><strong>注意：Java与数据库交互涉及到的相关Java API中的索引都从1开始。</strong></li>
</ul>
</li>
<li><p>ResultSet 接口的常用方法：</p>
<ul>
<li><p>boolean next()</p>
</li>
<li><p>getString()</p>
</li>
<li><p>…</p>
</li>
</ul>
<p><img src="assets/1555580152530.png" alt="1555580152530"></p>
</li>
</ul>
<h4 id="3-4-2-ResultSetMetaData"><a href="#3-4-2-ResultSetMetaData" class="headerlink" title="3.4.2 ResultSetMetaData"></a>3.4.2 ResultSetMetaData</h4><ul>
<li><p>可用于获取关于 ResultSet 对象中列的类型和属性信息的对象</p>
</li>
<li><p>ResultSetMetaData meta = rs.getMetaData();</p>
<ul>
<li><p><strong>getColumnName</strong>(int column)：获取指定列的名称</p>
</li>
<li><p><strong>getColumnLabel</strong>(int column)：获取指定列的别名</p>
</li>
<li><p><strong>getColumnCount</strong>()：返回当前 ResultSet 对象中的列数。 </p>
</li>
<li><p>getColumnTypeName(int column)：检索指定列的数据库特定的类型名称。 </p>
</li>
<li><p>getColumnDisplaySize(int column)：指示指定列的最大标准宽度，以字符为单位。 </p>
</li>
<li><p><strong>isNullable</strong>(int column)：指示指定列中的值是否可以为 null。 </p>
</li>
<li><p> isAutoIncrement(int column)：指示是否自动为指定列进行编号，这样这些列仍然是只读的。 </p>
</li>
</ul>
</li>
</ul>
<p><img src="assets/1555579494691.png" alt="1555579494691"></p>
<p><strong>问题1：得到结果集后, 如何知道该结果集中有哪些列 ？ 列名是什么？</strong></p>
<p>​     需要使用一个描述 ResultSet 的对象， 即 ResultSetMetaData</p>
<p><strong>问题2：关于ResultSetMetaData</strong></p>
<ol>
<li><strong>如何获取 ResultSetMetaData</strong>： 调用 ResultSet 的 getMetaData() 方法即可</li>
<li><strong>获取 ResultSet 中有多少列</strong>：调用 ResultSetMetaData 的 getColumnCount() 方法</li>
<li><strong>获取 ResultSet 每一列的列的别名是什么</strong>：调用 ResultSetMetaData 的getColumnLabel() 方法</li>
</ol>
<p><img src="assets/1555579816884.png" alt="1555579816884"></p>
<h3 id="3-5-资源的释放"><a href="#3-5-资源的释放" class="headerlink" title="3.5 资源的释放"></a>3.5 资源的释放</h3><ul>
<li>释放ResultSet, Statement,Connection。</li>
<li>数据库连接（Connection）是非常稀有的资源，用完后必须马上释放，如果Connection不能及时正确的关闭将导致系统宕机。Connection的使用原则是<strong>尽量晚创建，尽量早的释放。</strong></li>
<li>可以在finally中关闭，保证及时其他代码出现异常，资源也一定能被关闭。</li>
</ul>
<h3 id="3-6-JDBC-API小结"><a href="#3-6-JDBC-API小结" class="headerlink" title="3.6 JDBC API小结"></a>3.6 JDBC API小结</h3><ul>
<li><p>两种思想</p>
<ul>
<li><p>面向接口编程的思想</p>
</li>
<li><p>ORM思想(object relational mapping)</p>
<ul>
<li>一个数据表对应一个java类</li>
<li>表中的一条记录对应java类的一个对象</li>
<li>表中的一个字段对应java类的一个属性</li>
</ul>
</li>
</ul>
<blockquote>
<p>sql是需要结合列名和表的属性名来写。注意起别名。</p>
</blockquote>
</li>
<li><p>两种技术</p>
<ul>
<li>JDBC结果集的元数据：ResultSetMetaData<ul>
<li>获取列数：getColumnCount()</li>
<li>获取列的别名：getColumnLabel()</li>
</ul>
</li>
<li>通过反射，创建指定类的对象，获取指定的属性并赋值</li>
</ul>
</li>
</ul>
<hr>
<h2 id="章节练习"><a href="#章节练习" class="headerlink" title="章节练习"></a>章节练习</h2><p><strong>练习题1：从控制台向数据库的表customers中插入一条数据，表结构如下：</strong></p>
<p><img src="assets/1555580275036.png" alt="1555580275036"></p>
<p><strong>练习题2：创立数据库表 examstudent，表结构如下：</strong></p>
<p><img src="assets/1555580735377.png" alt="1555580735377"></p>
<p>向数据表中添加如下数据：</p>
<p><img src="assets/1555580763636.png" alt="1555580763636"></p>
<p><strong>代码实现1：插入一个新的student 信息</strong></p>
<p>请输入考生的详细信息</p>
<p>Type:<br>IDCard:<br>ExamCard:<br>StudentName:<br>Location:<br>Grade:</p>
<p>信息录入成功!</p>
<p><strong>代码实现2：在 eclipse中建立 java 程序：输入身份证号或准考证号可以查询到学生的基本信息。结果如下：</strong></p>
<p><img src="assets/1555580937490.png" alt="1555580937490"></p>
<p><strong>代码实现3：完成学生信息的删除功能</strong></p>
<p><img src="assets/1555580965019.png" alt="1555580965019"></p>
<hr>
<h2 id="第4章-操作BLOB类型字段"><a href="#第4章-操作BLOB类型字段" class="headerlink" title="第4章 操作BLOB类型字段"></a>第4章 操作BLOB类型字段</h2><h3 id="4-1-MySQL-BLOB类型"><a href="#4-1-MySQL-BLOB类型" class="headerlink" title="4.1 MySQL BLOB类型"></a>4.1 MySQL BLOB类型</h3><ul>
<li><p>MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。</p>
</li>
<li><p>插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接写的。</p>
</li>
<li><p>MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的)</p>
</li>
</ul>
<p><img src="assets/1555581069798.png" alt="1555581069798"></p>
<ul>
<li>实际使用中根据需要存入的数据大小定义不同的BLOB类型。</li>
<li>需要注意的是：如果存储的文件过大，数据库的性能会下降。</li>
<li>如果在指定了相关的Blob类型以后，还报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数： <strong>max_allowed_packet=16M</strong>。同时注意：修改了my.ini文件之后，需要重新启动mysql服务。</li>
</ul>
<h3 id="4-2-向数据表中插入大数据类型"><a href="#4-2-向数据表中插入大数据类型" class="headerlink" title="4.2 向数据表中插入大数据类型"></a>4.2 向数据表中插入大数据类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取连接</span></span><br><span class="line">Connection conn = JDBCUtils.getConnection();</span><br><span class="line">		</span><br><span class="line">String sql = <span class="string">&quot;insert into customers(name,email,birth,photo)values(?,?,?,?)&quot;</span>;</span><br><span class="line">PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充占位符</span></span><br><span class="line">ps.setString(<span class="number">1</span>, <span class="string">&quot;徐海强&quot;</span>);</span><br><span class="line">ps.setString(<span class="number">2</span>, <span class="string">&quot;xhq@126.com&quot;</span>);</span><br><span class="line">ps.setDate(<span class="number">3</span>, <span class="keyword">new</span> Date(<span class="keyword">new</span> java.util.Date().getTime()));</span><br><span class="line"><span class="comment">// 操作Blob类型的变量</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;xhq.png&quot;</span>);</span><br><span class="line">ps.setBlob(<span class="number">4</span>, fis);</span><br><span class="line"><span class="comment">//执行</span></span><br><span class="line">ps.execute();</span><br><span class="line">		</span><br><span class="line">fis.close();</span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="4-3-修改数据表中的Blob类型字段"><a href="#4-3-修改数据表中的Blob类型字段" class="headerlink" title="4.3 修改数据表中的Blob类型字段"></a>4.3 修改数据表中的Blob类型字段</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connection conn = JDBCUtils.getConnection();</span><br><span class="line">String sql = <span class="string">&quot;update customers set photo = ? where id = ?&quot;</span>;</span><br><span class="line">PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充占位符</span></span><br><span class="line"><span class="comment">// 操作Blob类型的变量</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;coffee.png&quot;</span>);</span><br><span class="line">ps.setBlob(<span class="number">1</span>, fis);</span><br><span class="line">ps.setInt(<span class="number">2</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">ps.execute();</span><br><span class="line"></span><br><span class="line">fis.close();</span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br></pre></td></tr></table></figure>



<h3 id="4-4-从数据表中读取大数据类型"><a href="#4-4-从数据表中读取大数据类型" class="headerlink" title="4.4 从数据表中读取大数据类型"></a>4.4 从数据表中读取大数据类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String sql = <span class="string">&quot;SELECT id, name, email, birth, photo FROM customer WHERE id = ?&quot;</span>;</span><br><span class="line">conn = getConnection();</span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line">ps.setInt(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">rs = ps.executeQuery();</span><br><span class="line"><span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line">	Integer id = rs.getInt(<span class="number">1</span>);</span><br><span class="line">    String name = rs.getString(<span class="number">2</span>);</span><br><span class="line">	String email = rs.getString(<span class="number">3</span>);</span><br><span class="line">    Date birth = rs.getDate(<span class="number">4</span>);</span><br><span class="line">	Customer cust = <span class="keyword">new</span> Customer(id, name, email, birth);</span><br><span class="line">    System.out.println(cust); </span><br><span class="line">    <span class="comment">//读取Blob类型的字段</span></span><br><span class="line">	Blob photo = rs.getBlob(<span class="number">5</span>);</span><br><span class="line">	InputStream is = photo.getBinaryStream();</span><br><span class="line">	OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;c.jpg&quot;</span>);</span><br><span class="line">	<span class="keyword">byte</span> [] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">		os.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">	&#125;</span><br><span class="line">    JDBCUtils.closeResource(conn, ps, rs);</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">if</span>(is != <span class="keyword">null</span>)&#123;</span><br><span class="line">		is.close();</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">if</span>(os !=  <span class="keyword">null</span>)&#123;</span><br><span class="line">		os.close();</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="第5章-批量插入"><a href="#第5章-批量插入" class="headerlink" title="第5章 批量插入"></a>第5章 批量插入</h2><h3 id="5-1-批量执行SQL语句"><a href="#5-1-批量执行SQL语句" class="headerlink" title="5.1 批量执行SQL语句"></a>5.1 批量执行SQL语句</h3><p>当需要成批插入或者更新记录时，可以采用Java的批量<strong>更新</strong>机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率</p>
<p>JDBC的批量处理语句包括下面三个方法：</p>
<ul>
<li><strong>addBatch(String)：添加需要批量处理的SQL语句或是参数；</strong></li>
<li><strong>executeBatch()：执行批量处理语句；</strong></li>
<li><strong>clearBatch():清空缓存的数据</strong></li>
</ul>
<p>通常我们会遇到两种批量执行SQL语句的情况：</p>
<ul>
<li>多条SQL语句的批量处理；</li>
<li>一个SQL语句的批量传参；</li>
</ul>
<h3 id="5-2-高效的批量插入"><a href="#5-2-高效的批量插入" class="headerlink" title="5.2 高效的批量插入"></a>5.2 高效的批量插入</h3><p>举例：向数据表中插入20000条数据</p>
<ul>
<li>数据库中提供一个goods表。创建如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> goods(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">NAME <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h4 id="5-2-1-实现层次一：使用Statement"><a href="#5-2-1-实现层次一：使用Statement" class="headerlink" title="5.2.1 实现层次一：使用Statement"></a>5.2.1 实现层次一：使用Statement</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connection conn = JDBCUtils.getConnection();</span><br><span class="line">Statement st = conn.createStatement();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">20000</span>;i++)&#123;</span><br><span class="line">	String sql = <span class="string">&quot;insert into goods(name) values(&#x27;name_&#x27; + &quot;</span>+ i +<span class="string">&quot;)&quot;</span>;</span><br><span class="line">	st.executeUpdate(sql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-2-2-实现层次二：使用PreparedStatement"><a href="#5-2-2-实现层次二：使用PreparedStatement" class="headerlink" title="5.2.2 实现层次二：使用PreparedStatement"></a>5.2.2 实现层次二：使用PreparedStatement</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">Connection conn = JDBCUtils.getConnection();</span><br><span class="line">		</span><br><span class="line">String sql = <span class="string">&quot;insert into goods(name)values(?)&quot;</span>;</span><br><span class="line">PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">20000</span>;i++)&#123;</span><br><span class="line">	ps.setString(<span class="number">1</span>, <span class="string">&quot;name_&quot;</span> + i);</span><br><span class="line">	ps.executeUpdate();</span><br><span class="line">&#125;</span><br><span class="line">		</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">//82340</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br></pre></td></tr></table></figure>

<h4 id="5-2-3-实现层次三"><a href="#5-2-3-实现层次三" class="headerlink" title="5.2.3 实现层次三"></a>5.2.3 实现层次三</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 修改1： 使用 addBatch() / executeBatch() / clearBatch()</span></span><br><span class="line"><span class="comment"> * 修改2：mysql服务器默认是关闭批处理的，我们需要通过一个参数，让mysql开启批处理的支持。</span></span><br><span class="line"><span class="comment"> * 		 ?rewriteBatchedStatements=true 写在配置文件的url后面</span></span><br><span class="line"><span class="comment"> * 修改3：使用更新的mysql 驱动：mysql-connector-java-5.1.37-bin.jar</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">	Connection conn = JDBCUtils.getConnection();</span><br><span class="line">		</span><br><span class="line">	String sql = <span class="string">&quot;insert into goods(name)values(?)&quot;</span>;</span><br><span class="line">	PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">1000000</span>;i++)&#123;</span><br><span class="line">		ps.setString(<span class="number">1</span>, <span class="string">&quot;name_&quot;</span> + i);</span><br><span class="line">			</span><br><span class="line">		<span class="comment">//1.“攒”sql</span></span><br><span class="line">		ps.addBatch();</span><br><span class="line">		<span class="keyword">if</span>(i % <span class="number">500</span> == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="comment">//2.执行</span></span><br><span class="line">			ps.executeBatch();</span><br><span class="line">			<span class="comment">//3.清空</span></span><br><span class="line">			ps.clearBatch();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">	System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">//20000条：625                                                                         //1000000条:14733  </span></span><br><span class="line">		</span><br><span class="line">	JDBCUtils.closeResource(conn, ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-4-实现层次四"><a href="#5-2-4-实现层次四" class="headerlink" title="5.2.4 实现层次四"></a>5.2.4 实现层次四</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 层次四：在层次三的基础上操作</span></span><br><span class="line"><span class="comment">* 使用Connection 的 setAutoCommit(false)  /  commit()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert2</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">	Connection conn = JDBCUtils.getConnection();</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//1.设置为不自动提交数据</span></span><br><span class="line">	conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">		</span><br><span class="line">	String sql = <span class="string">&quot;insert into goods(name)values(?)&quot;</span>;</span><br><span class="line">	PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">1000000</span>;i++)&#123;</span><br><span class="line">		ps.setString(<span class="number">1</span>, <span class="string">&quot;name_&quot;</span> + i);</span><br><span class="line">			</span><br><span class="line">		<span class="comment">//1.“攒”sql</span></span><br><span class="line">		ps.addBatch();</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">if</span>(i % <span class="number">500</span> == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="comment">//2.执行</span></span><br><span class="line">			ps.executeBatch();</span><br><span class="line">			<span class="comment">//3.清空</span></span><br><span class="line">			ps.clearBatch();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//2.提交数据</span></span><br><span class="line">	conn.commit();</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">	System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">//1000000条:4978 </span></span><br><span class="line">		</span><br><span class="line">	JDBCUtils.closeResource(conn, ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第6章：-数据库事务"><a href="#第6章：-数据库事务" class="headerlink" title="第6章： 数据库事务"></a>第6章： 数据库事务</h2><h3 id="6-1-数据库事务介绍"><a href="#6-1-数据库事务介绍" class="headerlink" title="6.1 数据库事务介绍"></a>6.1 数据库事务介绍</h3><ul>
<li><p><strong>事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。</strong></p>
</li>
<li><p><strong>事务处理（事务操作）：</strong>保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都**被提交(commit)<strong>，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务</strong>回滚(rollback)**到最初状态。</p>
</li>
<li><p>为确保数据库中数据的<strong>一致性</strong>，数据的操纵应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退到开始状态。 </p>
</li>
</ul>
<h3 id="6-2-JDBC事务处理"><a href="#6-2-JDBC事务处理" class="headerlink" title="6.2 JDBC事务处理"></a>6.2 JDBC事务处理</h3><ul>
<li><p>数据一旦提交，就不可回滚。</p>
</li>
<li><p>数据什么时候意味着提交？</p>
<ul>
<li><strong>当一个连接对象被创建时，默认情况下是自动提交事务</strong>：每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚。</li>
<li><strong>关闭数据库连接，数据就会自动的提交。</strong>如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务。即同一个事务的多个操作必须在同一个连接下。</li>
</ul>
</li>
<li><p><strong>JDBC程序中为了让多个 SQL 语句作为一个事务执行：</strong></p>
<ul>
<li>调用 Connection 对象的 <strong>setAutoCommit(false);</strong> 以取消自动提交事务</li>
<li>在所有的 SQL 语句都成功执行后，调用 <strong>commit();</strong> 方法提交事务</li>
<li>在出现异常时，调用 <strong>rollback();</strong> 方法回滚事务</li>
</ul>
<blockquote>
<p>若此时 Connection 没有被关闭，还可能被重复使用，则需要恢复其自动提交状态 setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。</p>
</blockquote>
</li>
</ul>
<p>【案例：用户AA向用户BB转账100】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJDBCTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Connection conn = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 1.获取数据库连接</span></span><br><span class="line">		conn = JDBCUtils.getConnection();</span><br><span class="line">		<span class="comment">// 2.开启事务</span></span><br><span class="line">		conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">		<span class="comment">// 3.进行数据库操作</span></span><br><span class="line">		String sql1 = <span class="string">&quot;update user_table set balance = balance - 100 where user = ?&quot;</span>;</span><br><span class="line">		update(conn, sql1, <span class="string">&quot;AA&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 模拟网络异常</span></span><br><span class="line">		<span class="comment">//System.out.println(10 / 0);</span></span><br><span class="line"></span><br><span class="line">		String sql2 = <span class="string">&quot;update user_table set balance = balance + 100 where user = ?&quot;</span>;</span><br><span class="line">		update(conn, sql2, <span class="string">&quot;BB&quot;</span>);</span><br><span class="line">		<span class="comment">// 4.若没有异常，则提交事务</span></span><br><span class="line">		conn.commit();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">		<span class="comment">// 5.若有异常，则回滚事务</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			conn.rollback();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">			e1.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//6.恢复每次DML操作的自动提交功能</span></span><br><span class="line">			conn.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//7.关闭连接</span></span><br><span class="line">		JDBCUtils.closeResource(conn, <span class="keyword">null</span>, <span class="keyword">null</span>); </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，对数据库操作的方法为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用事务以后的通用的增删改操作（version 2.0）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Connection conn ,String sql, Object... args)</span> </span>&#123;</span><br><span class="line">	PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 1.获取PreparedStatement的实例 (或：预编译sql语句)</span></span><br><span class="line">		ps = conn.prepareStatement(sql);</span><br><span class="line">		<span class="comment">// 2.填充占位符</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">			ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 3.执行sql语句</span></span><br><span class="line">		ps.execute();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="comment">// 4.关闭资源</span></span><br><span class="line">		JDBCUtils.closeResource(<span class="keyword">null</span>, ps);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-3-事务的ACID属性"><a href="#6-3-事务的ACID属性" class="headerlink" title="6.3 事务的ACID属性"></a>6.3 事务的ACID属性</h3><ol>
<li><p><strong>原子性（Atomicity）</strong><br> 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 </p>
</li>
<li><p><strong>一致性（Consistency）</strong><br> 事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</p>
</li>
<li><p><strong>隔离性（Isolation）</strong><br> 事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
</li>
<li><p><strong>持久性（Durability）</strong><br> 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。</p>
</li>
</ol>
<h4 id="6-3-1-数据库的并发问题"><a href="#6-3-1-数据库的并发问题" class="headerlink" title="6.3.1 数据库的并发问题"></a>6.3.1 数据库的并发问题</h4><ul>
<li><p>对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:</p>
<ul>
<li><strong>脏读</strong>: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还<strong>没有被提交</strong>的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。</li>
<li><strong>不可重复读</strong>: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 <strong>更新</strong>了该字段。之后, T1再次读取同一个字段, 值就不同了。</li>
<li><strong>幻读</strong>: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中<strong>插入</strong>了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。</li>
</ul>
</li>
<li><p><strong>数据库事务的隔离性</strong>: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。</p>
</li>
<li><p>一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, <strong>隔离级别越高, 数据一致性就越好, 但并发性越弱。</strong></p>
</li>
</ul>
<h4 id="6-3-2-四种隔离级别"><a href="#6-3-2-四种隔离级别" class="headerlink" title="6.3.2 四种隔离级别"></a>6.3.2 四种隔离级别</h4><ul>
<li><p>数据库提供的4种事务隔离级别：</p>
<p><img src="assets/1555586275271.png" alt="1555586275271"></p>
</li>
<li><p>Oracle 支持的 2 种事务隔离级别：<strong>READ COMMITED</strong>, SERIALIZABLE。 Oracle 默认的事务隔离级别为: <strong>READ COMMITED</strong> 。</p>
</li>
</ul>
<ul>
<li>Mysql 支持 4 种事务隔离级别。Mysql 默认的事务隔离级别为: <strong>REPEATABLE READ。</strong></li>
</ul>
<h4 id="6-3-3-在MySql中设置隔离级别"><a href="#6-3-3-在MySql中设置隔离级别" class="headerlink" title="6.3.3 在MySql中设置隔离级别"></a>6.3.3 在MySql中设置隔离级别</h4><ul>
<li><p>每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量 @@tx_isolation, 表示当前的事务隔离级别。</p>
</li>
<li><p>查看当前的隔离级别: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT @@tx_isolation;</span><br></pre></td></tr></table></figure></li>
<li><p>设置当前 mySQL 连接的隔离级别:  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set  transaction isolation level read committed;</span><br></pre></td></tr></table></figure></li>
<li><p>设置数据库系统的全局的隔离级别:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global transaction isolation level read committed;</span><br></pre></td></tr></table></figure></li>
<li><p>补充操作：</p>
<ul>
<li><p>创建mysql数据库用户：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create user tom identified by &#39;abc123&#39;;</span><br></pre></td></tr></table></figure></li>
<li><p>授予权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#授予通过网络方式登录的tom用户，对所有库所有表的全部权限，密码设为abc123.</span><br><span class="line">grant all privileges on *.* to tom@&#39;%&#39;  identified by &#39;abc123&#39;; </span><br><span class="line"></span><br><span class="line"> #给tom用户使用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。</span><br><span class="line">grant select,insert,delete,update on atguigudb.* to tom@localhost identified by &#39;abc123&#39;; </span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="第7章：DAO及相关实现类"><a href="#第7章：DAO及相关实现类" class="headerlink" title="第7章：DAO及相关实现类"></a>第7章：DAO及相关实现类</h2><ul>
<li>DAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息。有时也称作：BaseDAO</li>
<li>作用：为了实现功能的模块化，更有利于代码的维护和升级。</li>
<li>下面是尚硅谷JavaWeb阶段书城项目中DAO使用的体现：</li>
</ul>
<p><img src="assets/1566726681515.png" alt="1566726681515"></p>
<ul>
<li>层次结构：</li>
</ul>
<p><img src="assets/1566745811244.png" alt="1566745811244"></p>
<h3 id="【BaseDAO-java】"><a href="#【BaseDAO-java】" class="headerlink" title="【BaseDAO.java】"></a>【BaseDAO.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.QueryRunner;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanListHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.ScalarHandler;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个用来被继承的对数据库进行基本操作的Dao</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HanYanBing</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDao</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> QueryRunner queryRunner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">	<span class="comment">// 定义一个变量来接收泛型的类型</span></span><br><span class="line">	<span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取T的Class对象，获取泛型的类型，泛型是在被子类继承时才确定</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BaseDao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 获取子类的类型</span></span><br><span class="line">		Class clazz = <span class="keyword">this</span>.getClass();</span><br><span class="line">		<span class="comment">// 获取父类的类型</span></span><br><span class="line">		<span class="comment">// getGenericSuperclass()用来获取当前类的父类的类型</span></span><br><span class="line">		<span class="comment">// ParameterizedType表示的是带泛型的类型</span></span><br><span class="line">		ParameterizedType parameterizedType = (ParameterizedType) clazz.getGenericSuperclass();</span><br><span class="line">		<span class="comment">// 获取具体的泛型类型 getActualTypeArguments获取具体的泛型的类型</span></span><br><span class="line">		<span class="comment">// 这个方法会返回一个Type的数组</span></span><br><span class="line">		Type[] types = parameterizedType.getActualTypeArguments();</span><br><span class="line">		<span class="comment">// 获取具体的泛型的类型·</span></span><br><span class="line">		<span class="keyword">this</span>.type = (Class&lt;T&gt;) types[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 通用的增删改操作</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Connection conn,String sql, Object... params)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			count = queryRunner.update(conn, sql, params);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取一个对象</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getBean</span><span class="params">(Connection conn,String sql, Object... params)</span> </span>&#123;</span><br><span class="line">		T t = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			t = queryRunner.query(conn, sql, <span class="keyword">new</span> BeanHandler&lt;T&gt;(type), params);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取所有对象</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getBeanList</span><span class="params">(Connection conn,String sql, Object... params)</span> </span>&#123;</span><br><span class="line">		List&lt;T&gt; list = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			list = queryRunner.query(conn, sql, <span class="keyword">new</span> BeanListHandler&lt;T&gt;(type), params);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取一个但一值得方法，专门用来执行像 select count(*)...这样的sql语句</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">(Connection conn,String sql, Object... params)</span> </span>&#123;</span><br><span class="line">		Object count = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 调用queryRunner的query方法获取一个单一的值</span></span><br><span class="line">			count = queryRunner.query(conn, sql, <span class="keyword">new</span> ScalarHandler&lt;&gt;(), params);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【BookDAO-java】"><a href="#【BookDAO-java】" class="headerlink" title="【BookDAO.java】"></a>【BookDAO.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Book;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Page;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 从数据库中查询出所有的记录</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">List&lt;Book&gt; <span class="title">getBooks</span><span class="params">(Connection conn)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 向数据库中插入一条记录</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> book</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">saveBook</span><span class="params">(Connection conn,Book book)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 从数据库中根据图书的id删除一条记录</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> bookId</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deleteBookById</span><span class="params">(Connection conn,String bookId)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据图书的id从数据库中查询出一条记录</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> bookId</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Book <span class="title">getBookById</span><span class="params">(Connection conn,String bookId)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据图书的id从数据库中更新一条记录</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> book</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">updateBook</span><span class="params">(Connection conn,Book book)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取带分页的图书信息</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> page：是只包含了用户输入的pageNo属性的page对象</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 返回的Page对象是包含了所有属性的Page对象</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Page&lt;Book&gt; <span class="title">getPageBooks</span><span class="params">(Connection conn,Page&lt;Book&gt; page)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取带分页和价格范围的图书信息</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> page：是只包含了用户输入的pageNo属性的page对象</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 返回的Page对象是包含了所有属性的Page对象</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Page&lt;Book&gt; <span class="title">getPageBooksByPrice</span><span class="params">(Connection conn,Page&lt;Book&gt; page, <span class="keyword">double</span> minPrice, <span class="keyword">double</span> maxPrice)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【UserDAO-java】"><a href="#【UserDAO-java】" class="headerlink" title="【UserDAO.java】"></a>【UserDAO.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据User对象中的用户名和密码从数据库中获取一条记录</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> User 数据库中有记录 null 数据库中无此记录</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">User <span class="title">getUser</span><span class="params">(Connection conn,User user)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据User对象中的用户名从数据库中获取一条记录</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> true 数据库中有记录 false 数据库中无此记录</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">checkUsername</span><span class="params">(Connection conn,User user)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 向数据库中插入User对象</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(Connection conn,User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【BookDaoImpl-java】"><a href="#【BookDaoImpl-java】" class="headerlink" title="【BookDaoImpl.java】"></a>【BookDaoImpl.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Book;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Page;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.BaseDao;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.BookDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookDaoImpl</span> <span class="keyword">extends</span> <span class="title">BaseDao</span>&lt;<span class="title">Book</span>&gt; <span class="keyword">implements</span> <span class="title">BookDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBooks</span><span class="params">(Connection conn)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 调用BaseDao中得到一个List的方法</span></span><br><span class="line">		List&lt;Book&gt; beanList = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">// 写sql语句</span></span><br><span class="line">		String sql = <span class="string">&quot;select id,title,author,price,sales,stock,img_path imgPath from books&quot;</span>;</span><br><span class="line">		beanList = getBeanList(conn,sql);</span><br><span class="line">		<span class="keyword">return</span> beanList;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveBook</span><span class="params">(Connection conn,Book book)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 写sql语句</span></span><br><span class="line">		String sql = <span class="string">&quot;insert into books(title,author,price,sales,stock,img_path) values(?,?,?,?,?,?)&quot;</span>;</span><br><span class="line">		<span class="comment">// 调用BaseDao中通用的增删改的方法</span></span><br><span class="line">		update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(),book.getImgPath());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteBookById</span><span class="params">(Connection conn,String bookId)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 写sql语句</span></span><br><span class="line">		String sql = <span class="string">&quot;DELETE FROM books WHERE id = ?&quot;</span>;</span><br><span class="line">		<span class="comment">// 调用BaseDao中通用增删改的方法</span></span><br><span class="line">		update(conn,sql, bookId);</span><br><span class="line">			</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Book <span class="title">getBookById</span><span class="params">(Connection conn,String bookId)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 调用BaseDao中获取一个对象的方法</span></span><br><span class="line">		Book book = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">// 写sql语句</span></span><br><span class="line">		String sql = <span class="string">&quot;select id,title,author,price,sales,stock,img_path imgPath from books where id = ?&quot;</span>;</span><br><span class="line">		book = getBean(conn,sql, bookId);</span><br><span class="line">		<span class="keyword">return</span> book;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateBook</span><span class="params">(Connection conn,Book book)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 写sql语句</span></span><br><span class="line">		String sql = <span class="string">&quot;update books set title = ? , author = ? , price = ? , sales = ? , stock = ? where id = ?&quot;</span>;</span><br><span class="line">		<span class="comment">// 调用BaseDao中通用的增删改的方法</span></span><br><span class="line">		update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(), book.getId());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Page&lt;Book&gt; <span class="title">getPageBooks</span><span class="params">(Connection conn,Page&lt;Book&gt; page)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 获取数据库中图书的总记录数</span></span><br><span class="line">		String sql = <span class="string">&quot;select count(*) from books&quot;</span>;</span><br><span class="line">		<span class="comment">// 调用BaseDao中获取一个单一值的方法</span></span><br><span class="line">		<span class="keyword">long</span> totalRecord = (<span class="keyword">long</span>) getValue(conn,sql);</span><br><span class="line">		<span class="comment">// 将总记录数设置都page对象中</span></span><br><span class="line">		page.setTotalRecord((<span class="keyword">int</span>) totalRecord);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取当前页中的记录存放的List</span></span><br><span class="line">		String sql2 = <span class="string">&quot;select id,title,author,price,sales,stock,img_path imgPath from books limit ?,?&quot;</span>;</span><br><span class="line">		<span class="comment">// 调用BaseDao中获取一个集合的方法</span></span><br><span class="line">		List&lt;Book&gt; beanList = getBeanList(conn,sql2, (page.getPageNo() - <span class="number">1</span>) * Page.PAGE_SIZE, Page.PAGE_SIZE);</span><br><span class="line">		<span class="comment">// 将这个List设置到page对象中</span></span><br><span class="line">		page.setList(beanList);</span><br><span class="line">		<span class="keyword">return</span> page;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Page&lt;Book&gt; <span class="title">getPageBooksByPrice</span><span class="params">(Connection conn,Page&lt;Book&gt; page, <span class="keyword">double</span> minPrice, <span class="keyword">double</span> maxPrice)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 获取数据库中图书的总记录数</span></span><br><span class="line">		String sql = <span class="string">&quot;select count(*) from books where price between ? and ?&quot;</span>;</span><br><span class="line">		<span class="comment">// 调用BaseDao中获取一个单一值的方法</span></span><br><span class="line">		<span class="keyword">long</span> totalRecord = (<span class="keyword">long</span>) getValue(conn,sql,minPrice,maxPrice);</span><br><span class="line">		<span class="comment">// 将总记录数设置都page对象中</span></span><br><span class="line">		page.setTotalRecord((<span class="keyword">int</span>) totalRecord);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取当前页中的记录存放的List</span></span><br><span class="line">		String sql2 = <span class="string">&quot;select id,title,author,price,sales,stock,img_path imgPath from books where price between ? and ? limit ?,?&quot;</span>;</span><br><span class="line">		<span class="comment">// 调用BaseDao中获取一个集合的方法</span></span><br><span class="line">		List&lt;Book&gt; beanList = getBeanList(conn,sql2, minPrice , maxPrice , (page.getPageNo() - <span class="number">1</span>) * Page.PAGE_SIZE, Page.PAGE_SIZE);</span><br><span class="line">		<span class="comment">// 将这个List设置到page对象中</span></span><br><span class="line">		page.setList(beanList);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> page;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【UserDaoImpl-java】"><a href="#【UserDaoImpl-java】" class="headerlink" title="【UserDaoImpl.java】"></a>【UserDaoImpl.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.User;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.BaseDao;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.UserDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title">BaseDao</span>&lt;<span class="title">User</span>&gt; <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(Connection conn,User user)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 调用BaseDao中获取一个对象的方法</span></span><br><span class="line">		User bean = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">// 写sql语句</span></span><br><span class="line">		String sql = <span class="string">&quot;select id,username,password,email from users where username = ? and password = ?&quot;</span>;</span><br><span class="line">		bean = getBean(conn,sql, user.getUsername(), user.getPassword());</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkUsername</span><span class="params">(Connection conn,User user)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 调用BaseDao中获取一个对象的方法</span></span><br><span class="line">		User bean = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">// 写sql语句</span></span><br><span class="line">		String sql = <span class="string">&quot;select id,username,password,email from users where username = ?&quot;</span>;</span><br><span class="line">		bean = getBean(conn,sql, user.getUsername());</span><br><span class="line">		<span class="keyword">return</span> bean != <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(Connection conn,User user)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//写sql语句</span></span><br><span class="line">		String sql = <span class="string">&quot;insert into users(username,password,email) values(?,?,?)&quot;</span>;</span><br><span class="line">		<span class="comment">//调用BaseDao中通用的增删改的方法</span></span><br><span class="line">		update(conn,sql, user.getUsername(),user.getPassword(),user.getEmail());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【Book-java】"><a href="#【Book-java】" class="headerlink" title="【Book.java】"></a>【Book.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.beans;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图书类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songhongkang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line">	<span class="keyword">private</span> String title; <span class="comment">// 书名</span></span><br><span class="line">	<span class="keyword">private</span> String author; <span class="comment">// 作者</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> price; <span class="comment">// 价格</span></span><br><span class="line">	<span class="keyword">private</span> Integer sales; <span class="comment">// 销量</span></span><br><span class="line">	<span class="keyword">private</span> Integer stock; <span class="comment">// 库存</span></span><br><span class="line">	<span class="keyword">private</span> String imgPath = <span class="string">&quot;static/img/default.jpg&quot;</span>; <span class="comment">// 封面图片的路径</span></span><br><span class="line">	<span class="comment">//构造器，get()，set()，toString()方法略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【Page-java】"><a href="#【Page-java】" class="headerlink" title="【Page.java】"></a>【Page.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.beans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 页码类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songhongkang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Page</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> List&lt;T&gt; list; <span class="comment">// 每页查到的记录存放的集合</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PAGE_SIZE = <span class="number">4</span>; <span class="comment">// 每页显示的记录数</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> pageNo; <span class="comment">// 当前页</span></span><br><span class="line"><span class="comment">//	private int totalPageNo; // 总页数，通过计算得到</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> totalRecord; <span class="comment">// 总记录数，通过查询数据库得到</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="【User-java】"><a href="#【User-java】" class="headerlink" title="【User.java】"></a>【User.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.beans;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songhongkang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line">	<span class="keyword">private</span> String username;</span><br><span class="line">	<span class="keyword">private</span> String password;</span><br><span class="line">	<span class="keyword">private</span> String email;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="第8章：数据库连接池"><a href="#第8章：数据库连接池" class="headerlink" title="第8章：数据库连接池"></a>第8章：数据库连接池</h2><h3 id="8-1-JDBC数据库连接池的必要性"><a href="#8-1-JDBC数据库连接池的必要性" class="headerlink" title="8.1 JDBC数据库连接池的必要性"></a>8.1 JDBC数据库连接池的必要性</h3><ul>
<li><p>在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤：　　</p>
<ul>
<li><strong>在主程序（如servlet、beans）中建立数据库连接</strong></li>
<li><strong>进行sql操作</strong></li>
<li><strong>断开数据库连接</strong></li>
</ul>
</li>
<li><p>这种模式开发，存在的问题:</p>
<ul>
<li>普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。<strong>数据库的连接资源并没有得到很好的重复利用。</strong>若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。</li>
<li><strong>对于每一次数据库连接，使用完后都得断开。</strong>否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。（回忆：何为Java的内存泄漏？）</li>
<li><strong>这种开发不能控制被创建的连接对象数</strong>，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。 </li>
</ul>
</li>
</ul>
<h3 id="8-2-数据库连接池技术"><a href="#8-2-数据库连接池技术" class="headerlink" title="8.2 数据库连接池技术"></a>8.2 数据库连接池技术</h3><ul>
<li><p>为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。</p>
</li>
<li><p><strong>数据库连接池的基本思想</strong>：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。</p>
</li>
<li><p><strong>数据库连接池</strong>负责分配、管理和释放数据库连接，它<strong>允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个</strong>。</p>
</li>
<li><p>数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由<strong>最小数据库连接数来设定</strong>的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的<strong>最大数据库连接数量</strong>限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。</p>
</li>
</ul>
<p><img src="assets/1555593464033.png" alt="1555593464033"></p>
<ul>
<li><strong>工作原理：</strong></li>
</ul>
<p><img src="assets/1555593598606.png" alt="1555593598606"></p>
<ul>
<li><p><strong>数据库连接池技术的优点</strong></p>
<p><strong>1. 资源重用</strong></p>
<p>由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。</p>
<p><strong>2. 更快的系统反应速度</strong></p>
<p>数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间</p>
<p><strong>3. 新的资源分配手段</strong></p>
<p>对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源</p>
<p><strong>4. 统一的连接管理，避免数据库连接泄漏</strong></p>
<p>在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露</p>
</li>
</ul>
<h3 id="8-3-多种开源的数据库连接池"><a href="#8-3-多种开源的数据库连接池" class="headerlink" title="8.3 多种开源的数据库连接池"></a>8.3 多种开源的数据库连接池</h3><ul>
<li>JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现：<ul>
<li><strong>DBCP</strong> 是Apache提供的数据库连接池。tomcat 服务器自带dbcp数据库连接池。<strong>速度相对c3p0较快</strong>，但因自身存在BUG，Hibernate3已不再提供支持。</li>
<li><strong>C3P0</strong> 是一个开源组织提供的一个数据库连接池，<strong>速度相对较慢，稳定性还可以。</strong>hibernate官方推荐使用</li>
<li><strong>Proxool</strong> 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，<strong>稳定性较c3p0差一点</strong></li>
<li><strong>BoneCP</strong> 是一个开源组织提供的数据库连接池，速度快</li>
<li><strong>Druid</strong> 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不确定是否有BoneCP快</li>
</ul>
</li>
<li>DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池</li>
<li><strong>DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度。</strong></li>
<li>特别注意：<ul>
<li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此<strong>整个应用只需要一个数据源即可。</strong></li>
<li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li>
</ul>
</li>
</ul>
<h4 id="8-3-1-C3P0数据库连接池"><a href="#8-3-1-C3P0数据库连接池" class="headerlink" title="8.3.1 C3P0数据库连接池"></a>8.3.1 C3P0数据库连接池</h4><ul>
<li>获取连接方式一</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用C3P0数据库连接池的方式，获取数据库的连接：不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	ComboPooledDataSource cpds = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">	cpds.setDriverClass(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>); </span><br><span class="line">	cpds.setJdbcUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>);</span><br><span class="line">	cpds.setUser(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">	cpds.setPassword(<span class="string">&quot;abc123&quot;</span>);</span><br><span class="line">		</span><br><span class="line"><span class="comment">//	cpds.setMaxPoolSize(100);</span></span><br><span class="line">	</span><br><span class="line">	Connection conn = cpds.getConnection();</span><br><span class="line">	<span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>获取连接方式二</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用C3P0数据库连接池的配置文件方式，获取数据库的连接：推荐</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DataSource cpds = <span class="keyword">new</span> ComboPooledDataSource(<span class="string">&quot;helloc3p0&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection2</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>&#123;</span><br><span class="line">	Connection conn = cpds.getConnection();</span><br><span class="line">	<span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，src下的配置文件为：【c3p0-config.xml】</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">named-config</span> <span class="attr">name</span>=<span class="string">&quot;helloc3p0&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 获取连接的4个基本信息 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>abc123<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql:///test<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- 涉及到数据库连接池的管理的相关属性的设置 --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 若数据库中连接数不足时, 一次向数据库服务器申请多少个连接 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;acquireIncrement&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 初始化数据库连接池时连接的数量 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 数据库连接池中的最小的数据库连接数 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 数据库连接池中的最大的数据库连接数 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- C3P0 数据库连接池可以维护的 Statement 的个数 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatements&quot;</span>&gt;</span>20<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 每个连接同时可以使用的 Statement 对象的个数 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatementsPerConnection&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;/<span class="name">named-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="8-3-2-DBCP数据库连接池"><a href="#8-3-2-DBCP数据库连接池" class="headerlink" title="8.3.2 DBCP数据库连接池"></a>8.3.2 DBCP数据库连接池</h4><ul>
<li>DBCP 是 Apache 软件基金组织下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Common-pool。如需使用该连接池实现，应在系统中增加如下两个 jar 文件：<ul>
<li>Commons-dbcp.jar：连接池的实现</li>
<li>Commons-pool.jar：连接池实现的依赖库</li>
</ul>
</li>
<li><strong>Tomcat 的连接池正是采用该连接池来实现的。</strong>该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。</li>
<li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。</li>
<li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但上面的代码并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li>
<li>配置属性说明</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>initialSize</td>
<td>0</td>
<td>连接池启动时创建的初始化连接数量</td>
</tr>
<tr>
<td>maxActive</td>
<td>8</td>
<td>连接池中可同时连接的最大的连接数</td>
</tr>
<tr>
<td>maxIdle</td>
<td>8</td>
<td>连接池中最大的空闲的连接数，超过的空闲连接将被释放，如果设置为负数表示不限制</td>
</tr>
<tr>
<td>minIdle</td>
<td>0</td>
<td>连接池中最小的空闲的连接数，低于这个数量会被创建新的连接。该参数越接近maxIdle，性能越好，因为连接的创建和销毁，都是需要消耗资源的；但是不能太大。</td>
</tr>
<tr>
<td>maxWait</td>
<td>无限制</td>
<td>最大等待时间，当没有可用连接时，连接池等待连接释放的最大时间，超过该时间限制会抛出异常，如果设置-1表示无限等待</td>
</tr>
<tr>
<td>poolPreparedStatements</td>
<td>false</td>
<td>开启池的Statement是否prepared</td>
</tr>
<tr>
<td>maxOpenPreparedStatements</td>
<td>无限制</td>
<td>开启池的prepared 后的同时最大连接数</td>
</tr>
<tr>
<td>minEvictableIdleTimeMillis</td>
<td></td>
<td>连接池中连接，在时间段内一直空闲， 被逐出连接池的时间</td>
</tr>
<tr>
<td>removeAbandonedTimeout</td>
<td>300</td>
<td>超过时间限制，回收没有用(废弃)的连接</td>
</tr>
<tr>
<td>removeAbandoned</td>
<td>false</td>
<td>超过removeAbandonedTimeout时间后，是否进 行没用连接（废弃）的回收</td>
</tr>
</tbody></table>
<ul>
<li>获取连接方式一：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection3</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	BasicDataSource source = <span class="keyword">new</span> BasicDataSource();</span><br><span class="line">		</span><br><span class="line">	source.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">	source.setUrl(<span class="string">&quot;jdbc:mysql:///test&quot;</span>);</span><br><span class="line">	source.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">	source.setPassword(<span class="string">&quot;abc123&quot;</span>);</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	source.setInitialSize(<span class="number">10</span>);</span><br><span class="line">		</span><br><span class="line">	Connection conn = source.getConnection();</span><br><span class="line">	<span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取连接方式二：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用dbcp数据库连接池的配置文件方式，获取数据库的连接：推荐</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DataSource source = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">		</span><br><span class="line">		InputStream is = DBCPTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;dbcp.properties&quot;</span>);</span><br><span class="line">			</span><br><span class="line">		pros.load(is);</span><br><span class="line">		<span class="comment">//根据提供的BasicDataSourceFactory创建对应的DataSource对象</span></span><br><span class="line">		source = BasicDataSourceFactory.createDataSource(pros);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection4</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		</span><br><span class="line">	Connection conn = source.getConnection();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，src下的配置文件为：【dbcp.properties】</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true&amp;useServerPrepStmts=false</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">abc123</span></span><br><span class="line"></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">10</span></span><br><span class="line"><span class="comment">#...</span></span><br></pre></td></tr></table></figure>



<h4 id="8-3-3-Druid（德鲁伊）数据库连接池"><a href="#8-3-3-Druid（德鲁伊）数据库连接池" class="headerlink" title="8.3.3 Druid（德鲁伊）数据库连接池"></a>8.3.3 Druid（德鲁伊）数据库连接池</h4><p>Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，<strong>可以说是目前最好的连接池之一。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.druid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDruid</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Properties pro = <span class="keyword">new</span> Properties();		 pro.load(TestDruid.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>));</span><br><span class="line">		DataSource ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">		Connection conn = ds.getConnection();</span><br><span class="line">		System.out.println(conn);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，src下的配置文件为：【druid.properties】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">url=jdbc:mysql:<span class="comment">//localhost:3306/test?rewriteBatchedStatements=true</span></span><br><span class="line">username=root</span><br><span class="line">password=<span class="number">123456</span></span><br><span class="line">driverClassName=com.mysql.jdbc.Driver</span><br><span class="line"></span><br><span class="line">initialSize=<span class="number">10</span></span><br><span class="line">maxActive=<span class="number">20</span></span><br><span class="line">maxWait=<span class="number">1000</span></span><br><span class="line">filters=wall</span><br></pre></td></tr></table></figure>

<ul>
<li>详细配置参数：</li>
</ul>
<table>
<thead>
<tr>
<th><strong>配置</strong></th>
<th><strong>缺省</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td></td>
<td>配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。   如果没有配置，将会生成一个名字，格式是：”DataSource-” +   System.identityHashCode(this)</td>
</tr>
<tr>
<td>url</td>
<td></td>
<td>连接数据库的url，不同数据库不一样。例如：mysql :   jdbc:mysql://10.20.153.104:3306/druid2      oracle :   jdbc:oracle:thin:@10.20.149.85:1521:ocnauto</td>
</tr>
<tr>
<td>username</td>
<td></td>
<td>连接数据库的用户名</td>
</tr>
<tr>
<td>password</td>
<td></td>
<td>连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：<a href="https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter">https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter</a></td>
</tr>
<tr>
<td>driverClassName</td>
<td></td>
<td>根据url自动识别   这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下)</td>
</tr>
<tr>
<td>initialSize</td>
<td>0</td>
<td>初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时</td>
</tr>
<tr>
<td>maxActive</td>
<td>8</td>
<td>最大连接池数量</td>
</tr>
<tr>
<td>maxIdle</td>
<td>8</td>
<td>已经不再使用，配置了也没效果</td>
</tr>
<tr>
<td>minIdle</td>
<td></td>
<td>最小连接池数量</td>
</tr>
<tr>
<td>maxWait</td>
<td></td>
<td>获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。</td>
</tr>
<tr>
<td>poolPreparedStatements</td>
<td>false</td>
<td>是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。</td>
</tr>
<tr>
<td>maxOpenPreparedStatements</td>
<td>-1</td>
<td>要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100</td>
</tr>
<tr>
<td>validationQuery</td>
<td></td>
<td>用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。</td>
</tr>
<tr>
<td>testOnBorrow</td>
<td>true</td>
<td>申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。</td>
</tr>
<tr>
<td>testOnReturn</td>
<td>false</td>
<td>归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能</td>
</tr>
<tr>
<td>testWhileIdle</td>
<td>false</td>
<td>建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。</td>
</tr>
<tr>
<td>timeBetweenEvictionRunsMillis</td>
<td></td>
<td>有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的判断依据，详细看testWhileIdle属性的说明</td>
</tr>
<tr>
<td>numTestsPerEvictionRun</td>
<td></td>
<td>不再使用，一个DruidDataSource只支持一个EvictionRun</td>
</tr>
<tr>
<td>minEvictableIdleTimeMillis</td>
<td></td>
<td></td>
</tr>
<tr>
<td>connectionInitSqls</td>
<td></td>
<td>物理连接初始化的时候执行的sql</td>
</tr>
<tr>
<td>exceptionSorter</td>
<td></td>
<td>根据dbType自动识别   当数据库抛出一些不可恢复的异常时，抛弃连接</td>
</tr>
<tr>
<td>filters</td>
<td></td>
<td>属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：   监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall</td>
</tr>
<tr>
<td>proxyFilters</td>
<td></td>
<td>类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系</td>
</tr>
</tbody></table>
<h2 id="第9章：Apache-DBUtils实现CRUD操作"><a href="#第9章：Apache-DBUtils实现CRUD操作" class="headerlink" title="第9章：Apache-DBUtils实现CRUD操作"></a>第9章：Apache-DBUtils实现CRUD操作</h2><h3 id="9-1-Apache-DBUtils简介"><a href="#9-1-Apache-DBUtils简介" class="headerlink" title="9.1 Apache-DBUtils简介"></a>9.1 Apache-DBUtils简介</h3><ul>
<li><p>commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。</p>
</li>
<li><p>API介绍：</p>
<ul>
<li>org.apache.commons.dbutils.QueryRunner</li>
<li>org.apache.commons.dbutils.ResultSetHandler</li>
<li>工具类：org.apache.commons.dbutils.DbUtils   </li>
</ul>
</li>
<li><p>API包说明：</p>
</li>
</ul>
<p><img src="assets/1555595163263.png" alt="1555595163263"></p>
<p><img src="assets/1555595198644.png" alt="1555595198644"></p>
<h3 id="9-2-主要API的使用"><a href="#9-2-主要API的使用" class="headerlink" title="9.2 主要API的使用"></a>9.2 主要API的使用</h3><h4 id="9-2-1-DbUtils"><a href="#9-2-1-DbUtils" class="headerlink" title="9.2.1 DbUtils"></a>9.2.1 DbUtils</h4><ul>
<li>DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下：<ul>
<li><strong>public static void close(…) throws java.sql.SQLException</strong>：　DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。</li>
<li>public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。</li>
<li>public static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务，然后关闭连接</li>
<li>public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。 </li>
<li>public static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做了判断</li>
<li>public static void rollbackAndClose(Connection conn)throws SQLException</li>
<li>rollbackAndCloseQuietly(Connection)</li>
<li>public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。</li>
</ul>
</li>
</ul>
<h4 id="9-2-2-QueryRunner类"><a href="#9-2-2-QueryRunner类" class="headerlink" title="9.2.2 QueryRunner类"></a>9.2.2 QueryRunner类</h4><ul>
<li><p><strong>该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。</strong></p>
</li>
<li><p>QueryRunner类提供了两个构造器：</p>
<ul>
<li>默认的构造器</li>
<li>需要一个 javax.sql.DataSource 来作参数的构造器</li>
</ul>
</li>
<li><p>QueryRunner类的主要方法：</p>
<ul>
<li><strong>更新</strong><ul>
<li>public int update(Connection conn, String sql, Object… params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。</li>
<li> ……</li>
</ul>
</li>
<li><strong>插入</strong><ul>
<li>public <T> T insert(Connection conn,String sql,ResultSetHandler<T> rsh, Object… params) throws SQLException：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys.  返回值: An object generated by the handler.即自动生成的键值</li>
<li>….</li>
</ul>
</li>
<li><strong>批处理</strong><ul>
<li>public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句</li>
<li>public <T> T insertBatch(Connection conn,String sql,ResultSetHandler<T> rsh,Object[][] params)throws SQLException：只支持INSERT语句</li>
<li>…..</li>
</ul>
</li>
<li><strong>查询</strong><ul>
<li>public Object query(Connection conn, String sql, ResultSetHandler rsh,Object… params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。</li>
<li>…… </li>
</ul>
</li>
</ul>
</li>
<li><p>测试</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试添加</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">	Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">	String sql = <span class="string">&quot;insert into customers(name,email,birth)values(?,?,?)&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> count = runner.update(conn, sql, <span class="string">&quot;何成飞&quot;</span>, <span class="string">&quot;he@qq.com&quot;</span>, <span class="string">&quot;1992-09-08&quot;</span>);</span><br><span class="line"></span><br><span class="line">	System.out.println(<span class="string">&quot;添加了&quot;</span> + count + <span class="string">&quot;条记录&quot;</span>);</span><br><span class="line">		</span><br><span class="line">	JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试删除</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">	Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">	String sql = <span class="string">&quot;delete from customers where id &lt; ?&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> count = runner.update(conn, sql,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	System.out.println(<span class="string">&quot;删除了&quot;</span> + count + <span class="string">&quot;条记录&quot;</span>);</span><br><span class="line">		</span><br><span class="line">	JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="9-2-3-ResultSetHandler接口及实现类"><a href="#9-2-3-ResultSetHandler接口及实现类" class="headerlink" title="9.2.3 ResultSetHandler接口及实现类"></a>9.2.3 ResultSetHandler接口及实现类</h4><ul>
<li><p>该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。</p>
</li>
<li><p>ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。</p>
</li>
<li><p>接口的主要实现类：</p>
<ul>
<li>ArrayHandler：把结果集中的第一行数据转成对象数组。</li>
<li>ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。</li>
<li><strong>BeanHandler：</strong>将结果集中的第一行数据封装到一个对应的JavaBean实例中。</li>
<li><strong>BeanListHandler：</strong>将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。</li>
<li>ColumnListHandler：将结果集中某一列的数据存放到List中。</li>
<li>KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。</li>
<li><strong>MapHandler：</strong>将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。</li>
<li><strong>MapListHandler：</strong>将结果集中的每一行数据都封装到一个Map里，然后再存放到List</li>
<li><strong>ScalarHandler：</strong>查询单个值对象</li>
</ul>
</li>
<li><p>测试</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 测试查询:查询一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 使用ResultSetHandler的实现类：BeanHandler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryInstance</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">	Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">		</span><br><span class="line">	String sql = <span class="string">&quot;select id,name,email,birth from customers where id = ?&quot;</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	BeanHandler&lt;Customer&gt; handler = <span class="keyword">new</span> BeanHandler&lt;&gt;(Customer.class);</span><br><span class="line">	Customer customer = runner.query(conn, sql, handler, <span class="number">23</span>);</span><br><span class="line">	System.out.println(customer);	</span><br><span class="line">	JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 测试查询:查询多条记录构成的集合</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 使用ResultSetHandler的实现类：BeanListHandler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryList</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">	Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">		</span><br><span class="line">	String sql = <span class="string">&quot;select id,name,email,birth from customers where id &lt; ?&quot;</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	BeanListHandler&lt;Customer&gt; handler = <span class="keyword">new</span> BeanListHandler&lt;&gt;(Customer.class);</span><br><span class="line">	List&lt;Customer&gt; list = runner.query(conn, sql, handler, <span class="number">23</span>);</span><br><span class="line">	list.forEach(System.out::println);</span><br><span class="line">		</span><br><span class="line">	JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 自定义ResultSetHandler的实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryInstance1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">	Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">		</span><br><span class="line">	String sql = <span class="string">&quot;select id,name,email,birth from customers where id = ?&quot;</span>;</span><br><span class="line">		</span><br><span class="line">	ResultSetHandler&lt;Customer&gt; handler = <span class="keyword">new</span> ResultSetHandler&lt;Customer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Customer <span class="title">handle</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;handle&quot;</span>);</span><br><span class="line"><span class="comment">//			return new Customer(1,&quot;Tom&quot;,&quot;tom@126.com&quot;,new Date(123323432L));</span></span><br><span class="line">				</span><br><span class="line">			<span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line">				<span class="keyword">int</span> id = rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">				String name = rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">				String email = rs.getString(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">				Date birth = rs.getDate(<span class="string">&quot;birth&quot;</span>);</span><br><span class="line">					</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> Customer(id, name, email, birth);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">				</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">		</span><br><span class="line">	Customer customer = runner.query(conn, sql, handler, <span class="number">23</span>);</span><br><span class="line">		</span><br><span class="line">	System.out.println(customer);</span><br><span class="line">		</span><br><span class="line">	JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如何查询类似于最大的，最小的，平均的，总和，个数相关的数据，</span></span><br><span class="line"><span class="comment"> * 使用ScalarHandler</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryValue</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">	Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//测试一：</span></span><br><span class="line"><span class="comment">//	String sql = &quot;select count(*) from customers where id &lt; ?&quot;;</span></span><br><span class="line"><span class="comment">//	ScalarHandler handler = new ScalarHandler();</span></span><br><span class="line"><span class="comment">//	long count = (long) runner.query(conn, sql, handler, 20);</span></span><br><span class="line"><span class="comment">//	System.out.println(count);</span></span><br><span class="line">		</span><br><span class="line">	<span class="comment">//测试二：</span></span><br><span class="line">	String sql = <span class="string">&quot;select max(birth) from customers&quot;</span>;</span><br><span class="line">	ScalarHandler handler = <span class="keyword">new</span> ScalarHandler();</span><br><span class="line">	Date birth = (Date) runner.query(conn, sql, handler);</span><br><span class="line">	System.out.println(birth);</span><br><span class="line">		</span><br><span class="line">	JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JDBC总结"><a href="#JDBC总结" class="headerlink" title="JDBC总结"></a>JDBC总结</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">总结</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdateWithTx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	Connection conn = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//1.获取连接的操作（</span></span><br><span class="line">		<span class="comment">//① 手写的连接：JDBCUtils.getConnection();</span></span><br><span class="line">		<span class="comment">//② 使用数据库连接池：C3P0;DBCP;Druid</span></span><br><span class="line">		<span class="comment">//2.对数据表进行一系列CRUD操作</span></span><br><span class="line">		<span class="comment">//① 使用PreparedStatement实现通用的增删改、查询操作（version 1.0 \ version 2.0)</span></span><br><span class="line"><span class="comment">//version2.0的增删改public void update(Connection conn,String sql,Object ... args)&#123;&#125;</span></span><br><span class="line"><span class="comment">//version2.0的查询 public &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz,String sql,Object ... args)&#123;&#125;</span></span><br><span class="line">		<span class="comment">//② 使用dbutils提供的jar包中提供的QueryRunner类</span></span><br><span class="line">			</span><br><span class="line">		<span class="comment">//提交数据</span></span><br><span class="line">		conn.commit();</span><br><span class="line">			</span><br><span class="line">	</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//回滚数据</span></span><br><span class="line">			conn.rollback();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">			e1.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">		<span class="comment">//3.关闭连接等操作</span></span><br><span class="line">		<span class="comment">//① JDBCUtils.closeResource();</span></span><br><span class="line">		<span class="comment">//② 使用dbutils提供的jar包中提供的DbUtils类提供了关闭的相关操作</span></span><br><span class="line">			</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
        <tag>SQL</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Listener</title>
    <url>/2023/07/15/Listener/</url>
    <content><![CDATA[<h1 id="监听器笔记"><a href="#监听器笔记" class="headerlink" title="监听器笔记"></a>监听器笔记</h1><h2 id="1、观察者模式"><a href="#1、观察者模式" class="headerlink" title="1、观察者模式"></a>1、观察者模式</h2><p><img src="assets/Listener/intro.png" alt="./images"></p>
<ul>
<li>观察者监控被观察者的行为</li>
<li>被观察者做出相应的动作会触发事件</li>
<li>当观察者发现被观察者触发事件，就会调用事先准备好的方法</li>
</ul>
<h2 id="2、监听器分类"><a href="#2、监听器分类" class="headerlink" title="2、监听器分类"></a>2、监听器分类</h2><ul>
<li>监听域对象本身<ul>
<li>ServletContext</li>
<li>HttpSession</li>
<li>HttpServletRequest</li>
</ul>
</li>
<li>监听域对象的属性域<ul>
<li>应用域</li>
<li>会话域</li>
<li>请求域</li>
</ul>
</li>
<li>监听存入Session域的对象本身<ul>
<li>对象是否存入会话域</li>
<li>对象是否和Session一起被钝化到了硬盘上</li>
</ul>
</li>
</ul>
<h2 id="3、后续用到的监听器"><a href="#3、后续用到的监听器" class="headerlink" title="3、后续用到的监听器"></a>3、后续用到的监听器</h2><p>名称：ServletContextListener</p>
<p>方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>contextInitialized(ServletContextEvent sce)</td>
<td>ServletContext创建时调用</td>
</tr>
<tr>
<td>contextDestroyed(ServletContextEvent sce)</td>
<td>ServletContext销毁时调用</td>
</tr>
</tbody></table>
<blockquote>
<p>将来在SpringMVC中会用到：ContextLoaderListener，这个监听器就是实现了ServletContextListener接口。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux磁盘分区、挂载度</title>
    <url>/2023/09/19/Linux%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E3%80%81%E6%8C%82%E8%BD%BD%E5%BA%A6/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="Linux磁盘分区、挂载度"><a href="#Linux磁盘分区、挂载度" class="headerlink" title="Linux磁盘分区、挂载度"></a>Linux磁盘分区、挂载度</h1><h2 id="1-分区方式"><a href="#1-分区方式" class="headerlink" title="1. 分区方式"></a>1. 分区方式</h2><ul>
<li>MBR分区<ul>
<li>最多支持四个主分区</li>
<li>系统只能安装在主分区</li>
<li>扩展分区要占一个主分区</li>
<li>MBR最大只支持2TB，但拥有最好的兼容性</li>
</ul>
</li>
<li>GPT分区<ul>
<li>支持无限多个主分区（但操作系统可能限制，比如windows下最多128个分区）</li>
<li>最大支持18EB的大容量（1EB=1024PB，PB=1024TB）</li>
<li>windows7 64位以后支持gpt</li>
</ul>
</li>
</ul>
<h2 id="2-Linux分区"><a href="#2-Linux分区" class="headerlink" title="2. Linux分区"></a>2. Linux分区</h2><h3 id="2-1-分区原理"><a href="#2-1-分区原理" class="headerlink" title="2.1 分区原理"></a>2.1 分区原理</h3><ul>
<li>Linux来说无论有几个分区，分给哪一个目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构，Linux中每个分区都是用来组成整个文件系统的一部分。</li>
<li>Linux采用了一种叫做“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。<br><img src="../imgs/3/3.8Linux%E5%88%86%E5%8C%BA%E5%8E%9F%E7%90%86.jpg" alt="3.8Linux分区原理"></li>
</ul>
<h3 id="2-2-硬盘说明"><a href="#2-2-硬盘说明" class="headerlink" title="2.2 硬盘说明"></a>2.2 硬盘说明</h3><ul>
<li>Linux硬盘分IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘</li>
<li>lsblk [-f]：查看当前系统的分区和挂载情况。（list block）</li>
</ul>
<h3 id="3-挂载硬盘"><a href="#3-挂载硬盘" class="headerlink" title="3. 挂载硬盘"></a>3. 挂载硬盘</h3><blockquote>
<p>需求是给我们的Linux系统增加一个新的硬盘，并且挂载到/home/newdisk</p>
</blockquote>
<ol>
<li>添加硬盘</li>
<li>分区：fdisk /dev/sdb</li>
<li>格式化：mkfs -t ext4 /dev/sdb1</li>
<li>挂载：新建目录：mkdir /home/newdisk；挂载：mount /dev/sdb1 /home/newdisk</li>
<li>设置可以自动挂载（永久挂载）：重启系统后，仍然可以挂载。vim etc/fstab 增加挂载信息。mount -a：生效</li>
</ol>
<h3 id="3-1-具体步骤"><a href="#3-1-具体步骤" class="headerlink" title="3.1 具体步骤"></a>3.1 具体步骤</h3><h4 id="3-1-1-增加硬盘"><a href="#3-1-1-增加硬盘" class="headerlink" title="3.1.1 增加硬盘"></a>3.1.1 增加硬盘</h4><p><img src="../imgs/3/3.8%E5%A2%9E%E5%8A%A0%E7%A1%AC%E7%9B%98.jpg" alt="3.8增加硬盘.jpg"></p>
<h4 id="3-1-2-硬盘分区"><a href="#3-1-2-硬盘分区" class="headerlink" title="3.1.2 硬盘分区"></a>3.1.2 硬盘分区</h4><p><img src="../imgs/3/3.8%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA.jpg" alt="3.8硬盘分区.jpg"></p>
<h4 id="3-1-3-格式化磁盘"><a href="#3-1-3-格式化磁盘" class="headerlink" title="3.1.3 格式化磁盘"></a>3.1.3 格式化磁盘</h4><p><img src="../imgs/3/3.8%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%A3%81%E7%9B%98.jpg" alt="3.8格式化磁盘.jpg"></p>
<h4 id="3-1-4-挂载硬盘"><a href="#3-1-4-挂载硬盘" class="headerlink" title="3.1.4 挂载硬盘"></a>3.1.4 挂载硬盘</h4><p><img src="../imgs/3/3.8%E6%8C%82%E8%BD%BD%E7%A1%AC%E7%9B%98.jpg" alt="3.8格式化磁盘.jpg"></p>
<h4 id="3-1-5-永久挂载"><a href="#3-1-5-永久挂载" class="headerlink" title="3.1.5 永久挂载"></a>3.1.5 永久挂载</h4><p><img src="../imgs/3/3.8%E6%B0%B8%E4%B9%85%E6%8C%82%E8%BD%BD.jpg" alt="3.8格式化磁盘.jpg"></p>
<h3 id="3-2-取消挂载"><a href="#3-2-取消挂载" class="headerlink" title="3.2 取消挂载"></a>3.2 取消挂载</h3><ul>
<li>取消挂载：unmount /dev/sdb1</li>
</ul>
<h2 id="4-磁盘状况查询"><a href="#4-磁盘状况查询" class="headerlink" title="4. 磁盘状况查询"></a>4. 磁盘状况查询</h2><ul>
<li>磁盘情况查询：df -h / df -l</li>
</ul>
<blockquote>
<p>实例</p>
</blockquote>
<p><img src="../imgs/3/3.8%E6%9F%A5%E8%AF%A2%E7%B3%BB%E7%BB%9F%E7%A3%81%E7%9B%98.jpg" alt="3.8查询系统磁盘"></p>
<ul>
<li>查询指定目录的磁盘占用情况：du -h /目录，默认为当前目录<ul>
<li>-s：指定目录占用大小汇总</li>
<li>-h：带计量单位</li>
<li>-a：含文件</li>
<li>–max-depth=1：子目录深度</li>
<li>-c：列出明细的同时，增加汇总值</li>
</ul>
</li>
</ul>
<blockquote>
<p>实例</p>
</blockquote>
<p><img src="../imgs/3/3.8%E6%9F%A5%E8%AF%A2%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95.jpg" alt="3.8查询指定目录"></p>
<ul>
<li>磁盘情况-工作实用指令<ul>
<li>统计/home文件夹下文件的个数：ls -l /home | grep “^-“ | wc -l</li>
<li>统计/home文件夹下目录的个数：ls -l /home | grep “^d” | wc -l</li>
<li>统计/home文件夹下文件的个数，包括子文件夹里的：ls -lR /home | grep “^-“ | wc -l</li>
<li>统计文件夹下目录的个数，包括子文件夹里的：ls -lR /home | grep “^d” | wc -l</li>
<li>以树状显示目录结构：首先安装tree指令：yum install tree，tree</li>
</ul>
</li>
</ul>
<blockquote>
<p>实例</p>
</blockquote>
<p><img src="../imgs/3/3.8%E5%B7%A5%E4%BD%9C%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A41.jpg" alt="3.8工作实用指令1"><br><img src="../imgs/3/3.8%E5%B7%A5%E4%BD%9C%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A42.jpg" alt="3.8工作实用指令1.jpg"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB必知必会</title>
    <url>/2024/01/16/MongoDB/</url>
    <content><![CDATA[<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><h4 id="1-什么是MongoDB"><a href="#1-什么是MongoDB" class="headerlink" title="1.什么是MongoDB"></a>1.什么是MongoDB</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MongoDB是一个文档数据库，提供好的性能，领先的非关系型数据库。采用BSON存储文档数据。</span><br><span class="line">BSON（）是一种类json的一种二进制形式的存储格式，简称Binary JSON.</span><br><span class="line">相对于json多了date类型和二进制数组。</span><br></pre></td></tr></table></figure>

<h4 id="2-MongoDB的优势有哪些"><a href="#2-MongoDB的优势有哪些" class="headerlink" title="2.MongoDB的优势有哪些"></a>2.MongoDB的优势有哪些</h4><ul>
<li>面向文档的存储：以 JSON 格式的文档保存数据。</li>
<li>任何属性都可以建立索引。</li>
<li>复制以及高可扩展性。</li>
<li>自动分片。</li>
<li>丰富的查询功能。</li>
<li>快速的即时更新。</li>
</ul>
<h4 id="3-什么是数据库"><a href="#3-什么是数据库" class="headerlink" title="3.什么是数据库"></a>3.什么是数据库</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据库可以看成是一个电子化的文件柜,用户可以对文件中的数据运行新增、检索、更新、删除等操作。数据库是一个</span><br><span class="line">所有集合的容器，在文件系统中每一个数据库都有一个相关的物理文件。</span><br></pre></td></tr></table></figure>

<h4 id="4-什么是集合-表"><a href="#4-什么是集合-表" class="headerlink" title="4.什么是集合(表)"></a>4.什么是集合(表)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">集合就是一组 MongoDB 文档。它相当于关系型数据库（RDBMS）中的表这种概念。集合位于单独的一个数据库中。</span><br><span class="line">一个集合内的多个文档可以有多个不同的字段。一般来说，集合中的文档都有着相同或相关的目的。</span><br></pre></td></tr></table></figure>

<h4 id="5-什么是文档-记录"><a href="#5-什么是文档-记录" class="headerlink" title="5 什么是文档(记录)"></a>5 什么是文档(记录)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　　文档由一组key value组成。文档是动态模式,这意味着同一集合里的文档不需要有相同的字段和结构。在关系型</span><br><span class="line">数据库中table中的每一条记录相当于MongoDB中的一个文档</span><br></pre></td></tr></table></figure>

<h4 id="6-MongoDB和关系型数据库术语对比图"><a href="#6-MongoDB和关系型数据库术语对比图" class="headerlink" title="6 MongoDB和关系型数据库术语对比图"></a>6 MongoDB和关系型数据库术语对比图</h4><p><img src="https://img2018.cnblogs.com/blog/1521877/201904/1521877-20190429170250020-1693717595.png" alt="img"></p>
<h4 id="7-什么是非关系型数据库"><a href="#7-什么是非关系型数据库" class="headerlink" title="7.什么是非关系型数据库"></a>7.什么是非关系型数据库</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　非关系型数据库的显著特点是不使用SQL作为查询语言，数据存储不需要特定的表格模式。</span><br></pre></td></tr></table></figure>

<h4 id="8-为什么用MOngoDB？"><a href="#8-为什么用MOngoDB？" class="headerlink" title="8.为什么用MOngoDB？"></a>8.为什么用MOngoDB？</h4><ul>
<li>架构简单</li>
<li>没有复杂的连接</li>
<li>深度查询能力,MongoDB支持动态查询。</li>
<li>容易调试</li>
<li>容易扩展</li>
<li>不需要转化/映射应用对象到数据库对象</li>
<li>使用内部内存作为存储工作区,以便更快的存取数据。</li>
</ul>
<h4 id="9-MongoDB中的命名空间是什么意思"><a href="#9-MongoDB中的命名空间是什么意思" class="headerlink" title="9.MongoDB中的命名空间是什么意思?"></a>9.MongoDB中的命名空间是什么意思?</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MongoDB内部有预分配空间的机制，每个预分配的文件都用0进行填充。</span><br><span class="line"></span><br><span class="line">数据文件每新分配一次，它的大小都是上一个数据文件大小的2倍，每个数据文件最大2G。</span><br><span class="line"></span><br><span class="line">MongoDB每个集合和每个索引都对应一个命名空间，这些命名空间的元数据集中在16M的*.ns文件中，平均每个命名占用约 628 字节，也即整个数据库的命名空间的上限约为24000。</span><br><span class="line"></span><br><span class="line">如果每个集合有一个索引（比如默认的_id索引），那么最多可以创建12000个集合。如果索引数更多，则可创建的集合数就更少了。同时，如果集合数太多，一些操作也会变慢。</span><br><span class="line"></span><br><span class="line">要建立更多的集合的话，MongoDB 也是支持的，只需要在启动时加上“--nssize”参数，这样对应数据库的命名空间文件就可以变得更大以便保存更多的命名。这个命名空间文件（.ns文件）最大可以为 2G。</span><br><span class="line"></span><br><span class="line">每个命名空间对应的盘区不一定是连续的。与数据文件增长相同，每个命名空间对应的盘区大小都是随分配次数不断增长的。目的是为了平衡命名空间浪费的空间与保持一个命名空间数据的连续性。</span><br><span class="line"></span><br><span class="line">需要注意的一个命名空间$freelist，这个命名空间用于记录不再使用的盘区（被删除的Collection或索引）。每当命名空间需要分配新盘区时，会先查看$freelist是否有大小合适的盘区可以使用，如果有就回收空闲的磁盘空间。</span><br></pre></td></tr></table></figure>

<h4 id="10-在哪些场景使用MongoDB"><a href="#10-在哪些场景使用MongoDB" class="headerlink" title="10.在哪些场景使用MongoDB"></a>10.在哪些场景使用MongoDB</h4><ul>
<li>大数据</li>
<li>内容管理系统</li>
<li>移动端Apps</li>
<li>数据管理</li>
</ul>
<h4 id="11-monogodb-中的分片什么意思"><a href="#11-monogodb-中的分片什么意思" class="headerlink" title="11.monogodb 中的分片什么意思"></a>11.monogodb 中的分片什么意思</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">分片是将数据水平切分到不同的物理节点。当应用数据越来越大的时候，数据量也会越来越大。当数据量增长</span><br><span class="line">时，单台机器有可能无法存储数据或可接受的读取写入吞吐量。利用分片技术可以添加更多的机器来应对数据量增加</span><br><span class="line">以及读写操作的要求。</span><br></pre></td></tr></table></figure>

<h4 id="12-为什么要在MongoDB中使用分析器"><a href="#12-为什么要在MongoDB中使用分析器" class="headerlink" title="12.为什么要在MongoDB中使用分析器"></a>12.为什么要在MongoDB中使用分析器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongodb中包括了一个可以显示数据库中每个操作性能特点的数据库分析器.通过这个分析器你可以找到比预期慢</span><br><span class="line">的查询(或写操作);利用这一信息,比如,可以确定是否需要添加索引。</span><br></pre></td></tr></table></figure>

<h4 id="13-MongoDB支持主键外键关系吗"><a href="#13-MongoDB支持主键外键关系吗" class="headerlink" title="13.MongoDB支持主键外键关系吗"></a>13.MongoDB支持主键外键关系吗</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">默认MongoDB不支持主键和外键关系。 用Mongodb本身的API需要硬编码才能实现外键关联，不够直观且难度较大</span><br></pre></td></tr></table></figure>

<h4 id="14-MongoDB支持哪些数据类型"><a href="#14-MongoDB支持哪些数据类型" class="headerlink" title="14.MongoDB支持哪些数据类型"></a>14.MongoDB支持哪些数据类型</h4><ul>
<li>String</li>
<li>Integer</li>
<li>Double</li>
<li>Boolean</li>
<li>Object</li>
<li>Object ID</li>
<li>Arrays</li>
<li>Min/Max Keys</li>
<li>Datetime</li>
<li>Code</li>
<li>Regular Expression等</li>
</ul>
<h4 id="15-为什么要在MongoDB中用”Code”数据类型"><a href="#15-为什么要在MongoDB中用”Code”数据类型" class="headerlink" title="15.为什么要在MongoDB中用”Code”数据类型"></a>15.为什么要在MongoDB中用”Code”数据类型</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;Code&quot;类型用于在文档中存储 JavaScript 代码。</span><br></pre></td></tr></table></figure>

<h4 id="16-32位系统上有什么细微差别"><a href="#16-32位系统上有什么细微差别" class="headerlink" title="16.32位系统上有什么细微差别?"></a>16.32位系统上有什么细微差别?</h4><p>journaling会激活额外的内存映射文件。这将进一步抑制32位版本上的数据库大小。因此，现在journaling在32位系统上默认是禁用的。</p>
<h4 id="17-为什么在MongoDB中使用”Object-ID”数据类型"><a href="#17-为什么在MongoDB中使用”Object-ID”数据类型" class="headerlink" title="17.为什么在MongoDB中使用”Object ID”数据类型"></a>17.为什么在MongoDB中使用”Object ID”数据类型</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;ObjectID&quot;数据类型用于存储文档id</span><br></pre></td></tr></table></figure>

<h4 id="18-”ObjectID”有哪些部分组成"><a href="#18-”ObjectID”有哪些部分组成" class="headerlink" title="18.”ObjectID”有哪些部分组成"></a>18.”ObjectID”有哪些部分组成</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一共有四部分组成:时间戳、客户端ID、客户进程ID、三个字节的增量计数器</span><br><span class="line"></span><br><span class="line">_id是一个 12 字节长的十六进制数，它保证了每一个文档的唯一性。在插入文档时，需要提供_id。如果你不提供，那么 MongoDB 就会为每一文档提供一个唯一的 id。_id的头 4 个字节代表的是当前的时间戳，接着的后 3 个字节表示的是机器 id 号，接着的 2 个字节表示 MongoDB 服务器进程 id，最后的 3 个字节代表递增值。</span><br></pre></td></tr></table></figure>

<h4 id="19-在MongoDb中什么是索引"><a href="#19-在MongoDb中什么是索引" class="headerlink" title="19.在MongoDb中什么是索引"></a>19.在MongoDb中什么是索引</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">索引用于高效的执行查询,没有索引的MongoDB将扫描整个集合中的所有文档,这种扫描效率很低,需要处理大量的数据.</span><br><span class="line">索引是一种特殊的数据结构,将一小块数据集合保存为容易遍历的形式.索引能够存储某种特殊字段或字段集的值,并按照索引指定的方式将字段值进行排序.</span><br></pre></td></tr></table></figure>

<h4 id="20-如何添加索引"><a href="#20-如何添加索引" class="headerlink" title="20.如何添加索引"></a>20.如何添加索引</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用db.collection.createIndex()在集合中创建一个索引</span><br></pre></td></tr></table></figure>

<h4 id="21-如何查询集合中的文档"><a href="#21-如何查询集合中的文档" class="headerlink" title="21.如何查询集合中的文档"></a>21.如何查询集合中的文档</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.collectionName.find(&#123;key:value&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="22-用什么方法可以格式化输出结果"><a href="#22-用什么方法可以格式化输出结果" class="headerlink" title="22.用什么方法可以格式化输出结果"></a>22.用什么方法可以格式化输出结果</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.collectionName.find().pretty()</span><br></pre></td></tr></table></figure>

<h4 id="23-如何使用”AND”或”OR”条件循环查询集合中的文档"><a href="#23-如何使用”AND”或”OR”条件循环查询集合中的文档" class="headerlink" title="23.如何使用”AND”或”OR”条件循环查询集合中的文档"></a>23.如何使用”AND”或”OR”条件循环查询集合中的文档</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.mycol.find(</span><br><span class="line">   &#123;</span><br><span class="line">      $or: [</span><br><span class="line">         &#123;key1: value1&#125;, &#123;key2:value2&#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">).pretty()</span><br></pre></td></tr></table></figure>

<h4 id="24-你怎么比较MongoDB、CouchDB及CouchBase"><a href="#24-你怎么比较MongoDB、CouchDB及CouchBase" class="headerlink" title="24.你怎么比较MongoDB、CouchDB及CouchBase?"></a>24.你怎么比较MongoDB、CouchDB及CouchBase?</h4><p>MongoDB和CouchDB都是面向文档的数据库。MongoDB和CouchDB都是开源NoSQL数据库的最典型代表。 除了都以文档形式存储外它们没有其他的共同点。MongoDB和CouchDB在数据模型实现、接口、对象存储以及复制方法等方面有很多不同。</p>
<p>细节可以参见下面的链接：</p>
<p>MongDB vs CouchDB</p>
<p>CouchDB vs CouchBase</p>
<h4 id="25-名字空间-namespace-是什么"><a href="#25-名字空间-namespace-是什么" class="headerlink" title="25.名字空间(namespace)是什么?"></a>25.名字空间(namespace)是什么?</h4><p>MongoDB存储BSON对象在丛集(collection)中。数据库名字和丛集名字以句点连结起来叫做名字空间(namespace)。</p>
<h4 id="26-如果用户移除对象的属性，该属性是否从存储层中删除"><a href="#26-如果用户移除对象的属性，该属性是否从存储层中删除" class="headerlink" title="26.如果用户移除对象的属性，该属性是否从存储层中删除?"></a>26.如果用户移除对象的属性，该属性是否从存储层中删除?</h4><p>是的，用户移除属性然后对象会重新保存(re-save())。</p>
<h4 id="27-什么是聚合"><a href="#27-什么是聚合" class="headerlink" title="27.什么是聚合"></a>27.什么是聚合</h4><p>聚合操作能够处理数据记录并返回计算结果。聚合操作能将多个文档中的值组合起来，对成组数据执行各种操作，返回单一的结果。它相当于 SQL 中的 count(*) 组合 group by。对于 MongoDB 中的聚合操作，应该使用<code>aggregate()</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)</span><br></pre></td></tr></table></figure>

<h4 id="28-在MongoDB中什么是副本集（避免单点故障）"><a href="#28-在MongoDB中什么是副本集（避免单点故障）" class="headerlink" title="28.在MongoDB中什么是副本集（避免单点故障）"></a>28.在MongoDB中什么是副本集（避免单点故障）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在MongoDB中副本集由一组MongoDB实例组成，包括一个主节点多个次节点，MongoDB客户端的所有数据都</span><br><span class="line">写入主节点(Primary),副节点从主节点同步写入数据，以保持所有复制集内存储相同的数据，提高数据可用性。</span><br></pre></td></tr></table></figure>

<h4 id="29-什么是NoSQL数据库？NoSQL和RDBMS有什么区别？在哪些情况下使用和不使用NoSQL数据库？"><a href="#29-什么是NoSQL数据库？NoSQL和RDBMS有什么区别？在哪些情况下使用和不使用NoSQL数据库？" class="headerlink" title="29.什么是NoSQL数据库？NoSQL和RDBMS有什么区别？在哪些情况下使用和不使用NoSQL数据库？"></a>29.什么是NoSQL数据库？NoSQL和RDBMS有什么区别？在哪些情况下使用和不使用NoSQL数据库？</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NoSQL是非关系型数据库，NoSQL &#x3D; Not Only SQL。  关系型数据库采用的结构化的数据，NoSQL采用的是键值对的方式存储数据。</span><br><span class="line"></span><br><span class="line">在处理非结构化&#x2F;半结构化的大数据时；在水平方向上进行扩展时；随时应对动态增加的数据项时可以优先考虑使用NoSQL数据库。</span><br><span class="line"></span><br><span class="line">在考虑数据库的成熟度；支持；分析和商业智能；管理及专业性等问题时，应优先考虑关系型数据库。</span><br></pre></td></tr></table></figure>

<h4 id="30-MongoDB支持存储过程吗？如果支持的话，怎么用？"><a href="#30-MongoDB支持存储过程吗？如果支持的话，怎么用？" class="headerlink" title="30.MongoDB支持存储过程吗？如果支持的话，怎么用？"></a>30.MongoDB支持存储过程吗？如果支持的话，怎么用？</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MongoDB支持存储过程，它是javascript写的，保存在db.system.js表中。</span><br></pre></td></tr></table></figure>

<h4 id="31-如何理解MongoDB中的GridFS机制，MongoDB为何使用GridFS来存储文件？"><a href="#31-如何理解MongoDB中的GridFS机制，MongoDB为何使用GridFS来存储文件？" class="headerlink" title="31.如何理解MongoDB中的GridFS机制，MongoDB为何使用GridFS来存储文件？"></a>31.如何理解MongoDB中的GridFS机制，MongoDB为何使用GridFS来存储文件？</h4><p>GridFS是一种将大型文件存储在MongoDB中的文件规范。使用GridFS可以将大文件分隔成多个小文档存放，这样我们能够有效的保存大文档，而且解决了BSON对象有限制的问题。</p>
<h4 id="32-如何执行事务-加锁"><a href="#32-如何执行事务-加锁" class="headerlink" title="32.如何执行事务/加锁?"></a>32.如何执行事务/加锁?</h4><p>MongoDB没有使用传统的锁或者复杂的带回滚的事务，因为它设计的宗旨是轻量，快速以及可预计的高性能。可以把它类比成MySQL MylSAM的自动提交模式。通过精简对事务的支持，性能得到了提升，特别是在一个可能会穿过多个服务器的系统里。</p>
<h4 id="33-启用备份故障恢复需要多久"><a href="#33-启用备份故障恢复需要多久" class="headerlink" title="33.启用备份故障恢复需要多久?"></a>33.启用备份故障恢复需要多久?</h4><p>从备份数据库声明主数据库宕机到选出一个备份数据库作为新的主数据库将花费10到30秒时间。这期间在主数据库上的操作将会失败–包括写入和强一致性读取(strong consistent read)操作。然而，你还能在第二数据库上执行最终一致性查询(eventually consistent query)(在slaveOk模式下)，即使在这段时间里。</p>
<h4 id="34-我应该启动一个集群分片-sharded-还是一个非集群分片的-MongoDB-环境"><a href="#34-我应该启动一个集群分片-sharded-还是一个非集群分片的-MongoDB-环境" class="headerlink" title="34.我应该启动一个集群分片(sharded)还是一个非集群分片的 MongoDB 环境?"></a>34.我应该启动一个集群分片(sharded)还是一个非集群分片的 MongoDB 环境?</h4><p>为开发便捷起见，我们建议以非集群分片(unsharded)方式开始一个 MongoDB 环境，除非一台服务器不足以存放你的初始数据集。从非集群分片升级到集群分片(sharding)是无缝的，所以在你的数据集还不是很大的时候没必要考虑集群分片(sharding)。</p>
<h4 id="35-分片-sharding-和复制-replication-是怎样工作的"><a href="#35-分片-sharding-和复制-replication-是怎样工作的" class="headerlink" title="35.分片(sharding)和复制(replication)是怎样工作的?"></a>35.分片(sharding)和复制(replication)是怎样工作的?</h4><p>每一个分片(shard)是一个分区数据的逻辑集合。分片可能由单一服务器或者集群组成，我们推荐为每一个分片(shard)使用集群。</p>
<h4 id="36-数据在什么时候才会扩展到多个分片-shard-里"><a href="#36-数据在什么时候才会扩展到多个分片-shard-里" class="headerlink" title="36.数据在什么时候才会扩展到多个分片(shard)里?"></a>36.数据在什么时候才会扩展到多个分片(shard)里?</h4><p>MongoDB 分片是基于区域(range)的。所以一个集合(collection)中的所有的对象都被存放到一个块(chunk)中。只有当存在多余一个块的时候，才会有多个分片获取数据的选项。现在，每个默认块的大小是 64Mb，所以你需要至少 64 Mb 空间才可以实施一个迁移。</p>
<h4 id="37-我可以把moveChunk目录里的旧文件删除吗"><a href="#37-我可以把moveChunk目录里的旧文件删除吗" class="headerlink" title="37.我可以把moveChunk目录里的旧文件删除吗?"></a>37.我可以把moveChunk目录里的旧文件删除吗?</h4><p>没问题，这些文件是在分片(shard)进行均衡操作(balancing)的时候产生的临时文件。一旦这些操作已经完成，相关的临时文件也应该被删除掉。但目前清理工作是需要手动的，所以请小心地考虑再释放这些文件的空间。</p>
<h4 id="38-分片-sharding-和复制-replication-是怎样工作的"><a href="#38-分片-sharding-和复制-replication-是怎样工作的" class="headerlink" title="38.分片(sharding)和复制(replication)是怎样工作的?"></a>38.分片(sharding)和复制(replication)是怎样工作的?</h4><p>每一个分片(shard)是一个分区数据的逻辑集合.分片可能由单一服务器或者集群组成,我们推荐为每一个分片(shard)使用集群。</p>
<h4 id="39-如果块移动操作-movechunk-失败了-我需要手动清除部分转移的文档吗"><a href="#39-如果块移动操作-movechunk-失败了-我需要手动清除部分转移的文档吗" class="headerlink" title="39.如果块移动操作(movechunk)失败了,我需要手动清除部分转移的文档吗?"></a>39.如果块移动操作(movechunk)失败了,我需要手动清除部分转移的文档吗?</h4><p> 不需要,移动操作是一致(consistent)并且是确定性的(deterministic);一次失败后,移动操作会不断重试;当完成后,数据只会出现在新的分片里(shard)。</p>
<h4 id="40-mongodb是否支持事务"><a href="#40-mongodb是否支持事务" class="headerlink" title="40.mongodb是否支持事务"></a>40.mongodb是否支持事务</h4><p>MongoDB 4.0的新特性——事务（Transactions）：MongoDB 是不支持事务的，因此开发者在需要用到事务的时候，不得不借用其他工具，在业务代码层面去弥补数据库的不足。</p>
<p>事务和会话(Sessions)关联，一个会话同一时刻只能开启一个事务操作，当一个会话断开，这个会话中的事务也会结束。</p>
<h4 id="41-哪些语言支持MongoDB"><a href="#41-哪些语言支持MongoDB" class="headerlink" title="41.哪些语言支持MongoDB?"></a>41.哪些语言支持MongoDB?</h4><ul>
<li>C</li>
<li>C++</li>
<li>C#</li>
<li>Java</li>
<li>Node.js</li>
<li>Perl</li>
<li>Php 等</li>
</ul>
<h4 id="42-如何使用”AND”或”OR”条件循环查询集合中的文档"><a href="#42-如何使用”AND”或”OR”条件循环查询集合中的文档" class="headerlink" title="42.如何使用”AND”或”OR”条件循环查询集合中的文档"></a>42.如何使用”AND”或”OR”条件循环查询集合中的文档</h4><p>在<code>find()</code>方法中，如果传入多个键，并用逗号(<code>,</code>)分隔它们，那么 MongoDB 会把它看成是<strong>AND</strong>条件。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt;db.mycol.find(&#123;key1:value1, key2:value2&#125;).pretty()</span><br></pre></td></tr></table></figure>

<p>若基于<strong>OR</strong>条件来查询文档，可以使用关键字**$or**。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt;db.mycol.find(</span><br><span class="line">   &#123;</span><br><span class="line">      $or: [</span><br><span class="line">         &#123;key1: value1&#125;, &#123;key2:value2&#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">).pretty()</span><br></pre></td></tr></table></figure>

<h4 id="43-如何删除文档"><a href="#43-如何删除文档" class="headerlink" title="43.如何删除文档"></a>43.如何删除文档</h4><p>MongoDB 利用 <code>remove()</code> 方法 清除集合中的文档。它有 2 个可选参数：</p>
<ul>
<li>deletion criteria：（可选）删除文档的标准。</li>
<li>justOne：（可选）如果设为 true 或 1，则只删除一个文档。</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt;db.collectionName.remove(&#123;key:value&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="44-在MongoDB中如何排序"><a href="#44-在MongoDB中如何排序" class="headerlink" title="44.在MongoDB中如何排序"></a>44.在MongoDB中如何排序</h4><p>MongoDB 中的文档排序是通过<code>sort()</code>方法来实现的。<code>sort()</code>方法可以通过一些参数来指定要进行排序的字段，并使用 1 和 -1 来指定排序方式，其中 1 表示升序，而 -1 表示降序。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt;db.connectionName.find(&#123;key:value&#125;).sort(&#123;columnName:1&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="45-举例说明您将从Redis和MongoDB一起使用中受益的情况？"><a href="#45-举例说明您将从Redis和MongoDB一起使用中受益的情况？" class="headerlink" title="45.举例说明您将从Redis和MongoDB一起使用中受益的情况？"></a>45.举例说明您将从Redis和MongoDB一起使用中受益的情况？</h4><p>Redis和MongoDB可以一起使用，效果很好。Craiglist是一家以运行MongoDB和Redis（以及MySQL和Sphinx）而闻名的公司。请参阅Jeremy<br>Zawodny的<a href="http://www.slideshare.net/jzawodn/living-with-sql-and-nosql-at-craigslist-a-pragmatic-approach">演示文稿</a>。</p>
<p>MongoDB对于以各种方式索引的持久性，面向文档的数据很有趣。对于易失性数据或对延迟敏感的半永久性数据，Redis更有趣。</p>
<p>以下是在MongoDB之上具体使用Redis的一些示例。</p>
<ul>
<li>2.2版之前的MongoDB还没有到期机制。上限集合不能真正用于实现真正的TTL。Redis具有基于TTL的过期机制，可以方便地存储易失性数据。例如，用户会话通常存储在Redis中，而用户数据将存储在MongoDB中并建立索引。请注意，MongoDB 2.2在集合级别引入了一种低精度的过期机制（例如，用于清除数据）。</li>
<li>Redis提供了一种方便的集合数据类型及其关联的操作（联合，交集，多个集合的差等）。在此功能之上实现基本的多面搜索或标记引擎非常容易，这是对MongoDB更传统的索引功能的有趣补充。</li>
<li>Redis支持有效地阻止列表上的弹出操作。这可用于实现临时分布式排队系统。它比MongoDB可尾游标IMO更具灵活性，因为后端应用程序可以在超时的情况下侦听多个队列，原子地将项目转移到另一个队列，等等…如果应用程序需要排队，则将队列存储在Redis中是有意义的，并将持久性功能数据保留在MongoDB中。</li>
<li>Redis还提供了发布/订阅机制。在分布式应用程序中，事件传播系统可能会有用。对于持久性数据保留在MongoDB中而言，这也是Redis的绝佳用例。</li>
</ul>
<p>由于使用MongoDB设计数据模型要比使用Redis容易得多（Redis更底层），因此可以从MongoDB的主要持久性数据灵活性和Redis提供的额外功能（低延迟）中受益。<br>，项目到期，队列，发布/订阅，原子块等）。这确实是一个很好的组合。</p>
<p>请注意，您永远不要在同一台机器上运行Redis和MongoDB服务器。MongoDB内存被设计为可以换出，Redis不是。如果MongoDB触发某些交换活动，则Redis的性能将是灾难性的。它们应该在不同的节点上隔离。</p>
<h4 id="46-MongoDB-Azure-Android：com-mongodb-WriteConcernException-err：“非主用户”代码：“-10058”"><a href="#46-MongoDB-Azure-Android：com-mongodb-WriteConcernException-err：“非主用户”代码：“-10058”" class="headerlink" title="46.MongoDB + Azure + Android：com.mongodb.WriteConcernException err：“非主用户”代码：“ 10058”"></a>46.MongoDB + Azure + Android：com.mongodb.WriteConcernException err：“非主用户”代码：“ 10058”</h4><p><strong>背景</strong> ：</p>
<p>嗨，我正在Azure上运行MongoDB副本集，并已从Android应用程序中远程连接到它。我已使读取在所有实例上都能很好地工作（已更新：因为允许它们在主节点和辅助节点上读取）。但是，对数据库的写入仍然会出现间歇性错误，并出现以下错误，因为写入必须仅在主节点上进行。</p>
<p>另外，如果您可以提供更多具体资源来解决此问题，那么这也将非常有帮助。我已经阅读了大多数文档，并搜索了很多此错误。</p>
<p><strong>问题</strong> ：</p>
<p>如何防止此错误并允许100％的时间写入？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E&#x2F;AndroidRuntime(): com.mongodb.WriteConcernException: &#123;</span><br><span class="line">        &quot;serverUsed&quot; : &quot;&#x2F;&lt;my-remote-ip&gt;:27017&quot; , &quot;err&quot; : &quot;not master&quot; , </span><br><span class="line">        &quot;code&quot; : 10058 , &quot;n&quot; : 0 , &quot;lastOp&quot; : &#123; &quot;$ts&quot; : 0 , &quot;$inc&quot; : 0&#125; , </span><br><span class="line">        &quot;connectionId&quot; : 1918 , &quot;ok&quot; : 1.0&#125;</span><br></pre></td></tr></table></figure>

<p><strong>堆栈跟踪</strong> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E&#x2F;AndroidRuntime(13731): FATAL EXCEPTION: Thread-7629</span><br><span class="line">E&#x2F;AndroidRuntime(13731): Process: com.myapplication.examplemongodb, PID: 13731</span><br><span class="line">E&#x2F;AndroidRuntime(13731): com.mongodb.WriteConcernException: &#123; &quot;serverUsed&quot; : &quot;&#x2F;&lt;my-remote-ip&gt;:27017&quot; , &quot;err&quot; : &quot;not master&quot; , &quot;code&quot; : 10058 , &quot;n&quot; : 0 , &quot;lastOp&quot; : &#123; &quot;$ts&quot; : 0 , &quot;$inc&quot; : 0&#125; , &quot;connectionId&quot; : 1918 , &quot;ok&quot; : 1.0&#125;</span><br><span class="line">E&#x2F;AndroidRuntime(13731):    at com.mongodb.CommandResult.getException(CommandResult.java:77)</span><br><span class="line">E&#x2F;AndroidRuntime(13731):    at com.mongodb.CommandResult.throwOnError(CommandResult.java:110)</span><br><span class="line">E&#x2F;AndroidRuntime(13731):    at com.mongodb.DBTCPConnector._checkWriteError(DBTCPConnector.java:102)</span><br><span class="line">E&#x2F;AndroidRuntime(13731):    at com.mongodb.DBTCPConnector.say(DBTCPConnector.java:142)</span><br><span class="line">E&#x2F;AndroidRuntime(13731):    at com.mongodb.DBTCPConnector.say(DBTCPConnector.java:115)</span><br><span class="line">E&#x2F;AndroidRuntime(13731):    at com.mongodb.DBApiLayer$MyCollection.insert(DBApiLayer.java:248)</span><br><span class="line">E&#x2F;AndroidRuntime(13731):    at com.mongodb.DBApiLayer$MyCollection.insert(DBApiLayer.java:204)</span><br><span class="line">E&#x2F;AndroidRuntime(13731):    at com.mongodb.DBCollection.insert(DBCollection.java:76)</span><br><span class="line">E&#x2F;AndroidRuntime(13731):    at com.mongodb.DBCollection.insert(DBCollection.java:60)</span><br><span class="line">E&#x2F;AndroidRuntime(13731):    at com.mongodb.DBCollection.insert(DBCollection.java:105)</span><br><span class="line">E&#x2F;AndroidRuntime(13731):    at com.myapplication.examplemongodb.ActivityMain$1.run(ActivityMain.java:83)</span><br><span class="line">E&#x2F;AndroidRuntime(13731):    at java.lang.Thread.run(Thread.java:841)</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong> ：</p>
<ul>
<li><p>我正在使用<a href="http://central.maven.org/maven2/org/mongodb/mongo-java-driver/">mongo-java-driver v2.11.3</a>。</p>
</li>
<li><p>我使用了</p>
<p>mongo-azure库</p>
<p>来帮助创建具有两个工作角色的MongoDB副本集。</p>
<ul>
<li>（如果您还有其他资源，那么我很乐意阅读。我已经阅读了GitHub自述文件<a href="http://docs.mongodb.org/ecosystem/tutorial/deploy-mongodb-worker-roles-in-azure/">this</a>，<a href="http://docs.mongodb.org/ecosystem/tutorial/configure-worker-roles-in-azure/">this</a>和其他一些与MongoDB / Azure不相关的内容。但是，这些资源不是更新，也不详细。）</li>
</ul>
</li>
</ul>
<p><strong>可能的解决方案</strong> ：</p>
<ul>
<li>我认为这与设置副本集有关。</li>
<li>我不确定这种情况是否会发生，因为我只有两个实例副本集（一个主要副本和一个次要副本），并且他们正在为谁想成为主要副本而进行争夺（阅读：投票）。也许需要仲裁员？但是，我目前不知道该怎么做。</li>
</ul>
<p><strong>更新</strong> ：</p>
<ul>
<li>感谢@David Makogon的帮助，我非常确定问题在于如何建立与Azure的连接以及如何访问辅助角色。因此，这是我关于系统配置方式的最新注释：<ul>
<li>两个工作角色（MongoDB.WindowsAzure.MongoDBRole），我通过<code>TCP Input Endpoint</code>Android应用程序通过端口27017 直接连接到这些角色。正如@David所说，我目前无法控制连接到哪个实例。</li>
<li>我不做任何事情的一个Web角色（MongoDB.WindowsAzure.Manager）<code>HTTP Input Endpoint</code>在端口80上有一个。默认情况下，这是我上面提到的mongo-azure库的默认设置。我不确定是否应该对此做任何事情。</li>
</ul>
</li>
</ul>
<h4 id="47-使用Spring-Security-Spring数据-MongoDB进行身份验证"><a href="#47-使用Spring-Security-Spring数据-MongoDB进行身份验证" class="headerlink" title="47.使用Spring Security + Spring数据+ MongoDB进行身份验证"></a>47.使用Spring Security + Spring数据+ MongoDB进行身份验证</h4><p>我想将Spring安全性与MongoDB结合使用（使用Spring数据），并从我自己的数据库中检索用户以获取Spring安全性。但是，由于我的用户服务类型似乎不受支持，所以我不能这样做。</p>
<p>这是我的UserService类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UserService &#123;</span><br><span class="line">    private ApplicationContext applicationContext;</span><br><span class="line">    private MongoOperations mongoOperations;</span><br><span class="line"></span><br><span class="line">    public UserService() &#123;</span><br><span class="line">        applicationContext &#x3D; new AnnotationConfigApplicationContext(MongoConfig.class);</span><br><span class="line">        mongoOperations &#x3D; (MongoOperations) applicationContext.getBean(&quot;mongoTemplate&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User find(String username) &#123;</span><br><span class="line">        return mongoOperations.findOne(Query.query(Criteria.where(&quot;username&quot;).is(username)), User.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和我的SecurityConfig类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebSecurity</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void configAuthBuilder(AuthenticationManagerBuilder builder) throws Exception &#123;</span><br><span class="line">        builder.userDetailsService(userService); &#x2F;&#x2F;THIS DOES NOT WORK</span><br><span class="line">        builder.inMemoryAuthentication().withUser(&quot;username&quot;).password(&quot;password&quot;).roles(&quot;USER&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我评论的那句话说：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The inferred type UserService is not a valid substitute for the bounded parameter &lt;T extends UserDetail</span><br></pre></td></tr></table></figure>

<h4 id="48-Java-ORM-for-MongoDB的开销是多少"><a href="#48-Java-ORM-for-MongoDB的开销是多少" class="headerlink" title="48.Java ORM for MongoDB的开销是多少"></a>48.Java ORM for MongoDB的开销是多少</h4><p>将Java ORM用于MongoDB的开销是多少？或者更好的是，我们在基本驱动程序级别进行读写？</p>
<p>我们将为我们的要求之一添加Mongo DB。</p>
<p>有对Java夫妇的Java ORM映射工具<br>-morphia<br>-Spring数据<br>- <a href="http://www.mongodb.org/display/DOCS/Java+Language+Center">其他</a></p>
<p>Morphia的最新版本已于一年多以前发布，<br>但Spring数据得到了积极维护。如果我现在要开始使用哪一个，</p>
<h4 id="49-使用Jackson-PTH和Spring-Data-MongoDB-DBRef的Java到JSON序列化生成额外的目标属性"><a href="#49-使用Jackson-PTH和Spring-Data-MongoDB-DBRef的Java到JSON序列化生成额外的目标属性" class="headerlink" title="49.使用Jackson PTH和Spring Data MongoDB DBRef的Java到JSON序列化生成额外的目标属性"></a>49.使用Jackson PTH和Spring Data MongoDB DBRef的Java到JSON序列化生成额外的目标属性</h4><p>从Java序列化为JSON时，<code>target</code>当使用<code>@DBRef</code>带有延迟加载和Jackson的多态类型处理的Spring Data MongoDB<br>批注时，Jackson会为引用的实体生成一个额外的属性。为什么会发生这种情况，并且可以省略多余的<code>target</code>属性？</p>
<p><strong>代码示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Document(collection &#x3D; &quot;cdBox&quot;)</span><br><span class="line">public class CDBox &#123;</span><br><span class="line">  @Id</span><br><span class="line">  public String id;</span><br><span class="line"></span><br><span class="line">  @DBRef(lazy &#x3D; true)</span><br><span class="line">  public List&lt;Product&gt; products;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Document(collection &#x3D; &quot;album&quot;)</span><br><span class="line">public class Album extends Product &#123;</span><br><span class="line">  @DBRef(lazy &#x3D; true)</span><br><span class="line">  public List&lt;Song&gt; songs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Document(collection &#x3D; &quot;single&quot;)</span><br><span class="line">public class Single extends Product &#123;</span><br><span class="line">  @DBRef(lazy &#x3D; true)</span><br><span class="line">  public List&lt;Song&gt; songs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Document(collection &#x3D; &quot;song&quot;)</span><br><span class="line">public class Song &#123;</span><br><span class="line">  @Id</span><br><span class="line">  public String id;</span><br><span class="line"></span><br><span class="line">  public String title;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@JsonTypeInfo(use &#x3D; JsonTypeInfo.Id.NAME,</span><br><span class="line">                    property &#x3D; &quot;productType&quot;,</span><br><span class="line">                    include &#x3D; JsonTypeInfo.As.EXTERNAL_PROPERTY)</span><br><span class="line">@JsonSubTypes(value &#x3D; &#123;</span><br><span class="line">    @JsonSubTypes.Type(value &#x3D; Single.class),</span><br><span class="line">    @JsonSubTypes.Type(value &#x3D; Album.class)</span><br><span class="line">&#125;)</span><br><span class="line">public abstract class Product &#123;</span><br><span class="line">  @Id</span><br><span class="line">  public String id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>生成的JSON</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: &quot;someId1&quot;,</span><br><span class="line">  &quot;products&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;id&quot;: &quot;someId2&quot;,</span><br><span class="line">      &quot;songs&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">        &quot;id&quot;: &quot;someId3&quot;,</span><br><span class="line">        &quot;title&quot;: &quot;Some title&quot;,</span><br><span class="line">        &quot;target&quot;: &#123;</span><br><span class="line">          &quot;id&quot;: &quot;someId3&quot;,</span><br><span class="line">          &quot;title&quot;: &quot;Some title&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="50-表示MongoDB中具有属性的多对多关系的最佳模型"><a href="#50-表示MongoDB中具有属性的多对多关系的最佳模型" class="headerlink" title="50.表示MongoDB中具有属性的多对多关系的最佳模型"></a>50.表示MongoDB中具有属性的多对多关系的最佳模型</h4><p>代表具有属性的多对多关系的最“ mongo”方式是什么？</p>
<p>因此，例如：</p>
<h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><hr>
<p>MYSQL表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">people&#96; &#x3D;&gt; &#96;firstName, lastName, ...</span><br><span class="line">Movies&#96; &#x3D;&gt; &#96;name, length ..</span><br><span class="line">peopleMovies&#96; &#x3D;&gt; &#96;movieId, personId, language, role</span><br></pre></td></tr></table></figure>

<h5 id="解决方案1"><a href="#解决方案1" class="headerlink" title="解决方案1"></a>解决方案1</h5><hr>
<p>将人们嵌入电影中…？</p>
<p>在MongoDB中，我知道这样<code>denormalize and embed</code>做很好，但是我不想让<code>embed</code>人们看电影，从逻辑上讲这没有任何意义。因为人们不一定只属于电影。</p>
<h5 id="解决方案2"><a href="#解决方案2" class="headerlink" title="解决方案2"></a>解决方案2</h5><hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">People&#96;并且&#96;Movies&#96;将两个单独的集合。 &#96;People&#96;&#x3D;&gt;嵌入&#96;[&#123;movieId: 12, personId: 1, language: &quot;English&quot;, role: &quot;Main&quot;&#125; ...]</span><br><span class="line">Movies&#96; &#x3D;&gt;嵌入 &#96;[&#123;movieId: 12, personId: 1, language: &quot;English&quot;, role: &quot;Main&quot;&#125; ...]</span><br></pre></td></tr></table></figure>

<p>该解决方案的问题在于，当我们要<code>role</code>为特定对象更新人员时，<code>movie</code>我们需要运行两个更新查询以确保两个集合中的数据同步。</p>
<h5 id="解决方案3"><a href="#解决方案3" class="headerlink" title="解决方案3"></a>解决方案3</h5><hr>
<p>我们还可以做一些与关系有关的事情，最后得到三个集合</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">People&#96;&#x3D;&gt; &#96;firstName, lastName, ...&#96; &#96;Movies&#96;&#x3D;&gt; &#96;name, length ..&#96;</span><br><span class="line">&#96;Castings&#96;&#x3D;&gt;&#96;movieId, personId, language, role</span><br></pre></td></tr></table></figure>

<p>问题在于，由于MongoDB中缺少join语句，因此需要<code>3 queries</code>从人那里去-&gt;电影，反之亦然。</p>
<p>这是我的问题，还有什么其他方式可以对此类事物进行建模<code>MongoDB</code>以及更多<code>NoSQL</code>方式。就提供的解决方案而言，在mongo的性能和约定方面哪一种是最好的。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.cnblogs.com/angle6-liu/p/10791875.html">https://www.cnblogs.com/angle6-liu/p/10791875.html</a></p>
<p><a href="https://www.jb51.net/article/179908.htm">https://www.jb51.net/article/179908.htm</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/37437657">https://zhuanlan.zhihu.com/p/37437657</a></p>
<p><a href="https://blog.csdn.net/weixin_45669794/article/details/102991806">https://blog.csdn.net/weixin_45669794/article/details/102991806</a></p>
<p><a href="http://www.zzvips.com/article/69641.html">http://www.zzvips.com/article/69641.html</a></p>
<p><a href="https://funyan.cn/p/6173.html">https://funyan.cn/p/6173.html</a></p>
<p><a href="http://www.mianshigee.com/question/132761aes/">http://www.mianshigee.com/question/132761aes/</a></p>
<p><a href="http://www.mianshigee.com/question/65730fcs/">http://www.mianshigee.com/question/65730fcs/</a></p>
<p><a href="http://www.mianshigee.com/question/67979kov/">http://www.mianshigee.com/question/67979kov/</a></p>
<p><a href="http://www.mianshigee.com/question/159947bya/">http://www.mianshigee.com/question/159947bya/</a></p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx</title>
    <url>/2024/02/26/Nginx/</url>
    <content><![CDATA[<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><h4 id="1-什么是Nginx"><a href="#1-什么是Nginx" class="headerlink" title="1.什么是Nginx?"></a>1.什么是Nginx?</h4><p>Nginx是一个高性能的HTTP和反向代理服务器。同时也是一个 IMAP/POP3/SMTP 代理服务器。 官方网站:<a href="http://nginx.org./">http://nginx.org。</a></p>
<h4 id="2-Nginx主要特征？"><a href="#2-Nginx主要特征？" class="headerlink" title="2.Nginx主要特征？"></a>2.Nginx主要特征？</h4><p>处理静态文件，索引文件以及自动索引;打开文件描述符缓冲. 无缓存的反向代理加速，简单的负载均衡和容错. FastCGI，简单的负载均衡和容错.模块化的结构。包括 gzipping, byte ranges, chunked responses,以及 SSI-filter 等filter。如果由 FastCGI 或其它代理服务器处理单页中存在的多个 SSI，则这项处理可以并行 运行，而不需要相互等待。</p>
<p>支持 SSL 和 TLSSNI.</p>
<p>Nginx 它支持内核 Poll 模型，能经受高负载的考验,有报告表明能支持高达 50,000 个并发连接数。</p>
<p>Nginx 具有很高的稳定性。 例如当前 apache 一旦上到 200 个以上进程，web 响应速度就明显非常缓慢了。而 Nginx 采取了分阶段资源分配技术，使得它的 CPU 与内存占用率非常低。nginx 官方表示保持 10,000 个没有活动的连接，它只占 2.5M 内存，所以类似 DOS 这样的攻击对 nginx 来说基本上是毫无用处的。</p>
<p>Nginx 支持热部署。它的启动特别容易, 并且几乎可以做到 7*24 不间断运行，即使运 行数个月也不需要重新启动。对软件版本进行进行热升级。</p>
<p>Nginx 采用 master-slave 模型,能够充分利用 SMP 的优势，且能够减少工作进程在磁 盘 I/O 的阻塞延迟。当采用 select()/poll()调用时，还可以限制每个进程的连接数。</p>
<p>Nginx 代码质量非常高，代码很规范，手法成熟， 模块扩展也很容易。特别值得一提的是强大的 Upstream 与 Filter 链。</p>
<p>Nginx 采用了一些 os 提供的最新特性如对 sendfile (Linux2.2+)，accept-filter (FreeBSD4.1+)，TCP_DEFER_ACCEPT (Linux 2.4+)的支持，从而大大提高了性能。</p>
<p>免费开源，可以做高并发负载均衡。</p>
<h4 id="3-Nginx-常用命令"><a href="#3-Nginx-常用命令" class="headerlink" title="3.Nginx 常用命令?"></a>3.Nginx 常用命令?</h4><p>启动 nginx 。<br>停止 nginx -s stop 或 nginx -s quit 。<br>重载配置 ./sbin/nginx -s reload(平滑重启) 或 service nginx reload 。<br>重载指定配置文件 .nginx -c /usr/local/nginx/conf/nginx.conf 。<br>查看 nginx 版本 nginx -v 。<br>检查配置文件是否正确 nginx -t 。<br>显示帮助信息 nginx -h 。</p>
<h4 id="4-工作模式及连接数上限"><a href="#4-工作模式及连接数上限" class="headerlink" title="4.工作模式及连接数上限?"></a>4.工作模式及连接数上限?</h4><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">events</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="attribute">use</span> <span class="literal">epoll</span>; <span class="comment">#epoll 是多路复用 IO(I/O Multiplexing)中的一种方 式,但是仅用于 linux2.6 以上内核,可以大大提高 nginx 的性能</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">worker_connections</span> <span class="number">1024</span>;<span class="comment">#单个后台 worker process 进程的最大并发链接数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># multi_accept on; </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-Nginx负载均衡几种算法？"><a href="#5-Nginx负载均衡几种算法？" class="headerlink" title="5.Nginx负载均衡几种算法？"></a>5.Nginx负载均衡几种算法？</h4><p>5种。</p>
<p>1.轮询模式（默认）<br>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。<br>2.权重模式<br>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况<br>3.IP_hash模式 （IP散列）<br>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。<br>4.url_hash模式<br>5.fair模式<br>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p>
<h4 id="6-nginx有几种进程模型"><a href="#6-nginx有几种进程模型" class="headerlink" title="6.nginx有几种进程模型?"></a>6.nginx有几种进程模型?</h4><p>分为master-worker模式和单进程模式。在master-worker模式下，有一个master进程和至少一个的worker进程，单进程模式顾名思义只有一个进程。</p>
<h4 id="7-如何定义错误提示页面？"><a href="#7-如何定义错误提示页面？" class="headerlink" title="7.如何定义错误提示页面？"></a>7.如何定义错误提示页面？</h4><p># 定义错误提示页面</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">error_page</span> <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> /50x.html;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> = /50x.html &#123; <span class="attribute">root</span> /root;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-如何精准匹配路径"><a href="#8-如何精准匹配路径" class="headerlink" title="8.如何精准匹配路径?"></a>8.如何精准匹配路径?</h4><p>location  =开头表示精准匹配</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> = /get &#123;</span><br><span class="line"><span class="comment">#规则 A &#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="9-路径匹配优先级？"><a href="#9-路径匹配优先级？" class="headerlink" title="9.路径匹配优先级？"></a>9.路径匹配优先级？</h4><p>多个 location 配置的情况下匹配顺序为<br>首先匹配 =，其次匹配^~, 其次是按文件中顺序的正则匹配，最后是交给 / 通用匹配。当 有匹配成功时候，停止匹配，按当前匹配规则处理请求。</p>
<h4 id="10-如何把请求转发给后端应用服务器？"><a href="#10-如何把请求转发给后端应用服务器？" class="headerlink" title="10.如何把请求转发给后端应用服务器？"></a>10.如何把请求转发给后端应用服务器？</h4><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> = / &#123;</span><br><span class="line"></span><br><span class="line"><span class="attribute">proxy_pass</span> http://tomcat:8080/index </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="11-如何根据文件类型设置过期时间？"><a href="#11-如何根据文件类型设置过期时间？" class="headerlink" title="11.如何根据文件类型设置过期时间？"></a>11.如何根据文件类型设置过期时间？</h4><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~* \.(js|css|jpg|jpeg|gif|png|swf)$</span> &#123;</span><br><span class="line"><span class="attribute">if</span> (-f $request_filename) &#123;</span><br><span class="line"><span class="attribute">expires</span> <span class="number">1h</span>;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="12-禁止访问某个目录？"><a href="#12-禁止访问某个目录？" class="headerlink" title="12.禁止访问某个目录？"></a>12.禁止访问某个目录？</h4><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span><span class="regexp"> ^~/path/</span> &#123;</span><br><span class="line">    <span class="attribute">deny</span> all;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="13-Nginx负载均衡实现过程？"><a href="#13-Nginx负载均衡实现过程？" class="headerlink" title="13.Nginx负载均衡实现过程？"></a>13.Nginx负载均衡实现过程？</h4><p>首先在 http 模块中配置使用 upstream 模块定义后台的 webserver 的池子，名为 proxy-web，在池子中我们可以添加多台后台 webserver，其中状态 检查、调度算法都是在池子中配置;然后在 serverr 模块中定义虚拟主机，但是这个虚拟主 机不指定自己的 web 目录站点，它将使用 location 匹配 url 然后转发到上面定义好的 web 池子中，最后根据调度策略再转发到后台 web server 上 。</p>
<h4 id="14-负载均衡配置？"><a href="#14-负载均衡配置？" class="headerlink" title="14.负载均衡配置？"></a>14.负载均衡配置？</h4><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Upstream</span> proxy_nginx &#123;</span><br><span class="line"></span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.0.254</span>  weight=1max_fails=<span class="number">2</span> fail_timeout=<span class="number">10s</span> ; </span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.0.253</span> weight=<span class="number">2</span> max_fails=2fail_timeout=<span class="number">10s</span>;</span><br><span class="line">server192.168.0.252 backup; server192.168.0.251 down;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line"> <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line"> <span class="attribute">server_name</span> xiaoka.com;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line"></span><br><span class="line"> <span class="attribute">proxy_pass</span> http:// proxy_nginx;</span><br><span class="line"> <span class="attribute">proxy_set_header</span> Host</span><br><span class="line"> proxy_set_header X-Real-IP</span><br><span class="line"> proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="15-设置超时时间？"><a href="#15-设置超时时间？" class="headerlink" title="15.设置超时时间？"></a>15.设置超时时间？</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line"> ……….</span><br><span class="line"> <span class="attribute">keepalive_timeout</span> <span class="number">60</span>; <span class="comment">###设置客户端连接保持会话的超时时间，超过这个时间，服务器会关闭该连接。 tcp_nodelay on;</span></span><br><span class="line"> \####打开 tcp_nodelay，在包含了 keepalive 参数才有效</span><br><span class="line"> <span class="attribute">client_header_timeout</span> <span class="number">15</span>; <span class="comment">####设置客户端请求头读取超时时间，如果超过这个时间，客户端还没有发送任何数据， Nginx 将返回“Request time out(408)”错误</span></span><br><span class="line"> <span class="attribute">client_body_timeout</span> <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">\####设置客户端请求主体读取超时时间，如果超过这个时间，客户端还没有发送任何数据， Nginx 将返回“Request time out(408)”错误</span><br><span class="line"> <span class="attribute">send_timeout</span> <span class="number">15</span>; <span class="comment">####指定响应客户端的超时时间。这个超过仅限于两个连接活动之间的时间，如果超过这 个时间，客户端没有任何活动，Nginx 将会关闭连接。</span></span><br><span class="line"></span><br><span class="line">…… &#125;</span><br></pre></td></tr></table></figure>

<h4 id="16-开启压缩功能好处？坏处？"><a href="#16-开启压缩功能好处？坏处？" class="headerlink" title="16.开启压缩功能好处？坏处？"></a>16.开启压缩功能好处？坏处？</h4><p>好处：压缩是可以节省带宽，提高传输效率</p>
<p>坏处：但是由于是在服务器上进行压缩，会消耗服务器起源</p>
<h4 id="17-Nginx配置文件nginx-conf有哪些属性模块"><a href="#17-Nginx配置文件nginx-conf有哪些属性模块" class="headerlink" title="17.Nginx配置文件nginx.conf有哪些属性模块?"></a>17.Nginx配置文件nginx.conf有哪些属性模块?</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">worker_processes  1；                					# worker进程的数量</span><br><span class="line">events &#123;                              					# 事件区块开始</span><br><span class="line">    worker_connections  1024；            				# 每个worker进程支持的最大连接数</span><br><span class="line">&#125;                                    					# 事件区块结束</span><br><span class="line">http &#123;                               					# HTTP区块开始</span><br><span class="line">    include       mime.types；            				# Nginx支持的媒体类型库文件</span><br><span class="line">    default_type  application&#x2F;octet-stream；     		# 默认的媒体类型</span><br><span class="line">    sendfile        on；       							# 开启高效传输模式</span><br><span class="line">    keepalive_timeout  65；       						# 连接超时</span><br><span class="line">    server &#123;            								# 第一个Server区块开始，表示一个独立的虚拟主机站点</span><br><span class="line">        listen       80；      							# 提供服务的端口，默认80</span><br><span class="line">        server_name  localhost；       					# 提供服务的域名主机名</span><br><span class="line">        location &#x2F; &#123;            						# 第一个location区块开始</span><br><span class="line">            root   html；       						# 站点的根目录，相当于Nginx的安装目录</span><br><span class="line">            index  index.html index.htm；      			# 默认的首页文件，多个用空格分开</span><br><span class="line">        &#125;          										# 第一个location区块结果</span><br><span class="line">        error_page   500502503504  &#x2F;50x.html；     		# 出现对应的http状态码时，使用50x.html回应客户</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;          				# location区块开始，访问50x.html</span><br><span class="line">            root   html；      							# 指定对应的站点目录为html</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    ......</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="18-Nginx静态资源"><a href="#18-Nginx静态资源" class="headerlink" title="18.Nginx静态资源?"></a>18.Nginx静态资源?</h4><p> 静态资源访问，就是存放在nginx的html页面，我们也可以编写</p>
<h4 id="19-如何用Nginx解决前端跨域问题？"><a href="#19-如何用Nginx解决前端跨域问题？" class="headerlink" title="19.如何用Nginx解决前端跨域问题？"></a>19.如何用Nginx解决前端跨域问题？</h4><ul>
<li>使用Nginx转发请求。把跨域的接口写成调本域的接口，然后将这些接口转发到真正的请求地址。</li>
</ul>
<h4 id="20-Nginx虚拟主机怎么配置"><a href="#20-Nginx虚拟主机怎么配置" class="headerlink" title="20.Nginx虚拟主机怎么配置?"></a>20.Nginx虚拟主机怎么配置?</h4><ul>
<li>1、基于域名的虚拟主机，通过域名来区分虚拟主机——应用：外部网站</li>
<li>2、基于端口的虚拟主机，通过端口来区分虚拟主机——应用：公司内部网站，外部网站的管理后台</li>
<li>3、基于ip的虚拟主机。</li>
</ul>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h4><ul>
<li><p>《Nginx从入门到精通》</p>
</li>
<li><p>《Nginx高性能Web服务器详解》</p>
</li>
<li><p>《深入理解nginx》</p>
<p><img src="https://gitee.com/yizhibuerdai/Imagetools/raw/master/images/common1.png" alt="WechatIMG360"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Web Servers</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty</title>
    <url>/2024/02/16/Netty/</url>
    <content><![CDATA[<h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><h4 id="1-Netty的特点？"><a href="#1-Netty的特点？" class="headerlink" title="1.Netty的特点？"></a>1.Netty的特点？</h4><ul>
<li>一个高性能、异步事件驱动的NIO框架，它提供了对TCP、UDP和文件传输的支持</li>
<li>使用更高效的socket底层，对epoll空轮询引起的cpu占用飙升在内部进行了处理，避免了直接使用NIO的陷阱，简化了NIO的处理方式。</li>
<li>采用多种decoder/encoder 支持，对TCP粘包/分包进行自动化处理</li>
<li>可使用接受/处理线程池，提高连接效率，对重连、心跳检测的简单支持</li>
<li>可配置IO线程数、TCP参数， TCP接收和发送缓冲区使用直接内存代替堆内存，通过内存池的方式循环利用ByteBuf</li>
<li>通过引用计数器及时申请释放不再引用的对象，降低了GC频率</li>
<li>使用单线程串行化的方式，高效的Reactor线程模型</li>
<li>大量使用了volitale、使用了CAS和原子类、线程安全类的使用、读写锁的使用</li>
</ul>
<h4 id="2-Netty的线程模型？"><a href="#2-Netty的线程模型？" class="headerlink" title="2.Netty的线程模型？"></a>2.Netty的线程模型？</h4><ul>
<li>Netty通过Reactor模型基于多路复用器接收并处理用户请求，内部实现了两个线程池，boss线程池和work线程池，其中boss线程池的线程负责处理请求的accept事件，当接收到accept事件的请求时，把对应的socket封装到一个NioSocketChannel中，并交给work线程池，其中work线程池负责请求的read和write事件，由对应的Handler处理。</li>
<li>单线程模型：所有I/O操作都由一个线程完成，即多路复用、事件分发和处理都是在一个Reactor线程上完成的。既要接收客户端的连接请求,向服务端发起连接，又要发送/读取请求或应答/响应消息。一个NIO 线程同时处理成百上千的链路，性能上无法支撑，速度慢，若线程进入死循环，整个程序不可用，对于高负载、大并发的应用场景不合适。</li>
<li>多线程模型：有一个NIO 线程（Acceptor） 只负责监听服务端，接收客户端的TCP 连接请求；NIO 线程池负责网络IO 的操作，即消息的读取、解码、编码和发送；1 个NIO 线程可以同时处理N 条链路，但是1 个链路只对应1 个NIO 线程，这是为了防止发生并发操作问题。但在并发百万客户端连接或需要安全认证时，一个Acceptor 线程可能会存在性能不足问题。</li>
<li>主从多线程模型：Acceptor 线程用于绑定监听端口，接收客户端连接，将SocketChannel 从主线程池的Reactor 线程的多路复用器上移除，重新注册到Sub 线程池的线程上，用于处理I/O 的读写等操作，从而保证mainReactor只负责接入认证、握手等操作；</li>
</ul>
<h4 id="3-TCP-粘包-拆包的原因及解决方法？"><a href="#3-TCP-粘包-拆包的原因及解决方法？" class="headerlink" title="3.TCP 粘包/拆包的原因及解决方法？"></a>3.TCP 粘包/拆包的原因及解决方法？</h4><ul>
<li>TCP是以流的方式来处理数据，一个完整的包可能会被TCP拆分成多个包进行发送，也可能把小的封装成一个大的数据包发送。</li>
<li>TCP粘包/分包的原因：<ul>
<li>应用程序写入的字节大小大于套接字发送缓冲区的大小，会发生拆包现象，而应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包现象；</li>
<li>进行MSS大小的TCP分段，当TCP报文长度-TCP头部长度&gt;MSS的时候将发生拆包</li>
<li>以太网帧的payload（净荷）大于MTU（1500字节）进行ip分片。</li>
</ul>
</li>
<li>解决方法<ul>
<li>消息定长：FixedLengthFrameDecoder类</li>
<li>包尾增加特殊字符分割：行分隔符类：LineBasedFrameDecoder或自定义分隔符类 ：DelimiterBasedFrameDecoder</li>
<li>将消息分为消息头和消息体：LengthFieldBasedFrameDecoder类。分为有头部的拆包与粘包、长度字段在前且有头部的拆包与粘包、多扩展头部的拆包与粘包。</li>
</ul>
</li>
</ul>
<h4 id="4-了解哪几种序列化协议？"><a href="#4-了解哪几种序列化协议？" class="headerlink" title="4.了解哪几种序列化协议？"></a>4.了解哪几种序列化协议？</h4><ul>
<li>序列化（编码）是将对象序列化为二进制形式（字节数组），主要用于网络传输、数据持久化等；而反序列化（解码）则是将从网络、磁盘等读取的字节数组还原成原始对象，主要用于网络传输对象的解码，以便完成远程调用。</li>
<li>影响序列化性能的关键因素：序列化后的码流大小（网络带宽的占用）、序列化的性能（CPU资源占用）；是否支持跨语言（异构系统的对接和开发语言切换）。</li>
<li>Java默认提供的序列化：无法跨语言、序列化后的码流太大、序列化的性能差</li>
<li>XML，优点：人机可读性好，可指定元素或特性的名称。缺点：序列化数据只包含数据本身以及类的结构，不包括类型标识和程序集信息；只能序列化公共属性和字段；不能序列化方法；文件庞大，文件格式复杂，传输占带宽。适用场景：当做配置文件存储数据，实时数据转换。</li>
<li>JSON，是一种轻量级的数据交换格式，优点：兼容性高、数据格式比较简单，易于读写、序列化后数据较小，可扩展性好，兼容性好、与XML相比，其协议比较简单，解析速度比较快。缺点：数据的描述性比XML差、不适合性能要求为ms级别的情况、额外空间开销比较大。适用场景（可替代ＸＭＬ）：跨防火墙访问、可调式性要求高、基于Web browser的Ajax请求、传输数据量相对小，实时性要求相对低（例如秒级别）的服务。</li>
<li>Fastjson，采用一种“假定有序快速匹配”的算法。优点：接口简单易用、目前java语言中最快的json库。缺点：过于注重快，而偏离了“标准”及功能性、代码质量不高，文档不全。适用场景：协议交互、Web输出、Android客户端</li>
<li>Thrift，不仅是序列化协议，还是一个RPC框架。优点：序列化后的体积小, 速度快、支持多种语言和丰富的数据类型、对于数据字段的增删具有较强的兼容性、支持二进制压缩编码。缺点：使用者较少、跨防火墙访问时，不安全、不具有可读性，调试代码时相对困难、不能与其他传输层协议共同使用（例如HTTP）、无法支持向持久层直接读写数据，即不适合做数据持久化序列化协议。适用场景：分布式系统的RPC解决方案</li>
<li>Avro，Hadoop的一个子项目，解决了JSON的冗长和没有IDL的问题。优点：支持丰富的数据类型、简单的动态语言结合功能、具有自我描述属性、提高了数据解析速度、快速可压缩的二进制数据形式、可以实现远程过程调用RPC、支持跨编程语言实现。缺点：对于习惯于静态类型语言的用户不直观。适用场景：在Hadoop中做Hive、Pig和MapReduce的持久化数据格式。</li>
<li>Protobuf，将数据结构以.proto文件进行描述，通过代码生成工具可以生成对应数据结构的POJO对象和Protobuf相关的方法和属性。优点：序列化后码流小，性能高、结构化数据存储格式（XML JSON等）、通过标识字段的顺序，可以实现协议的前向兼容、结构化的文档更容易管理和维护。缺点：需要依赖于工具生成代码、支持的语言相对较少，官方只支持Java 、C++ 、python。适用场景：对性能要求高的RPC调用、具有良好的跨防火墙的访问属性、适合应用层对象的持久化</li>
<li>其它<ul>
<li>protostuff 基于protobuf协议，但不需要配置proto文件，直接导包即可</li>
<li>Jboss marshaling 可以直接序列化java类， 无须实java.io.Serializable接口</li>
<li>Message pack 一个高效的二进制序列化格式</li>
<li>Hessian 采用二进制协议的轻量级remoting onhttp工具</li>
<li>kryo 基于protobuf协议，只支持java语言,需要注册（Registration），然后序列化（Output），反序列化（Input）</li>
</ul>
</li>
</ul>
<h4 id="5-如何选择序列化协议？"><a href="#5-如何选择序列化协议？" class="headerlink" title="5.如何选择序列化协议？"></a>5.如何选择序列化协议？</h4><ul>
<li>具体场景<ul>
<li>对于公司间的系统调用，如果性能要求在100ms以上的服务，基于XML的SOAP协议是一个值得考虑的方案。</li>
<li>基于Web browser的Ajax，以及Mobile app与服务端之间的通讯，JSON协议是首选。对于性能要求不太高，或者以动态类型语言为主，或者传输数据载荷很小的的运用场景，JSON也是非常不错的选择。</li>
<li>对于调试环境比较恶劣的场景，采用JSON或XML能够极大的提高调试效率，降低系统开发成本。</li>
<li>当对性能和简洁性有极高要求的场景，Protobuf，Thrift，Avro之间具有一定的竞争关系。</li>
<li>对于T级别的数据的持久化应用场景，Protobuf和Avro是首要选择。如果持久化后的数据存储在hadoop子项目里，Avro会是更好的选择。</li>
<li>对于持久层非Hadoop项目，以静态类型语言为主的应用场景，Protobuf会更符合静态类型语言工程师的开发习惯。由于Avro的设计理念偏向于动态类型语言，对于动态语言为主的应用场景，Avro是更好的选择。</li>
<li>如果需要提供一个完整的RPC解决方案，Thrift是一个好的选择。</li>
<li>如果序列化之后需要支持不同的传输层协议，或者需要跨防火墙访问的高性能场景，Protobuf可以优先考虑。</li>
</ul>
</li>
<li>protobuf的数据类型有多种：bool、double、float、int32、int64、string、bytes、enum、message。protobuf的限定符：required: 必须赋值，不能为空、optional:字段可以赋值，也可以不赋值、repeated: 该字段可以重复任意次数（包括0次）、枚举；只能用指定的常量集中的一个值作为其值；</li>
<li>protobuf的基本规则：每个消息中必须至少留有一个required类型的字段、包含0个或多个optional类型的字段；repeated表示的字段可以包含0个或多个数据；[1,15]之内的标识号在编码的时候会占用一个字节（常用），[16,2047]之内的标识号则占用2个字节，标识号一定不能重复、使用消息类型，也可以将消息嵌套任意多层，可用嵌套消息类型来代替组。</li>
<li>protobuf的消息升级原则：不要更改任何已有的字段的数值标识；不能移除已经存在的required字段，optional和repeated类型的字段可以被移除，但要保留标号不能被重用。新添加的字段必须是optional或repeated。因为旧版本程序无法读取或写入新增的required限定符的字段。</li>
<li>编译器为每一个消息类型生成了一个.java文件，以及一个特殊的Builder类（该类是用来创建消息类接口的）。如：UserProto.User.Builder builder = UserProto.User.newBuilder();builder.build()；</li>
<li>Netty中的使用：ProtobufVarint32FrameDecoder 是用于处理半包消息的解码类；ProtobufDecoder(UserProto.User.getDefaultInstance())这是创建的UserProto.java文件中的解码类；ProtobufVarint32LengthFieldPrepender 对protobuf协议的消息头上加上一个长度为32的整形字段，用于标志这个消息的长度的类；ProtobufEncoder 是编码类</li>
<li>将StringBuilder转换为ByteBuf类型：copiedBuffer()方法</li>
</ul>
<h4 id="6-Netty的零拷贝实现？"><a href="#6-Netty的零拷贝实现？" class="headerlink" title="6.Netty的零拷贝实现？"></a>6.Netty的零拷贝实现？</h4><ul>
<li>Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。堆内存多了一次内存拷贝，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中。ByteBuffer由ChannelConfig分配，而ChannelConfig创建ByteBufAllocator默认使用Direct Buffer</li>
<li>CompositeByteBuf 类可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf, 避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。addComponents方法将 header 与 body 合并为一个逻辑上的 ByteBuf, 这两个 ByteBuf 在CompositeByteBuf 内部都是单独存在的, CompositeByteBuf 只是逻辑上是一个整体</li>
<li>通过 FileRegion 包装的FileChannel.tranferTo方法 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环write方式导致的内存拷贝问题。</li>
<li>通过 wrap方法, 我们可以将 byte[] 数组、ByteBuf、ByteBuffer等包装成一个 Netty ByteBuf 对象, 进而避免了拷贝操作。</li>
<li>Selector BUG：若Selector的轮询结果为空，也没有wakeup或新消息处理，则发生空轮询，CPU使用率100%，</li>
<li>Netty的解决办法：对Selector的select操作周期进行统计，每完成一次空的select操作进行一次计数，若在某个周期内连续发生N次空轮询，则触发了epoll死循环bug。重建Selector，判断是否是其他线程发起的重建请求，若不是则将原SocketChannel从旧的Selector上去除注册，重新注册到新的Selector上，并将原来的Selector关闭。</li>
</ul>
<h4 id="7-Netty的高性能表现在哪些方面？"><a href="#7-Netty的高性能表现在哪些方面？" class="headerlink" title="7.Netty的高性能表现在哪些方面？"></a>7.Netty的高性能表现在哪些方面？</h4><ul>
<li><strong>心跳</strong>，对服务端：会定时清除闲置会话inactive(netty5)，对客户端:用来检测会话是否断开，是否重来，检测网络延迟，其中idleStateHandler类 用来检测会话状态</li>
<li><strong>串行无锁化设计</strong>，即消息的处理尽可能在同一个线程内完成，期间不进行线程切换，这样就避免了多线程竞争和同步锁。表面上看，串行化设计似乎CPU利用率不高，并发程度不够。但是，通过调整NIO线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列-多个工作线程模型性能更优。</li>
<li><strong>可靠性</strong>，链路有效性检测：链路空闲检测机制，读/写空闲超时机制；内存保护机制：通过内存池重用ByteBuf;ByteBuf的解码保护；优雅停机：不再接收新消息、退出前的预处理操作、资源的释放操作。</li>
<li><strong>Netty安全性</strong>：支持的安全协议：SSL V2和V3，TLS，SSL单向认证、双向认证和第三方CA认证。</li>
<li><strong>高效并发编程的体现</strong>：volatile的大量、正确使用；CAS和原子类的广泛使用；线程安全容器的使用；通过读写锁提升并发性能。IO通信性能三原则：传输（AIO）、协议（Http）、线程（主从多线程）</li>
<li><strong>流量整型</strong>的作用（变压器）：防止由于上下游网元性能不均衡导致下游网元被压垮，业务流中断；防止由于通信模块接受消息过快，后端业务线程处理不及时导致撑死问题。</li>
<li><strong>TCP参数配置</strong>：SO_RCVBUF和SO_SNDBUF：通常建议值为128K或者256K；SO_TCPNODELAY：NAGLE算法通过将缓冲区内的小封包自动相连，组成较大的封包，阻止大量小封包的发送阻塞网络，从而提高网络应用效率。但是对于时延敏感的应用场景需要关闭该优化算法；</li>
</ul>
<h4 id="8-客户端关闭的时候会抛出异常，死循环"><a href="#8-客户端关闭的时候会抛出异常，死循环" class="headerlink" title="8.客户端关闭的时候会抛出异常，死循环"></a>8.客户端关闭的时候会抛出异常，死循环</h4><p>解决方案</p>
<pre><code>int read = channel.read(buffer);
if(read &gt; 0)&#123;
byte[] data = buffer.array();
String msg = new String(data).trim();
System.out.println(“服务端收到信息：” + msg);
    //回写数据
    ByteBuffer outBuffer = ByteBuffer.wrap(&quot;好的&quot;.getBytes());
    channel.write(outBuffer);// 将消息回送给客户端
&#125;else&#123;
    System.out.println(&quot;客户端关闭&quot;);
    key.cancel();
&#125;
</code></pre>
<h4 id="9、selector-select-阻塞，那为什么说nio是非阻塞的IO？"><a href="#9、selector-select-阻塞，那为什么说nio是非阻塞的IO？" class="headerlink" title="9、selector.select();阻塞，那为什么说nio是非阻塞的IO？"></a>9、selector.select();阻塞，那为什么说nio是非阻塞的IO？</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">selector.select()</span><br><span class="line">selector.select(1000);不阻塞 会继续往下执行程序</span><br><span class="line">selector.wakeup();也可以唤醒selector 继续往下执行程序</span><br><span class="line">selector.selectNow();也可以立马返回程序 死循环</span><br></pre></td></tr></table></figure>

<h4 id="10、SelectionKey-OP-WRITE是代表什么意思"><a href="#10、SelectionKey-OP-WRITE是代表什么意思" class="headerlink" title="10、SelectionKey.OP_WRITE是代表什么意思"></a>10、SelectionKey.OP_WRITE是代表什么意思</h4><p>OP_WRITE表示底层缓冲区是否有空间，是则响应返还true<br>netty版本大致版本分为 netty3.x 和 netty4.x、netty5.x</p>
<p>netty可以运用在那些领域？</p>
<h4 id="11-分布式进程通信"><a href="#11-分布式进程通信" class="headerlink" title="11.分布式进程通信"></a>11.分布式进程通信</h4><p>例如: hadoop、dubbo、akka等具有分布式功能的框架，底层RPC通信都是基于netty实现的，这些框架使用的版本通常都还在用netty3.x</p>
<h4 id="12、游戏服务器开发"><a href="#12、游戏服务器开发" class="headerlink" title="12、游戏服务器开发"></a>12、游戏服务器开发</h4><p>最新的游戏服务器有部分公司可能已经开始采用netty4.x 或 netty5.x</p>
<h4 id="13、netty服务端hello-world案例"><a href="#13、netty服务端hello-world案例" class="headerlink" title="13、netty服务端hello world案例"></a>13、netty服务端hello world案例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SimpleChannelHandler 处理消息接收和写</span><br><span class="line">&#123;</span><br><span class="line">messageReceived接收消息</span><br><span class="line"></span><br><span class="line">channelConnected新连接，通常用来检测IP是否是黑名单</span><br><span class="line"></span><br><span class="line">channelDisconnected链接关闭，可以再用户断线的时候清楚用户的缓存数据等</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="14、netty客户端hello-world案例"><a href="#14、netty客户端hello-world案例" class="headerlink" title="14、netty客户端hello world案例"></a>14、netty客户端hello world案例</h4><p>channelDisconnected与channelClosed的区别？</p>
<p>channelDisconnected只有在连接建立后断开才会调用<br>channelClosed无论连接是否成功都会调用关闭资源</p>
<h4 id="15-一个NIO是不是只能有一个selector？"><a href="#15-一个NIO是不是只能有一个selector？" class="headerlink" title="15.一个NIO是不是只能有一个selector？"></a>15.一个NIO是不是只能有一个selector？</h4><p>不是，一个系统可以有多个selector</p>
<h4 id="16-selector是不是只能注册一个ServerSocketChannel？"><a href="#16-selector是不是只能注册一个ServerSocketChannel？" class="headerlink" title="16.selector是不是只能注册一个ServerSocketChannel？"></a>16.selector是不是只能注册一个ServerSocketChannel？</h4><p>不是，可以注册多个<br>一个thread + 队列 == 一个单线程线程池 =====&gt; 线程安全的，任务是线性串行执行的<br>线程安全，不会产生阻塞效应 ，使用对象组<br>线程不安全，会产生阻塞效应， 使用对象池</p>
<h4 id="17-心跳其实就是一个普通的请求，特点数据简单，业务也简单"><a href="#17-心跳其实就是一个普通的请求，特点数据简单，业务也简单" class="headerlink" title="17.心跳其实就是一个普通的请求，特点数据简单，业务也简单"></a>17.心跳其实就是一个普通的请求，特点数据简单，业务也简单</h4><p>心跳对于服务端来说，定时清除闲置会话inactive(netty5) channelclose(netty3)<br>心跳对客户端来说，用来检测会话是否断开，是否重连！ 用来检测网络延时！</p>
<h4 id="18-Netty-IdleStateHandler出现问题-我是否以错误的方式对其进行了测试？"><a href="#18-Netty-IdleStateHandler出现问题-我是否以错误的方式对其进行了测试？" class="headerlink" title="18.Netty IdleStateHandler出现问题-我是否以错误的方式对其进行了测试？"></a>18.Netty IdleStateHandler出现问题-我是否以错误的方式对其进行了测试？</h4><p>我有一个玩具Netty服务器，并且尝试在客户端的通道未发生任何事件时向其发送心跳消息。我正在通过telnet到服务器，编写消息然后不发送任何内容来对此进行测试，但是我听不到任何声音！</p>
<p>安慰：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;telnet localhost 6969</span><br><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to localhost.</span><br><span class="line">Escape character is &#39;^]&#39;.</span><br><span class="line">&gt;&gt;foo</span><br><span class="line">Did you say &#39;foo&#39;?</span><br></pre></td></tr></table></figure>

<p>MyPipelineFactory.java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyPipelineFactory implements ChannelPipelineFactory &#123;</span><br><span class="line">    private final Timer timer;</span><br><span class="line">    private static final ChannelHandler stringDecoder &#x3D; new StringDecoder();</span><br><span class="line">    private static final ChannelHandler stringEncoder &#x3D; new StringEncoder();</span><br><span class="line">    private final ChannelHandler idleStateHandler;</span><br><span class="line"></span><br><span class="line">    public MyPipelineFactory(Timer t) &#123;</span><br><span class="line">        this.timer &#x3D; t;</span><br><span class="line">        this.idleStateHandler &#x3D; new IdleStateHandler(timer, 5, 5, 5);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ChannelPipeline getPipeline() &#123;</span><br><span class="line">        &#x2F;&#x2F; create default pipeline from static method</span><br><span class="line">        ChannelPipeline pipeline &#x3D; Channels.pipeline();</span><br><span class="line">        pipeline.addLast(&quot;idleStateHandler&quot;, this.idleStateHandler); &#x2F;&#x2F; heartbeat</span><br><span class="line">        pipeline.addLast(&quot;framer&quot;, new DelimiterBasedFrameDecoder(1024, Delimiters.lineDelimiter()));</span><br><span class="line">        &#x2F;&#x2F;pipeline.addLast(&quot;frameDecoder&quot;, new LengthFieldBasedFrameDecoder(1024,0,1)); &#x2F;&#x2F; get header from message</span><br><span class="line">        pipeline.addLast(&quot;stringDecoder&quot;, stringDecoder);</span><br><span class="line">        pipeline.addLast(&quot;stringEncoder&quot;, stringEncoder);</span><br><span class="line">        pipeline.addLast(&quot;ServerHandler&quot;, new ServerHandler()); &#x2F;&#x2F; goes at the end</span><br><span class="line"></span><br><span class="line">        return pipeline;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HeartbeatHandler.java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HeartbeatHandler extends IdleStateAwareChannelHandler &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelIdle(ChannelHandlerContext ctx, IdleStateEvent e) &#123;</span><br><span class="line">        if (e.getState() &#x3D;&#x3D; IdleState.READER_IDLE) &#123;</span><br><span class="line">            System.out.println(&quot;Reader idle, closing channel&quot;);</span><br><span class="line">            &#x2F;&#x2F;e.getChannel().close();</span><br><span class="line">            e.getChannel().write(&quot;heartbeat-reader_idle&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (e.getState() &#x3D;&#x3D; IdleState.WRITER_IDLE) &#123;</span><br><span class="line">            System.out.println(&quot;Writer idle, sending heartbeat&quot;);</span><br><span class="line">            e.getChannel().write(&quot;heartbeat-writer_idle&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (e.getState() &#x3D;&#x3D; IdleState.ALL_IDLE) &#123;</span><br><span class="line">            System.out.println(&quot;All idle, sending heartbeat&quot;);</span><br><span class="line">            e.getChannel().write(&quot;heartbeat-all_idle&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>固定：</p>
<p>我忘记了HeartbeatHandler，它需要IdleStateHandler（这部分对我来说并不明显）。这样可行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyPipelineFactory implements ChannelPipelineFactory &#123;</span><br><span class="line">    private final Timer timer;</span><br><span class="line">    private static final ChannelHandler stringDecoder &#x3D; new StringDecoder();</span><br><span class="line">    private static final ChannelHandler stringEncoder &#x3D; new StringEncoder();</span><br><span class="line">    private final ChannelHandler idleStateHandler;</span><br><span class="line">    private final ChannelHandler heartbeatHandler;</span><br><span class="line"></span><br><span class="line">    public MyPipelineFactory(Timer t) &#123;</span><br><span class="line">        this.timer &#x3D; t;</span><br><span class="line">        this.idleStateHandler &#x3D; new IdleStateHandler(timer, 5, 5, 5);</span><br><span class="line">        this.heartbeatHandler &#x3D; new HeartbeatHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ChannelPipeline getPipeline() &#123;</span><br><span class="line">        &#x2F;&#x2F; create default pipeline from static method</span><br><span class="line">        ChannelPipeline pipeline &#x3D; Channels.pipeline();</span><br><span class="line">        pipeline.addLast(&quot;idleStateHandler&quot;, this.idleStateHandler);</span><br><span class="line">        pipeline.addLast(&quot;heartbeatHandler&quot;, this.heartbeatHandler); &#x2F;&#x2F; heartbeat</span><br><span class="line">        pipeline.addLast(&quot;framer&quot;, new DelimiterBasedFrameDecoder(1024, Delimiters.lineDelimiter()));</span><br><span class="line">        &#x2F;&#x2F;pipeline.addLast(&quot;frameDecoder&quot;, new LengthFieldBasedFrameDecoder(1024,0,1)); &#x2F;&#x2F; get header from message</span><br><span class="line">        pipeline.addLast(&quot;stringDecoder&quot;, stringDecoder);</span><br><span class="line">        pipeline.addLast(&quot;stringEncoder&quot;, stringEncoder);</span><br><span class="line">        pipeline.addLast(&quot;ServerHandler&quot;, new ServerHandler()); &#x2F;&#x2F; goes at the end</span><br><span class="line"></span><br><span class="line">        return pipeline;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="19-Netty如何使用线程池？"><a href="#19-Netty如何使用线程池？" class="headerlink" title="19.Netty如何使用线程池？"></a>19.Netty如何使用线程池？</h4><p>您能解释一下Netty如何使用线程池工作吗？我是否正确理解，线程池有两种：老板线程和工人线程。老板用于执行I /<br>O，而worker用于调用用户回调（messageReceived）来处理数据？</p>
<p>这是来自NioServerSocketChannelFactory文档</p>
<blockquote>
<p>一个ServerSocketChannelFactory，它创建一个基于NIO的服务器端ServerSocketChannel。它利用NIO引入的非阻塞I<br>/ O模式来有效地服务许多并发连接。</p>
<p>线程如何工作<br>NioServerSocketChannelFactory中有两种类型的线程：一个是老板线程，另一个是工作线程。</p>
<p>老板线程</p>
<p>每个绑定的ServerSocketChannel都有自己的老板线程。例如，如果您打开了两个服务器端口（例如80和443），则将有两个老板线程。Boss线程接受传入的连接，直到未绑定端口。一旦成功接受了连接，老板线程就将接受的Channel传递给NioServerSocketChannelFactory管理的工作线程之一。</p>
<p>工作线程<br>一个NioServerSocketChannelFactory可以具有一个或多个工作线程。工作线程以非阻塞模式对一个或多个通道执行非阻塞读写。</p>
</blockquote>
<p>在Nio模型中，bossThread照顾所有有界套接字（监听套接字），workerThread照顾Accepted-<br>socket（包括IO和调用messageMethod等接收事件的方法）。</p>
<h4 id="20-Netty-IllegalReferenceCountException"><a href="#20-Netty-IllegalReferenceCountException" class="headerlink" title="20.Netty IllegalReferenceCountException"></a>20.Netty IllegalReferenceCountException</h4><p>尽管我的业务逻辑没有问题，但事实证明我没有使用Netty<br><code>ByteBuf</code>。更新要使用的测试代码后<code>ByteBuf</code>，我遇到了<a href="http://netty.io/wiki/reference-counted-objects.html">IllegalReferenceCountException</a>的无尽循环。我承认对Netty还是陌生的，但这并不能证明在手动分配和释放资源的日子里回来。创建GC就是为了避免这种混乱。迪斯科，有人吗？那贝尔底呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StringDecoder extends AbstractDecoder&lt;String&gt; &#123;</span><br><span class="line">    private static final IntPredicate NEWLINE_DELIMITER &#x3D; b -&gt; b &#x3D;&#x3D; &#39;\n&#39; || b &#x3D;&#x3D; &#39;\r&#39;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Flux&lt;String&gt; decode(Publisher&lt;DataBuffer&gt; publisher, ResolvableType elementType, MimeType mimeType, Map&lt;String, Object&gt; hints) &#123;</span><br><span class="line">        return Flux.from(publisher)</span><br><span class="line">            .scan(Tuples.&lt;Flux&lt;DataBuffer&gt;, Optional&lt;DataBuffer&gt;&gt;of(Flux.empty(), Optional.empty()),</span><br><span class="line">                    (acc, buffer) -&gt; &#123;</span><br><span class="line">                        List&lt;DataBuffer&gt; results &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">                        int startIdx &#x3D; 0, endIdx &#x3D; 0, limit &#x3D; buffer.readableByteCount();</span><br><span class="line">                        Optional&lt;DataBuffer&gt; incomplete &#x3D; acc.getT2();</span><br><span class="line"></span><br><span class="line">                        while (startIdx &lt; limit &amp;&amp; endIdx !&#x3D; -1) &#123;</span><br><span class="line">                            endIdx &#x3D; buffer.indexOf(NEWLINE_DELIMITER, startIdx);</span><br><span class="line">                            int length &#x3D; (endIdx &#x3D;&#x3D; -1 ? limit : endIdx) - startIdx;</span><br><span class="line">                            DataBuffer slice &#x3D; buffer.slice(startIdx, length);</span><br><span class="line">                            DataBuffer tmp &#x3D; incomplete.map(b -&gt; b.write(slice))</span><br><span class="line">                                    .orElse(buffer.factory().allocateBuffer(length).write(slice));</span><br><span class="line">                            tmp &#x3D; DataBufferUtils.retain(tmp);</span><br><span class="line"></span><br><span class="line">                            if (endIdx !&#x3D; -1) &#123;</span><br><span class="line">                                startIdx &#x3D; endIdx + 1;</span><br><span class="line">                                results.add(tmp);</span><br><span class="line">                                incomplete &#x3D; Optional.empty();</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                incomplete &#x3D; Optional.of(tmp);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        releaseBuffer(buffer);</span><br><span class="line"></span><br><span class="line">                        return Tuples.of(Flux.fromIterable(results), incomplete);</span><br><span class="line">                    &#125;)</span><br><span class="line">            .flatMap(t -&gt; &#123;</span><br><span class="line">                t.getT2().ifPresent(this::releaseBuffer);</span><br><span class="line">                return t.getT1();</span><br><span class="line">            &#125;)</span><br><span class="line">            .map(buffer -&gt; &#123;</span><br><span class="line">                &#x2F;&#x2F; charset resolution should in general use supplied mimeType</span><br><span class="line">                String s &#x3D; UTF_8.decode(buffer.asByteBuffer()).toString();</span><br><span class="line">                releaseBuffer(buffer);</span><br><span class="line"></span><br><span class="line">                return s;</span><br><span class="line">            &#125;)</span><br><span class="line">            .log();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void releaseBuffer(DataBuffer buffer) &#123;</span><br><span class="line">        boolean release &#x3D; DataBufferUtils.release(buffer);</span><br><span class="line">        if (release) &#123;</span><br><span class="line">            System.out.println(&quot;Buffer was released.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class StringDecoderTest &#123;</span><br><span class="line">    private StringDecoder stringDecoder &#x3D; new StringDecoder();</span><br><span class="line">    DataBufferFactory dataBufferFactory &#x3D; new NettyDataBufferFactory(UnpooledByteBufAllocator.DEFAULT);</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testDecode() &#123;</span><br><span class="line">        Flux&lt;DataBuffer&gt; pub &#x3D; Flux.just(&quot;abc\n&quot;, &quot;abc&quot;, &quot;def\n&quot;, &quot;abc&quot;, &quot;def\nxyz\n&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;xyz\n&quot;)</span><br><span class="line">                .map(s -&gt; dataBufferFactory.wrap(s.getBytes(UTF_8)));</span><br><span class="line"></span><br><span class="line">        StepVerifier.create(stringDecoder.decode(pub, null, null, null))</span><br><span class="line">                .expectNext(&quot;abc&quot;, &quot;abcdef&quot;, &quot;abcdef&quot;, &quot;xyz&quot;, &quot;abcdefxyz&quot;)</span><br><span class="line">                .verifyComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我不断得到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ERROR] (main) onError(io.netty.util.IllegalReferenceCountException: refCnt: 0)</span><br><span class="line">[ERROR] (main)  - io.netty.util.IllegalReferenceCountException: refCnt: 0</span><br><span class="line">io.netty.util.IllegalReferenceCountException: refCnt: 0</span><br><span class="line">    at io.netty.buffer.AbstractByteBuf.ensureAccessible(AbstractByteBuf.java:1415)</span><br><span class="line">    at io.netty.buffer.UnpooledHeapByteBuf.nioBuffer(UnpooledHeapByteBuf.java:314)</span><br><span class="line">    at io.netty.buffer.AbstractUnpooledSlicedByteBuf.nioBuffer(AbstractUnpooledSlicedByteBuf.java:434)</span><br><span class="line">    at io.netty.buffer.CompositeByteBuf.nioBuffers(CompositeByteBuf.java:1496)</span><br><span class="line">    at io.netty.buffer.CompositeByteBuf.nioBuffer(CompositeByteBuf.java:1468)</span><br><span class="line">    at io.netty.buffer.AbstractByteBuf.nioBuffer(AbstractByteBuf.java:1205)</span><br><span class="line">    at org.springframework.core.io.buffer.NettyDataBuffer.asByteBuffer(NettyDataBuffer.java:234)</span><br><span class="line">    at org.abhijitsarkar.java.StringDecoder.lambda$decode$4(StringDecoder.java:61)</span><br></pre></td></tr></table></figure>

<p>工作代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StringDecoder extends AbstractDecoder&lt;String&gt; &#123;</span><br><span class="line">    private static final IntPredicate NEWLINE_DELIMITER &#x3D; b -&gt; b &#x3D;&#x3D; &#39;\n&#39; || b &#x3D;&#x3D; &#39;\r&#39;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Flux&lt;String&gt; decode(Publisher&lt;DataBuffer&gt; publisher, ResolvableType elementType, MimeType mimeType, Map&lt;String, Object&gt; hints) &#123;</span><br><span class="line">        DataBuffer incomplete &#x3D; new NettyDataBufferFactory(UnpooledByteBufAllocator.DEFAULT).allocateBuffer(0);</span><br><span class="line"></span><br><span class="line">        return Flux.from(publisher)</span><br><span class="line">                .scan(Tuples.&lt;Flux&lt;DataBuffer&gt;, DataBuffer&gt;of(Flux.empty(), retain(incomplete)),</span><br><span class="line">                      (acc, buffer) -&gt; &#123;</span><br><span class="line">                          List&lt;DataBuffer&gt; results &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">                          int startIdx &#x3D; 0, endIdx &#x3D; 0, limit &#x3D; buffer.readableByteCount();</span><br><span class="line"></span><br><span class="line">                          while (startIdx &lt; limit &amp;&amp; endIdx !&#x3D; -1) &#123;</span><br><span class="line">                              endIdx &#x3D; buffer.indexOf(NEWLINE_DELIMITER, startIdx);</span><br><span class="line">                              int length &#x3D; (endIdx &#x3D;&#x3D; -1 ? limit : endIdx) - startIdx;</span><br><span class="line"></span><br><span class="line">                              DataBuffer slice &#x3D; buffer.slice(startIdx, length);</span><br><span class="line">                              byte[] slice1 &#x3D; new byte[length];</span><br><span class="line">                              slice.read(slice1, 0, slice1.length);</span><br><span class="line"></span><br><span class="line">                              if (endIdx !&#x3D; -1) &#123;</span><br><span class="line">                                  byte[] slice2 &#x3D; new byte[incomplete.readableByteCount()];</span><br><span class="line">                                  incomplete.read(slice2, 0, slice2.length);</span><br><span class="line">                                  &#x2F;&#x2F; call retain to match release during decoding to string later</span><br><span class="line">                                  results.add(retain(</span><br><span class="line">                                          incomplete.factory().allocateBuffer()</span><br><span class="line">                                                  .write(slice2)</span><br><span class="line">                                                  .write(slice1)</span><br><span class="line">                                  ));</span><br><span class="line">                                  startIdx &#x3D; endIdx + 1;</span><br><span class="line">                              &#125; else &#123;</span><br><span class="line">                                  incomplete.write(slice1);</span><br><span class="line">                              &#125;</span><br><span class="line">                          &#125;</span><br><span class="line"></span><br><span class="line">                          return Tuples.of(Flux.fromIterable(results), incomplete);</span><br><span class="line">                      &#125;)</span><br><span class="line">                .flatMap(Tuple2::getT1)</span><br><span class="line">                .map(buffer -&gt; &#123;</span><br><span class="line">                    &#x2F;&#x2F; charset resolution should in general use supplied mimeType</span><br><span class="line">                    String s &#x3D; UTF_8.decode(buffer.asByteBuffer()).toString();</span><br><span class="line"></span><br><span class="line">                    return s;</span><br><span class="line">                &#125;)</span><br><span class="line">                .doOnTerminate(() -&gt; release(incomplete))</span><br><span class="line">                .log();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该代码可能更<a href="https://jira.spring.io/browse/SPR-16351">简洁</a>一些，但是适用于Spring bug<br><a href="https://jira.spring.io/browse/SPR-16351">SPR-16351</a>。</p>
<h4 id="21-Java-Netty负载测试问题"><a href="#21-Java-Netty负载测试问题" class="headerlink" title="21.Java Netty负载测试问题"></a>21.Java Netty负载测试问题</h4><p>我编写了使用文本协议接受连接和轰炸消息（〜100字节）的服务器，并且我的实现能够与3rt客户端发送约400K /<br>sec的回送消息。我为此任务选择了Netty，即SUSE 11 RealTime，JRockit<br>RTS。但是，当我开始基于Netty开发自己的客户端时，吞吐量却急剧下降（从400K msg / sec降低到1.3K msg /<br>sec）。客户端的代码非常简单。能否请您提供建议或示例，说明如何编写更有效的客户。实际上，我实际上更关心延迟，但是从吞吐量测试开始，我认为在环回中以1.5Kmsg<br>/ sec的速度正常是不正常的。PS客户端的目的只是接收来自服务器的消息，很少发送心跳信号。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Client.java</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">private static ClientBootstrap bootstrap;</span><br><span class="line">private static Channel connector;</span><br><span class="line">public static boolean start()</span><br><span class="line">&#123;</span><br><span class="line">    ChannelFactory factory &#x3D;</span><br><span class="line">        new NioClientSocketChannelFactory(</span><br><span class="line">                Executors.newCachedThreadPool(),</span><br><span class="line">                Executors.newCachedThreadPool());</span><br><span class="line">    ExecutionHandler executionHandler &#x3D; new ExecutionHandler( new OrderedMemoryAwareThreadPoolExecutor(16, 1048576, 1048576));</span><br><span class="line"></span><br><span class="line">    bootstrap &#x3D; new ClientBootstrap(factory);</span><br><span class="line"></span><br><span class="line">    bootstrap.setPipelineFactory( new ClientPipelineFactory() );</span><br><span class="line"></span><br><span class="line">    bootstrap.setOption(&quot;tcpNoDelay&quot;, true);</span><br><span class="line">    bootstrap.setOption(&quot;keepAlive&quot;, true);</span><br><span class="line">    bootstrap.setOption(&quot;receiveBufferSize&quot;, 1048576);</span><br><span class="line">    ChannelFuture future &#x3D; bootstrap</span><br><span class="line">            .connect(new InetSocketAddress(&quot;localhost&quot;, 9013));</span><br><span class="line">    if (!future.awaitUninterruptibly().isSuccess()) &#123;</span><br><span class="line">        System.out.println(&quot;--- CLIENT - Failed to connect to server at &quot; +</span><br><span class="line">                           &quot;localhost:9013.&quot;);</span><br><span class="line">        bootstrap.releaseExternalResources();</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    connector &#x3D; future.getChannel();</span><br><span class="line"></span><br><span class="line">    return connector.isConnected();</span><br><span class="line">&#125;</span><br><span class="line">public static void main( String[] args )</span><br><span class="line">&#123;</span><br><span class="line">    boolean started &#x3D; start();</span><br><span class="line">    if ( started )</span><br><span class="line">        System.out.println( &quot;Client connected to the server&quot; );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ClientPipelineFactory.java</span><br><span class="line"></span><br><span class="line">public class ClientPipelineFactory  implements ChannelPipelineFactory&#123;</span><br><span class="line"></span><br><span class="line">private final ExecutionHandler executionHandler;</span><br><span class="line">public ClientPipelineFactory( ExecutionHandler executionHandle )</span><br><span class="line">&#123;</span><br><span class="line">    this.executionHandler &#x3D; executionHandle;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public ChannelPipeline getPipeline() throws Exception &#123;</span><br><span class="line">    ChannelPipeline pipeline &#x3D; pipeline();</span><br><span class="line">    pipeline.addLast(&quot;framer&quot;, new DelimiterBasedFrameDecoder(</span><br><span class="line">              1024, Delimiters.lineDelimiter()));</span><br><span class="line">    pipeline.addLast( &quot;executor&quot;, executionHandler);</span><br><span class="line">    pipeline.addLast(&quot;handler&quot;, new MessageHandler() );</span><br><span class="line"></span><br><span class="line">    return pipeline;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MessageHandler.java</span><br><span class="line">public class MessageHandler extends SimpleChannelHandler&#123;</span><br><span class="line"></span><br><span class="line">long max_msg &#x3D; 10000;</span><br><span class="line">long cur_msg &#x3D; 0;</span><br><span class="line">long startTime &#x3D; System.nanoTime();</span><br><span class="line">@Override</span><br><span class="line">public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) &#123;</span><br><span class="line">    cur_msg++;</span><br><span class="line"></span><br><span class="line">    if ( cur_msg &#x3D;&#x3D; max_msg )</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println( &quot;Throughput (msg&#x2F;sec) : &quot; + max_msg* NANOS_IN_SEC&#x2F;(     System.nanoTime() - startTime )   );</span><br><span class="line">        cur_msg &#x3D; 0;</span><br><span class="line">        startTime &#x3D; System.nanoTime();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) &#123;</span><br><span class="line">    e.getCause().printStackTrace();</span><br><span class="line">    e.getChannel().close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新。在服务器端，存在一个定期线程，该线程写入已接受的客户端通道。而且该频道很快就无法写入。更新N2。在管道中添加了OrderedMemoryAwareExecutor，但是吞吐量仍然很低（大约4k<br>msg / sec）</p>
<p>固定。我将执行程序放在整个管道堆栈的前面，结果成功了！</p>
<p>如果服务器正在发送固定大小（〜100字节）的消息，则可以将ReceiveBufferSizePredictor设置为客户端引导程序，这将优化读取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bootstrap.setOption(&quot;receiveBufferSizePredictorFactory&quot;,</span><br><span class="line">            new AdaptiveReceiveBufferSizePredictorFactory(MIN_PACKET_SIZE, INITIAL_PACKET_SIZE, MAX_PACKET_SIZE));</span><br></pre></td></tr></table></figure>

<p>根据您发布的代码段：客户端的nio工作线程正在做管道中的所有事情，因此它将忙于解码和执行消息处理程序。您必须添加一个执行处理程序。</p>
<p>您已经说过，通道从服务器端变得不可写，因此您可能必须在服务器引导程序中调整水印大小。您可以定期监视写缓冲区大小（写队列大小），并确保由于消息无法写到网络而使通道变得不可写。可以通过以下类似的util类来完成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package org.jboss.netty.channel.socket.nio;</span><br><span class="line"></span><br><span class="line">import org.jboss.netty.channel.Channel;</span><br><span class="line"></span><br><span class="line">public final class NioChannelUtil &#123;</span><br><span class="line">  public static long getWriteTaskQueueCount(Channel channel) &#123;</span><br><span class="line">    NioSocketChannel nioChannel &#x3D; (NioSocketChannel) channel;</span><br><span class="line">    return nioChannel.writeBufferSize.get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="22"><a href="#22" class="headerlink" title="22."></a>22.</h4><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.cnblogs.com/xuxinstyle/p/9872915.html">https://www.cnblogs.com/xuxinstyle/p/9872915.html</a></p>
<p><a href="https://blog.csdn.net/qq_38772518/article/details/105834573">https://blog.csdn.net/qq_38772518/article/details/105834573</a></p>
<p><a href="http://www.mianshigee.com/">http://www.mianshigee.com/</a></p>
]]></content>
      <categories>
        <category>Middleware</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>OOM异常</title>
    <url>/2023/02/05/OOM%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h1 id="OOM-异常-OutOfMemoryError"><a href="#OOM-异常-OutOfMemoryError" class="headerlink" title="OOM 异常 (OutOfMemoryError)"></a>OOM 异常 (OutOfMemoryError)</h1><!-- TOC -->

<ul>
<li><a href="#oom-%E5%BC%82%E5%B8%B8-outofmemoryerror">OOM 异常 (OutOfMemoryError)</a><ul>
<li><a href="#java-%E5%A0%86%E6%BA%A2%E5%87%BA">Java 堆溢出</a></li>
<li><a href="#java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E6%BA%A2%E5%87%BA">Java 虚拟机栈和本地方法栈溢出</a></li>
<li><a href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E6%BA%A2%E5%87%BA">方法区和运行时常量池溢出</a></li>
<li><a href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA">直接内存溢出</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h2 id="Java-堆溢出"><a href="#Java-堆溢出" class="headerlink" title="Java 堆溢出"></a>Java 堆溢出</h2><ul>
<li>出现标志：<code>java.lang.OutOfMemoryError: Java heap space</code></li>
<li>解决方法：<ul>
<li>先通过内存映像分析工具分析 Dump 出来的堆转储快照，确认内存中的对象是否是必要的，即分清楚是出现了内存泄漏还是内存溢出；</li>
<li>如果是内存泄漏，通过工具查看泄漏对象到 GC Root 的引用链，定位出泄漏的位置；</li>
<li>如果不存在泄漏，检查虚拟机堆参数（-Xmx 和 -Xms）是否可以调大，检查代码中是否有哪些对象的生命周期过长，尝试减少程序运行期的内存消耗。</li>
</ul>
</li>
<li>虚拟机参数：<ul>
<li><code>-XX:HeapDumpOnOutOfMemoryError</code>：让虚拟机在出现内存泄漏异常时 Dump 出当前的内存堆转储快照用于事后分析。</li>
</ul>
</li>
</ul>
<h2 id="Java-虚拟机栈和本地方法栈溢出"><a href="#Java-虚拟机栈和本地方法栈溢出" class="headerlink" title="Java 虚拟机栈和本地方法栈溢出"></a>Java 虚拟机栈和本地方法栈溢出</h2><ul>
<li>单线程下，栈帧过大、虚拟机容量过小都不会导致 OutOfMemoryError，只会导致 StackOverflowError（栈会比内存先爆掉），一般多线程才会出现 OutOfMemoryError，因为线程本身要占用内存；</li>
<li>如果是多线程导致的 OutOfMemoryError，在不能减少线程数或更换 64 位虚拟机的情况，只能通过减少最大堆和减少栈容量来换取更多的线程；<ul>
<li>这个调节思路和 Java 堆出现 OOM 正好相反，Java 堆出现 OOM 要调大堆内存的设置值，而栈出现 OOM 反而要调小。</li>
</ul>
</li>
</ul>
<h2 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h2><ul>
<li>测试思路：产生大量的类去填满方法区，直到溢出；</li>
<li>在经常动态生成大量 Class 的应用中，如 Spring 框架（使用 CGLib 字节码技术），方法区溢出是一种常见的内存溢出，要特别注意类的回收状况。</li>
</ul>
<h2 id="直接内存溢出"><a href="#直接内存溢出" class="headerlink" title="直接内存溢出"></a>直接内存溢出</h2><ul>
<li>出现特征：Heap Dump 文件中看不见明显异常，程序中直接或间接用了 NIO；</li>
<li>虚拟机参数：<code>-XX:MaxDirectMemorySize</code>，如果不指定，则和 <code>-Xmx</code> 一样。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ</title>
    <url>/2024/03/04/RabbitMQ/</url>
    <content><![CDATA[<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><h4 id="1、什么是-RabbitMQ？为什么使用-RabbitMQ？"><a href="#1、什么是-RabbitMQ？为什么使用-RabbitMQ？" class="headerlink" title="1、什么是 RabbitMQ？为什么使用 RabbitMQ？"></a>1、什么是 RabbitMQ？为什么使用 RabbitMQ？</h4><p>RabbitMQ 是一款开源的，Erlang 编写的，基于 AMQP 协议的，消息中间件；</p>
<p>可以用它来：解耦、异步、削峰。</p>
<h4 id="2、RabbitMQ-有什么优缺点？"><a href="#2、RabbitMQ-有什么优缺点？" class="headerlink" title="2、RabbitMQ 有什么优缺点？"></a>2、RabbitMQ 有什么优缺点？</h4><p>优点：解耦、异步、削峰；</p>
<p>缺点：降低了系统的稳定性：本来系统运行好好的，现在你非要加入个消息队列进去，那消息队列挂了，你的系统不是呵呵了。因此，系统可用性会降低；</p>
<p>增加了系统的复杂性：加入了消息队列，要多考虑很多方面的问题，比如：一致性问题、如何保证消息不被重复消费、如何保证消息可靠性传输等。因此，需要考虑的东西更多，复杂性增大。</p>
<h4 id="3-rabbitmq-的使用场景"><a href="#3-rabbitmq-的使用场景" class="headerlink" title="3.rabbitmq 的使用场景"></a>3.rabbitmq 的使用场景</h4><p>（1）服务间异步通信</p>
<p>（2）顺序消费</p>
<p>（3）定时任务</p>
<p>（4）请求削峰</p>
<h4 id="4-RabbitMQ基本概念"><a href="#4-RabbitMQ基本概念" class="headerlink" title="4.RabbitMQ基本概念"></a>4.RabbitMQ基本概念</h4><p> Broker： 简单来说就是消息队列服务器实体<br>Exchange： 消息交换机，它指定消息按什么规则，路由到哪个队列<br>Queue： 消息队列载体，每个消息都会被投入到一个或多个队列<br>Binding： 绑定，它的作用就是把exchange和queue按照路由规则绑定起来<br>Routing Key： 路由关键字，exchange根据这个关键字进行消息投递<br>VHost： vhost 可以理解为虚拟 broker ，即 mini-RabbitMQ server。其内部均含有独立的 queue、exchange 和 binding 等，但最最重要的是，其拥有独立的权限系统，可以做到 vhost 范围的用户控制。当然，从 RabbitMQ 的全局角度，vhost 可以作为不同权限隔离的手段（一个典型的例子就是不同的应用可以跑在不同的 vhost 中）。<br>Producer： 消息生产者，就是投递消息的程序<br>Consumer： 消息消费者，就是接受消息的程序<br>Channel： 消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务<br>由Exchange、Queue、RoutingKey三个才能决定一个从Exchange到Queue的唯一的线路。</p>
<h4 id="5-RabbitMQ-中的-broker-是指什么？cluster-又是指什么？"><a href="#5-RabbitMQ-中的-broker-是指什么？cluster-又是指什么？" class="headerlink" title="5.RabbitMQ 中的 broker 是指什么？cluster 又是指什么？"></a>5.RabbitMQ 中的 broker 是指什么？cluster 又是指什么？</h4><p><code>broker</code> 是指一个或多个 <code>erlang node</code> 的逻辑分组，且 <code>node</code> 上运行着 <code>RabbitMQ</code> 应用程序。<br><code>cluster</code> 是在 <code>broker</code> 的基础之上，增加了 <code>node</code> 之间共享元数据的约束。</p>
<h4 id="6、RabbitMQ-概念里的-channel、exchange-和-queue-是逻辑概念，还是对应着进程实体？分别起什么作用？"><a href="#6、RabbitMQ-概念里的-channel、exchange-和-queue-是逻辑概念，还是对应着进程实体？分别起什么作用？" class="headerlink" title="6、RabbitMQ 概念里的 channel、exchange 和 queue 是逻辑概念，还是对应着进程实体？分别起什么作用？"></a>6、RabbitMQ 概念里的 channel、exchange 和 queue 是逻辑概念，还是对应着进程实体？分别起什么作用？</h4><p><strong>Queue</strong> 具有自己的 <strong>erlang</strong> 进程；<strong>exchange</strong> 内部实现为保存 binding 关系的查找表；channel 是实际进行路由工作的实体，即负责按照 routing_key 将 message 投递给 queue 。由 AMQP 协议描述可知，channel 是真实 TCP 连接之上的虚拟连接，所有 AMQP 命令都是通过 channel 发送的，且每一个 channel 有唯一的 ID。一个 channel 只能被单独一个操作系统线程使用，故投递到特定 channel 上的 message 是有顺序的。但一个操作系统线程上允许使用多个 channel 。</p>
<h4 id="7-vhost-是什么？起什么作用？"><a href="#7-vhost-是什么？起什么作用？" class="headerlink" title="7 vhost 是什么？起什么作用？"></a>7 vhost 是什么？起什么作用？</h4><p><code>vhost</code> 可以理解为虚拟 <code>broker</code> ，即 <code>mini-RabbitMQ server</code>。其内部均含有独立的 <code>queue</code>、<code>exchange</code> 和 <code>binding</code> 等，但最最重要的是，其拥有独立的权限系统，可以做到 <code>vhost</code> 范围的用户控制。当然，从 <code>RabbitMQ</code> 的全局角度，<code>vhost</code> 可以作为不同权限隔离的手段（一个典型的例子就是不同的应用可以跑在不同的 <code>vhost</code> 中）。</p>
<h4 id="8-消息基于什么传输？"><a href="#8-消息基于什么传输？" class="headerlink" title="8. 消息基于什么传输？"></a>8. 消息基于什么传输？</h4><p>由于TCP连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。RabbitMQ使用信道的方式来传输数据。信道是建立在真实的TCP连接内的虚拟连接，且每条TCP连接上的信道数量没有限制。</p>
<h4 id="9-消息如何分发？"><a href="#9-消息如何分发？" class="headerlink" title="9. 消息如何分发？"></a>9. 消息如何分发？</h4><p>若该队列至少有一个消费者订阅，消息将以循环（round-robin）的方式发送给消费者。每条消息只会分发给一个订阅的消费者（前提是消费者能够正常处理消息并进行确认）。</p>
<h4 id="10-消息怎么路由？"><a href="#10-消息怎么路由？" class="headerlink" title="10. 消息怎么路由？"></a>10. 消息怎么路由？</h4><p>从概念上来说，消息路由必须有三部分：<strong>交换器</strong>、<strong>路由</strong>、<strong>绑定</strong>。生产者把消息发布到交换器上；绑定决定了消息如何从路由器路由到特定的队列；消息最终到达队列，并被消费者接收。</p>
<p>消息发布到交换器时，消息将拥有一个路由键（routing key），在消息创建时设定。<br>通过队列路由键，可以把队列绑定到交换器上。<br>消息到达交换器后，RabbitMQ会将消息的路由键与队列的路由键进行匹配（针对不同的交换器有不同的路由规则）。如果能够匹配到队列，则消息会投递到相应队列中；如果不能匹配到任何队列，消息将进入 “黑洞”。</p>
<p>常用的交换器主要分为一下三种：</p>
<ul>
<li>direct：如果路由键完全匹配，消息就被投递到相应的队列</li>
<li>fanout：如果交换器收到消息，将会广播到所有绑定的队列上</li>
<li>topic：可以使来自不同源头的消息能够到达同一个队列。使用topic交换器时，可以使用通配符。<br>比如：“*” 匹配特定位置的任意文本， “.” 把路由键分为了几部分，“#” 匹配所有规则等。<br>特别注意：发往topic交换器的消息不能随意的设置选择键（routing_key），必须是由”.”隔开的一系列的标识符组成。</li>
</ul>
<h4 id="11-什么是元数据？元数据分为哪些类型？包括哪些内容？与-cluster-相关的元数据有哪些？元数据是如何保存的？元数据在-cluster-中是如何分布的？"><a href="#11-什么是元数据？元数据分为哪些类型？包括哪些内容？与-cluster-相关的元数据有哪些？元数据是如何保存的？元数据在-cluster-中是如何分布的？" class="headerlink" title="11. 什么是元数据？元数据分为哪些类型？包括哪些内容？与 cluster 相关的元数据有哪些？元数据是如何保存的？元数据在 cluster 中是如何分布的？"></a>11. 什么是元数据？元数据分为哪些类型？包括哪些内容？与 cluster 相关的元数据有哪些？元数据是如何保存的？元数据在 cluster 中是如何分布的？</h4><p>在非 <code>cluster</code> 模式下，元数据主要分为 <code>Queue</code> 元数据（queue 名字和属性等）、<code>Exchange</code>元数据（exchange 名字、类型和属性等）、<code>Binding</code> 元数据（存放路由关系的查找表）、<code>Vhost</code>元数据（vhost 范围内针对前三者的名字空间约束和安全属性设置）。<br>在 <code>cluster</code> 模式下，还包括 cluster 中 node 位置信息和 node 关系信息。元数据按照 erlang node 的类型确定是仅保存于 RAM 中，还是同时保存在 RAM 和 disk 上。元数据在 cluster 中是全 node 分布的。</p>
<h4 id="12-在单node-系统和多-node-构成的-cluster-系统中声明-queue、exchange-，以及进行-binding-会有什么不同？"><a href="#12-在单node-系统和多-node-构成的-cluster-系统中声明-queue、exchange-，以及进行-binding-会有什么不同？" class="headerlink" title="12. 在单node 系统和多 node 构成的 cluster 系统中声明 queue、exchange ，以及进行 binding 会有什么不同？"></a>12. 在单node 系统和多 node 构成的 cluster 系统中声明 queue、exchange ，以及进行 binding 会有什么不同？</h4><p>答：当你在单 node 上声明 queue 时，只要该 node 上相关元数据进行了变更，你就会得到 Queue.Declare-ok 回应；而在 cluster 上声明 queue ，则要求 cluster 上的全部 node 都要进行元数据成功更新，才会得到 Queue.Declare-ok 回应。另外，若 node 类型为 RAM node 则变更的数据仅保存在内存中，若类型为 disk node 则还要变更保存在磁盘上的数据。</p>
<p>死信队列&amp;死信交换器：DLX 全称（Dead-Letter-Exchange）,称之为死信交换器，当消息变成一个死信之后，如果这个消息所在的队列存在x-dead-letter-exchange参数，那么它会被发送到x-dead-letter-exchange对应值的交换器上，这个交换器就称之为死信交换器，与这个死信交换器绑定的队列就是死信队列。</p>
<h4 id="13-如何确保消息正确地发送至RabbitMQ？"><a href="#13-如何确保消息正确地发送至RabbitMQ？" class="headerlink" title="13. 如何确保消息正确地发送至RabbitMQ？"></a>13. 如何确保消息正确地发送至RabbitMQ？</h4><p><strong>RabbitMQ</strong>使用发送方确认模式，确保消息正确地发送到<strong>RabbitMQ</strong>。<br>发送方确认模式：将信道设置成<code>confirm</code>模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的ID。一旦消息被投递到目的队列后，或者消息被写入磁盘后（可持久化的消息），信道会发送一个确认给生产者（包含消息唯一ID）。如果<code>RabbitMQ</code>发生内部错误从而导致消息丢失，会发送一条<code>nack</code>（not acknowledged，未确认）消息。发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。</p>
<h4 id="14-如何确保消息接收方消费了消息？"><a href="#14-如何确保消息接收方消费了消息？" class="headerlink" title="14. 如何确保消息接收方消费了消息？"></a>14. 如何确保消息接收方消费了消息？</h4><p>接收方消息确认机制：消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。只有消费者确认了消息，<code>RabbitMQ</code>才能安全地把消息从队列中删除。这里并没有用到超时机制，<code>RabbitMQ</code>仅通过<code>Consumer</code>的连接中断来确认是否需要重新发送消息。也就是说，只要连接不中断，<code>RabbitMQ</code>给了<code>Consumer</code>足够长的时间来处理消息。</p>
<p>下面罗列几种特殊情况：</p>
<ul>
<li>如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ会认为消息没有被分发，然后重新分发给下一个订阅的消费者。（可能存在消息重复消费的隐患，需要根据bizId去重）</li>
<li>如果消费者接收到消息却没有确认消息，连接也未断开，则RabbitMQ认为该消费者繁忙，将不会给该消费者分发更多的消息。</li>
</ul>
<h4 id="15、如何保证-RabbitMQ-不被重复消费？"><a href="#15、如何保证-RabbitMQ-不被重复消费？" class="headerlink" title="15、如何保证 RabbitMQ 不被重复消费？"></a>15、如何保证 RabbitMQ 不被重复消费？</h4><p>先说为什么会重复消费：正常情况下，消费者在消费消息的时候，消费完毕后，会发送一个确认消息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除；</p>
<p>但是因为网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将消息分发给其他的消费者。</p>
<p>针对以上问题，一个解决思路是：保证消息的唯一性，就算是多次传输，不要让消息的多次消费带来影响；保证消息等幂性；</p>
<p>比如：在写入消息队列的数据做唯一标示，消费消息时，根据唯一标识判断是否消费过；</p>
<h4 id="16、如何保证-RabbitMQ-消息的可靠传输？"><a href="#16、如何保证-RabbitMQ-消息的可靠传输？" class="headerlink" title="16、如何保证 RabbitMQ 消息的可靠传输？"></a>16、如何保证 RabbitMQ 消息的可靠传输？</h4><p>消息不可靠的情况可能是消息丢失，劫持等原因；</p>
<p>丢失又分为：生产者丢失消息、消息列表丢失消息、消费者丢失消息；</p>
<p>生产者丢失消息：从生产者弄丢数据这个角度来看，RabbitMQ 提供 transaction 和 confirm 模式来确保生产者不丢消息；</p>
<p>transaction 机制就是说：发送消息前，开启事务（channel.txSelect()）, 然后发送消息，如果发送过程中出现什么异常，事务就会回滚（channel.txRollback()）, 如果发送成功则提交事务（channel.txCommit()）。然而，这种方式有个缺点：吞吐量下降；</p>
<p>confirm 模式用的居多：一旦 channel 进入 confirm 模式，所有在该信道上发布的消息都将会被指派一个唯一的 ID（从 1 开始），一旦消息被投递到所有匹配的队列之后；</p>
<p>rabbitMQ 就会发送一个 ACK 给生产者（包含消息的唯一 ID），这就使得生产者知道消息已经正确到达目的队列了；</p>
<p>如果 rabbitMQ 没能处理该消息，则会发送一个 Nack 消息给你，你可以进行重试操作。</p>
<p>消息队列丢数据：消息持久化。</p>
<p>处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。</p>
<p>这个持久化配置可以和 confirm 机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个 Ack 信号。</p>
<p>这样，如果消息持久化磁盘之前，rabbitMQ 阵亡了，那么生产者收不到 Ack 信号，生产者会自动重发。</p>
<p>那么如何持久化呢？</p>
<p>这里顺便说一下吧，其实也很容易，就下面两步</p>
<ol>
<li>将 queue 的持久化标识 durable 设置为 true, 则代表是一个持久的队列</li>
<li>发送消息的时候将 deliveryMode=2</li>
</ol>
<p>这样设置以后，即使 rabbitMQ 挂了，重启后也能恢复数据</p>
<p>消费者丢失消息：消费者丢数据一般是因为采用了自动确认消息模式，改为手动确认消息即可！</p>
<p>消费者在收到消息之后，处理消息之前，会自动回复 RabbitMQ 已收到消息；</p>
<p>如果这时处理消息失败，就会丢失该消息；</p>
<p>解决方案：处理消息成功后，手动回复确认消息。</p>
<h4 id="17、如何保证-RabbitMQ-消息的顺序性？"><a href="#17、如何保证-RabbitMQ-消息的顺序性？" class="headerlink" title="17、如何保证 RabbitMQ 消息的顺序性？"></a>17、如何保证 RabbitMQ 消息的顺序性？</h4><p>单线程消费保证消息的顺序性；对消息进行编号，消费者处理消息是根据编号处理消息；</p>
<h4 id="18-死信队列和延迟队列的使用"><a href="#18-死信队列和延迟队列的使用" class="headerlink" title="18. 死信队列和延迟队列的使用?"></a>18. 死信队列和延迟队列的使用?</h4><p><strong>死信消息：</strong></p>
<p>消息被拒绝（Basic.Reject或Basic.Nack）并且设置 requeue 参数的值为 false<br>消息过期了<br>队列达到最大的长度</p>
<p><strong>过期消息：</strong></p>
<p>在 rabbitmq 中存在2种方可设置消息的过期时间，第一种通过对队列进行设置，这种设置后，该队列中所有的消息都存在相同的过期时间，第二种通过对消息本身进行设置，那么每条消息的过期时间都不一样。如果同时使用这2种方法，那么以过期时间小的那个数值为准。当消息达到过期时间还没有被消费，那么那个消息就成为了一个 死信 消息。</p>
<p><strong>队列设置：</strong>在队列申明的时候使用 x-message-ttl 参数，单位为 毫秒</p>
<p><strong>单个消息设置：</strong>是设置消息属性的 expiration 参数的值，单位为 毫秒</p>
<p><strong>延时队列：</strong>在rabbitmq中不存在延时队列，但是我们可以通过设置消息的过期时间和死信队列来模拟出延时队列。消费者监听死信交换器绑定的队列，而不要监听消息发送的队列。</p>
<hr>
<p>有了以上的基础知识，我们完成以下需求：</p>
<p>需求：用户在系统中创建一个订单，如果超过时间用户没有进行支付，那么自动取消订单。</p>
<p>分析：</p>
<p>1、上面这个情况，我们就适合使用延时队列来实现，那么延时队列如何创建<br>2、延时队列可以由 过期消息+死信队列 来时间<br>3、过期消息通过队列中设置 x-message-ttl 参数实现<br>4、死信队列通过在队列申明时，给队列设置 x-dead-letter-exchange 参数，然后另外申明一个队列绑定x-dead-letter-exchange对应的交换器。</p>
<h4 id="19-使用了消息队列会有什么缺点"><a href="#19-使用了消息队列会有什么缺点" class="headerlink" title="19. 使用了消息队列会有什么缺点?"></a>19. 使用了消息队列会有什么缺点?</h4><p>1.系统可用性降低:你想啊，本来其他系统只要运行好好的，那你的系统就是正常的。现在你非要加个消息队列进去，那消息队列挂了，你的系统不是呵呵了。因此，系统可用性降低</p>
<p>2.系统复杂性增加:要多考虑很多方面的问题，比如一致性问题、如何保证消息不被重复消费，如何保证保证消息可靠传输。因此，需要考虑的东西更多，系统复杂性增大。</p>
<h4 id="20-多个消费者监听一个队列时，消息如何分发"><a href="#20-多个消费者监听一个队列时，消息如何分发" class="headerlink" title="20. 多个消费者监听一个队列时，消息如何分发?"></a>20. 多个消费者监听一个队列时，消息如何分发?</h4><ul>
<li>轮询: 默认的策略，消费者轮流，平均地接收消息</li>
<li>公平分发: 根据消费者的能力来分发消息，给空闲的消费者发送更多消息</li>
</ul>
<p>当消费者有x条消息没有响应ACK时，不再给这个消费者发送消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.basicQos(<span class="keyword">int</span> x)</span><br></pre></td></tr></table></figure>



<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.cnblogs.com/woadmin/p/10537174.html">https://www.cnblogs.com/woadmin/p/10537174.html</a></p>
<p><a href="https://blog.csdn.net/thinkwon/article/details/104588612/">https://blog.csdn.net/thinkwon/article/details/104588612/</a>    </p>
<p><a href="https://www.cnblogs.com/coder-programming/p/12465314.html">https://www.cnblogs.com/coder-programming/p/12465314.html</a></p>
]]></content>
      <categories>
        <category>Message Queues</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-上卷</title>
    <url>/2024/01/31/Redis-%E4%B8%8A%E5%8D%B7/</url>
    <content><![CDATA[<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h4 id="1-Redis是什么"><a href="#1-Redis是什么" class="headerlink" title="1.Redis是什么?"></a>1.Redis是什么?</h4><p>Redis是一个开放源代码（BSD许可）的内存中数据结构存储，可用作数据库，缓存和消息代理，是一个基于键值对的NoSQl数据库。</p>
<h4 id="2-Redis特性"><a href="#2-Redis特性" class="headerlink" title="2.Redis特性?"></a>2.Redis特性?</h4><ul>
<li>速度快</li>
<li>基于键值对的数据结构服务器</li>
<li>丰富的功能、丰富的数据结构</li>
<li>简单稳定</li>
<li>客户端语言多</li>
<li>持久化</li>
<li>主从复制</li>
<li>高可以 &amp; 分布式</li>
</ul>
<h4 id="3-Redis合适的应用场景？"><a href="#3-Redis合适的应用场景？" class="headerlink" title="3.Redis合适的应用场景？"></a>3.Redis合适的应用场景？</h4><ul>
<li>缓存</li>
<li>排行榜</li>
<li>计数器</li>
<li>分布式会话</li>
<li>分布式锁</li>
<li>社交网络</li>
<li>最新列表</li>
<li>消息系统</li>
</ul>
<h4 id="4-除了Redis你还知道哪些NoSQL数据库？"><a href="#4-除了Redis你还知道哪些NoSQL数据库？" class="headerlink" title="4.除了Redis你还知道哪些NoSQL数据库？"></a>4.除了Redis你还知道哪些NoSQL数据库？</h4><p>MongoDB、MemcacheDB、Cassandra、CouchDB、Hypertable、Leveldb。</p>
<h4 id="5-Redis和Memcache区别？"><a href="#5-Redis和Memcache区别？" class="headerlink" title="5.Redis和Memcache区别？"></a>5.Redis和Memcache区别？</h4><p>支持的存储类型不同，memcached只支持简单的k/v结构。redis支持更多类型的存储结构类型(详见问题6)。</p>
<p>memcached数据不可恢复，redis则可以把数据持久化到磁盘上。</p>
<p>新版本的redis直接自己构建了VM 机制 ，一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。 </p>
<p>redis当物理内存用完时，可以将很久没用到的value交换到磁盘。</p>
<h4 id="6-Redis的有几种数据类型？"><a href="#6-Redis的有几种数据类型？" class="headerlink" title="6.Redis的有几种数据类型？"></a>6.Redis的有几种数据类型？</h4><p>基础：字符串（String）、哈希（hash)、列表（list)、集合(set)、有序集合(zset)。</p>
<p>还有HyperLogLog、流、地理坐标等。</p>
<h4 id="7-Redis有哪些高级功能？"><a href="#7-Redis有哪些高级功能？" class="headerlink" title="7.Redis有哪些高级功能？"></a>7.Redis有哪些高级功能？</h4><p>消息队列、自动过期删除、事务、数据持久化、分布式锁、附近的人、慢查询分析、Sentinel 和集群等多项功能。</p>
<h4 id="8-安装过Redis吗-简单说下步骤？"><a href="#8-安装过Redis吗-简单说下步骤？" class="headerlink" title="8.安装过Redis吗,简单说下步骤？"></a>8.安装过Redis吗,简单说下步骤？</h4><p> 1.下载Redis指定版本源码安装包压缩到当前目录。</p>
<ol>
<li><p>解压缩Redis源码安装包。</p>
</li>
<li><p>建立一个redis目录软链接，指向解压包。</p>
</li>
<li><p>进入redis目录</p>
</li>
<li><p>编译</p>
</li>
<li><p>安装</p>
<p>对于使用docker的童靴来说就比较容易了。</p>
<p>docker pull redis</p>
</li>
</ol>
<h4 id="9-redis几个比较主要的可执行文件？分别是？"><a href="#9-redis几个比较主要的可执行文件？分别是？" class="headerlink" title="9.redis几个比较主要的可执行文件？分别是？"></a>9.redis几个比较主要的可执行文件？分别是？</h4><p><img src="https://gitee.com/yizhibuerdai/Imagetools/raw/master/images/image-20200425221430652.png" alt="image-20200425221430652"></p>
<h4 id="10-启动Redis的几种方式？"><a href="#10-启动Redis的几种方式？" class="headerlink" title="10.启动Redis的几种方式？"></a>10.启动Redis的几种方式？</h4><p>1.默认配置 :   </p>
<p>./redis-server </p>
<p>2.运行启动: redis-server 加上要修改配置名和值（可以是多对），没有配置的将使用默认配置。</p>
<p>例如: redis-server ———port 7359</p>
<p>3.指定配置文件启动:</p>
<p>./redis-server /opt/redis/redis.conf</p>
<h4 id="11-Redis配置需要自己写？如何配置？"><a href="#11-Redis配置需要自己写？如何配置？" class="headerlink" title="11.Redis配置需要自己写？如何配置？"></a>11.Redis配置需要自己写？如何配置？</h4><p>redis目录下有一个redis.conf的模板配置。所以只需要复制模板配置然后修改即可。</p>
<p>一般来说大部分生产环境都会用指定配置文件的方式启动redis。</p>
<h4 id="12-Redis客户端命令执行的方式？"><a href="#12-Redis客户端命令执行的方式？" class="headerlink" title="12.Redis客户端命令执行的方式？"></a>12.Redis客户端命令执行的方式？</h4><p>1.交互方式: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379</span><br></pre></td></tr></table></figure>

<p>连接到redis后，后面执行的命令就可以通过交互方式实现了。</p>
<p>2.命令行方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379 get value</span><br></pre></td></tr></table></figure>

<h4 id="13-如何停止redis服务？"><a href="#13-如何停止redis服务？" class="headerlink" title="13.如何停止redis服务？"></a>13.如何停止redis服务？</h4><p>Kill -9 pid (粗暴，请不要使用,数据不仅不会持久化，还会造成缓存区等资源不能被优雅关闭)</p>
<p>可以用redis 的shutdown 命令，可以选择是否在关闭前持久化数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli shutdown nosave|save</span><br></pre></td></tr></table></figure>

<h4 id="14-如何查看当前键是否存在？"><a href="#14-如何查看当前键是否存在？" class="headerlink" title="14.如何查看当前键是否存在？"></a>14.如何查看当前键是否存在？</h4><p>exists key</p>
<h4 id="15-如何删除数据？"><a href="#15-如何删除数据？" class="headerlink" title="15.如何删除数据？"></a>15.如何删除数据？</h4><p>del key</p>
<h4 id="16-redis为什么快？单线程？"><a href="#16-redis为什么快？单线程？" class="headerlink" title="16.redis为什么快？单线程？"></a>16.redis为什么快？单线程？</h4><ul>
<li>redis使用了单线程架构和I/O多路复用模型模型。</li>
<li>纯内存访问。</li>
<li>由于是单线程避免了线程上下文切换带来的资源消耗。</li>
</ul>
<h4 id="17-字符串最大不能超过多少？"><a href="#17-字符串最大不能超过多少？" class="headerlink" title="17.字符串最大不能超过多少？"></a>17.字符串最大不能超过多少？</h4><p>512MB</p>
<h4 id="18-redis默认分多少个数据库？"><a href="#18-redis默认分多少个数据库？" class="headerlink" title="18.redis默认分多少个数据库？"></a>18.redis默认分多少个数据库？</h4><p>16 </p>
<h4 id="19-redis持久化的几种方式？"><a href="#19-redis持久化的几种方式？" class="headerlink" title="19.redis持久化的几种方式？"></a>19.redis持久化的几种方式？</h4><p>RDB、AOF、混合持久化。</p>
<h4 id="20-RDB持久化"><a href="#20-RDB持久化" class="headerlink" title="20.RDB持久化?"></a>20.RDB持久化?</h4><p>RDB（Redis DataBase)持久化是把当前进程数据生成快照保存到硬盘的过程。</p>
<p>Tips:是以二进制的方式写入磁盘。</p>
<h4 id="21-RDB的持久化是如何触发的？"><a href="#21-RDB的持久化是如何触发的？" class="headerlink" title="21.RDB的持久化是如何触发的？"></a>21.RDB的持久化是如何触发的？</h4><p>手动触发: </p>
<p>save: 阻塞当前Redis服务器，直到RDB过程完成为止，如果数据比较大的话，会造成长时间的阻塞，</p>
<p>线上不建议。</p>
<p>bgsave:redis进程执行 fork操作创作子进程，持久化由子进程负责，完成后自动结束，阻塞只发生在</p>
<p>fork阶段，一半时间很短。</p>
<p>自动触发：</p>
<p>save xsecends n:</p>
<p>表示在x秒内，至少有n个键发生变化，就会触发RDB持久化。也就是说满足了条件就会触发持久化。</p>
<p>flushall :</p>
<p>主从同步触发</p>
<h4 id="22-RDB的优点？"><a href="#22-RDB的优点？" class="headerlink" title="22.RDB的优点？"></a>22.RDB的优点？</h4><ul>
<li>rdb是一个紧凑的二进制文件，代表Redis在某个时间点上的数据快照。</li>
<li>适合于备份，全量复制的场景，对于灾难恢复非常有用。</li>
<li>Redis加载RDB恢复数据的速度远快于AOF方式。</li>
</ul>
<h4 id="23-RDB的缺点？"><a href="#23-RDB的缺点？" class="headerlink" title="23.RDB的缺点？"></a>23.RDB的缺点？</h4><ul>
<li>RDB没法做到实时的持久化。中途意外终止，会丢失一段时间内的数据。</li>
<li>RDB需要fork()创建子进程，属于重量级操作，可能导致Redis卡顿若干秒。</li>
</ul>
<h4 id="24-如何禁用持久化？"><a href="#24-如何禁用持久化？" class="headerlink" title="24.如何禁用持久化？"></a>24.如何禁用持久化？</h4><p>一般来说生成环境不会用到，了解一下也有好处的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config set save &quot;&quot;</span><br></pre></td></tr></table></figure>

<h4 id="25-AOF持久化？"><a href="#25-AOF持久化？" class="headerlink" title="25.AOF持久化？"></a>25.AOF持久化？</h4><p>AOF(append only file)为了解决rdb不能实时持久化的问题，aof来搞定。以独立的日志方式记录把每次命令记录到aof文件中。</p>
<h4 id="26-如何查询AOF是否开启"><a href="#26-如何查询AOF是否开启" class="headerlink" title="26.如何查询AOF是否开启?"></a>26.如何查询AOF是否开启?</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config get appendonly</span><br></pre></td></tr></table></figure>

<h4 id="27-如何开启AOF"><a href="#27-如何开启AOF" class="headerlink" title="27.如何开启AOF?"></a>27.如何开启AOF?</h4><p>命令行方式： 实时生效，但重启后失效。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config set appendonly</span><br></pre></td></tr></table></figure>

<p>配置文件：需要重启生效，重启后依然生效。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>

<h4 id="28-AOF工作流程？"><a href="#28-AOF工作流程？" class="headerlink" title="28.AOF工作流程？"></a>28.AOF工作流程？</h4><p>1.所有写入命令追加到aof_buf缓冲区。</p>
<p>2.AOF缓冲区根据对应的策略向硬盘做同步操作。</p>
<p>3.随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。</p>
<p>4.当redis服务器重启时，可以加载AOF文件进行数据恢复。</p>
<h4 id="29-为什么AOF要先把命令追加到缓存区-aof-buf-中？"><a href="#29-为什么AOF要先把命令追加到缓存区-aof-buf-中？" class="headerlink" title="29.为什么AOF要先把命令追加到缓存区(aof_buf)中？"></a>29.为什么AOF要先把命令追加到缓存区(aof_buf)中？</h4><p>Redis使用单线程响应命令，如果每次写入文件命令都直接追加到硬盘，性能就会取决于硬盘的负载。如果使用缓冲区，redis提供多种缓冲区策略，在性能和安全性方面做出平衡。</p>
<h4 id="30-AOF持久化如何触发的？"><a href="#30-AOF持久化如何触发的？" class="headerlink" title="30.AOF持久化如何触发的？"></a>30.AOF持久化如何触发的？</h4><p>自动触发：满足设置的策略和满足重写触发。</p>
<p>策略：(在配置文件中配置)</p>
<p>![image-20200427101221526](<a href="https://gitee.com/yizhibuerdai/Imagetools/raw/master/images/image-20200427101221526.png">https://gitee.com/yizhibuerdai/Imagetools/raw/master/images/image-20200427101221526.png</a></p>
<p>手动触发：（执行命令）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bgrewriteaof </span><br></pre></td></tr></table></figure>

<h4 id="31-AOF优点？"><a href="#31-AOF优点？" class="headerlink" title="31.AOF优点？"></a>31.AOF优点？</h4><ul>
<li>AOF提供了3种保存策略：每秒保存、跟系统策略、每次操作保存。实时性比较高，一般来说会选择每秒保存，因此意外发生时顶多失去一秒的数据。</li>
<li>文件追加写形式，所以文件很少有损坏问题，如最后意外发生少写数据，可通过redis-check-aof工具修复。</li>
<li>AOF由于是文本形式，直接采用协议格式，避免二次处理开销，另外对于修改也比较灵活。</li>
</ul>
<h4 id="32-AOF缺点？"><a href="#32-AOF缺点？" class="headerlink" title="32.AOF缺点？"></a>32.AOF缺点？</h4><ul>
<li>AOF文件要比RDB文件大。</li>
<li>AOF冷备没RDB迅速。</li>
<li>由于执行频率比较高，所以负载高时，性能没有RDB好。</li>
</ul>
<h4 id="33-混合持久化？优缺点？"><a href="#33-混合持久化？优缺点？" class="headerlink" title="33.混合持久化？优缺点？"></a>33.混合持久化？优缺点？</h4><p>一般来说我们的线上都会采取混合持久化。redis4.0以后添加了新的混合持久化方式。</p>
<p>优点：</p>
<ul>
<li>在快速加载的同时，避免了丢失过更多的数据。</li>
</ul>
<p>缺点：</p>
<ul>
<li>由于混合了两种格式，所以可读性差。</li>
<li>兼容性，需要4.0以后才支持。</li>
</ul>
<h4 id="34-Redis的Java客户端官方推荐？实际选择？"><a href="#34-Redis的Java客户端官方推荐？实际选择？" class="headerlink" title="34.Redis的Java客户端官方推荐？实际选择？"></a>34.Redis的Java客户端官方推荐？实际选择？</h4><p>官方推荐的有3种：Jedis、Redisson和lettuce。</p>
<p>一般来说用的比较多的有:Jedis|Redisson。</p>
<p>Jedis：更轻量、简介、不支持读写分离需要我们来实现，文档比较少。API提供了比较全面的Redis命令的支持。</p>
<p>Redisson：基于Netty实现，性能高，支持异步请求。提供了很多分布式相关操作服务。高级功能能比较多，文档也比较丰富，但实用上复杂度也相对高。和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。</p>
<h4 id="35-Redis事务？"><a href="#35-Redis事务？" class="headerlink" title="35.Redis事务？"></a>35.Redis事务？</h4><p>事务提供了一种将多个命令请求打包，一次性、按顺序的执行多个命令的机制。并且在事务执行期间，服务器不会中断事务而改去执行其他客户端命令请求，它会</p>
<h4 id="36-Redis事务开始到结束的几个阶段？"><a href="#36-Redis事务开始到结束的几个阶段？" class="headerlink" title="36.Redis事务开始到结束的几个阶段？"></a>36.Redis事务开始到结束的几个阶段？</h4><ul>
<li>开启事务</li>
<li>命令入队</li>
<li>执行事务/放弃事务</li>
</ul>
<h4 id="37-Redis中key的过期操作？"><a href="#37-Redis中key的过期操作？" class="headerlink" title="37.Redis中key的过期操作？"></a>37.Redis中key的过期操作？</h4><p>​    设置key的生存时间为n秒</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expire key nseconds</span><br></pre></td></tr></table></figure>

<p>​    设置key的生存时间为nmilliseconds</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pxpire key milliseconds</span><br></pre></td></tr></table></figure>

<p>​    设置过期时间为timestamp所指定的秒数时间戳</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expireat key timespamp</span><br></pre></td></tr></table></figure>

<p>  设置过期时间为timestamp毫秒级时间戳</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pexpireat key millisecondsTimestamp</span><br></pre></td></tr></table></figure>

<h4 id="38-Redis过期键删除策略"><a href="#38-Redis过期键删除策略" class="headerlink" title="38.Redis过期键删除策略?"></a>38.Redis过期键删除策略?</h4><p>定时删除：在设置的过期时间同时，创建一个定时器在键的过期时间来临时，立即执行队键的操作删除。</p>
<p>惰性删除：放任过期键不管，但每次从键空间中获取键时，都检查取得的键是否过期，如果过期就删除，如果没有就返回该键。</p>
<p>定期删除：每隔一段时间执行一次删除过期键操作，并通过先吃删除操作执行的时长和频率来减少删除操作对cpu时间的影响。</p>
<h4 id="39-Pipeline是什么？为什么要它？"><a href="#39-Pipeline是什么？为什么要它？" class="headerlink" title="39.Pipeline是什么？为什么要它？"></a>39.Pipeline是什么？为什么要它？</h4><p>命令批处理技术，对命令进行组装，然后一次性执行多个命令。</p>
<p>可以有效的节省RTT(Round Trip Time 往返时间)。</p>
<p>经过测试验证：</p>
<ul>
<li>pipeline执行速度一般比逐条执行快。</li>
<li>客户端和服务的网络延越大，pipeline效果越明显。</li>
</ul>
<h4 id="40-如何获取当前最大内存？如何动态设置？"><a href="#40-如何获取当前最大内存？如何动态设置？" class="headerlink" title="40.如何获取当前最大内存？如何动态设置？"></a>40.如何获取当前最大内存？如何动态设置？</h4><p>获取最大内存:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config get maxmemory</span><br></pre></td></tr></table></figure>

<p>设置最大内存：</p>
<p>命令设置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config set maxmemory 1GB</span><br></pre></td></tr></table></figure>

<h4 id="41-Redis内存溢出控制？"><a href="#41-Redis内存溢出控制？" class="headerlink" title="41.Redis内存溢出控制？"></a>41.Redis内存溢出控制？</h4><p>当Redis所用内存达到maxmemory上限时，会出发相应的溢出策略。</p>
<h4 id="42-Redis内存溢出策略？"><a href="#42-Redis内存溢出策略？" class="headerlink" title="42.Redis内存溢出策略？"></a>42.Redis内存溢出策略？</h4><p>1.noeviction(默认策略):拒绝所有写入操作并返回客户端错误信息（error) OOM command not allowed     when used memory,只响应读操作。</p>
<ol>
<li>volatile-lru:根据LRU算法删除设置了超时属性（expire)的键，直到腾出足够空间为止。如果没有可删除的键对象，回退到noeviction策略。</li>
<li>allkeys-lru:根据LRU算法删除键，不管数据有没有设置超时属性， 直到腾出足够空间为止。</li>
<li>allkeys-random:随机删除所有键，直到腾出足够空间为止。</li>
<li>volatile-random:随机删除过期键，直到腾出足够空间为止。</li>
<li>volatile-tth根据键值对象的ttl属性，删除最近将要过期数据。如果没有，回退到noeviction策略。</li>
</ol>
<h4 id="43-Redis高可用方案？"><a href="#43-Redis高可用方案？" class="headerlink" title="43.Redis高可用方案？"></a>43.Redis高可用方案？</h4><p>Redis Sentinel(哨兵)能自动完成故障发现和转移。</p>
<h4 id="44-Redis集群方案？"><a href="#44-Redis集群方案？" class="headerlink" title="44.Redis集群方案？"></a>44.Redis集群方案？</h4><p>Twemproxy、Redis Cluster、Codis。</p>
<h4 id="45-Redis-Cluster槽范围？"><a href="#45-Redis-Cluster槽范围？" class="headerlink" title="45.Redis Cluster槽范围？"></a>45.Redis Cluster槽范围？</h4><p>0~16383</p>
<h4 id="46-Redis锁实现思路"><a href="#46-Redis锁实现思路" class="headerlink" title="46.Redis锁实现思路?"></a>46.Redis锁实现思路?</h4><p>setnx (set if not exists),如果创建成功则表示获取到锁。</p>
<p>setnx lock true 创建锁</p>
<p>del lock 释放锁</p>
<p>如果中途崩溃，无法释放锁？</p>
<p>此时需要考虑到超时时间的问题。比如 :expire lock 300</p>
<p>由于命令是非原子的，所以还是会死锁,如何解决？</p>
<p>Redis 支持 set 并设置超时时间的功能。</p>
<p>比如: set lock true  ex 30 nx</p>
<h4 id="47-什么是布隆过滤器？"><a href="#47-什么是布隆过滤器？" class="headerlink" title="47.什么是布隆过滤器？"></a>47.什么是布隆过滤器？</h4><p>是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难。</p>
<p>Tips:当判断一定存在时，可能会误判，当判断不存在时，就一定不存在。</p>
<h4 id="48-什么是缓存穿透？处理问题？"><a href="#48-什么是缓存穿透？处理问题？" class="headerlink" title="48.什么是缓存穿透？处理问题？"></a>48.什么是缓存穿透？处理问题？</h4><p>缓存穿透：缓存层不命中，存储层不命中。</p>
<p>处理方式1:缓存空对象，不过此时会占用更多内存空间，所以根据大家业务特性去设置超时时间来控制内存占用的问题。</p>
<p>处理方式2:布隆过滤器。</p>
<h4 id="49-什么是缓存预热？"><a href="#49-什么是缓存预热？" class="headerlink" title="49.什么是缓存预热？"></a>49.什么是缓存预热？</h4><p>就是系统上线后，提前将相关数据加载到缓存系统，避免用户先查库，然后在缓存。</p>
<h4 id="50-什么是缓存雪崩？处理问题？"><a href="#50-什么是缓存雪崩？处理问题？" class="headerlink" title="50.什么是缓存雪崩？处理问题？"></a>50.什么是缓存雪崩？处理问题？</h4><p>缓存雪崩：由于缓存层承载着大量请求，有效的保护了存储层，但如果存储层由于某些原因不能提供服务，存储层调用暴增，造成存储层宕机。</p>
<p>处理：</p>
<ul>
<li>保证缓存层服务高可用性。</li>
<li>对缓存系统做实时监控，报警等。</li>
<li>依赖隔离组件为后端限流并降级。</li>
<li>做好持久化，以便数据的快速恢复。</li>
</ul>
<p>参考：</p>
<ul>
<li>《Redis深度历险:核心原理和应用实践》</li>
<li>《Redis开发与运维》</li>
<li>《Redis设计与实现》</li>
<li><a href="https://redis.io/">https://redis.io/</a></li>
<li>百度百科</li>
</ul>
<p><img src="https://gitee.com/yizhibuerdai/Imagetools/raw/master/images/common1.png" alt="WechatIMG360"></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM整合</title>
    <url>/2023/10/27/SSM%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<h1 id="1-ssmbuild"><a href="#1-ssmbuild" class="headerlink" title="1. ssmbuild"></a>1. ssmbuild</h1><h1 id="2-环境要求"><a href="#2-环境要求" class="headerlink" title="2. 环境要求"></a>2. 环境要求</h1><ul>
<li>IDEA</li>
<li>MySQL5.7.19</li>
<li>Tomcat 9</li>
<li>Maven3.6 </li>
</ul>
<p><strong>需要熟练掌握MySQL数据库、Spring、JavaWeb及Mybatis知识，简单的前端知识</strong></p>
<h1 id="3-创建数据库"><a href="#3-创建数据库" class="headerlink" title="3. 创建数据库"></a>3. 创建数据库</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE ssmbuild;</span><br><span class="line"></span><br><span class="line">USE ssmbuild;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `books`(</span><br><span class="line">`bookID` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;书id&#x27;</span>,</span><br><span class="line">`bookName` <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;书名&#x27;</span>,</span><br><span class="line">`bookCounts` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;数量&#x27;</span>,</span><br><span class="line">`detail` <span class="type">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;描述&#x27;</span>,</span><br><span class="line">KEY `bookID`(`bookID`)</span><br><span class="line">)ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `books`(`bookID`,`bookName`,`bookCounts`,`detail`)<span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>,<span class="string">&#x27;Java&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;从入门到放弃&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="string">&#x27;MySQL&#x27;</span>,<span class="number">10</span>,<span class="string">&#x27;从删库到跑路&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>,<span class="string">&#x27;Linux&#x27;</span>,<span class="number">5</span>,<span class="string">&#x27;从进门到进牢&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20210105175714381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="4-pom-xml"><a href="#4-pom-xml" class="headerlink" title="4. pom.xml"></a>4. pom.xml</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xiaofan<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ssmbuild<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Junit--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库驱动--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 数据库连接池 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mchange<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--Servlet - JSP --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--Mybatis--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--Spring--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--AOP植入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="5-web-xml"><a href="#5-web-xml" class="headerlink" title="5. web.xml"></a>5. web.xml</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--DispatcherServlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--一定要注意:我们这里加载的是总的配置文件，之前被这里坑了！--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--tomcat启动时，应用一起启动--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--encodingFilter--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span></span><br><span class="line">            org.springframework.web.filter.CharacterEncodingFilter</span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--Session过期时间--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>15<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="6-项目结构"><a href="#6-项目结构" class="headerlink" title="6. 项目结构"></a>6. 项目结构</h1><p><img src="https://img-blog.csdnimg.cn/20210105180153649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="7-刚开始导入项目需要注意的地方"><a href="#7-刚开始导入项目需要注意的地方" class="headerlink" title="7.刚开始导入项目需要注意的地方"></a>7.刚开始导入项目需要注意的地方</h1><p><img src="https://img-blog.csdnimg.cn/2021010518464252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210105184925445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot</title>
    <url>/2023/11/01/SpringBoot/</url>
    <content><![CDATA[<h1 id="1-微服务阶段"><a href="#1-微服务阶段" class="headerlink" title="1. 微服务阶段"></a>1. 微服务阶段</h1><p><img src="https://img-blog.csdnimg.cn/20210106111034109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210106112212255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210106113728756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="2-什么是SpringBoot"><a href="#2-什么是SpringBoot" class="headerlink" title="2. 什么是SpringBoot"></a>2. 什么是SpringBoot</h1><p><img src="https://img-blog.csdnimg.cn/20210106114959427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210106120408305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210106120351122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="3-微服务"><a href="#3-微服务" class="headerlink" title="3. 微服务"></a>3. 微服务</h1><p><img src="https://img-blog.csdnimg.cn/20210106142114293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210106143449920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/2021010614403357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="4-第一个springboot项目搭建-springboot-01-helloworld"><a href="#4-第一个springboot项目搭建-springboot-01-helloworld" class="headerlink" title="4. 第一个springboot项目搭建 springboot-01-helloworld"></a>4. 第一个springboot项目搭建 <code>springboot-01-helloworld</code></h1><p><img src="https://img-blog.csdnimg.cn/20210106164149110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210106164420231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210106164606791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210106154746496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="5-SpringBoot自动装配原理"><a href="#5-SpringBoot自动装配原理" class="headerlink" title="5. SpringBoot自动装配原理"></a>5. SpringBoot自动装配原理</h1><p><img src="https://img-blog.csdnimg.cn/20210106171538681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210106172155949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210106180641369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210106180251407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="5-1-自动装配原理分析"><a href="#5-1-自动装配原理分析" class="headerlink" title="5.1. 自动装配原理分析"></a>5.1. 自动装配原理分析</h2><ul>
<li><p>@SpringBootApplication</p>
<ul>
<li><p>@SpringBootConfiguration</p>
<ul>
<li>@Configuration<ul>
<li>@Component</li>
</ul>
</li>
</ul>
</li>
<li><p>@EnableAutoConfiguration 自动导入包</p>
<ul>
<li><p>@AutoConfigurationPackage 将 <strong>添加该注解的类所在的package</strong> 作为 <strong>自动配置package</strong> 进行管理</p>
<ul>
<li>@Import({Registrar.class})</li>
</ul>
</li>
<li><p>@Import({AutoConfigurationImportSelector.class}) 自动导入包的核心</p>
<ul>
<li>getAutoConfigurationEntry(annotationMetadata); 获取自动装配的实体</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>getCandidateConfigurations（annotationMetadata, attributes）;  获取候选的配置</p>
<ul>
<li>protected Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() {<pre><code>      return EnableAutoConfiguration.class;
  &#125;   标注了EnableAutoConfiguration注解的类
</code></pre>
<ul>
<li>public static List loadFactoryNames(): 获取所有的加载配置</li>
</ul>
</li>
</ul>
</li>
<li><p>loadFactories()    loadSpringFactories()</p>
<pre><code>- 项目资源： classLoader.getResources(FACTORIES_RESOURCE_LOCATION)   &quot;META-INF/spring.factories&quot;; 从这里获取配置 spring-boot-autoconfigure-2.2.0.RELEASE.jar      META-INF     spring.factories;所有的自动配置类都在这里了！（自动配置生效，需要导入对应的start核心注解：@ConditionalOnXXX， 如果这里的条件都满足，才生效！）
</code></pre>
<ul>
<li><p>系统资源：classLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION)</p>
<pre><code>- 从这些资源中遍历了所有的nextElement（自动配置），遍历完成之后，封装成Properties供我们使用
</code></pre>
</li>
<li><p>@ComponentScan 扫描当前主启动类同级的包</p>
</li>
</ul>
</li>
</ul>
<h2 id="5-2-SpringApplication-启动-run"><a href="#5-2-SpringApplication-启动-run" class="headerlink" title="5.2. SpringApplication 启动 run"></a>5.2. SpringApplication 启动 run</h2><p><img src="https://img-blog.csdnimg.cn/20210107094141923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="5-3-自动配置原理再理解"><a href="#5-3-自动配置原理再理解" class="headerlink" title="5.3. 自动配置原理再理解"></a>5.3. 自动配置原理再理解</h2><p><img src="https://img-blog.csdnimg.cn/20210107183116896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210107183031922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210107184832433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="6-yaml讲解"><a href="#6-yaml讲解" class="headerlink" title="6. yaml讲解"></a>6. yaml讲解</h1><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># k = v</span></span><br><span class="line"><span class="comment"># 对空格要求十分严格</span></span><br><span class="line"><span class="comment"># 普通的 key-value</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注入到我们的配置类中！</span></span><br><span class="line"></span><br><span class="line"><span class="attr">name:</span> <span class="string">xiaofan</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对象</span></span><br><span class="line"><span class="attr">student:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">xiaofan</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 行内写法</span></span><br><span class="line"><span class="attr">teacher:</span> &#123;<span class="attr">name:</span> <span class="string">xiaofan</span>, <span class="attr">age:</span> <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数组</span></span><br><span class="line"><span class="attr">pets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">dog</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pig</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 行内写法</span></span><br><span class="line"><span class="attr">animals:</span> [<span class="string">cat</span>, <span class="string">dog</span>, <span class="string">pig</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>yaml</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaofan.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> happy;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; lists;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">boolean</span> happy, Date birth, Map&lt;String, Object&gt; maps, List&lt;Object&gt; lists, Dog dog)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.happy = happy;</span><br><span class="line">        <span class="keyword">this</span>.birth = birth;</span><br><span class="line">        <span class="keyword">this</span>.maps = maps;</span><br><span class="line">        <span class="keyword">this</span>.lists = lists;</span><br><span class="line">        <span class="keyword">this</span>.dog = dog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> happy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHappy</span><span class="params">(<span class="keyword">boolean</span> happy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.happy = happy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getBirth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> birth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirth</span><span class="params">(Date birth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birth = birth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getMaps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaps</span><span class="params">(Map&lt;String, Object&gt; maps)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maps = maps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getLists</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLists</span><span class="params">(List&lt;Object&gt; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lists = lists;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dog <span class="title">getDog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDog</span><span class="params">(Dog dog)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dog = dog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, happy=&quot;</span> + happy +</span><br><span class="line">                <span class="string">&quot;, birth=&quot;</span> + birth +</span><br><span class="line">                <span class="string">&quot;, maps=&quot;</span> + maps +</span><br><span class="line">                <span class="string">&quot;, lists=&quot;</span> + lists +</span><br><span class="line">                <span class="string">&quot;, dog=&quot;</span> + dog +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 解决有红色提示问题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">xiaofan$&#123;random.int&#125;</span></span><br><span class="line">  <span class="attr">age:</span> <span class="string">$&#123;random.int&#125;</span></span><br><span class="line">  <span class="attr">happy:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">birth:</span> <span class="number">2021</span><span class="string">/11/07</span></span><br><span class="line">  <span class="attr">hello:</span> <span class="string">小小的一个</span></span><br><span class="line">  <span class="attr">maps:</span> &#123;<span class="attr">k1:</span> <span class="string">v1</span>, <span class="attr">k2:</span> <span class="string">v2</span>&#125;</span><br><span class="line">  <span class="attr">lists:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">code</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">music</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">girl</span></span><br><span class="line">  <span class="attr">dog:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">$&#123;person.hello1:hello&#125;_旺财</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>properties</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加载指定的配置文件</span></span><br><span class="line"><span class="meta">@PropertySource(value</span>=<span class="string">&quot;classpath:xiaofan.properties&quot;)</span></span><br></pre></td></tr></table></figure>



<h2 id="6-1-yaml-和properties的对比"><a href="#6-1-yaml-和properties的对比" class="headerlink" title="6.1. yaml 和properties的对比"></a>6.1. yaml 和properties的对比</h2><p><img src="https://img-blog.csdnimg.cn/20210107145537715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><p>松散绑定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String lastName;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line">  <span class="attr">last-name:</span> <span class="string">xiaofan$&#123;random.int&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>JSR303 数据校验</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210107152938398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210107153213402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="7-多环境配置及配置文件的位置"><a href="#7-多环境配置及配置文件的位置" class="headerlink" title="7. 多环境配置及配置文件的位置"></a>7. 多环境配置及配置文件的位置</h1><ul>
<li>配置文件的位置</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210107162137136.png" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210107162215613.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>多环境</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">test</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8088</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">activate:</span></span><br><span class="line">      <span class="attr">on-profile:</span> <span class="string">dev</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8089</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">activate:</span></span><br><span class="line">      <span class="attr">on-profile:</span> <span class="string">test</span></span><br></pre></td></tr></table></figure>

<h1 id="9-Web开发探索"><a href="#9-Web开发探索" class="headerlink" title="9 Web开发探索"></a>9 Web开发探索</h1><p><img src="https://img-blog.csdnimg.cn/2021010719055089.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="9-1-静态资源导入"><a href="#9-1-静态资源导入" class="headerlink" title="9.1. 静态资源导入"></a>9.1. 静态资源导入</h2><ul>
<li><p>WebMvcAutoConfiguration</p>
<p>内部类：EnableWebMvcConfiguration   （WebProperties）</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否自定义静态资源路径，自定义之后，默认的将会失效</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Default resource handling disabled&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Duration cachePeriod = <span class="keyword">this</span>.resourceProperties.getCache().getPeriod();</span><br><span class="line">        CacheControl cacheControl = <span class="keyword">this</span>.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();</span><br><span class="line">        <span class="comment">// 如果配置了webjars: https://www.webjars.org/  (一般不用)</span></span><br><span class="line">        <span class="keyword">if</span> (!registry.hasMappingForPattern(<span class="string">&quot;/webjars/**&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;/webjars/**&quot;</span>&#125;).addResourceLocations(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>&#125;).setCachePeriod(<span class="keyword">this</span>.getSeconds(cachePeriod)).setCacheControl(cacheControl).setUseLastModified(<span class="keyword">this</span>.resourceProperties.getCache().isUseLastModified()));</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 没有自定义路径，new String[]&#123;&quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot;&#125;;</span></span><br><span class="line">        <span class="keyword">private</span> String[] staticLocations;</span><br><span class="line">        String staticPathPattern = <span class="keyword">this</span>.mvcProperties.getStaticPathPattern();</span><br><span class="line">        <span class="keyword">if</span> (!registry.hasMappingForPattern(staticPathPattern)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="keyword">new</span> String[]&#123;staticPathPattern&#125;).addResourceLocations(WebMvcAutoConfiguration.getResourceLocations(<span class="keyword">this</span>.resourceProperties.getStaticLocations())).setCachePeriod(<span class="keyword">this</span>.getSeconds(cachePeriod)).setCacheControl(cacheControl).setUseLastModified(<span class="keyword">this</span>.resourceProperties.getCache().isUseLastModified()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20210108092316789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="9-2-首页"><a href="#9-2-首页" class="headerlink" title="9.2. 首页"></a>9.2. 首页</h2><p>直接把首页放入到static目录即可！</p>
<h2 id="9-3-Thymeleaf模板引擎"><a href="#9-3-Thymeleaf模板引擎" class="headerlink" title="9.3. Thymeleaf模板引擎"></a>9.3. Thymeleaf模板引擎</h2><ul>
<li><p>官网：<a href="https://www.thymeleaf.org/">https://www.thymeleaf.org/</a></p>
</li>
<li><p>Github： <a href="https://github.com/thymeleaf">https://github.com/thymeleaf</a></p>
</li>
<li><p>导入starter</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--所有html元素都可以被thymeleaf替换接管： th:元素名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;msg&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:utext</span>=<span class="string">&quot;$&#123;msg&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">th:each</span>=<span class="string">&quot;user:$&#123;users&#125;&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaofan.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;&lt;h1&gt;hello springboot!&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;users&quot;</span>, Arrays.asList(<span class="string">&quot;中国&quot;</span>, <span class="string">&quot;美国&quot;</span>, <span class="string">&quot;日本&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-4-MVC配置原理"><a href="#9-4-MVC配置原理" class="headerlink" title="9.4. MVC配置原理"></a>9.4. MVC配置原理</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">package com.xiaofan.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.web.servlet.View;</span><br><span class="line">import org.springframework.web.servlet.ViewResolver;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line">import java.util.Locale;</span><br><span class="line"></span><br><span class="line">// 扩展springmvc</span><br><span class="line">@Configuration</span><br><span class="line">public class MyMvcConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ViewResolver myViewResolver() &#123;</span><br><span class="line">        return new myViewResolver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class myViewResolver implements ViewResolver &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public View resolveViewName(String s, Locale locale) throws Exception &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20210108120009632.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="10-员工管理系统springboot-04-system"><a href="#10-员工管理系统springboot-04-system" class="headerlink" title="10. 员工管理系统springboot-04-system"></a>10. 员工管理系统<code>springboot-04-system</code></h1><p><img src="https://img-blog.csdnimg.cn/20210112084832857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210112162210565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="11-如何写一个网站"><a href="#11-如何写一个网站" class="headerlink" title="11. 如何写一个网站"></a>11. 如何写一个网站</h1><p><img src="https://img-blog.csdnimg.cn/20210113112500985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210113112532107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210113143713733.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="12-Spring-Data"><a href="#12-Spring-Data" class="headerlink" title="12. Spring Data"></a>12. Spring Data</h1><ul>
<li>JDBC</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210113182258631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>Druid</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210113182132689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="comment"># 如果时区报错了需要添加时区字段 serverTimezone</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.1.30:3306/mybatis?useUnicode=true&amp;characterEncoding=utf-8</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="comment"># 默认是用的是 com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#Spring Boot 默认是不注入这些属性值的，需要自己绑定</span></span><br><span class="line">    <span class="comment">#druid 数据源专有配置</span></span><br><span class="line">    <span class="attr">initialSize:</span> <span class="number">5</span></span><br><span class="line">    <span class="attr">minIdle:</span> <span class="number">5</span></span><br><span class="line">    <span class="attr">maxActive:</span> <span class="number">20</span></span><br><span class="line">    <span class="attr">maxWait:</span> <span class="number">60000</span></span><br><span class="line">    <span class="attr">timeBetweenEvictionRunsMillis:</span> <span class="number">60000</span></span><br><span class="line">    <span class="attr">minEvictableIdleTimeMillis:</span> <span class="number">300000</span></span><br><span class="line">    <span class="attr">validationQuery:</span> <span class="string">SELECT</span> <span class="number">1</span> <span class="string">FROM</span> <span class="string">DUAL</span></span><br><span class="line">    <span class="attr">testWhileIdle:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">testOnBorrow:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">testOnReturn:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">poolPreparedStatements:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入</span></span><br><span class="line">    <span class="comment">#如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority</span></span><br><span class="line">    <span class="comment">#则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j</span></span><br><span class="line">    <span class="attr">filters:</span> <span class="string">stat,wall,log4j</span></span><br><span class="line">    <span class="attr">maxPoolPreparedStatementPerConnectionSize:</span> <span class="number">20</span></span><br><span class="line">    <span class="attr">useGlobalDataSourceStat:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">connectionProperties:</span> <span class="string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaofan.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.support.http.StatViewServlet;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.ServletRegistrationBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">druidDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">statViewServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServletRegistrationBean&lt;StatViewServlet&gt; bean = <span class="keyword">new</span> ServletRegistrationBean&lt;&gt;(<span class="keyword">new</span> StatViewServlet(), <span class="string">&quot;/druid/*&quot;</span>);</span><br><span class="line">        Map&lt;String, String&gt; initParams = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        initParams.put(<span class="string">&quot;loginUsername&quot;</span>, <span class="string">&quot;admin&quot;</span>); <span class="comment">//后台管理界面的登录账号</span></span><br><span class="line">        initParams.put(<span class="string">&quot;loginPassword&quot;</span>, <span class="string">&quot;123456&quot;</span>); <span class="comment">//后台管理界面的登录密码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//后台允许谁可以访问</span></span><br><span class="line">        <span class="comment">//initParams.put(&quot;allow&quot;, &quot;localhost&quot;)：表示只有本机可以访问</span></span><br><span class="line">        <span class="comment">//initParams.put(&quot;allow&quot;, &quot;&quot;)：为空或者为null时，表示允许所有访问</span></span><br><span class="line">        initParams.put(<span class="string">&quot;allow&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//deny：Druid 后台拒绝谁访问</span></span><br><span class="line">        <span class="comment">//initParams.put(&quot;kuangshen&quot;, &quot;192.168.1.20&quot;);表示禁止此ip访问</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置初始化参数</span></span><br><span class="line">        bean.setInitParameters(initParams);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="13-整合mybaits框架"><a href="#13-整合mybaits框架" class="headerlink" title="13. 整合mybaits框架"></a>13. 整合mybaits框架</h1><ul>
<li>pom.xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis 自研--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>UserMapper.xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.xiaofan.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        select * from user where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        insert into user (id, name, pwd) values (#&#123;id&#125;, #&#123;name&#125;, #&#123;pwd&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        update user set name = #&#123;name&#125;, pwd = #&#123;pwd&#125; where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        delete from user where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Springboot整合mybatis</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 整合mybatis</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.xiaofan.pojo</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mybatis/mapper/*.xml</span></span><br></pre></td></tr></table></figure>

<ul>
<li>编写controller进行测试</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaofan.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xiaofan.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> com.xiaofan.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/queryUserList&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">queryUserList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; users = userMapper.queryUserList();</span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="14-SpringSecurity"><a href="#14-SpringSecurity" class="headerlink" title="14. SpringSecurity"></a>14. SpringSecurity</h1><p><img src="https://img-blog.csdnimg.cn/20210114154719122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210114164235361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="14-1-核心点"><a href="#14-1-核心点" class="headerlink" title="14.1. 核心点"></a>14.1. 核心点</h2><ul>
<li>pom.xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 整合 springsecurity thymeleaf --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf.extras<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-extras-springsecurity5<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>SecurityConfig.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaofan.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AOP: 拦截器！</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 授权</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 首页所有人可以访问， 功能页只有对应权限的人才能访问</span></span><br><span class="line">        <span class="comment">// 请求授权规则</span></span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/&quot;</span>).permitAll()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/level1/**&quot;</span>).hasRole(<span class="string">&quot;vip1&quot;</span>)</span><br><span class="line">                .antMatchers(<span class="string">&quot;/level2/**&quot;</span>).hasRole(<span class="string">&quot;vip2&quot;</span>)</span><br><span class="line">                .antMatchers(<span class="string">&quot;/level3/**&quot;</span>).hasRole(<span class="string">&quot;vip3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有权限，默认会到登录页面, 定制login页面 注意这里的链接和login.html表单中的做成一直就可以</span></span><br><span class="line">        http.formLogin().loginPage(<span class="string">&quot;/toLogin&quot;</span>);</span><br><span class="line">        <span class="comment">// 开启了注销功能</span></span><br><span class="line"></span><br><span class="line">        http.csrf().disable();  <span class="comment">// 防止跨域攻击csrf  springsecurity5不加也没报错</span></span><br><span class="line">        http.logout().logoutSuccessUrl(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启记住我功能, 默认两周时间, 自定义接收前端的参数</span></span><br><span class="line">        http.rememberMe().rememberMeParameter(<span class="string">&quot;remember&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 认证, springboot 2.1.x 可以直接使用</span></span><br><span class="line">    <span class="comment">// 密码编码： PasswordEncoder</span></span><br><span class="line">    <span class="comment">// 在Spring Security 5.0 + 增加了很多加密的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.inMemoryAuthentication().passwordEncoder(<span class="keyword">new</span> BCryptPasswordEncoder())</span><br><span class="line">                .withUser(<span class="string">&quot;xiaofan&quot;</span>).password(<span class="keyword">new</span> BCryptPasswordEncoder().encode(<span class="string">&quot;123456&quot;</span>)).roles(<span class="string">&quot;vip1&quot;</span>, <span class="string">&quot;vip2&quot;</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .withUser(<span class="string">&quot;root&quot;</span>).password(<span class="keyword">new</span> BCryptPasswordEncoder().encode(<span class="string">&quot;123456&quot;</span>)).roles(<span class="string">&quot;vip1&quot;</span>, <span class="string">&quot;vip2&quot;</span>, <span class="string">&quot;vip3&quot;</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .withUser(<span class="string">&quot;guest&quot;</span>).password(<span class="keyword">new</span> BCryptPasswordEncoder().encode(<span class="string">&quot;123456&quot;</span>)).roles(<span class="string">&quot;vip1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>index.html页面重点</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span> <span class="attr">xmlns:sec</span>=<span class="string">&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity5&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">sec:authorize</span>=<span class="string">&quot;!isAuthenticated()&quot;</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--未登录--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/toLogin&#125;&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;address card icon&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 登录</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">sec:authorize</span>=<span class="string">&quot;isAuthenticated()&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">                        用户名：<span class="tag">&lt;<span class="name">span</span> <span class="attr">sec:authentication</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                        角 色：<span class="tag">&lt;<span class="name">span</span> <span class="attr">sec:authentication</span>=<span class="string">&quot;principal.authorities&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">sec:authorize</span>=<span class="string">&quot;isAuthenticated()&quot;</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--如果登录，用户名，注销--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/logout&#125;&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;sign-out icon&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 注销</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.xiaofan.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class RouteController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&#123;&quot;&#x2F;&quot;, &quot;&#x2F;index&quot;&#125;)</span><br><span class="line">    public String index() &#123;</span><br><span class="line">        return &quot;index&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;toLogin&quot;)</span><br><span class="line">    public String toLogin() &#123;</span><br><span class="line">        return &quot;views&#x2F;login&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;level&#123;suffix&#125;&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public String level(@PathVariable(&quot;suffix&quot;) Integer suffix, @PathVariable(&quot;id&quot;) Integer id) &#123;</span><br><span class="line">        return &quot;views&#x2F;level&quot; + suffix + &quot;&#x2F;&quot; + id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="15-Shiro"><a href="#15-Shiro" class="headerlink" title="15. Shiro"></a>15. Shiro</h1><p><img src="https://img-blog.csdnimg.cn/20210115084801101.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210115105424486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>三大对象<img src="https://img-blog.csdnimg.cn/20210115111112746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><ul>
<li>Subject： 用户</li>
<li>SecurityManager： 管理所有用户</li>
<li>Realm： 连接数据</li>
</ul>
</li>
</ul>
<p><strong>springboot-08-shiro下面包含了多个module</strong></p>
<h1 id="16-Swagger"><a href="#16-Swagger" class="headerlink" title="16. Swagger"></a>16. Swagger</h1><p><img src="https://img-blog.csdnimg.cn/20210118090837893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210118091008199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210118093047615.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="16-1-springboot集成swagger"><a href="#16-1-springboot集成swagger" class="headerlink" title="16.1. springboot集成swagger"></a>16.1. springboot集成swagger</h2><p><img src="https://img-blog.csdnimg.cn/20210118100102186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210118101907101.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210118101814791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="16-2-配置Swagger"><a href="#16-2-配置Swagger" class="headerlink" title="16.2. 配置Swagger"></a>16.2. 配置Swagger</h2><h2 id="16-3-配置Swagger接口扫描及开关"><a href="#16-3-配置Swagger接口扫描及开关" class="headerlink" title="16.3. 配置Swagger接口扫描及开关"></a>16.3. 配置Swagger接口扫描及开关</h2><h2 id="16-4-配置多个分组"><a href="#16-4-配置多个分组" class="headerlink" title="16.4. 配置多个分组"></a>16.4. 配置多个分组</h2><ul>
<li>application.yaml</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">activate:</span></span><br><span class="line">      <span class="attr">on-profile:</span> <span class="string">dev</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">activate:</span></span><br><span class="line">      <span class="attr">on-profile:</span> <span class="string">test</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">activate:</span></span><br><span class="line">      <span class="attr">on-profile:</span> <span class="string">prod</span></span><br></pre></td></tr></table></figure>

<ul>
<li>SwaggerConfig.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaofan.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.Environment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.Profiles;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.PathSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.RequestHandlerSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.Contact;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">docket1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">docket2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">docket3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置要显示swagger环境</span></span><br><span class="line">        Profiles profiles = Profiles.of(<span class="string">&quot;dev&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">// 判断是否处在在自己设定的环境当中</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = environment.acceptsProfiles(profiles);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .enable(flag)      <span class="comment">// 是否启动swagger</span></span><br><span class="line">                .groupName(<span class="string">&quot;雪山飞狐&quot;</span>)</span><br><span class="line">                .select()</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 配置要扫描的接口的方式 RequestHandlerSelectors</span></span><br><span class="line"><span class="comment">                 * basePackage：指定要扫描的包</span></span><br><span class="line"><span class="comment">                 * any(): 扫描全部</span></span><br><span class="line"><span class="comment">                 * none()：不扫描</span></span><br><span class="line"><span class="comment">                 * withClassAnnotation(RestController.class): 扫描类上有RestController.class的注解</span></span><br><span class="line"><span class="comment">                 * withMethodAnnotation(GetMapping.class):    扫描方法上的注解</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.xiaofan.controller&quot;</span>))</span><br><span class="line">                <span class="comment">// 过滤请求路径</span></span><br><span class="line">                .paths(PathSelectors.ant(<span class="string">&quot;/xiaofan/**&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 作者信息</span></span><br><span class="line">        Contact contact = <span class="keyword">new</span> Contact(<span class="string">&quot;雪山飞狐&quot;</span>, <span class="string">&quot;https://blog.csdn.net/fanjianhai&quot;</span>, <span class="string">&quot;594042358@qq.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfo(</span><br><span class="line">                <span class="string">&quot;小范的SwaggerAPI文档&quot;</span>,</span><br><span class="line">                <span class="string">&quot;即使再小的帆也能远航&quot;</span>,</span><br><span class="line">                <span class="string">&quot;v1.0&quot;</span>,</span><br><span class="line">                <span class="string">&quot;https://github.com/fanjianhai/kuangshen&quot;</span>,</span><br><span class="line">                contact,</span><br><span class="line">                <span class="string">&quot;Apache 2.0&quot;</span>,</span><br><span class="line">                <span class="string">&quot;http://www.apache.org/licenses/LICENSE-2.0&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> ArrayList&lt;&gt;()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>HelloController.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaofan.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xiaofan.pojo.User;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiOperation;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;hello测试&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/xiaofan/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello swagger!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只要我们的接口中，返回值中存在实体类，它就会被扫描的swagger中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/xiaofan/user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">&quot;东邪&quot;</span>, <span class="string">&quot;黄药师&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;登录接口&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/xiaofan/login&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(<span class="meta">@ApiParam(&quot;用户名&quot;)</span> String username, <span class="meta">@ApiParam(&quot;用户密码&quot;)</span> String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login succeed!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;测试前端传递json接口&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(value=&quot;/xiaofan/jsontest&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">jsonTest</span><span class="params">(<span class="meta">@ApiParam(&quot;json传参&quot;)</span> <span class="meta">@RequestBody</span> String json)</span></span>&#123;</span><br><span class="line">        System.out.println(json);</span><br><span class="line">        <span class="keyword">return</span> json;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试： <a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a></li>
</ul>
<h2 id="16-5-swagger2常用注解说明"><a href="#16-5-swagger2常用注解说明" class="headerlink" title="16.5. swagger2常用注解说明"></a>16.5. swagger2常用注解说明</h2><p> 常用注解：<br>- **@Api()**用于类；<br>表示标识这个类是swagger的资源<br>- **@ApiOperation()**用于方法；<br>表示一个http请求的操作<br>- **@ApiParam()**用于方法，参数，字段说明；<br>表示对参数的添加元数据（说明或是否必填等）<br>- **@ApiModel()**用于类<br>表示对类进行说明，用于参数用实体类接收<br>- **@ApiModelProperty()**用于方法，字段<br>表示对model属性的说明或者数据操作更改<br>- **@ApiIgnore()**用于类，方法，方法参数<br>表示这个方法或者类被忽略<br>- <strong>@ApiImplicitParam()</strong> 用于方法<br>表示单独的请求参数<br>- <strong>@ApiImplicitParams()</strong> 用于方法，包含多个 @ApiImplicitParam </p>
<p><a href="https://blog.csdn.net/u014231523/article/details/76522486?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight">https://blog.csdn.net/u014231523/article/details/76522486?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight</a></p>
<h2 id="16-6-总结"><a href="#16-6-总结" class="headerlink" title="16.6. 总结"></a>16.6. 总结</h2><p><img src="https://img-blog.csdnimg.cn/20210118151027853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="17-任务"><a href="#17-任务" class="headerlink" title="17. 任务"></a>17. 任务</h1><h2 id="17-1-异步任务"><a href="#17-1-异步任务" class="headerlink" title="17.1. 异步任务"></a>17.1. 异步任务</h2><ul>
<li>```java<br>@EnableAsync<br>@SpringBootApplication<br>public class Springboot10TaskApplication {<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">@Async &#x2F;&#x2F; 告诉spring这是一个异步方法</span><br><span class="line">public String hello() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;执行完毕...&quot;);</span><br><span class="line">    return &quot;hello async&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="17-2-邮件任务以qq邮箱为例"><a href="#17-2-邮件任务以qq邮箱为例" class="headerlink" title="17.2. 邮件任务以qq邮箱为例"></a>17.2. 邮件任务<code>以qq邮箱为例</code></h2><ul>
<li>maven坐标</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--底层导入的本质还是javax.mail 配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>yaml配置</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mail:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="number">594042358</span><span class="string">@qq.com</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">qrfrhtepnixxbeje</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">smtp.qq.com</span></span><br><span class="line">    <span class="comment"># qq 邮箱需要开启这个</span></span><br><span class="line">    <span class="attr">properties:</span> &#123;<span class="attr">&quot;mail.smtp.ssl.enable&quot;:</span> <span class="string">&quot;true&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaofan;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.mail.SimpleMailMessage;</span><br><span class="line"><span class="keyword">import</span> org.springframework.mail.javamail.JavaMailSenderImpl;</span><br><span class="line"><span class="keyword">import</span> org.springframework.mail.javamail.MimeMailMessage;</span><br><span class="line"><span class="keyword">import</span> org.springframework.mail.javamail.MimeMessageHelper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.mail.MessagingException;</span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.MimeMessage;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Springboot10TaskApplicationTests</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JavaMailSenderImpl mailSender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleMailMessage simpleMailMessage = <span class="keyword">new</span> SimpleMailMessage();</span><br><span class="line">        simpleMailMessage.setSubject(<span class="string">&quot;文飞扬你好呀~&quot;</span>);</span><br><span class="line">        simpleMailMessage.setText(<span class="string">&quot;你这家伙又在玩游戏了？？&quot;</span>);</span><br><span class="line">        simpleMailMessage.setTo(<span class="string">&quot;594042358@qq.com&quot;</span>);</span><br><span class="line">        simpleMailMessage.setFrom(<span class="string">&quot;594042358@qq.com&quot;</span>);</span><br><span class="line">        mailSender.send(simpleMailMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads2</span><span class="params">()</span> <span class="keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">        <span class="comment">// 一个复杂的邮件~</span></span><br><span class="line">        MimeMessage mimeMessage = mailSender.createMimeMessage();</span><br><span class="line">        <span class="comment">// 组装</span></span><br><span class="line">        MimeMessageHelper helper = <span class="keyword">new</span> MimeMessageHelper(mimeMessage, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正文</span></span><br><span class="line">        helper.setSubject(<span class="string">&quot;雪山飞狐你好呀~plus&quot;</span>);</span><br><span class="line">        helper.setText(<span class="string">&quot;&lt;p style=&#x27;color:red&#x27;&gt;你这家伙又在玩游戏了？？&lt;/p&gt;&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加附件</span></span><br><span class="line">        helper.addAttachment(<span class="string">&quot;abc.jpg&quot;</span>, <span class="keyword">new</span> File(<span class="string">&quot;C:\\Users\\59404\\Pictures\\images\\jar\\abc.jpg&quot;</span>));</span><br><span class="line"></span><br><span class="line">        helper.setTo(<span class="string">&quot;594042358@qq.com&quot;</span>);</span><br><span class="line">        helper.setFrom(<span class="string">&quot;594042358@qq.com&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        mailSender.send(mimeMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="17-3-定时执行任务"><a href="#17-3-定时执行任务" class="headerlink" title="17.3. 定时执行任务"></a>17.3. 定时执行任务</h2><ul>
<li>任务调度者：TaskScheduler</li>
<li>任务执行者：TaskExecutor</li>
<li>开启定时注解的功能：@EnableScheduling</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaofan.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每隔3秒钟执行一次</span></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0/3 * * * * ?&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello, 你被执行了~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="18-SpringBoot整合redis"><a href="#18-SpringBoot整合redis" class="headerlink" title="18.SpringBoot整合redis"></a>18.SpringBoot整合redis</h1><p><a href="https://github.com/fanjianhai/kuangshen/tree/master/7.redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">https://github.com/fanjianhai/kuangshen/tree/master/7.redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0</a></p>
<h1 id="19-分布式-Dubbo-Zookeeper"><a href="#19-分布式-Dubbo-Zookeeper" class="headerlink" title="19. 分布式 Dubbo + Zookeeper"></a>19. 分布式 Dubbo + Zookeeper</h1><h2 id="19-1-分布式"><a href="#19-1-分布式" class="headerlink" title="19.1. 分布式"></a>19.1. 分布式</h2><p><img src="https://img-blog.csdnimg.cn/20210119131905297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210119132804785.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210119132850992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210119132922558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/2021011913295099.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210119133056168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="19-2-RPC"><a href="#19-2-RPC" class="headerlink" title="19.2. RPC"></a>19.2. RPC</h2><p><img src="https://img-blog.csdnimg.cn/20210119140900481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/202101191410201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210119141119779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>RPC两个核心模块：通讯，序列化</strong></p>
<p><img src="E:\狂神学java\kuangshen\13.JavaWeb\images\1611037002659.png" alt="1611037002659"></p>
<h2 id="19-3-Dubbo"><a href="#19-3-Dubbo" class="headerlink" title="19.3. Dubbo"></a>19.3. Dubbo</h2><p><img src="https://img-blog.csdnimg.cn/20210119142408240.png" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210119142624583.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210119142651838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>安装zookeeper（3.4.3）</li>
<li>安装Dubbo</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210119150444291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210119150558414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210119151815559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210119164917585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="19-4-服务发现"><a href="#19-4-服务发现" class="headerlink" title="19.4. 服务发现"></a>19.4. 服务发现</h2><p><img src="https://img-blog.csdnimg.cn/20210119182404877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210119182433599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210119184744723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>Dubbo + Zookeeper 还得深入研究，这里只是简单的测试！</p>
<h2 id="19-5-Dubbo-Zookeeper-vs-Spring-Cloud-之间的比较"><a href="#19-5-Dubbo-Zookeeper-vs-Spring-Cloud-之间的比较" class="headerlink" title="19.5. Dubbo+Zookeeper vs Spring Cloud 之间的比较"></a>19.5. Dubbo+Zookeeper vs Spring Cloud 之间的比较</h2><p><img src="https://img-blog.csdnimg.cn/20200107172821713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MDI5MDI2,size_16,color_FFFFFF,t_70"></p>
<p> 总的来说这两个搭建分布式系统的框架各有各的好处，在选择时要根据自己的需求等情况综合做选择；<br>但是Eureka作为单纯的服务注册中心来说感觉要比Zookeeper更加“专业”，因为注册服务更重要的是高可用性，可以接受短期内，达不到一致性的状况 </p>
<h1 id="20-回顾"><a href="#20-回顾" class="headerlink" title="20.回顾"></a>20.回顾</h1><p><img src="https://img-blog.csdnimg.cn/2021011819051574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>​     <img src="https://img-blog.csdnimg.cn/20210118191309671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210119085725864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210119090627528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210119105647524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-下卷</title>
    <url>/2024/02/07/Redis-%E4%B8%8B%E5%8D%B7/</url>
    <content><![CDATA[<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h4 id="1-查看配置语法"><a href="#1-查看配置语法" class="headerlink" title="1.查看配置语法"></a>1.查看配置语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONFIG GET CONFIG_SETTING_NAME</span><br></pre></td></tr></table></figure>

<h4 id="2-获取所有配置项"><a href="#2-获取所有配置项" class="headerlink" title="2.获取所有配置项"></a>2.获取所有配置项</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get *</span><br><span class="line">  1) &quot;dbfilename&quot;</span><br><span class="line">  2) &quot;dump.rdb&quot;</span><br><span class="line">  3) &quot;requirepass&quot;</span><br><span class="line">  4) &quot;&quot;</span><br><span class="line">  5) &quot;masterauth&quot;</span><br><span class="line">  6) &quot;&quot;</span><br><span class="line">  7) &quot;cluster-announce-ip&quot;</span><br><span class="line">  8) &quot;&quot;</span><br><span class="line">  9) &quot;unixsocket&quot;</span><br><span class="line"> 10) &quot;&quot;</span><br><span class="line"> 11) &quot;logfile&quot;</span><br><span class="line"> 12) &quot;&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="3-设置字符串"><a href="#3-设置字符串" class="headerlink" title="3.设置字符串"></a>3.设置字符串</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set xk www.javaxks.com</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h4 id="4-获取字符串"><a href="#4-获取字符串" class="headerlink" title="4.获取字符串"></a>4.获取字符串</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get xk</span><br><span class="line">&quot;www.javaxks.com&quot;</span><br></pre></td></tr></table></figure>

<h4 id="5-获取随机key"><a href="#5-获取随机key" class="headerlink" title="5.获取随机key"></a>5.获取随机key</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; randomkey</span><br><span class="line">&quot;xk&quot;</span><br></pre></td></tr></table></figure>

<h4 id="6-获取key存储的类型"><a href="#6-获取key存储的类型" class="headerlink" title="6.获取key存储的类型"></a>6.获取key存储的类型</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; randomkey</span><br><span class="line">&quot;xk&quot;</span><br></pre></td></tr></table></figure>

<h4 id="7-判断key是否存在"><a href="#7-判断key是否存在" class="headerlink" title="7.判断key是否存在"></a>7.判断key是否存在</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; randomkey</span><br><span class="line">&quot;xk&quot;</span><br></pre></td></tr></table></figure>

<h4 id="8-修改key的名称"><a href="#8-修改key的名称" class="headerlink" title="8.修改key的名称"></a>8.修改key的名称</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; randomkey</span><br><span class="line">&quot;xk&quot;</span><br></pre></td></tr></table></figure>

<h4 id="9-返回key存储的字符串的长度"><a href="#9-返回key存储的字符串的长度" class="headerlink" title="9.返回key存储的字符串的长度"></a>9.返回key存储的字符串的长度</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; randomkey</span><br><span class="line">&quot;xk&quot;</span><br></pre></td></tr></table></figure>

<h4 id="10-同时设置多个kv对"><a href="#10-同时设置多个kv对" class="headerlink" title="10.同时设置多个kv对"></a>10.同时设置多个kv对</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mset date 5.21 mood haha</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h4 id="11-获取多个key的值"><a href="#11-获取多个key的值" class="headerlink" title="11.获取多个key的值"></a>11.获取多个key的值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mget date mood</span><br><span class="line">1) &quot;5.21&quot;</span><br><span class="line">2) &quot;haha&quot;</span><br></pre></td></tr></table></figure>

<h4 id="12-设置key-10秒后过期"><a href="#12-设置key-10秒后过期" class="headerlink" title="12.设置key 10秒后过期"></a>12.设置key 10秒后过期</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; expire date 10</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<h4 id="13-查看当前还剩几秒过期"><a href="#13-查看当前还剩几秒过期" class="headerlink" title="13.查看当前还剩几秒过期"></a>13.查看当前还剩几秒过期</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ttl date</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure>

<h4 id="14-过期后获取key"><a href="#14-过期后获取key" class="headerlink" title="14.过期后获取key"></a>14.过期后获取key</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get date</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<h4 id="15-列表最多可以存多少元素"><a href="#15-列表最多可以存多少元素" class="headerlink" title="15.列表最多可以存多少元素"></a>15.列表最多可以存多少元素</h4><p>2的32次方 - 1 </p>
<h4 id="16-从左向列表中添加元素"><a href="#16-从左向列表中添加元素" class="headerlink" title="16.从左向列表中添加元素"></a>16.从左向列表中添加元素</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush fruit apple</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lpush fruit strawberry</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; lpush fruit pear</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lpush fruit orange</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure>

<h4 id="17-获取列表中所有的元素"><a href="#17-获取列表中所有的元素" class="headerlink" title="17.获取列表中所有的元素"></a>17.获取列表中所有的元素</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange fruit 0 -1</span><br><span class="line">1) &quot;orange&quot;</span><br><span class="line">2) &quot;pear&quot;</span><br><span class="line">3) &quot;strawberry&quot;</span><br><span class="line">4) &quot;apple&quot;</span><br></pre></td></tr></table></figure>

<h4 id="18-从左弹出元素"><a href="#18-从左弹出元素" class="headerlink" title="18.从左弹出元素"></a>18.从左弹出元素</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpop fruit</span><br><span class="line">&quot;orange&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange fruit 0 -1</span><br><span class="line">1) &quot;pear&quot;</span><br><span class="line">2) &quot;strawberry&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br></pre></td></tr></table></figure>

<h4 id="19-获取指定位置的元素"><a href="#19-获取指定位置的元素" class="headerlink" title="19.获取指定位置的元素"></a>19.获取指定位置的元素</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lindex fruit 2</span><br><span class="line">&quot;apple&quot;</span><br></pre></td></tr></table></figure>

<h4 id="20-获取列表长度"><a href="#20-获取列表长度" class="headerlink" title="20.获取列表长度"></a>20.获取列表长度</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; llen fruit</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>

<h4 id="21-集合"><a href="#21-集合" class="headerlink" title="21.集合"></a>21.集合</h4><p>set是string类型的无序集合，集合中的元素都是唯一的。</p>
<h4 id="22-向集合中添加元素"><a href="#22-向集合中添加元素" class="headerlink" title="22.向集合中添加元素"></a>22.向集合中添加元素</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd books java</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd books python</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd books php</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd books go</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd books ruby</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<h4 id="23-获取集合中的元素"><a href="#23-获取集合中的元素" class="headerlink" title="23.获取集合中的元素"></a>23.获取集合中的元素</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers books</span><br><span class="line">1) &quot;go&quot;</span><br><span class="line">2) &quot;python&quot;</span><br><span class="line">3) &quot;java&quot;</span><br><span class="line">4) &quot;php&quot;</span><br><span class="line">5) &quot;ruby&quot;</span><br></pre></td></tr></table></figure>

<h4 id="24-删除集合中的指定元素"><a href="#24-删除集合中的指定元素" class="headerlink" title="24.删除集合中的指定元素"></a>24.删除集合中的指定元素</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; srem books ruby</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers books</span><br><span class="line">1) &quot;php&quot;</span><br><span class="line">2) &quot;java&quot;</span><br><span class="line">3) &quot;python&quot;</span><br><span class="line">4) &quot;go&quot;</span><br></pre></td></tr></table></figure>

<h4 id="25-zset类型"><a href="#25-zset类型" class="headerlink" title="25.zset类型"></a>25.zset类型</h4><p>有序的集合</p>
<p>元素为string类型</p>
<p>元素唯一，不重复。每个元素有自己的权重。</p>
<h4 id="26-向有序集合中添加元素"><a href="#26-向有序集合中添加元素" class="headerlink" title="26.向有序集合中添加元素"></a>26.向有序集合中添加元素</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd animal 1 monkey</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd animal 2 chicken</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd animal 3 mouse</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd animal 4 horse</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<h4 id="27-获取有序集合元素个数"><a href="#27-获取有序集合元素个数" class="headerlink" title="27.获取有序集合元素个数"></a>27.获取有序集合元素个数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zcard animal</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure>

<h4 id="28-获取所有元素"><a href="#28-获取所有元素" class="headerlink" title="28.获取所有元素"></a>28.获取所有元素</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange animal 0 -1</span><br><span class="line">1) &quot;monkey&quot;</span><br><span class="line">2) &quot;chicken&quot;</span><br><span class="line">3) &quot;mouse&quot;</span><br><span class="line">4) &quot;horse&quot;</span><br></pre></td></tr></table></figure>

<h4 id="29-获取所有元素并带上分值"><a href="#29-获取所有元素并带上分值" class="headerlink" title="29.获取所有元素并带上分值"></a>29.获取所有元素并带上分值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange animal 0 -1 withscores</span><br><span class="line">1) &quot;monkey&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;chicken&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;mouse&quot;</span><br><span class="line">6) &quot;3&quot;</span><br><span class="line">7) &quot;horse&quot;</span><br><span class="line">8) &quot;4&quot;</span><br></pre></td></tr></table></figure>

<h4 id="30-HyperLogLog"><a href="#30-HyperLogLog" class="headerlink" title="30.HyperLogLog"></a>30.HyperLogLog</h4><p>Redis 在 2.8.9 版本添加了 HyperLogLog 结构。</p>
<p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</p>
<p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>
<p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>
<h4 id="31-向HyperLogLog中添加元素"><a href="#31-向HyperLogLog中添加元素" class="headerlink" title="31.向HyperLogLog中添加元素"></a>31.向HyperLogLog中添加元素</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd color blue</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd color yellow</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd color pink</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd color white</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd color black</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<h4 id="32-获取HyperLogLog元素个数"><a href="#32-获取HyperLogLog元素个数" class="headerlink" title="32.获取HyperLogLog元素个数"></a>32.获取HyperLogLog元素个数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfcount color</span><br><span class="line">(integer) 5</span><br></pre></td></tr></table></figure>

<h4 id="33-发布订阅"><a href="#33-发布订阅" class="headerlink" title="33.发布订阅"></a>33.发布订阅</h4><p>种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p>
<p>Redis 客户端可以订阅任意数量的频道。</p>
<h4 id="34-创建订阅频道"><a href="#34-创建订阅频道" class="headerlink" title="34.创建订阅频道"></a>34.创建订阅频道</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; subscribe everydayNews</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;everydayNews&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line">1) &quot;message&quot;</span><br></pre></td></tr></table></figure>

<h4 id="35-在对应频道发布消息"><a href="#35-在对应频道发布消息" class="headerlink" title="35.在对应频道发布消息"></a>35.在对应频道发布消息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; publish everydayNews &quot;morning&quot;</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<p>订阅者收到:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;everydayNews&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;everydayNews&quot;</span><br><span class="line">3) &quot;morning&quot;</span><br></pre></td></tr></table></figure>

<h4 id="36-非后台执行备份"><a href="#36-非后台执行备份" class="headerlink" title="36.非后台执行备份"></a>36.非后台执行备份</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; save</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h4 id="37-后台执行备份"><a href="#37-后台执行备份" class="headerlink" title="37.后台执行备份"></a>37.后台执行备份</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; BGSAVE</span><br><span class="line">Background saving started</span><br></pre></td></tr></table></figure>

<h4 id="38-查看是否需要密码验证"><a href="#38-查看是否需要密码验证" class="headerlink" title="38.查看是否需要密码验证"></a>38.查看是否需要密码验证</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get requirepass</span><br><span class="line">1) &quot;requirepass&quot;</span><br><span class="line">2) &quot;&quot;</span><br></pre></td></tr></table></figure>



<h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><p><a href="https://redis.io/">https://redis.io/</a></p>
<p><a href="http://redisdoc.com/">http://redisdoc.com/</a></p>
<p><a href="https://www.runoob.com/redis/">https://www.runoob.com/redis/</a></p>
<p><img src="https://gitee.com/yizhibuerdai/Imagetools/raw/master/images/common1.png" alt="WechatIMG360"></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM框架之Mybatis</title>
    <url>/2023/10/08/SSM%E6%A1%86%E6%9E%B6%E4%B9%8BMybatis/</url>
    <content><![CDATA[<h1 id="0-ssm框架大纲"><a href="#0-ssm框架大纲" class="headerlink" title="0. ssm框架大纲"></a>0. ssm框架大纲</h1><p><img src="https://img-blog.csdnimg.cn/20201216113448264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/2020121611573756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20201216120216116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="1-Mybatis"><a href="#1-Mybatis" class="headerlink" title="1. Mybatis"></a>1. Mybatis</h1><p><img src="https://img-blog.csdnimg.cn/2020121615053085.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/2020121615120223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20201216160829574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20201216160720478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="2-第一个Mybatis程序mybatis-01"><a href="#2-第一个Mybatis程序mybatis-01" class="headerlink" title="2. 第一个Mybatis程序mybatis-01"></a>2. 第一个Mybatis程序<code>mybatis-01</code></h1><ul>
<li>搭建环境</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE `mybatis`;</span><br><span class="line"></span><br><span class="line">USE `mybatis`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">`id` <span class="type">INT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">`name` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`pwd` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span></span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` (`id`,`name`,`pwd`) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;狂神&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;123890&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>新建项目(创建子模块)</p>
<ul>
<li>配置mybatis的核心配置文件</li>
<li>编写mybatis工具类</li>
</ul>
</li>
<li><p>编写实体类</p>
<ul>
<li>实体类</li>
<li>Dao接口</li>
<li>接口实现类</li>
</ul>
</li>
<li><p>测试</p>
<ul>
<li>junit测试</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 错误1</span></span><br><span class="line">org.apache.ibatis.binding.BindingException: Type interface com.xiaofan.dao.UserDao is not known to the MapperRegistry.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解决方案</span></span><br><span class="line">&lt;mappers&gt;</span><br><span class="line">	&lt;mapper resource=&quot;com/xiaofan/dao/UserMapper.xml&quot;/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 错误2</span></span><br><span class="line">Cause: org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: java.io.IOException: Could not find resource com/xiaofan/dao/UserMapper.xml</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解决方案</span></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;resources&gt;</span><br><span class="line">            &lt;resource&gt;</span><br><span class="line">                &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">                &lt;includes&gt;</span><br><span class="line">                    &lt;include&gt;**/*.properties&lt;/include&gt;</span><br><span class="line">                    &lt;include&gt;**/*.xml&lt;/include&gt;</span><br><span class="line">                    &lt;include&gt;**/*.tld&lt;/include&gt;</span><br><span class="line">                &lt;/includes&gt;</span><br><span class="line">                &lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">            &lt;/resource&gt;</span><br><span class="line">            &lt;resource&gt;</span><br><span class="line">                &lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">                &lt;includes&gt;</span><br><span class="line">                    &lt;include&gt;**/*.properties&lt;/include&gt;</span><br><span class="line">                    &lt;include&gt;**/*.xml&lt;/include&gt;</span><br><span class="line">                    &lt;include&gt;**/*.tld&lt;/include&gt;</span><br><span class="line">                &lt;/includes&gt;</span><br><span class="line">                &lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">            &lt;/resource&gt;</span><br><span class="line">        &lt;/resources&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20201216210136539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>传递Map的情况</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addUser1</span><span class="params">(Map&lt;String, Object&gt; map)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- map只要和键值保持一致即可 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser1&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    insert into mybatis.user (id, name, pwd) values(#&#123;userId&#125;, #&#123;userName&#125;, #&#123;password&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAddUser1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;userId&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    map.put(<span class="string">&quot;userName&quot;</span>, <span class="string">&quot;胡一刀&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mapper.addUser1(map);</span><br><span class="line">    <span class="comment">// 增删改必须提交事务</span></span><br><span class="line">    sqlSession.commit();</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>模糊查询</p>
<ul>
<li><p>Java代码执行的时候，传递通配符%%</p>
</li>
<li><p>在拼接sql中拼接通配符！</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserLike</span><span class="params">(String value)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.xiaofan.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    select * from mybatis.user where name like #&#123;value&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetUserLike</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    SqlSession sqlSession = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        List&lt;User&gt; userList = mapper.getUserLike(<span class="string">&quot;%胡%&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sqlSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sqlSession.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="3-mybatis配置解析mybatis-02"><a href="#3-mybatis配置解析mybatis-02" class="headerlink" title="3. mybatis配置解析mybatis-02"></a>3. mybatis配置解析<code>mybatis-02</code></h1><p><img src="https://img-blog.csdnimg.cn/20201216220303741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20201216225245392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20201216234043102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.ibatis.type.Alias;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Alias(value = &quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20201217104645535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20201217104715614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="4-结果集映射（解决属性名和字段名不一致的情况）mybatis-03"><a href="#4-结果集映射（解决属性名和字段名不一致的情况）mybatis-03" class="headerlink" title="4. 结果集映射（解决属性名和字段名不一致的情况）mybatis-03"></a>4. 结果集映射（解决属性名和字段名不一致的情况）<code>mybatis-03</code></h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.xiaofan.dao.UserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;UserMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--column: 数据库中的字段 property: 实体字段--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库字段和实体字段一样的就不用做处理--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;result column=&quot;id&quot; property=&quot;id&quot; /&gt;</span></span><br><span class="line"><span class="comment">        &lt;result column=&quot;name&quot; property=&quot;name&quot; /&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserMap&quot;</span>&gt;</span></span><br><span class="line">        select * from mybatis.user where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="5-日志mybatis-04"><a href="#5-日志mybatis-04" class="headerlink" title="5. 日志mybatis-04"></a>5. 日志<code>mybatis-04</code></h1><p><img src="https://img-blog.csdnimg.cn/20201217132840333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><strong>STDOUT_LOGGING标准日志</strong></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201217133509697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>LOG4J</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201217143920764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码</span></span><br><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">DEBUG,console,file</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置CONSOLE输出到控制台</span></span><br><span class="line"><span class="meta">log4j.appender.console</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.console.layout</span>=<span class="string">org.apache.log4j.PatternLayout </span></span><br><span class="line"><span class="comment"># 配置CONSOLE日志的输出格式  [frame] 2019-08-22 22:52:12,000  %r耗费毫秒数 %p日志的优先级 %t线程名 %C所属类名通常为全类名 %L代码中的行号 %x线程相关联的NDC %m日志 %n换行</span></span><br><span class="line"><span class="meta">log4j.appender.console.layout.ConversionPattern</span>=<span class="string">[frame] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; - %-4r %-5p [%t] %C:%L %x - %m%n</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出到日志文件中</span></span><br><span class="line"><span class="meta">log4j.appender.file</span>=<span class="string">org.apache.log4j.RollingFileAppender</span></span><br><span class="line"><span class="comment"># 保存编码格式</span></span><br><span class="line"><span class="meta">log4j.appender.file.Encoding</span>=<span class="string">UTF-8</span></span><br><span class="line"><span class="comment"># 输出文件位置此为项目根目录下的logs文件夹中</span></span><br><span class="line"><span class="meta">log4j.appender.file.File</span>=<span class="string">logs/root.log</span></span><br><span class="line"><span class="comment"># 后缀可以是KB,MB,GB达到该大小后创建新的日志文件</span></span><br><span class="line"><span class="meta">log4j.appender.file.MaxFileSize</span>=<span class="string">10MB</span></span><br><span class="line"><span class="comment"># 设置滚定文件的最大值3 指可以产生root.log.1、root.log.2、root.log.3和root.log四个日志文件</span></span><br><span class="line"><span class="meta">log4j.appender.file.MaxBackupIndex</span>=<span class="string">3  </span></span><br><span class="line"><span class="comment"># 配置logfile为自定义布局模式</span></span><br><span class="line"><span class="meta">log4j.appender.file.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.file.layout.ConversionPattern</span>=<span class="string">%d&#123;yyyy-MM-dd HH:mm:ss&#125; %F %p %m%n</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出日志级别(设置mybatis的日志级别)</span></span><br><span class="line"><span class="meta">log4j.logger.org.mybatis</span>=<span class="string">DEBUG</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对不同的类输出不同的日志文件</span></span><br><span class="line"><span class="comment"># com.xiaofan.dao包下的日志单独输出到xiaofan.log</span></span><br><span class="line"><span class="meta">log4j.logger.com.xiaofan.dao</span>=<span class="string">DEBUG,xiaofan</span></span><br><span class="line"><span class="comment"># 设置为false该日志信息就不会加入到rootLogger中了</span></span><br><span class="line"><span class="meta">log4j.additivity.com.xiaofan.dao</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"># 下面就和上面配置一样了</span></span><br><span class="line"><span class="meta">log4j.appender.xiaofan</span>=<span class="string">org.apache.log4j.RollingFileAppender</span></span><br><span class="line"><span class="meta">log4j.appender.xiaofan.Encoding</span>=<span class="string">UTF-8</span></span><br><span class="line"><span class="meta">log4j.appender.xiaofan.File</span>=<span class="string">logs/xiaofan.log</span></span><br><span class="line"><span class="meta">log4j.appender.xiaofan.MaxFileSize</span>=<span class="string">10MB</span></span><br><span class="line"><span class="meta">log4j.appender.xiaofan.MaxBackupIndex</span>=<span class="string">3</span></span><br><span class="line"><span class="meta">log4j.appender.xiaofan.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.xiaofan.layout.ConversionPattern</span>=<span class="string">%d&#123;yyyy-MM-dd HH:mm:ss&#125; %F %p %m%n</span></span><br></pre></td></tr></table></figure>

<p>测试通过！</p>
<p>参考链接：<a href="https://www.cnblogs.com/zhangguangxiang/p/12007924.html">https://www.cnblogs.com/zhangguangxiang/p/12007924.html</a></p>
<p>​                    <a href="https://www.cnblogs.com/yidaxia/p/5820036.html">https://www.cnblogs.com/yidaxia/p/5820036.html</a></p>
<h1 id="6-分页-mybatis-04"><a href="#6-分页-mybatis-04" class="headerlink" title="6. 分页 mybatis-04"></a>6. 分页 <code>mybatis-04</code></h1><h1 id="7-Mybatis执行流程"><a href="#7-Mybatis执行流程" class="headerlink" title="7. Mybatis执行流程"></a>7. Mybatis执行流程</h1><p><img src="https://img-blog.csdnimg.cn/20201217172214786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20201217172401673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20201217172435544.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="8-Lombok的使用-真正开发项目中不用"><a href="#8-Lombok的使用-真正开发项目中不用" class="headerlink" title="8. Lombok的使用(真正开发项目中不用)"></a>8. Lombok的使用(真正开发项目中不用)</h1><ul>
<li>idea 安装Lombok插件</li>
<li>导包</li>
<li>用法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaofan.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="9-复杂查询环境搭建"><a href="#9-复杂查询环境搭建" class="headerlink" title="9 复杂查询环境搭建"></a>9 复杂查询环境搭建</h1><p><strong>注解和xml配合使用，对于简单的可以使用注解，复杂的使用xml</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `teacher` (</span><br><span class="line">  `id` <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">  `name` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span></span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> teacher (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;秦老师&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student` (</span><br><span class="line">  `id` <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tid` <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   <span class="keyword">PRIMARY</span> KEY(`id`),</span><br><span class="line">   KEY `fktid` (`tid`),</span><br><span class="line">   <span class="keyword">CONSTRAINT</span> `fktid` <span class="keyword">FOREIGN</span> KEY (`tid`) <span class="keyword">REFERENCES</span> `teacher`(`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` (`id`, `name`, `tid`) <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">&#x27;小明&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `s`student`tudent` (`id`, `name`, `tid`) <span class="keyword">VALUES</span>(<span class="number">2</span>, <span class="string">&#x27;小红&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` (`id`, `name`, `tid`) <span class="keyword">VALUES</span>(<span class="number">3</span>, <span class="string">&#x27;小张&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` (`id`, `name`, `tid`) <span class="keyword">VALUES</span>(<span class="number">4</span>, <span class="string">&#x27;小李&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` (`id`, `name`, `tid`) <span class="keyword">VALUES</span>(<span class="number">5</span>, <span class="string">&#x27;小王&#x27;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h2 id="9-1-多对一mybatis-05"><a href="#9-1-多对一mybatis-05" class="headerlink" title="9.1. 多对一mybatis-05"></a>9.1. 多对一<code>mybatis-05</code></h2><ul>
<li>按照嵌套查询进行处理（子查询）</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudent1&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;StudentTeacher1&quot;</span>&gt;</span></span><br><span class="line">    select * from mybatis.student;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;StudentTeacher1&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--复杂的属性需要单独处理 对象：association 集合：collection--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Teacher&quot;</span> <span class="attr">select</span>=<span class="string">&quot;getTeacherById&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacherById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span></span><br><span class="line">    select * from mybatis.teacher where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>按照结果嵌套处理（多表关联）</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudent2&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;StudentTeacher2&quot;</span>&gt;</span></span><br><span class="line">    select s.id sid, s.name sname, t.name tname from student s, teacher t where s.tid = t.id</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注意别名问题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;StudentTeacher2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sid&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 学生的名字 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sname&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 老师的名字--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tname&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="9-2-一对多mybatis-06"><a href="#9-2-一对多mybatis-06" class="headerlink" title="9.2. 一对多mybatis-06"></a>9.2. 一对多<code>mybatis-06</code></h2><ul>
<li>按照嵌套查询进行处理（子查询）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaofan.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xiaofan.pojo.Teacher;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TeacherMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from mybatis.teacher where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">Teacher <span class="title">getTeacherById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Teacher <span class="title">getTeacher1</span><span class="params">(<span class="meta">@Param(&quot;tid&quot;)</span> <span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacher1&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;TeacherStudent1&quot;</span>&gt;</span></span><br><span class="line">    select * from mybatis.teacher where id = #&#123;tid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;TeacherStudent1&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;students&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Student&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;ArrayList&quot;</span> <span class="attr">select</span>=<span class="string">&quot;getStudentByTeacherId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudentByTeacherId&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">    select * from mybatis.student where tid = #&#123;tid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ul>
<li>按照结果嵌套处理（多表关联）</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacher2&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;TeacherStudent&quot;</span>&gt;</span></span><br><span class="line">    select s.id sid, s.name sname, t.id tid, t.name tname</span><br><span class="line">    from student s, teacher t</span><br><span class="line">    where s.tid = t.id and t.id = #&#123;tid&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;TeacherStudent&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tname&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;students&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sid&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sname&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;tid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="10-动态Sqlmybatis-07"><a href="#10-动态Sqlmybatis-07" class="headerlink" title="10. 动态Sqlmybatis-07"></a>10. 动态Sql<code>mybatis-07</code></h1><p><code>动态SQL就是指根据不同的条件生成不同的SQL语句</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> blog (</span><br><span class="line">	id <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;博客id&#x27;</span>,</span><br><span class="line">    title <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;博客标题&#x27;</span>,</span><br><span class="line">    author <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;博客作者&#x27;</span>,</span><br><span class="line">    create_time datetime <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">    views <span class="type">int</span>(<span class="number">30</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;浏览量&#x27;</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> charset<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<ul>
<li>if</li>
<li>choose (when, otherwise)</li>
<li>trim (where, set)</li>
<li>foreach</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaofan.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xiaofan.pojo.Blog;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlogMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addBlog</span><span class="params">(Blog blog)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Blog&gt; <span class="title">queryBlogIF</span><span class="params">(Map map)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Blog&gt; <span class="title">queryBlogChoose</span><span class="params">(Map map)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateBlog</span><span class="params">(Map map)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Blog&gt; <span class="title">queryBlogForeach</span><span class="params">(Map map)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.xiaofan.dao.BlogMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addBlog&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;blog&quot;</span>&gt;</span></span><br><span class="line">        insert into mybatis.blog (id, title, author, create_time, views)</span><br><span class="line">        values (#&#123;id&#125;, #&#123;title&#125;, #&#123;author&#125;, #&#123;createTime&#125;, #&#123;views&#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBlogIF&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;blog&quot;</span>&gt;</span></span><br><span class="line">        select * from mybatis.blog</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">                title = #&#123;title&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null&quot;</span>&gt;</span></span><br><span class="line">                and author = #&#123;author&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBlogChoose&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;blog&quot;</span>&gt;</span></span><br><span class="line">        select * from mybatis.blog</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">                    title = #&#123;title&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;author != null&quot;</span>&gt;</span></span><br><span class="line">                    and author = #&#123;author&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">                    and views = #&#123;views&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateBlog&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">        update mybatis.blog</span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">                title = #&#123;title&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null&quot;</span>&gt;</span></span><br><span class="line">                author = #&#123;author&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- select * from mybatis.blog where 1=1 and (id=1 or id=2 or id=3) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBlogForeach&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;blog&quot;</span>&gt;</span></span><br><span class="line">        select * from mybatis.blog</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">open</span>=<span class="string">&quot;and (&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;or&quot;</span>&gt;</span></span><br><span class="line">                id = #&#123;id&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaofan.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xiaofan.pojo.Blog;</span><br><span class="line"><span class="keyword">import</span> com.xiaofan.utils.IDUtils;</span><br><span class="line"><span class="keyword">import</span> com.xiaofan.utils.MybatisUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAddBlog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line">        BlogMapper mapper = sqlSession.getMapper(BlogMapper.class);</span><br><span class="line"></span><br><span class="line">        Blog blog = <span class="keyword">new</span> Blog(IDUtils.getId(), <span class="string">&quot;Mybatis如此简单&quot;</span>, <span class="string">&quot;狂神说&quot;</span>, <span class="keyword">new</span> Date(), <span class="number">9999</span>);</span><br><span class="line">        mapper.addBlog(blog);</span><br><span class="line"></span><br><span class="line">        blog.setId(IDUtils.getId());</span><br><span class="line">        blog.setTitle(<span class="string">&quot;Java如此简单&quot;</span>);</span><br><span class="line">        mapper.addBlog(blog);</span><br><span class="line"></span><br><span class="line">        blog.setId(IDUtils.getId());</span><br><span class="line">        blog.setTitle(<span class="string">&quot;Spring如此简单&quot;</span>);</span><br><span class="line">        mapper.addBlog(blog);</span><br><span class="line"></span><br><span class="line">        blog.setId(IDUtils.getId());</span><br><span class="line">        blog.setTitle(<span class="string">&quot;微服务如此简单&quot;</span>);</span><br><span class="line">        mapper.addBlog(blog);</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryBlogIF</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line">        BlogMapper mapper = sqlSession.getMapper(BlogMapper.class);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="string">&quot;title&quot;</span>, <span class="string">&quot;Mybatis如此简单&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;author&quot;</span>, <span class="string">&quot;狂神说&quot;</span>);</span><br><span class="line">        mapper.queryBlogIF(map);</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryBlogChoose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line">        BlogMapper mapper = sqlSession.getMapper(BlogMapper.class);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="string">&quot;title&quot;</span>, <span class="string">&quot;Mybatis如此简单&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;author&quot;</span>, <span class="string">&quot;狂神说&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;views&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">        mapper.queryBlogChoose(map);</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateBlog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line">        BlogMapper mapper = sqlSession.getMapper(BlogMapper.class);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="string">&quot;title&quot;</span>, <span class="string">&quot;Mybatis如此简单2&quot;</span>);</span><br><span class="line"><span class="comment">//        map.put(&quot;author&quot;, &quot;狂神说&quot;);</span></span><br><span class="line">        map.put(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;0d15b0c288514e39a8f757030a5708a9&quot;</span>);</span><br><span class="line">        mapper.updateBlog(map);</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryBlogForeach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line">        BlogMapper mapper = sqlSession.getMapper(BlogMapper.class);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        List&lt;Integer&gt; ids = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        ids.add(<span class="number">1</span>);</span><br><span class="line">        ids.add(<span class="number">2</span>);</span><br><span class="line">        ids.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">&quot;ids&quot;</span>, ids);</span><br><span class="line"></span><br><span class="line">        List&lt;Blog&gt; blogs = mapper.queryBlogForeach(map);</span><br><span class="line">        <span class="keyword">for</span> (Blog blog : blogs) &#123;</span><br><span class="line">            System.out.println(blog);</span><br><span class="line">        &#125;</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="11-SQL片段"><a href="#11-SQL片段" class="headerlink" title="11. SQL片段"></a>11. SQL片段</h1><p>有的时候，我们可能会将一些功能的部分抽取出来，方便复用！</p>
<ol>
<li>使用sql标签抽取公共部分</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;if-title_author&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">        title = #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null&quot;</span>&gt;</span></span><br><span class="line">        and author = #&#123;author&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ol start="2">
<li>在需要使用的地方使用include标签应用即可</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBlogIF&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.xiaofan.pojo.Blog&quot;</span>&gt;</span></span><br><span class="line">    select * from mybatis.blog</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;if-title_author&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>注意事项：</p>
<ol>
<li>最好基于单标来定义sql片段</li>
<li>不要存在where标签</li>
</ol>
<h1 id="12-缓存mybatis-08"><a href="#12-缓存mybatis-08" class="headerlink" title="12. 缓存mybatis-08"></a>12. 缓存<code>mybatis-08</code></h1><ul>
<li><p>一级缓存（默认开启）</p>
<ul>
<li><p>开启日志</p>
</li>
<li><p>测试在一个Session中查询两次相同的记录</p>
</li>
<li><p>查看日志输出</p>
</li>
<li><p>缓存失效的情况</p>
<ul>
<li>查询不同的东西</li>
<li>增删改查操作，可能会改变原来的数据，所以必定会刷新缓存！</li>
<li>查询不同的Mapper.xml</li>
<li>手动清除缓存</li>
</ul>
</li>
</ul>
</li>
<li><p>二级缓存</p>
<p><img src="https://img-blog.csdnimg.cn/20201218163259540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>开启全局缓存</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在当前Mapper中使用缓存</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启二级缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意事项：实体需要序列化哦！</p>
<p><img src="https://img-blog.csdnimg.cn/2020082416365829.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
</ul>
<p><img src="https://images2017.cnblogs.com/blog/1254583/201710/1254583-20171029185910164-1823278112.png"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM框架之Mybatis</title>
    <url>/2023/10/15/SpringMVC/</url>
    <content><![CDATA[<h1 id="0-老版本Spring官方文档-https-docs-spring-io-spring-framework-docs-4-3-24-RELEASE-spring-framework-reference-html"><a href="#0-老版本Spring官方文档-https-docs-spring-io-spring-framework-docs-4-3-24-RELEASE-spring-framework-reference-html" class="headerlink" title="0. 老版本Spring官方文档 https://docs.spring.io/spring-framework/docs/4.3.24.RELEASE/spring-framework-reference/html/"></a>0. 老版本Spring官方文档 <a href="https://docs.spring.io/spring-framework/docs/4.3.24.RELEASE/spring-framework-reference/html/">https://docs.spring.io/spring-framework/docs/4.3.24.RELEASE/spring-framework-reference/html/</a></h1><h1 id="1-SpringMVC"><a href="#1-SpringMVC" class="headerlink" title="1. SpringMVC"></a>1. SpringMVC</h1><p><img src="https://img-blog.csdnimg.cn/20201229085230796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20201229191551383.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20201229192034536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="2-HelloSpringMVC-配置版本springmvc-02-mymvc"><a href="#2-HelloSpringMVC-配置版本springmvc-02-mymvc" class="headerlink" title="2. HelloSpringMVC 配置版本springmvc-02-mymvc"></a>2. HelloSpringMVC 配置版本<code>springmvc-02-mymvc</code></h1><ul>
<li><p>2.1. 新建一个module，添加web支持！</p>
</li>
<li><p>2.2. 确定导入了SpringMVC的依赖！</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xiaofan<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>springmvc-01-servlet<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>springmvc-02-mymvc<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>2.3. 配置web.xml， 注册DispatcherServlet！</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;5.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置DispatcherServlet： 这个是SpringMVC的核心，请求分发器，前端控制器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--DispatcherServlet要绑定spring的配置文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--启动级别 1--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--/: 只匹配所有的请求，不会去匹配jsp页面--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--/*: 配所有的请求，包括jsp页面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>2.4. 编写SpringMVC的配置文件  springmvc-servlet.xml : [servletname]-servlet.xml 说明，这里的名称是按照官方来的</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--处理器映射器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--处理器适配器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--处理器解析器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="attr">id</span>=<span class="string">&quot;InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--前缀--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--后缀--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--BeanNameUrlHandlerMapping:bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;/hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xiaofan.controller.HelloController&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>2.5. 添加处理映射器</p>
</li>
<li><p>2.6. 添加处理器适配器</p>
</li>
<li><p>2.7. 添加视图解析器</p>
</li>
<li><p>2.8. 编写我们要操作业务Controller，要么实现Controller接口， 要么增加注解；需要返回一个ModelAndView，装数据，封视图；</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaofan.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.Controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 业务代码</span></span><br><span class="line">        String result = <span class="string">&quot;hello springmvc!&quot;</span>;</span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;msg&quot;</span>, result);</span><br><span class="line">        <span class="comment">// 跳转视图</span></span><br><span class="line">        modelAndView.setViewName(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>2.9. 将自己的类交给SpringIOC容器，注册bean</li>
<li>2.10. 写需要跳转的jsp页面，显示ModelandView存放的数据，以及我们的正常页面；</li>
<li>2.11. 配置Tomcat启动测试！</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201230094925531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20201231144912833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="3-SpringMVC执行原理"><a href="#3-SpringMVC执行原理" class="headerlink" title="3. SpringMVC执行原理"></a>3. SpringMVC执行原理</h1><p><img src="https://img-blog.csdnimg.cn/20201231084510902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20201231084951860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20201231085018219.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20201231085548374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="4-SpringMVC注解版本springmvc-03-annotation"><a href="#4-SpringMVC注解版本springmvc-03-annotation" class="headerlink" title="4. SpringMVC注解版本springmvc-03-annotation"></a>4. SpringMVC注解版本<code>springmvc-03-annotation</code></h1><ul>
<li>web.xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;5.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置DispatcherServlet： 这个是SpringMVC的核心，请求分发器，前端控制器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--DispatcherServlet要绑定spring的配置文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--启动级别 1--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--/: 只匹配所有的请求，不会去匹配jsp页面--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--/*: 配所有的请求，包括jsp页面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>springmvc-servlet.xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--自动扫描包， 让指定包下的注解生效，由IOC容器统一管理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.xiaofan.controller&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--让Spring MVC不处理静态资源 .css .js .html .mp3 .mp4--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--支持mvc注解驱动</span></span><br><span class="line"><span class="comment">        在spring中一般采用@RequestMapping注解完成映射关系， 要想使@RequestMapping注解生效，必须向上下文注册DefaultAnnotationHandlerMapping</span></span><br><span class="line"><span class="comment">        和一个AnnotationMethodHandlerAdapter实例，这两个实例分别在类级别和方法级别处理， 而annotation-driven配置帮助我们自动完成上述两个实例的注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--处理器解析器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="attr">id</span>=<span class="string">&quot;InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--前缀--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--后缀--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>HelloController.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaofan.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 封装数据</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;hello SpringMVCAnnotation!&quot;</span>);</span><br><span class="line">        <span class="comment">// 会被视图解析器处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>hello.jsp</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">$&#123;msg&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h1 id="5-RestFul-风格springmvc-04-controller"><a href="#5-RestFul-风格springmvc-04-controller" class="headerlink" title="5. RestFul 风格springmvc-04-controller"></a>5. RestFul 风格<code>springmvc-04-controller</code></h1><p><img src="https://img-blog.csdnimg.cn/20201231174235560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20201231182101527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaofan.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestFulController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// http://localhost:8080/springmvc_04_controller_war_exploded/add/1/22</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/add/&#123;a&#125;/&#123;b&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">int</span> a, <span class="meta">@PathVariable</span> <span class="keyword">int</span> b, Model model)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = a + b;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;结果为1：&quot;</span> + res);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/add/&#123;a&#125;/&#123;b&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">int</span> a, <span class="meta">@PathVariable</span> <span class="keyword">int</span> b, Model model)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = a + b;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;结果为2：&quot;</span> + res);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%--模仿post方式 RestFul风格提交--%&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;/springmvc_04_controller_war_exploded/add/1/20&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h1 id="6-转发和重定向"><a href="#6-转发和重定向" class="headerlink" title="6. 转发和重定向"></a>6. 转发和重定向</h1><ul>
<li>无视图解析器</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201231185048492.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>有视图解析器</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201231185325648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="7-接收请求数据及数据回显"><a href="#7-接收请求数据及数据回显" class="headerlink" title="7. 接收请求数据及数据回显"></a>7. 接收请求数据及数据回显</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaofan.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xiaofan.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// localhost:8080/user/t1?username=xxx</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/t1&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String name, Model model)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;接收到的前端参数：&quot;</span> + name);</span><br><span class="line"></span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>, name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收一个对象 http://localhost:8080/springmvc_04_controller_war_exploded/user/t2?name=xiaofan&amp;age=3&amp;id=999</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/t2&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">(User user, Model model)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;接收到的前端参数：&quot;</span> + user);</span><br><span class="line"></span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>, user);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20210102111619805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="8-乱码问题解决"><a href="#8-乱码问题解决" class="headerlink" title="8. 乱码问题解决"></a>8. 乱码问题解决</h1><ul>
<li>配置spring过滤器</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;5.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置DispatcherServlet： 这个是SpringMVC的核心，请求分发器，前端控制器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--DispatcherServlet要绑定spring的配置文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--启动级别 1--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--/: 只匹配所有的请求，不会去匹配jsp页面--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--/*: 配所有的请求，包括jsp页面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配饰SpringMVC的乱码过滤--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>form.jsp</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action=<span class="string">&quot;/e/t1&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;submit&quot;</span>/&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>EncodingController.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaofan.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncodingController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过滤器解决乱码</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/e/t1&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">(String name, Model model)</span> </span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>, name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>tomcat.server</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">URIEncoding</span>=<span class="string">&quot;utf-8&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="9-JSONspringmvc-05-json"><a href="#9-JSONspringmvc-05-json" class="headerlink" title="9. JSONspringmvc-05-json"></a>9. JSON<code>springmvc-05-json</code></h1><ul>
<li>fastjson</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210102151458820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>json乱码问题</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--自动扫描包， 让指定包下的注解生效，由IOC容器统一管理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.xiaofan.controller&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--让Spring MVC不处理静态资源 .css .js .html .mp3 .mp4--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--支持mvc注解驱动</span></span><br><span class="line"><span class="comment">        在spring中一般采用@RequestMapping注解完成映射关系， 要想使@RequestMapping注解生效，必须向上下文注册DefaultAnnotationHandlerMapping</span></span><br><span class="line"><span class="comment">        和一个AnnotationMethodHandlerAdapter实例，这两个实例分别在类级别和方法级别处理， 而annotation-driven配置帮助我们自动完成上述两个实例的注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:message-converters</span> <span class="attr">register-defaults</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;supportedMediaTypes&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">value</span>&gt;</span>text/html;charset=UTF-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">value</span>&gt;</span>application/json;charset=UTF-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--处理器解析器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="attr">id</span>=<span class="string">&quot;InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--前缀--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--后缀--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="10-拦截器springmvc-07-interceptor"><a href="#10-拦截器springmvc-07-interceptor" class="headerlink" title="10. 拦截器springmvc-07-interceptor"></a>10. 拦截器<code>springmvc-07-interceptor</code></h1><h1 id="11-文件上传下载"><a href="#11-文件上传下载" class="headerlink" title="11. 文件上传下载"></a>11. 文件上传下载</h1>]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>Thymeleaf</title>
    <url>/2023/08/04/Thymeleaf/</url>
    <content><![CDATA[<h1 id="Thymeleaf笔记"><a href="#Thymeleaf笔记" class="headerlink" title="Thymeleaf笔记"></a>Thymeleaf笔记</h1><h2 id="从三层架构到MVC"><a href="#从三层架构到MVC" class="headerlink" title="从三层架构到MVC"></a>从三层架构到MVC</h2><ul>
<li>MVC理念和三层架构并不矛盾，反而是三层架构的延伸</li>
<li>MVC专指表述层的设计理念</li>
<li>MVC理念的核心思想：解耦</li>
</ul>
<p><img src="./assets/Thymeleaf/MVC.png" alt="./images"></p>
<h2 id="从业务功能和三层架构角度看项目网格"><a href="#从业务功能和三层架构角度看项目网格" class="headerlink" title="从业务功能和三层架构角度看项目网格"></a>从业务功能和三层架构角度看项目网格</h2><p><img src="./assets/Thymeleaf/MVCProject.png" alt="./images"></p>
<h2 id="Thymeleaf搭建环境"><a href="#Thymeleaf搭建环境" class="headerlink" title="Thymeleaf搭建环境"></a>Thymeleaf搭建环境</h2><h3 id="导入jar包"><a href="#导入jar包" class="headerlink" title="导入jar包"></a>导入jar包</h3><blockquote>
<p>attoparser-2.0.5.RELEASE.jar</p>
<p>javassist-3.20.0-GA.jar</p>
<p>log4j-1.2.15.jar</p>
<p>ognl-3.1.26.jar</p>
<p>slf4j-api-1.7.25.jar</p>
<p>slf4j-log4j12-1.7.25.jar</p>
<p>thymeleaf-3.0.12.RELEASE.jar</p>
<p>unbescape-1.1.6.RELEASE.jar</p>
</blockquote>
<h3 id="配置web-xml"><a href="#配置web-xml" class="headerlink" title="配置web.xml"></a>配置web.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在上下文参数中配置视图前缀和视图后缀 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>view-prefix<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/view/<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>view-suffix<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>.html<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="创建ViewBaseServlet"><a href="#创建ViewBaseServlet" class="headerlink" title="创建ViewBaseServlet"></a>创建ViewBaseServlet</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.thymeleaf.TemplateEngine;</span><br><span class="line"><span class="keyword">import</span> org.thymeleaf.context.WebContext;</span><br><span class="line"><span class="keyword">import</span> org.thymeleaf.templatemode.TemplateMode;</span><br><span class="line"><span class="keyword">import</span> org.thymeleaf.templateresolver.ServletContextTemplateResolver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContext;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewBaseServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TemplateEngine templateEngine;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.获取ServletContext对象</span></span><br><span class="line">        ServletContext servletContext = <span class="keyword">this</span>.getServletContext();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建Thymeleaf解析器对象</span></span><br><span class="line">        ServletContextTemplateResolver templateResolver = <span class="keyword">new</span> ServletContextTemplateResolver(servletContext);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.给解析器对象设置参数</span></span><br><span class="line">        <span class="comment">// ①HTML是默认模式，明确设置是为了代码更容易理解</span></span><br><span class="line">        templateResolver.setTemplateMode(TemplateMode.HTML);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ②设置前缀</span></span><br><span class="line">        String viewPrefix = servletContext.getInitParameter(<span class="string">&quot;view-prefix&quot;</span>);</span><br><span class="line"></span><br><span class="line">        templateResolver.setPrefix(viewPrefix);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ③设置后缀</span></span><br><span class="line">        String viewSuffix = servletContext.getInitParameter(<span class="string">&quot;view-suffix&quot;</span>);</span><br><span class="line"></span><br><span class="line">        templateResolver.setSuffix(viewSuffix);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ④设置缓存过期时间（毫秒）</span></span><br><span class="line">        templateResolver.setCacheTTLMs(<span class="number">60000L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ⑤设置是否缓存</span></span><br><span class="line">        templateResolver.setCacheable(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ⑥设置服务器端编码方式</span></span><br><span class="line">        templateResolver.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.创建模板引擎对象</span></span><br><span class="line">        templateEngine = <span class="keyword">new</span> TemplateEngine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.给模板引擎对象设置模板解析器</span></span><br><span class="line">        templateEngine.setTemplateResolver(templateResolver);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processTemplate</span><span class="params">(String templateName, HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.设置响应体内容类型和字符集</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建WebContext对象</span></span><br><span class="line">        WebContext webContext = <span class="keyword">new</span> WebContext(req, resp, getServletContext());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.处理模板数据</span></span><br><span class="line">        templateEngine.process(templateName, webContext, resp.getWriter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ViewBaseServlet用法"><a href="#ViewBaseServlet用法" class="headerlink" title="ViewBaseServlet用法"></a>ViewBaseServlet用法</h3><ul>
<li>具体模块下的Servlet继承ViewBaseServlet</li>
<li>想要<strong>转发</strong>到某个视图时，调用父类的processTemplate()即可</li>
<li>按照习惯，我们通常会将模板视图文件放在WEB-INF目录下，这样就不能直接重定向到模板视图文件。此时我们需要重定向到一个Servlet，然后再通过这个Servlet转发到这个模板视图并渲染。</li>
<li>访问项目的首页时，也必须经过Servlet，执行processTemplate()方法，才能够正确解析首页页面上的Thymeleaf元素。</li>
</ul>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAn4AAAAhCAIAAADI9TE8AAAKt0lEQVR42u1dPW8UPRB2/gG0iCIi+QGpKBBIgSJQEokCqEKDBA1EQtAghUg0IKTkGpDSQEcKJKADCoQAUVBBn6AUiDr/AObNiHnnZmyvd/duc1mepzjl9myv7fl47PHsZur3798BAAAAAICuMAXqBQAAAIAuAeoFAAAAgE4B6gUAAACATgHqBQAAAIBOAeoFAAAAgE4B6gUAAACATgHqBQBgIvDw4cP379+/efPG/7S5uXn37t2tra1U3ampqefPn1+8eNFc/PTp08mTJ1O1Pn/+fOrUKfhAoHtUU++5c+fevn27vb197Nixxrf58ePHzMzM2bNno3bVBiPpXiFmZ2fpRjDUicL169efPHmS97DjBnHGnTt3vOsHaoGIcGlpaXsPxpzZgVy7du3x48e+Iv1Kn8bDcJW8YlCZhYUFsmupxTYeLfzgwYPbt2+HvypXPq5x+D3AIOMHxsc+HryYSymqRjX1si62dG2g3j6B51xfIeFmdiRjRdTkTA/HrR6g3hGCBUo8R1NaWdhIluROn+xkSqg3/PWV0g7ZOJGx95u0gdbU++7dO63wdF+qHvW2VJh6AuodN3pIvSPB/lIve8b2/hfUy/DUy2g/w6wn4uNKYEyOWxhH3zKoS70Nhvmvgac0Y2ubm5uXLl0isT569Ii+ak/HdaO1SnYadamXNTAlfVBvA7T3A761SvYhEZdQZh6g3tplStAb6r13797379/X1tamp6cbVPfzyVfay5f9aRuT454Y1SejmijqbTDMg4LDhw8vLS2RarVsp5x6w54OeAM321kuLw3yr7pB1hlNvfr8OEW9meAzNzix1EuSunHjBrmC/e5IBO39gEYJ+5RTZh6g3tplStAb6iWsr68vLy/fvHmzgZeMzudIJqe9yZGL7P5oDdQr2NnZWV1d/fDhw8rKCnFweUXDlDJLmSpa2Qyz+iu+gLk1i68W9Ur4x4ier/O9JpZ6v337NhgM6JMIuJakOgCo9z8YPytff/36JctGP0cm5kMzQoXN4I1pSU/Yies2ZYnqe5vvjw89cR+0aMmopJN652R6FfpFvYTd3V1i31evXhH71rK9KPVqdxOccI0uClfR31yMWvOBYqN1/nqIUW/JwbPOptGapq2UFYM6+fHjRz591EoukW0acpR69X5IND8aD+8mU6FLkENfXFw8dOjQy5cvCyMrZOM/f/4kZWjj/kjrSFhc3XCepl6S/tWrV0Wa9JU+WWfKqZdaIKGT4h05ckRHR2f3IPedWOpl0CLpypUrc3NztWJg2n9qU/KabDywMSIx3i9fvlAxmkaa2IyBmCQ47YoLqVdbpTQrFCDgdsTRff36ld2U+BZtyFpjx069PglC+53UWaCm3migxsyFIeNoV/P9qaRe8yvdhYNXckX78Z5RL4O8JNke/VHuJaPUqzkvpQAydSwXUlBtBimTy6uKMTn+mlnhRslPTEWslAbCRk6KdPz48Zk9aEbnIbAr8dTrE2W5+j9CvYxmkZXGR2485ywFnmctkRT1suxEf+oGnHW3+Q/j/Secehl1JSX+c2Njw+i5Hn40XVzbEVur+IE89Ua9iriUEuqlv00LXD1PvYYmqB1SD9NJ0Y2xU29wvk+cnWx3pIC4G1/GbJKkgB5APppX2Z8QowrpgDSr/Tv3SrqtzbKEemkfGQ4aBoMBrX/J9lZWVmizki/s55NnRssrDDOKLhDUWtiINRpoItFcvnxZLEoyYPWTHlGDjxqAj6noHH6vq3rI/i6sDEZFvQaaPteKpx1EddIgn76zs/P06dO6Uc1MthRDFEwvg/gnnerMEOrVmc/eUTag3mg/hWBKqJdMb3d3d3/FRB1YXV2lz5IYmPhPPXUm4UM8qnaYTHL+MS1DmVEDofbpXia/xBhdhnrDsFFLTIurRylTyEWGICRtXJmIe+zUazym3/GYKeAOychNcFLfyK9i8iOp7E9IU69PxjFKYHIXC6mXNpH7bkh1QR0m+yfSJeolAs4Xji4/ZcJ5lvxOTkcyZNdrxFrCSUa5oyanw90+HGTa1xd1GNl3TJoyfTDUGz1v1hdrUe9BVCcN5pX5+Xli31ppfZlMK30wzAqgi0XdS1BrMhEE6yR9lfJCvWbf7KmXSrIVROXILVML1Fol9T579uz169f7LagakjI7JTPDeitppMCzqtcl/ignlBmIKVNCvT4VIL9b9VzGtUwATI+0i7PeVIqNPjgxgxdRZZ5b1y3LEiPTyZKUnxT1GtF6ZjUutZcBZ17t0taKsy0qt7whRr16JlOJTloKqUhGyuS8wuSplyEmJ6aSydzhBjMZGdrAzE31cFJPN/lu9DLNSoNTruom8kg6eiH1mp9Izbb2QNU3NjYyp/6sVHy4QARJAqWvC3sooV5pWUvcd+lABJxJRiQpkhetvM+fP19ZPqXAYuNhT9szYaeoHVW27yPD5dRrjNpwZIZ6tUyjxfSIekK9UgzUOybQOnd5eZnodm1tbW5urrBWPmN8tNRrmIx+OnHiROWuV0NHI9tQrw6BmDGCeg0arOcYOtm4POAcRZ566Ub3798nCcrbMEi+dJ04lalXVEWSMfNnvSER2Jxw6m0mqe6p1zwMJhmaoN4h6vXxRhOgSEWENMTT5ZMeQb3NUHedq5Gn3kzAWbinnHpNFkwoCzhr6HcQRgPOvnCUeuXQ5MyZM6bzJQHn/DD7BE6anZ6erhthDsNB5loB57qdFGGlXkQlzXoxpag3ikmmXmJcWnnPz8+TE6glqeiBXRi28UzA2ZwHl1Avl8z4cFDv/0kH/ul1Gbw5mpYb0bKL7UGLNu9bS6jXv27mH6fe9fX1wWBQd0ciyFOvV4DgkptS1GtyAoI7DZKNRZR6o+8OlDRFbsGkV4S/rw7WzwykiFNClGbhaIZT+VoPP8zeYHFxkTZS5MrJoTeorrOcmgWcw3D+LTVIS6XMEidFvZxo7XWP358l1GtCoL63E0u9p0+fps9a4S4zw2F4XWJsnA0zeixamRvlDcTk9AinjIp6zSG0vumBod4Qi8izyurBR2POet8QXF6ZjlHIjJf0R0eu/HO9qVqhv9RLW15i3GavsgoFryipfKggRb0mWqufqBNwrn+GeqNdSj1wbPqWp15RJKM5ZjiVL7P0w+zNw0W05SVX3mA9J9Mi09gs4CxZVxJwJnXNsG+UeuXVs/qBXeF7oV7qsI/tydcJf6UGSarZ8iiorZGJN0SJ1sAvrD1fegN58eKFUQb2Aynq5VuzhpRQr+mtea73wFBvGM7Eodm5cOGCH7yJFJlZ85tUlmsD6tX9AfW2R/l7s+Vrnqs0tP/iW+grVOXo0aP5gLMhfh8wNIbt/91Ninqlohl7dDiZx/+jw9wPSU4WzDa37q7X/Hcjfdbrs6AFnnr1qYQ+4pX/MNibgHNjiP9kx84XMxkS8jX62pnoVtUbiHYpVIVfwDJC6tXHyRNBvQAAAB3AvAeqHNElkUmzSi2bDPUa12levsEN4p8G9jtZoRuAegEA2H/of1ZT+fZmgbCp3zmlMpzNWx009Zq0gOBiyLxpw64X1NseoF4AAHqIyud6GUy9t27d8lk2QAqg3vYA9QIAAAA1AOptD1AvAAAAUAOg3vYA9QIAAABApwD1AgAAAECnAPUCAAAAQKcA9QIAAABApwD1AgAAAECn+ANgDRm+pfWAqwAAAABJRU5ErkJggg==" alt="./images"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>PortalServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>cn.kirklin.servlet.PortalServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>PortalServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/index.html<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="创建ModelBaseServlet"><a href="#创建ModelBaseServlet" class="headerlink" title="创建ModelBaseServlet"></a>创建ModelBaseServlet</h3><p>这个类和Thymeleaf没有直接关系，我们使用这个基类，是为了避免每处理一个请求就创建一个Servlet。继承了ModelBaseServlet之后，就可以把同一个模块内处理各个请求的方法集中到同一个Servlet中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelBaseServlet</span> <span class="keyword">extends</span> <span class="title">ViewBaseServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在doGet()方法中调用doPost()方法，这样就可以在doPost()方法中集中处理所有请求</span></span><br><span class="line">        doPost(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0.在所有request.getParameter()前面设置解析请求体的字符集</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.从请求参数中获取method对应的数据</span></span><br><span class="line">        String method = request.getParameter(<span class="string">&quot;method&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.通过反射调用method对应的方法</span></span><br><span class="line">        <span class="comment">// ①获取Class对象</span></span><br><span class="line">        Class&lt;? extends ModelBaseServlet&gt; clazz = <span class="keyword">this</span>.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// ②获取method对应的Method对象</span></span><br><span class="line">            Method methodObject = clazz.getDeclaredMethod(method, HttpServletRequest.class, HttpServletResponse.class);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ③打开访问权限</span></span><br><span class="line">            methodObject.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ④通过Method对象调用目标方法</span></span><br><span class="line">            methodObject.invoke(<span class="keyword">this</span>, request, response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="各个Servlet之间的继承关系"><a href="#各个Servlet之间的继承关系" class="headerlink" title="各个Servlet之间的继承关系"></a>各个Servlet之间的继承关系</h3><p><img src="./assets/Thymeleaf/InheritanceRelationship.png" alt="./images"></p>
<h2 id="Thymeleaf页面th名称空间"><a href="#Thymeleaf页面th名称空间" class="headerlink" title="Thymeleaf页面th名称空间"></a>Thymeleaf页面th名称空间</h2><p><img src="./assets/Thymeleaf/thNameSpace.png" alt="./images"></p>
<h2 id="Thymeleaf语法"><a href="#Thymeleaf语法" class="headerlink" title="Thymeleaf语法"></a>Thymeleaf语法</h2><h3 id="th-xxx"><a href="#th-xxx" class="headerlink" title="th:xxx"></a>th:xxx</h3><table>
<thead>
<tr>
<th>属性名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>th:text</td>
<td>使用表达式设置文本标签体的数据</td>
</tr>
<tr>
<td>th:属性名</td>
<td>使用表达式运算得到的值设置HTML属性</td>
</tr>
<tr>
<td>th:if/th:unless</td>
<td>分支判断</td>
</tr>
<tr>
<td>th:each</td>
<td>迭代</td>
</tr>
</tbody></table>
<h3 id="直接写表达式"><a href="#直接写表达式" class="headerlink" title="直接写表达式"></a>直接写表达式</h3><ul>
<li>有转义效果：[[${表达式}]]</li>
<li>无转义效果：[(${表达式})]</li>
</ul>
<h3 id="表达式的类型"><a href="#表达式的类型" class="headerlink" title="表达式的类型"></a>表达式的类型</h3><ul>
<li>@{}：给传入的字符串前面附加<strong>『上下文路径』</strong></li>
<li>${}：解析OGNL表达式</li>
</ul>
<h3 id="OGNL表达式"><a href="#OGNL表达式" class="headerlink" title="OGNL表达式"></a>OGNL表达式</h3><p>OGNL：Objects-Graph Navigation Language对象图导航语言</p>
<h4 id="起点"><a href="#起点" class="headerlink" title="起点"></a>起点</h4><table>
<thead>
<tr>
<th>表达式起点描述</th>
<th>作用</th>
<th>参考</th>
</tr>
</thead>
<tbody><tr>
<td>请求域属性名</td>
<td>根据属性名从请求域取出数据</td>
<td></td>
</tr>
<tr>
<td>session</td>
<td>访问session域</td>
<td></td>
</tr>
<tr>
<td>application</td>
<td>访问application域</td>
<td></td>
</tr>
<tr>
<td>param</td>
<td>读取请求参数</td>
<td></td>
</tr>
<tr>
<td>#strings</td>
<td>执行字符串的相关处理</td>
<td>org.thymeleaf.expression.Strings</td>
</tr>
<tr>
<td>#lists</td>
<td>执行集合相关的处理</td>
<td>org.thymeleaf.expression.Lists</td>
</tr>
<tr>
<td>#request</td>
<td>原生的request对象</td>
<td></td>
</tr>
<tr>
<td>#response</td>
<td>原生的response对象</td>
<td></td>
</tr>
<tr>
<td>#session</td>
<td>原生的session对象</td>
<td></td>
</tr>
<tr>
<td>#servletContext</td>
<td>原生的ServletContext对象</td>
<td></td>
</tr>
</tbody></table>
<h4 id="访问具体属性语法"><a href="#访问具体属性语法" class="headerlink" title="访问具体属性语法"></a>访问具体属性语法</h4><table>
<thead>
<tr>
<th>对象类型</th>
<th>访问方式</th>
</tr>
</thead>
<tbody><tr>
<td>普通对象包含使用getXxx()、setXxx()定义的属性</td>
<td>对象.属性名</td>
</tr>
<tr>
<td>List集合</td>
<td>[index]</td>
</tr>
<tr>
<td>数组</td>
<td>[下标]</td>
</tr>
<tr>
<td>Map集合</td>
<td>map.key</td>
</tr>
<tr>
<td>有方法的对象</td>
<td>对象.方法() 对象.方法(参数列表)</td>
</tr>
</tbody></table>
<h3 id="包含代码片段页面"><a href="#包含代码片段页面" class="headerlink" title="包含代码片段页面"></a>包含代码片段页面</h3><h4 id="声明代码片段"><a href="#声明代码片段" class="headerlink" title="声明代码片段"></a>声明代码片段</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用th:fragment属性给代码片段命名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:fragment</span>=<span class="string">&quot;navigator&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;BookManagerServlet?method=showBookList&quot;</span> <span class="attr">class</span>=<span class="string">&quot;order&quot;</span>&gt;</span>图书管理<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;order_manager.html&quot;</span> <span class="attr">class</span>=<span class="string">&quot;destory&quot;</span>&gt;</span>订单管理<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;index.html&quot;</span> <span class="attr">class</span>=<span class="string">&quot;gohome&quot;</span>&gt;</span>返回商城<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="引入代码片段"><a href="#引入代码片段" class="headerlink" title="引入代码片段"></a>引入代码片段</h4><table>
<thead>
<tr>
<th>引入方式</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>th:insert=”segment/admin-navigator :: navigator”</td>
<td>把目标代码片段整体包含到当前标签内部</td>
</tr>
<tr>
<td>th:include=”segment/admin-navigator :: navigator”</td>
<td>把目标代码片段内部的内容包含到当前标签内</td>
</tr>
<tr>
<td>th:replace=”segment/admin-navigator :: navigator”</td>
<td>使用目标代码片段替换当前标签</td>
</tr>
</tbody></table>
<p>segment/admin-navigator代表目标代码片段的逻辑视图。</p>
<p>navigator代表目标代码片段中使用th:fragment指定的名称。</p>
<h2 id="视图名称"><a href="#视图名称" class="headerlink" title="视图名称"></a>视图名称</h2><h3 id="物理视图"><a href="#物理视图" class="headerlink" title="物理视图"></a>物理视图</h3><p>能够将请求转发到目标页面时使用的完整路径。</p>
<blockquote>
<p>/WEB-INF/view/hello.html</p>
</blockquote>
<h3 id="逻辑视图"><a href="#逻辑视图" class="headerlink" title="逻辑视图"></a>逻辑视图</h3><p>物理视图=前缀+逻辑视图+后缀</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>docker必知必会</title>
    <url>/2023/12/05/docker%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</url>
    <content><![CDATA[<h1 id="docker心得体会"><a href="#docker心得体会" class="headerlink" title="docker心得体会"></a>docker心得体会</h1><p><strong>==并不是笔记，而是针对自己需要记忆的东西，留下痕迹。一定要学会 好好用==</strong></p>
<ul>
<li><p>docker所解决的问题如下<img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650710800911.png" alt="1650710800911"></p>
</li>
<li><p>docker火的原因是十分的轻巧    docker是容器化技术</p>
</li>
<li><p>docker是基于go语言开发的</p>
</li>
<li><p><a href="https://docs.docker.com/">Docker Documentation | Docker Documentation</a>  docker的文档非常详细<br><a href="https://hub.docker.com/">Docker Hub</a> docker的仓库地址</p>
</li>
<li><p>Docker如果是安在阿里云服务器上的话  还可以配置镜像加速</p>
</li>
<li><p>Docker Run的原理示意图<img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650761222173.png" alt="1650761222173"></p>
</li>
<li><p>启动Docker指令 systemctl start docker     运行Docker指令 docker run XXX</p>
</li>
<li><p>底层原理<img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650761599658.png" alt="1650761599658"></p>
</li>
<li><p><strong>==Docker常用的命令（其余不多记 直接看笔记）==</strong><br><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650762106989.png" alt="1650762106989"><br><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650763449482.png" alt="1650763449482"><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650763706514.png" alt="1650763706514"><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650764125304.png" alt="1650764125304"><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650764160903.png" alt="1650764160903"></p>
<p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650764826238.png" alt="1650764826238"></p>
<p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650765225083.png" alt="1650765225083"></p>
<p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650765543807.png" alt="1650765543807"><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650766287438.png" alt="1650766287438"></p>
</li>
</ul>
<p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650766233160.png" alt="1650766233160"></p>
<p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650766601382.png" alt="1650766601382"></p>
<p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650766891690.png" alt="1650766891690"></p>
<p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650785841816.png" alt="1650785841816"></p>
<p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650785939799.png" alt="1650785939799"><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650785976455.png" alt="1650785976455"></p>
<p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650786128934.png" alt="1650786128934"></p>
<p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650786495145.png" alt="1650786495145"></p>
<p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650786729761.png" alt="1650786729761"></p>
<p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650786773454.png" alt="1650786773454"></p>
<p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650787381577.png" alt="1650787381577"></p>
<p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650787408191.png" alt="1650787408191"></p>
<p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650852477454.png" alt="1650852477454"></p>
<p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650852452286.png" alt="1650852452286"></p>
<p>打包后的就是类似于这样，类似虚拟机的快照</p>
<p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650852724189.png" alt="1650852724189"></p>
<p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650787553171.png" alt="1650787553171"></p>
<ul>
<li><p>docker images -q显示镜像id    dockers images -aq 显示所有镜像id 有些隐藏的镜像也可以显示</p>
</li>
<li><p>Docker下载镜像采用的是分层下载  如果你下载一个镜像 他一些层级已经被下载过了  他就可以共用而不用下载了</p>
</li>
<li><p>markdown的使用小技巧  ```+编程语言会创建代码段</p>
</li>
<li><p>docker run -d XXX  默认是执行/bin/bash这个命令在后台启动成功后执行了就直接关闭了，如果要持久化的话  要指定一个持久的命令</p>
</li>
<li><p>touch用来新建文件 mkdir用来新建文件夹  rm用来删除文件 </p>
</li>
<li><p>当下载一个新的镜像时  可以去dockerHub上查看关注文档</p>
</li>
<li><p>Linux命令 whereis<br>-b 　只查找二进制文件。</p>
<p>-B&lt;目录&gt; 　只在设置的目录下查找二进制文件。</p>
<p>-f 　不显示文件名前的路径名称。</p>
<p>-m 　只查找说明文件。</p>
<p>-M&lt;目录&gt; 　只在设置的目录下查找说明文件。</p>
<p>-s 　只查找原始代码文件。</p>
<p>-S&lt;目录&gt; 　只在设置的目录下查找原始代码文件。</p>
<p>-u 　查找不包含指定类型的文件。</p>
</li>
<li><p>用完后会自动移除 而不是还存在<img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650794874103.png" alt="1650794874103"></p>
</li>
<li><p>像这些镜像其实很大程度都是被阉割过的 保证最小运行就行  就比如说tomcat webapp里没东西  其实在webapp.dist中有  把它复制过来就行了</p>
</li>
<li><p>镜像分层的理解  如果加一层是之前那层的更新 会进行替换     拉取镜像的时候 已经存在的就不会再拉了<img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650850692165.png" alt="1650850692165"></p>
</li>
<li><p>镜像都是只读的  当我们镜像启动容器的时候  会有个新的可写层加到镜像层的顶部，这一层我们可以进行操作 这层通常来说叫做容器层  我们所有的操作都是基于容器层的  我做的修改什么的会保存在容器层</p>
</li>
<li><p>docker -p 可以设置要映射的端口和容器端口  一个端口上只能绑定一个容器</p>
</li>
<li><p>卷技术，就是容器目录的挂载，容器间的数据共享机制    目的就是容器的持久化和同步操作、容器间数据共享</p>
<p>映射过后  对容器内部的文件进行操作 会自动同步到外部 对外部进行操作 会自动同步到容器内部（就算是容器停止运行了  也会同步）  <strong>好处：我们以后修改直接在本地修改即可，容器内部会自动同步</strong></p>
</li>
<li><p>==卷技术的使用 <strong>指令</strong>==</p>
<p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650853968342.png" alt="1650853968342"></p>
<p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650861186878.png" alt="1650861186878"></p>
<p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650862630616.png" alt="1650862630616"></p>
<p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650863101402.png" alt="1650863101402"></p>
<p><code>也可以使用dockerfile进行挂载</code><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650863902597.png" alt="1650863902597"></p>
<p><code>容器间的挂载:--volumes-from </code> 拷贝的概念</p>
<p>当两个挂载一到一个上面的时候  相当于全部都挂载上了  就算把挂载的那个对象删了  其他两个照样同步</p>
<p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650867175134.png" alt="1650867175134"></p>
</li>
<li><p>当我拉取mysql镜像的时候，拉了mysql8版本太高 读取需要些插件  换成5.7就可以了 </p>
</li>
<li><p>docker启动mysql需要做的</p>
<p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650860312511.png" alt="1650860312511"></p>
</li>
<li><p>有些镜像启动需要配置环境  -e   需要去docker hub上看帮助文档进行测试</p>
</li>
<li><p>就算在本地把对应的容器删了   但你容器中挂载出来的文件还是会存在 数据并不会丢失</p>
</li>
<li><p>图床指的是存储图片的服务器</p>
</li>
<li><p>如果要查看docker挂载的对应目录在哪  用docker inspect 容器id  查看具体信息  在mounts看到挂载的信息 可以找到对应的目录</p>
</li>
<li><p>通过dockerfile 挂载卷  如果容器内没有对应的文件夹 也会自动生成  如果没有挂载卷 那么之后就要以手动的方式 -v挂载卷</p>
</li>
<li><p>==<strong>DockFile指令</strong>==</p>
<p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650868496106.png" alt="1650868496106"></p>
<p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650868508792.png" alt="1650868508792"></p>
</li>
<li><p>例子什么的 在最全笔记中看</p>
</li>
<li><p>yum -y中 -y的意思就是代替手动输入yes</p>
</li>
<li><p>$符号在Linux的shell中使用 作用就是获取一个变量的值</p>
</li>
<li><p>docker build -f 指定要使用dockerfile的路径</p>
</li>
<li><p>docker build -f zytdockfile-centos -t mycentos:0.1 ==.==  这个点的意思就是目的地址为当前地址 构建这个镜像在这个目的地址    </p>
</li>
<li><p>CMD ENTRYPOINT的区别<br><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650871228569.png" alt="1650871228569"><br><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650872614684.png" alt="1650872614684"></p>
<p>在CMD命令下 如果运行时追加参数  会将CMD的命令进行替换   比如说 CMD里是 ls -a  我们在外面写个-l  会报错  除非我们些的是 ls -al 就不报错  因为会被替换</p>
</li>
<li><p>实战Tomcat这是精髓一定要好好看，之后自己有机会发布镜像的时候  模仿这个进行构建</p>
</li>
<li><p>构建dockerfile采用官方命名<code>Dockerfile</code>这样build的时候 都不需要指定-f了 会自动去寻找  直接 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t &quot;name&quot; #即可 会自动去寻找Dockerfile</span><br></pre></td></tr></table></figure></li>
<li><p>WORKDIR 是进去的第一个落脚点      ENV 就是设置环境变量</p>
</li>
<li><p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650874256508.png" alt="1650874256508"><br><code>设置PATH变量是为了让操作系统找到指定的工具程序，那么设置CLASSPATH变量的目的就是让执行环境找到程序对应的class文件以及程序中引用的其他class文件</code></p>
</li>
<li><p>javaweb生成项目后默认的其实页是index.jsp和index.html</p>
</li>
<li><p>tomcat是热部署的</p>
</li>
<li><p>自己push的镜像一定要带版本号     使用 docker tag 给镜像附上版本也可以一开始取名的时候就附上   前面一定是要自己<code>docker hub的用户名</code>/镜像名：版本号！</p>
</li>
<li><p>除了推送到docker hub还有推送到阿里云上，阿里云推送有固定的方法</p>
</li>
<li><p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650935337032.png" alt="1650935337032"></p>
</li>
<li><p><code>Docker 网络</code></p>
</li>
<li><p>容器和容器之间是可以互相ping通的</p>
</li>
<li><p>容器和容器之间联通实际上是通过路由器相接    删掉对应的容器 网卡就会消失<img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650939538442.png" alt="1650939538442"><br><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650939727074.png" alt="1650939727074"></p>
</li>
<li><p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650939832717.png" alt="1650939832717"></p>
</li>
<li><p>通过服务名直接ping通  不用ip地址  这样有助于当我们对应的服务器ip地址进行更换 不用重启 修改</p>
</li>
<li><p>“hosts文件是一个用于储存计算机网络中各节点信息的计算机文件；作用是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址。”  所以很多代理映射都放到这里面   <code>docker中--link的操作就是在hosts配置中加了一个映射</code>  目前已经不建议使用–link了  而是使用自定义网络 不适用docker0  因为docker0不支持服务名访问</p>
</li>
<li><p><strong>网络模式</strong></p>
<ul>
<li>bridge  :  桥接 docker(默认，自己创建也使用桥接模式)</li>
<li>none    :  不配置网络</li>
<li>host     :   和宿主机共享网络</li>
<li>container :   容器网络连同！(用的少！局限大)</li>
</ul>
</li>
<li><p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650941422023.png" alt="1650941422023"><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650941385208.png" alt="1650941385208"><br>直接启动 它会默认连接docker0   我们想用自己网络的话  可以创建一个网络  按照上面的方法启动</p>
<ul>
<li>docker0特点：默认，域名不能访问  能通过–link打通连接   有局限性</li>
<li>所以我们可以自定义网络</li>
</ul>
</li>
<li><p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650941832117.png" alt="1650941832117"><br>自定义网络可以直接ping 名字</p>
</li>
<li><p><strong>网络联通   在不同网段中的容器是无法联通的</strong></p>
<p><img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\1650946676275.png" alt="1650946676275"></p>
<p>联通了之后可以在对应的network inspect中看到    这就是一个容器 多个ip地址</p>
<p><code>假如要跨网络操作别人，就需要使用 docker network connect联通</code></p>
</li>
<li><p>创建集群  看狂神笔记  玩玩看</p>
</li>
<li><p>网关是实现不同网络之间的通信  像仅仅是搭建redis集群 可以不设置网关</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>会话控制</title>
    <url>/2023/08/16/%E4%BC%9A%E8%AF%9D%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="会话控制笔记"><a href="#会话控制笔记" class="headerlink" title="会话控制笔记"></a>会话控制笔记</h1><h2 id="1、核心代码"><a href="#1、核心代码" class="headerlink" title="1、核心代码"></a>1、核心代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpSession session = request.getSession();</span><br><span class="line">session.setAttribute(<span class="string">&quot;属性名&quot;</span>,<span class="string">&quot;属性值&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="2、Cookie的工作机制"><a href="#2、Cookie的工作机制" class="headerlink" title="2、Cookie的工作机制"></a>2、Cookie的工作机制</h2><ul>
<li>Cookie信息是在服务器创建的</li>
<li>Cookie在服务器端被放在响应数据中返回给浏览器</li>
<li>浏览器接收到Cookie后，会把Cookie保存起来</li>
<li>浏览器保存了Cookie后每一个请求都会把路径匹配的Cookie带上</li>
</ul>
<h2 id="3、Cookie的时效性"><a href="#3、Cookie的时效性" class="headerlink" title="3、Cookie的时效性"></a>3、Cookie的时效性</h2><ul>
<li>会话级Cookie：默认情况<ul>
<li>保存在浏览器的内存里，在浏览器关闭时会被释放</li>
</ul>
</li>
<li>持久化Cookie：<ul>
<li>服务器端调用Cookie的setMaxAge(以秒为单位的存活时间)方法<ul>
<li>存活时间正数：还能够存活的秒数</li>
<li>存活时间为零：告诉浏览器立即删除这个Cookie</li>
<li>存活时间为负：告诉浏览器这个Cookie是一个会话级Cookie</li>
</ul>
</li>
<li>服务器把这个Cookie返回给浏览器时就等于通知浏览器：这个Cookie还能存在多长时间</li>
</ul>
</li>
</ul>
<h2 id="4、Cookie的路径"><a href="#4、Cookie的路径" class="headerlink" title="4、Cookie的路径"></a>4、Cookie的路径</h2><ul>
<li>每个Cookie都有domain和path这样的两个属性<ul>
<li>domain：表示这个Cookie属于哪个网站，通常以域名为值</li>
<li>path：表示这个Cookie属于网站下的哪一个具体的资源</li>
</ul>
</li>
<li>实际开发中Cookie路径的影响：如果不小心在路径中某个地方多加了一个斜杠，会导致Cookie路径不匹配，该携带的Cookie携带不上来，从而导致Session工作不正常。</li>
</ul>
<h2 id="5、Session的工作机制"><a href="#5、Session的工作机制" class="headerlink" title="5、Session的工作机制"></a>5、Session的工作机制</h2><ul>
<li>当服务器端调用了request.getSession()方法<ul>
<li>检查当前请求中是否携带了JSESSIONID这个Cookie<ul>
<li>有携带：根据这个JSESSIONID在服务器端查找对应的Session对象<ul>
<li>能找到：把找到的Session作为getSession()方法的返回值返回</li>
<li>找不到：<ul>
<li>创建新的Session对象</li>
<li>用新的JSESSIONID的值创建Cookie</li>
<li>把新的Cookie返回给浏览器</li>
</ul>
</li>
</ul>
</li>
<li>没携带：<ul>
<li>创建新的Session对象</li>
<li>用新的JSESSIONID的值创建Cookie</li>
<li>把新的Cookie返回给浏览器</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="assets/%E4%BC%9A%E8%AF%9D%E6%8E%A7%E5%88%B6/session.png" alt="./images"></p>
<h2 id="6、Session的时效性"><a href="#6、Session的时效性" class="headerlink" title="6、Session的时效性"></a>6、Session的时效性</h2><h3 id="Session对象为什么要有时效限制？"><a href="#Session对象为什么要有时效限制？" class="headerlink" title="Session对象为什么要有时效限制？"></a>Session对象为什么要有时效限制？</h3><p>如果没有时间限制，Session对象数量会快速膨胀，随着访问网站的用户越来越多，Session对象只创建不释放，一定会在某个时间耗尽服务器端的资源。</p>
<h3 id="Session时效性机制"><a href="#Session时效性机制" class="headerlink" title="Session时效性机制"></a>Session时效性机制</h3><p>这个机制的设计很巧妙，它是一个柔性的机制，既避免Session对象无节制的创建耗尽服务器端内存空间，又保证了用户在持续使用Session时Session对象一直都在，不会打断用户的操作。</p>
<ul>
<li>每一个Session对象从创建出来就开始倒计时</li>
<li>在倒计时的过程中，一旦有请求访问了这个Session，倒计时清零重新开始</li>
<li>一旦一个Session对象的倒计时结束，那么这个Session对象就会被释放</li>
</ul>
<h3 id="Session时效性方法"><a href="#Session时效性方法" class="headerlink" title="Session时效性方法"></a>Session时效性方法</h3><ul>
<li>setMaxInactiveInterval(int interval)设置Session最大的过期时间，interval是一个以秒为单位的过期时间。</li>
<li>最大空闲时间默认为1800秒，即半个小时。</li>
<li>**invalidate()**立即释放Session对象</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat</title>
    <url>/2024/03/15/Tomcat/</url>
    <content><![CDATA[<h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><h4 id="1-Tomcat的缺省端口是多少，怎么修改？"><a href="#1-Tomcat的缺省端口是多少，怎么修改？" class="headerlink" title="1.Tomcat的缺省端口是多少，怎么修改？"></a>1.Tomcat的缺省端口是多少，怎么修改？</h4><p>1）找到Tomcat目录下的conf文件夹</p>
<p>2）进入conf文件夹里面找到server.xml文件</p>
<p>3）打开server.xml文件</p>
<p>4）在server.xml文件里面找到下列信息</p>
<Connector connectionTimeout="20000" port="8080" protocol="HTTP/1.1" redirectPort="8443" uriEncoding="utf-8"/>
port="8080"改成你想要的端口

<h4 id="2-tomcat-有哪几种Connector-运行模式-优化-？"><a href="#2-tomcat-有哪几种Connector-运行模式-优化-？" class="headerlink" title="2.tomcat 有哪几种Connector 运行模式(优化)？"></a>2.tomcat 有哪几种Connector 运行模式(优化)？</h4><p>bio：传统的Java I/O操作，同步且阻塞IO。<br>maxThreads=”150”//Tomcat使用线程来处理接收的每个请求。这个值表示Tomcat可创建的最大的线程数。默认值200。可以根据机器的时期性能和内存大小调整，一般可以在400-500。最大可以在800左右。<br>minSpareThreads=”25”—Tomcat初始化时创建的线程数。默认值4。如果当前没有空闲线程，且没有超过maxThreads，一次性创建的空闲线程数量。Tomcat初始化时创建的线程数量也由此值设置。<br>maxSpareThreads=”75”–一旦创建的线程超过这个值，Tomcat就会关闭不再需要的socket线程。默认值50。一旦创建的线程超过此数值，Tomcat会关闭不再需要的线程。线程数可以大致上用 “同时在线人数<em>每秒用户操作次数</em>系统平均操作时间” 来计算。<br>acceptCount=”100”—-指定当所有可以使用的处理请求的线程数都被使用时，可以放到处理队列中的请求数，超过这个数的请求将不予处理。默认值10。如果当前可用线程数为0，则将请求放入处理队列中。这个值限定了请求队列的大小，超过这个数值的请求将不予处理。<br>connectionTimeout=”20000” –网络连接超时，默认值20000，单位：毫秒。设置为0表示永不超时，这样设置有隐患的。通常可设置为30000毫秒。 </p>
<p>nio：JDK1.4开始支持，同步阻塞或同步非阻塞IO。<br>指定使用NIO模型来接受HTTP请求<br>protocol=”org.apache.coyote.http11.Http11NioProtocol” 指定使用NIO模型来接受HTTP请求。默认是BlockingIO，配置为protocol=”HTTP/1.1”<br>acceptorThreadCount=”2” 使用NIO模型时接收线程的数目 </p>
<p>aio(nio.2)：JDK7开始支持，异步非阻塞IO。</p>
<p>apr：Tomcat将以JNI的形式调用Apache HTTP服务器的核心动态链接库来处理文件读取或网络传输操作，从而大大地 提高Tomcat对静态文件的处理性能。</p>
<!--
      <Connector connectionTimeout="20000" port="8000" protocol="HTTP/1.1" redirectPort="8443" uriEncoding="utf-8"/>
    -->
<pre><code>&lt;!-- protocol 启用 nio模式，(tomcat8默认使用的是nio)(apr模式利用系统级异步io) --&gt;
&lt;!-- minProcessors最小空闲连接线程数--&gt;
&lt;!-- maxProcessors最大连接线程数--&gt;
&lt;!-- acceptCount允许的最大连接数，应大于等于maxProcessors--&gt;
&lt;!-- enableLookups 如果为true,requst.getRemoteHost会执行DNS查找，反向解析ip对应域名或主机名--&gt;
&lt;Connector port=&quot;8080&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; 
    connectionTimeout=&quot;20000&quot;
    redirectPort=&quot;8443
    maxThreads=“500” 
    minSpareThreads=“100” 
    maxSpareThreads=“200”
    acceptCount=&quot;200&quot;
    enableLookups=&quot;false&quot;       
/&gt;
</code></pre>
<p>其他配置</p>
<p>maxHttpHeaderSize=”8192” http请求头信息的最大程度，超过此长度的部分不予处理。一般8K。<br>URIEncoding=”UTF-8” 指定Tomcat容器的URL编码格式。<br>disableUploadTimeout=”true” 上传时是否使用超时机制<br>enableLookups=”false”–是否反查域名，默认值为true。为了提高处理能力，应设置为false<br>compression=”on”   打开压缩功能<br>compressionMinSize=”10240” 启用压缩的输出内容大小，默认为2KB<br>noCompressionUserAgents=”gozilla, traviata”   对于以下的浏览器，不启用压缩<br>compressableMimeType=”text/html,text/xml,text/javascript,text/css,text/plain” 哪些资源类型需要压缩 </p>
<h4 id="3-Tomcat有几种部署方式？"><a href="#3-Tomcat有几种部署方式？" class="headerlink" title="3.Tomcat有几种部署方式？"></a>3.Tomcat有几种部署方式？</h4><p>1）直接把Web项目放在webapps下，Tomcat会自动将其部署</p>
<p>2）在server.xml文件上配置<Context>节点，设置相关的属性即可</p>
<p>3）通过Catalina来进行配置:进入到conf\Catalina\localhost文件下，创建一个xml文件，该文件的名字就是站点的名字。</p>
<p>编写XML的方式来进行设置。</p>
<h4 id="4-tomcat容器是如何创建servlet类实例？用到了什么原理？"><a href="#4-tomcat容器是如何创建servlet类实例？用到了什么原理？" class="headerlink" title="4.tomcat容器是如何创建servlet类实例？用到了什么原理？"></a>4.tomcat容器是如何创建servlet类实例？用到了什么原理？</h4><p>当容器启动时，会读取在webapps目录下所有的web应用中的web.xml文件，然后对xml文件进行解析，</p>
<p>并读取servlet注册信息。然后，将每个应用中注册的servlet类都进行加载，并通过反射的方式实例化。</p>
<p>（有时候也是在第一次请求时实例化）在servlet注册时加上如果为正数，则在一开始就实例化，</p>
<p>如果不写或为负数，则第一次请求实例化。</p>
<h4 id="5-tomcat-如何优化？"><a href="#5-tomcat-如何优化？" class="headerlink" title="5.tomcat 如何优化？"></a>5.tomcat 如何优化？</h4><p>1、优化连接配置.这里以tomcat7的参数配置为例，需要修改conf/server.xml文件，修改连接数，关闭客户端dns查询。</p>
<p>参数解释：</p>
<p>URIEncoding=”UTF-8″ :使得tomcat可以解析含有中文名的文件的url，真方便，不像apache里还有搞个mod_encoding，还要手工编译</p>
<p>maxSpareThreads : 如果空闲状态的线程数多于设置的数目，则将这些线程中止，减少这个池中的线程总数。</p>
<p>minSpareThreads : 最小备用线程数，tomcat启动时的初始化的线程数。</p>
<p>enableLookups : 这个功效和Apache中的HostnameLookups一样，设为关闭。</p>
<p>connectionTimeout : connectionTimeout为网络连接超时时间毫秒数。</p>
<p>maxThreads : maxThreads Tomcat使用线程来处理接收的每个请求。这个值表示Tomcat可创建的最大的线程数，即最大并发数。</p>
<p>acceptCount : acceptCount是当线程数达到maxThreads后，后续请求会被放入一个等待队列，这个acceptCount是这个队列的大小，如果这个队列也满了，就直接refuse connection</p>
<p>maxProcessors与minProcessors : 在 Java中线程是程序运行时的路径，是在一个程序中与其它控制线程无关的、能够独立运行的代码段。它们共享相同的地址空间。多线程帮助程序员写出CPU最 大利用率的高效程序，使空闲时间保持最低，从而接受更多的请求。</p>
<p>通常Windows是1000个左右，Linux是2000个左右。</p>
<p>useURIValidationHack:</p>
<p>我们来看一下tomcat中的一段源码：</p>
<p>【security】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (connector.getUseURIValidationHack()) &#123;</span><br><span class="line"></span><br><span class="line">String uri &#x3D; validate(request.getRequestURI());</span><br><span class="line"></span><br><span class="line">if (uri &#x3D;&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">res.setStatus(400);</span><br><span class="line"></span><br><span class="line">res.setMessage(“Invalid URI”);</span><br><span class="line"></span><br><span class="line">throw new IOException(“Invalid URI”);</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">req.requestURI().setString(uri);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Redoing the URI decoding</span><br><span class="line"></span><br><span class="line">req.decodedURI().duplicate(req.requestURI());</span><br><span class="line"></span><br><span class="line">req.getURLDecoder().convert(req.decodedURI(), true);</span><br></pre></td></tr></table></figure>

<p>可以看到如果把useURIValidationHack设成”false”，可以减少它对一些url的不必要的检查从而减省开销。</p>
<p>enableLookups=”false” ： 为了消除DNS查询对性能的影响我们可以关闭DNS查询，方式是修改server.xml文件中的enableLookups参数值。</p>
<p>disableUploadTimeout ：类似于Apache中的keeyalive一样</p>
<p>给Tomcat配置gzip压缩(HTTP压缩)功能</p>
<p>compression=”on” compressionMinSize=”2048″</p>
<p>compressableMimeType=”text/html,text/xml,text/JavaScript,text/css,text/plain”</p>
<p>HTTP 压缩可以大大提高浏览网站的速度，它的原理是，在客户端请求网页后，从服务器端将网页文件压缩，再下载到客户端，由客户端的浏览器负责解压缩并浏览。相对于普通的浏览过程HTML,CSS,javascript , Text ，它可以节省40%左右的流量。更为重要的是，它可以对动态生成的，包括CGI、PHP , JSP , ASP , Servlet,SHTML等输出的网页也能进行压缩，压缩效率惊人。</p>
<p>1)compression=”on” 打开压缩功能</p>
<p>2)compressionMinSize=”2048″ 启用压缩的输出内容大小，这里面默认为2KB</p>
<p>3)noCompressionUserAgents=”gozilla, traviata” 对于以下的浏览器，不启用压缩</p>
<p>4)compressableMimeType=”text/html,text/xml”　压缩类型</p>
<p>最后不要忘了把8443端口的地方也加上同样的配置，因为如果我们走https协议的话，我们将会用到8443端口这个段的配置，对吧？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!–enable tomcat ssl–&gt;</span><br><span class="line"></span><br><span class="line">&lt;Connector port&#x3D;”8443″ protocol&#x3D;”HTTP&#x2F;1.1″</span><br><span class="line"></span><br><span class="line">URIEncoding&#x3D;”UTF-8″ minSpareThreads&#x3D;”25″ maxSpareThreads&#x3D;”75″</span><br><span class="line"></span><br><span class="line">enableLookups&#x3D;”false” disableUploadTimeout&#x3D;”true” connectionTimeout&#x3D;”20000″</span><br><span class="line"></span><br><span class="line">acceptCount&#x3D;”300″ maxThreads&#x3D;”300″ maxProcessors&#x3D;”1000″ minProcessors&#x3D;”5″</span><br><span class="line"></span><br><span class="line">useURIValidationHack&#x3D;”false”</span><br><span class="line"></span><br><span class="line">compression&#x3D;”on” compressionMinSize&#x3D;”2048″</span><br><span class="line"></span><br><span class="line">compressableMimeType&#x3D;”text&#x2F;html,text&#x2F;xml,text&#x2F;javascript,text&#x2F;css,text&#x2F;plain”</span><br><span class="line"></span><br><span class="line">SSLEnabled&#x3D;”true”</span><br><span class="line"></span><br><span class="line">scheme&#x3D;”https” secure&#x3D;”true”</span><br><span class="line"></span><br><span class="line">clientAuth&#x3D;”false” sslProtocol&#x3D;”TLS”</span><br><span class="line"></span><br><span class="line">keystoreFile&#x3D;”d:&#x2F;tomcat2&#x2F;conf&#x2F;shnlap93.jks” keystorePass&#x3D;”aaaaaa”</span><br><span class="line"></span><br><span class="line">&#x2F;&gt;</span><br></pre></td></tr></table></figure>



<h4 id="6-内存调优"><a href="#6-内存调优" class="headerlink" title="6.内存调优"></a>6.内存调优</h4><p>内存方式的设置是在catalina.sh中，调整一下JAVA_OPTS变量即可，因为后面的启动参数会把JAVA_OPTS作为JVM的启动参数来处理。<br>具体设置如下：<br>JAVA_OPTS=”$JAVA_OPTS -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4”<br>其各项参数如下：<br>-Xmx3550m：设置JVM最大可用内存为3550M。<br>-Xms3550m：设置JVM促使内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。<br>-Xmn2g：设置年轻代大小为2G。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。<br>-Xss128k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。<br>-XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5<br>-XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6<br>-XX:MaxPermSize=16m:设置持久代大小为16m。<br>-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。 </p>
<h4 id="7-垃圾回收策略调优"><a href="#7-垃圾回收策略调优" class="headerlink" title="7.垃圾回收策略调优"></a>7.垃圾回收策略调优</h4><p>垃圾回收的设置也是在catalina.sh中，调整JAVA_OPTS变量。<br>具体设置如下：<br>JAVA_OPTS=”$JAVA_OPTS -Xmx3550m -Xms3550m -Xss128k -XX:+UseParallelGC  -XX:MaxGCPauseMillis=100”<br>具体的垃圾回收策略及相应策略的各项参数如下：<br>串行收集器（JDK1.5以前主要的回收方式）<br>-XX:+UseSerialGC:设置串行收集器<br>并行收集器（吞吐量优先）<br>示例：<br>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC  -XX:MaxGCPauseMillis=100 </p>
<p>-XX:+UseParallelGC：选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。<br>-XX:ParallelGCThreads=20：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。<br>-XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集<br>-XX:MaxGCPauseMillis=100:设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。<br>-XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。<br>并发收集器（响应时间优先）<br>示例：java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC<br>-XX:+UseConcMarkSweepGC：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。<br>-XX:+UseParNewGC: 设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。<br>-XX:CMSFullGCsBeforeCompaction：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。 </p>
<h4 id="8-添加JMS远程监控"><a href="#8-添加JMS远程监控" class="headerlink" title="8.添加JMS远程监控"></a>8.添加JMS远程监控</h4><p>对于部署在局域网内其它机器上的Tomcat，可以打开JMX监控端口，局域网其它机器就可以通过这个端口查看一些常用的参数（但一些比较复杂的功能不支持），同样是在JVM启动参数中配置即可，配置如下：<br>-Dcom.sun.management.jmxremote.ssl=false  -Dcom.sun.management.jmxremote.authenticate=false<br>-Djava.rmi.server.hostname=192.168.71.38 设置JVM的JMS监控监听的IP地址，主要是为了防止错误的监听成127.0.0.1这个内网地址<br>-Dcom.sun.management.jmxremote.port=1090 设置JVM的JMS监控的端口<br>-Dcom.sun.management.jmxremote.ssl=false 设置JVM的JMS监控不实用SSL<br>-Dcom.sun.management.jmxremote.authenticate=false 设置JVM的JMS监控不需要认证</p>
<h4 id="9-专业点的分析工具有"><a href="#9-专业点的分析工具有" class="headerlink" title="9.专业点的分析工具有"></a>9.专业点的分析工具有</h4><p>IBM ISA，JProfiler、probe 等，具体监控及分析方式去网上搜索即可 </p>
<h4 id="10-关于Tomcat的session数目"><a href="#10-关于Tomcat的session数目" class="headerlink" title="10.关于Tomcat的session数目"></a>10.关于Tomcat的session数目</h4><p>这个可以直接从Tomcat的web管理界面去查看即可 ； 或者借助于第三方工具Lambda Probe来查看，它相对于Tomcat自带的管理稍微多了点功能，但也不多 ；</p>
<h4 id="11-监视Tomcat的内存使用情况"><a href="#11-监视Tomcat的内存使用情况" class="headerlink" title="11.监视Tomcat的内存使用情况"></a>11.监视Tomcat的内存使用情况</h4><p>使用JDK自带的jconsole可以比较明了的看到内存的使用情况，线程的状态，当前加载的类的总量等； JDK自带的jvisualvm可以下载插件（如GC等），可以查看更丰富的信息。如果是分析本地的Tomcat的话，还可以进行内存抽样等，检查每个类的使用情况</p>
<h4 id="12-打印类的加载情况及对象的回收情况"><a href="#12-打印类的加载情况及对象的回收情况" class="headerlink" title="12.打印类的加载情况及对象的回收情况"></a>12.打印类的加载情况及对象的回收情况</h4><p>这个可以通过配置JVM的启动参数，打印这些信息（到屏幕（默认也会到catalina.log中）或者文件），具体参数如下： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:+PrintGC：输出形式：[GC 118250K-&gt;113543K(130112K), 0.0094143 secs] [Full GC 121376K-&gt;10414K(130112K), 0.0650971 secs] </span><br><span class="line">-XX:+PrintGCDetails：输出形式：[GC [DefNew: 8614K-&gt;781K(9088K), 0.0123035 secs] 118250K-&gt;113543K(130112K), 0.0124633 secs] [GC [DefNew: 8614K-&gt;8614K(9088K), 0.0000665 secs][Tenured: 112761K-&gt;10414K(121024K), 0.0433488 secs] 121376K-&gt;10414K(130112K), 0.0436268 secs] </span><br><span class="line">-XX:+PrintGCTimeStamps -XX:+PrintGC：PrintGCTimeStamps可与上面两个混合使用，输出形式：11.851: [GC 98328K-&gt;93620K(130112K), 0.0082960 secs] </span><br><span class="line">-XX:+PrintGCApplicationConcurrentTime：打印每次垃圾回收前，程序未中断的执行时间。可与上面混合使用。输出形式：Application time: 0.5291524 seconds </span><br><span class="line">-XX:+PrintGCApplicationStoppedTime：打印垃圾回收期间程序暂停的时间。可与上面混合使用。输出形式：Total time for which application threads were stopped: 0.0468229 seconds </span><br><span class="line">-XX:PrintHeapAtGC: 打印GC前后的详细堆栈信息 </span><br><span class="line">-Xloggc:filename:与上面几个配合使用，把相关日志信息记录到文件以便分析 </span><br><span class="line">-verbose:class 监视加载的类的情况 </span><br><span class="line">-verbose:gc 在虚拟机发生内存回收时在输出设备显示信息 </span><br><span class="line">-verbose:jni 输出native方法调用的相关情况，一般用于诊断jni调用错误信息 </span><br></pre></td></tr></table></figure>

<h4 id="13-Tomcat一个请求的完整过程"><a href="#13-Tomcat一个请求的完整过程" class="headerlink" title="13.Tomcat一个请求的完整过程"></a>13.Tomcat一个请求的完整过程</h4><p>Ng:(nginx)</p>
<p>upstream yy_001{<br>        server 10.99.99.99:8080;<br>        server 10.99.99.100:8080; </p>
<pre><code>    hash $**; 

    healthcheck_enabled; 
    healthcheck_delay 3000; 
    healthcheck_timeout 1000; 
    healthcheck_failcount 2; 
    healthcheck_send &#39;GET /healthcheck.html HTTP/1.0&#39; &#39;Host: wo.com&#39; &#39;Connection: close&#39;; 
&#125;

 server &#123;
    include base.conf;
    server_name  wo.de.tian;
     ...
    location /yy/ &#123; 
        proxy_pass http://yy_001;
    &#125;
</code></pre>
<p>首先 dns 解析 wo.de.tian机器，一般是ng服务器ip地址<br>然后 ng根据server的配置，寻找路径为 yy/的机器列表，ip和端口<br>最后 选择其中一台机器进行访问—-&gt;下面为详细过程</p>
<ol>
<li>请求被发送到本机端口8080，被在那里侦听的Coyote HTTP/1.1 Connector获得 </li>
<li>Connector把该请求交给它所在的Service的Engine来处理，并等待来自Engine的回应 </li>
<li>Engine获得请求localhost/yy/index.jsp，匹配它所拥有的所有虚拟主机Host </li>
<li>Engine匹配到名为localhost的Host（即使匹配不到也把请求交给该Host处理，因为该Host被定义为该Engine的默认主机） </li>
<li>localhost Host获得请求/yy/index.jsp，匹配它所拥有的所有Context </li>
<li>Host匹配到路径为/yy的Context（如果匹配不到就把该请求交给路径名为”“的Context去处理） </li>
<li>path=”/yy”的Context获得请求/index.jsp，在它的mapping table中寻找对应的servlet </li>
<li>Context匹配到URL PATTERN为*.jsp的servlet，对应于JspServlet类 </li>
<li>构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用JspServlet的doGet或doPost方法 </li>
<li>Context把执行完了之后的HttpServletResponse对象返回给Host </li>
<li>Host把HttpServletResponse对象返回给Engine </li>
<li>Engine把HttpServletResponse对象返回给Connector </li>
<li>Connector把HttpServletResponse对象返回给客户browser</li>
</ol>
<h4 id="14-Tomcat工作模式？"><a href="#14-Tomcat工作模式？" class="headerlink" title="14.Tomcat工作模式？"></a>14.Tomcat工作模式？</h4><p>笔者回答：Tomcat是一个JSP/Servlet容器。其作为Servlet容器，有三种工作模式：独立的Servlet容器、进程内的Servlet容器和进程外的Servlet容器。</p>
<p>进入Tomcat的请求可以根据Tomcat的工作模式分为如下两类：</p>
<p>Tomcat作为应用程序服务器：请求来自于前端的web服务器，这可能是Apache, IIS, Nginx等；</p>
<p>Tomcat作为独立服务器：请求来自于web浏览器；</p>
<h4 id="15-tomcat结构目录有哪些"><a href="#15-tomcat结构目录有哪些" class="headerlink" title="15.tomcat结构目录有哪些?"></a>15.tomcat结构目录有哪些?</h4><p>①bin：启动和关闭tomcat的bat文件。</p>
<p>②conf：配置文件。</p>
<p>③server.xml该文件用于配置server相关的信息，比如tomcat启动的端口号，配置主机(Host)。</p>
<p>④web.xml文件配置与web应用(web应用相当于一个web站点)</p>
<p>⑤tomcat-user.xml配置用户名密码和相关权限。</p>
<p>⑥lib：该目录放置运行tomcat运行需要的jar包。</p>
<p>⑦logs：存放日志，当我们需要查看日志的时候，可以查询信息。</p>
<p>⑧webapps：放置我们的web应用。</p>
<p>⑨work工作目录：该目录用于存放jsp被访问后生成对应的server文件和.class文件。</p>
<h4 id="16-如何配置Tomcat虚拟目录"><a href="#16-如何配置Tomcat虚拟目录" class="headerlink" title="16.如何配置Tomcat虚拟目录?"></a>16.如何配置Tomcat虚拟目录?</h4><p>1、在server.xml中的节点下添加如下代码。path表示的是访问时输入的web项目名，docBase表示的是站点目录的绝对路径。</p>
<p>2、进入到confCatalinalocalhost文件下，创建一个xml文件，该文件的名字就是站点的名字。</p>
<h4 id="17-Tomcat体系结构是怎样的"><a href="#17-Tomcat体系结构是怎样的" class="headerlink" title="17.Tomcat体系结构是怎样的?"></a>17.Tomcat体系结构是怎样的?</h4><p>浏览器 -&gt; tomcat server-&gt; service -&gt;connector -&gt; engine(引擎) -&gt; host(主机) -&gt; web应用。</p>
<h4 id="18-Web请求在Tomcat请求中的请求流程是怎么样的"><a href="#18-Web请求在Tomcat请求中的请求流程是怎么样的" class="headerlink" title="18.Web请求在Tomcat请求中的请求流程是怎么样的?"></a>18.Web请求在Tomcat请求中的请求流程是怎么样的?</h4><p>①浏览器输入URL地址;</p>
<p>②查询本机hosts文件寻找IP;</p>
<p>③查询DNS服务器寻找IP;</p>
<p>④向该IP发送Http请求;</p>
<p>⑤Tomcat容器解析主机名;</p>
<p>⑥Tomcat容器解析Web应用;</p>
<p>⑦Tomcat容器解析资源名称;</p>
<p>⑧Tomcat容器获取资源;</p>
<p>⑨Tomcat响应浏览器。</p>
<h4 id="19-如何在tomcat集群中实现Session共享"><a href="#19-如何在tomcat集群中实现Session共享" class="headerlink" title="19.如何在tomcat集群中实现Session共享"></a>19.如何在tomcat集群中实现Session共享</h4><p>Apache集群实现Tomcat的Session共享配置其实很简单，在Tomcat自带的文档中有详细的说明( /docs/cluster-howto.html )，只不过是英语的，所以联合下面根据说下怎么配置吧：</p>
<p>1、既然是集群肯定要多准备几个Tomcat来模拟，比如分别为Tomcat01、Tomcat02、Tomcat03。</p>
<p>如果各Tomcat程序放在不同的机器上，那么就不会有端口的冲突。如果是放在同一台机器上的话，那就简单改几个端口，防止端口占用造成的冲突。打开conf文件夹中的server.xml文件，需要修改的端口有：</p>
<p> 1、&lt;Server port= “ 8015 ” shutdown= “ SHUTDOWN ” &gt;</p>
<p> 2、&lt;Connector port= “ 8081 ” protocol= “ HTTP/1.1 ” connectionTimeout= “ 20000 ” redirectPort= “ 8443 ” /&gt;</p>
<p> 3、&lt;Connector port= “ 8019 ” protocol= “ AJP/1.3 ” redirectPort= “ 8443 ” /&gt;</p>
<p>以上port需要修改，至于修改成什么样子，看你自己了，只要不出现端口冲突就可以了，要保证各个Tomcat实例间没有端口冲突。</p>
<h4 id="20-tomcat有哪些Connector"><a href="#20-tomcat有哪些Connector" class="headerlink" title="20.tomcat有哪些Connector?"></a>20.tomcat有哪些Connector?</h4><p>Tomcat的Web服务器连接器支持两种协议：AJP和HTTP，它们均定义了以二进制格式在Web服务器和Tomcat之间进行数据传输，并提供相应的控制命令。</p>
<p>AJP(Apache JServ Protocol)协议：目前正在使用的AJP协议的版本是通过JK和JK2连接器提供支持的AJP13，它基于二进制的格式在Web服务器和Tomcat之间传输数据，而此前的版本AJP10和AJP11则使用文本格式传输数据。</p>
<p>HTTP协议：诚如其名称所表示，其是使用HTTP或HTTPS协议在Web服务器和Tomcat之间建立通信，此时，Tomcat就是一个完全功能的HTTP服务器，它需要监听在某端口上以接收来自于商前服务器的请求。</p>
<h4 id="21-tomcat的Valve的作用是什么"><a href="#21-tomcat的Valve的作用是什么" class="headerlink" title="21.tomcat的Valve的作用是什么?"></a>21.tomcat的Valve的作用是什么?</h4><p>Valve类似于过滤器，它可以工作于Engine和Host/Context之间、Host和Context之间以及Context和Web应用程序的某资源之间。一个容器内可以建立多个Valve，而且Valve定义的次序也决定了它们生效的次序。</p>
<h4 id="22-Webserver和-Application-Server的区别是什么"><a href="#22-Webserver和-Application-Server的区别是什么" class="headerlink" title="22.Webserver和 Application Server的区别是什么?"></a>22.Webserver和 Application Server的区别是什么?</h4><p>最大区别，WebServer 一般仅仅指Web(如servlet，jsp)的应用服务器，ApplicationServer不仅可以是Web，还可以是Ejb等其它的应用服务器。</p>
<p>web server可以是application server的一部分，也可以是单独存在。</p>
<h4 id="23-Tomcat的缺省端口是多少，怎么修改"><a href="#23-Tomcat的缺省端口是多少，怎么修改" class="headerlink" title="23.Tomcat的缺省端口是多少，怎么修改?"></a>23.Tomcat的缺省端口是多少，怎么修改?</h4><p>1)找到Tomcat目录下的conf文件夹;</p>
<p>2)进入conf文件夹里面找到server.xml文件;</p>
<p>3)打开server.xml文件;</p>
<p>4)在server.xml文件里面找到下列信息;</p>
<p>port=“8080”改成你想要的端口</p>
<h4 id="24-Tomcat-有几种部署方式"><a href="#24-Tomcat-有几种部署方式" class="headerlink" title="24.Tomcat 有几种部署方式?"></a>24.Tomcat 有几种部署方式?</h4><p>1)直接把Web项目放在webapps下，Tomcat会自动将其部署</p>
<p>2)在server.xml文件上配置节点，设置相关的属性即可</p>
<p>3)通过Catalina来进行配置：进入到conf\Catalina\localhost文件下，创建一个xml文件，该文件的名字就是站点的名字。编写XML的方式来进行设置。</p>
<h4 id="25-tomcat容器是如何创建servlet类实例-用到了什么原理"><a href="#25-tomcat容器是如何创建servlet类实例-用到了什么原理" class="headerlink" title="25.tomcat容器是如何创建servlet类实例?用到了什么原理?"></a>25.tomcat容器是如何创建servlet类实例?用到了什么原理?</h4><p>当容器启动时，会读取在webapps 目录下所有的web应用中的web.xml 文件，然后对xml文件进行解析，并读取servlet注册信息。然后，将每个应用中注册的servlet类都进行加载，并通过反射的方式实例化。(有时候也是在第一次请求时实例化)在servlet注册时加上如果为正数，则在一开始就实例化，如果不写或为负数，则第一次请求实例化。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://blog.csdn.net/qq_25934401/article/details/81536958">https://blog.csdn.net/qq_25934401/article/details/81536958</a></p>
<p><a href="http://blog.itpub.net/69902581/viewspace-2673221/">http://blog.itpub.net/69902581/viewspace-2673221/</a></p>
<p><img src="https://gitee.com/yizhibuerdai/Imagetools/raw/master/images/common1.png" alt="WechatIMG360"></p>
]]></content>
      <categories>
        <category>Web Servers</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾收集 (GC)</title>
    <url>/2023/02/15/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86(GC)/</url>
    <content><![CDATA[<h1 id="垃圾收集-GC"><a href="#垃圾收集-GC" class="headerlink" title="垃圾收集 (GC)"></a>垃圾收集 (GC)</h1><p>垃圾收集（Garbage Collection，GC），它的任务是解决以下 3 件问题：</p>
<ul>
<li>哪些内存需要回收？</li>
<li>什么时候回收？</li>
<li>如何回收？</li>
</ul>
<p>其中第一个问题很好回答，在 Java 中，GC 主要发生在 Java 堆和方法区中，对于后两个问题，我们将在之后的内容中进行讨论，并介绍 HotSpot 的 7 个垃圾收集器。</p>
<!-- TOC -->

<ul>
<li><a href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86-gc">垃圾收集 (GC)</a><ul>
<li><a href="#%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E6%AD%BB">判断对象的生死</a><ul>
<li><a href="#%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E7%94%A8%E7%9A%84%E7%AE%97%E6%B3%95">判断对象是否可用的算法</a><ul>
<li><a href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95">引用计数算法</a></li>
<li><a href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%E4%B8%BB%E6%B5%81">可达性分析算法（主流）</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B">四种引用类型</a></li>
<li><a href="#%E5%AE%A3%E5%91%8A%E5%AF%B9%E8%B1%A1%E6%AD%BB%E4%BA%A1%E7%9A%84%E4%B8%A4%E6%AC%A1%E6%A0%87%E8%AE%B0%E8%BF%87%E7%A8%8B">宣告对象死亡的两次标记过程</a></li>
<li><a href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9B%9E%E6%94%B6">方法区的回收</a></li>
</ul>
</li>
<li><a href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95">垃圾收集算法</a><ul>
<li><a href="#%E5%9F%BA%E7%A1%80%E6%A0%87%E8%AE%B0---%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95">基础：标记 - 清除算法</a></li>
<li><a href="#%E8%A7%A3%E5%86%B3%E6%95%88%E7%8E%87%E9%97%AE%E9%A2%98%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95">解决效率问题：复制算法</a></li>
<li><a href="#%E8%A7%A3%E5%86%B3%E7%A9%BA%E9%97%B4%E7%A2%8E%E7%89%87%E9%97%AE%E9%A2%98%E6%A0%87%E8%AE%B0---%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95">解决空间碎片问题：标记 - 整理算法</a></li>
<li><a href="#%E8%BF%9B%E5%8C%96%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95">进化：分代收集算法</a></li>
</ul>
</li>
<li><a href="#hotspot-%E4%B8%AD-gc-%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0">HotSpot 中 GC 算法的实现</a></li>
<li><a href="#7-%E4%B8%AA%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8">7 个垃圾收集器</a><ul>
<li><a href="#serial--parnew-%E6%90%AD%E9%85%8D-serial-old-%E6%94%B6%E9%9B%86%E5%99%A8">Serial / ParNew 搭配 Serial Old 收集器</a></li>
<li><a href="#parallel-%E6%90%AD%E9%85%8D-parallel-scavenge-%E6%94%B6%E9%9B%86%E5%99%A8">Parallel 搭配 Parallel Scavenge 收集器</a></li>
<li><a href="#cms-%E6%94%B6%E9%9B%86%E5%99%A8">CMS 收集器</a></li>
<li><a href="#g1-%E6%94%B6%E9%9B%86%E5%99%A8">G1 收集器</a></li>
</ul>
</li>
<li><a href="#gc-%E6%97%A5%E5%BF%97%E8%A7%A3%E8%AF%BB">GC 日志解读</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h2 id="判断对象的生死"><a href="#判断对象的生死" class="headerlink" title="判断对象的生死"></a>判断对象的生死</h2><p><img src="./pic/%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E6%AD%BB.png" alt="判断对象的生死.png"></p>
<p>什么时候回收对象？当然是这个对象再也不会被用到的时候回收。所以要想解决 “什么时候回收？” 这个问题，我们要先能判断一个对象什么时候什么时候真正的 “死” 掉了，判断对象是否可用主要有以下两种方法。</p>
<h3 id="判断对象是否可用的算法"><a href="#判断对象是否可用的算法" class="headerlink" title="判断对象是否可用的算法"></a>判断对象是否可用的算法</h3><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><ul>
<li><strong>算法描述：</strong><ul>
<li>给对象添加一个引用计数器；</li>
<li>每有一个地方引用它，计数器加 1；</li>
<li>引用失效时，计数器减 1；</li>
<li>计数器值为 0 的对象不再可用。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>很难解决循环引用的问题。即 <code>objA.instance = objB; objB.instance = objA;</code>，objA 和 objB 都不会再被访问后，它们仍然相互引用着对方，所以它们的引用计数器不为 0，将永远不能被判为不可用。</li>
</ul>
</li>
</ul>
<h4 id="可达性分析算法（主流）"><a href="#可达性分析算法（主流）" class="headerlink" title="可达性分析算法（主流）"></a>可达性分析算法（主流）</h4><ul>
<li><strong>算法描述：</strong><ul>
<li>从 “GC Root” 对象作为起点开始向下搜索，走过的路径称为引用链（Reference Chain）；</li>
<li>从 “GC Root” 开始，不可达的对象被判为不可用。</li>
</ul>
</li>
<li><strong>Java 中可作为 “GC Root” 的对象：</strong><ul>
<li>栈中（本地变量表中的reference）<ul>
<li>虚拟机栈中，栈帧中的本地变量表引用的对象；</li>
<li>本地方法栈中，JNI 引用的对象（native方法）；</li>
</ul>
</li>
<li>方法区中<ul>
<li>类的静态属性引用的对象；</li>
<li>常量引用的对象；</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>即便如此，一个对象也不是一旦被判为不可达，就立即死去的，宣告一个的死亡需要经过两次标记过程。</p>
<h3 id="四种引用类型"><a href="#四种引用类型" class="headerlink" title="四种引用类型"></a>四种引用类型</h3><p>JDK 1.2 后，Java 中才有了后 3 种引用的实现。</p>
<ul>
<li><strong>强引用：</strong> 像 <code>Object obj = new Object()</code> 这种，只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。</li>
<li><strong>软引用：</strong> 用来引用还存在但非必须的对象。对于软引用对象，在 OOM 前，虚拟机会把这些对象列入回收范围中进行第二次回收，如果这次回收后，内存还是不够用，就 OOM。实现类：<code>SoftReference</code>。</li>
<li><strong>弱引用：</strong> 被弱引用引用的对象只能生存到下一次垃圾收集前，一旦发生垃圾收集，被弱引用所引用的对象就会被清掉。实现类：<code>WeakReference</code>。</li>
<li><strong>虚引用：</strong> 幽灵引用，对对象没有半毛钱影响，甚至不能用来取得一个对象的实例。它唯一的用途就是：当被一个虚引用引用的对象被回收时，系统会收到这个对象被回收了的通知。实现类：<code>PhantomReference</code>。</li>
</ul>
<h3 id="宣告对象死亡的两次标记过程"><a href="#宣告对象死亡的两次标记过程" class="headerlink" title="宣告对象死亡的两次标记过程"></a>宣告对象死亡的两次标记过程</h3><ul>
<li>当发现对象不可达后，该对象被第一次标记，并进行是否有必要执行 <code>finalize()</code> 方法的判断；<ul>
<li>不需要执行：对象没有覆盖 <code>finalize()</code> 方法，或者 <code>finalize()</code> 方法已被执行过（<code>finalize()</code> 只被执行一次）；</li>
<li>需要执行：将该对象放置在一个队列中，稍后由一个虚拟机自动创建的低优先级线程执行。</li>
</ul>
</li>
<li><code>finalize()</code> 方法是对象逃脱死亡的最后一次机会，不过虚拟机不保证等待 <code>finalize()</code> 方法执行结束，也就是说，虚拟机只触发 <code>finalize()</code> 方法的执行，如果这个方法要执行超久，那么虚拟机并不等待它执行结束，所以最好不要用这个方法。</li>
<li><code>finalize()</code> 方法能做的，try-finally 都能做，所以忘了这个方法吧！</li>
</ul>
<h3 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h3><p>永久代的 GC 主要回收：<strong>废弃常量</strong> 和 <strong>无用的类</strong>。</p>
<ul>
<li>废弃常量：例如一个字符串 “abc”，当没有任何引用指向 “abc” 时，它就是废弃常量了。</li>
<li>无用的类：同时满足以下 3 个条件的类。<ul>
<li>该类的所有实例已被回收，Java 堆中不存在该类的任何实例；</li>
<li>加载该类的 Classloader 已被回收；</li>
<li>该类的 Class 对象没有被任何地方引用，即无法在任何地方通过反射访问该类的方法。</li>
</ul>
</li>
</ul>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p><img src="./pic/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95.png" alt="垃圾收集算法.png"></p>
<h3 id="基础：标记-清除算法"><a href="#基础：标记-清除算法" class="headerlink" title="基础：标记 - 清除算法"></a>基础：标记 - 清除算法</h3><ul>
<li><strong>算法描述：</strong><ul>
<li>先标记出所有需要回收的对象（图中深色区域）；</li>
<li>标记完后，统一回收所有被标记对象（留下狗啃似的可用内存区域……）。</li>
</ul>
</li>
<li><strong>不足：</strong><ul>
<li>效率问题：标记和清理两个过程的效率都不高。</li>
<li>空间碎片问题：标记清除后会产生大量不连续的内存碎片，导致以后为较大的对象分配内存时找不到足够的连续内存，会提前触发另一次 GC。</li>
</ul>
</li>
</ul>
<p><img src="./pic/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4GC%E7%AE%97%E6%B3%95.png" alt="标记清除GC算法.png"></p>
<h3 id="解决效率问题：复制算法"><a href="#解决效率问题：复制算法" class="headerlink" title="解决效率问题：复制算法"></a>解决效率问题：复制算法</h3><ul>
<li><p><strong>算法描述：</strong></p>
<ul>
<li>将可用内存分为大小相等的两块，每次只使用其中一块；</li>
<li>当一块内存用完时，将这块内存上还存活的对象复制到另一块内存上去，将这一块内存全部清理掉。</li>
</ul>
</li>
<li><p><strong>不足：</strong> 可用内存缩小为原来的一半，适合GC过后只有少量对象存活的新生代。</p>
</li>
<li><p><strong>节省内存的方法：</strong></p>
<ul>
<li>新生代中的对象 98% 都是朝生夕死的，所以不需要按照 1:1 的比例对内存进行划分；</li>
<li>把内存划分为：<ul>
<li>1 块比较大的 Eden 区；</li>
<li>2 块较小的 Survivor 区；</li>
</ul>
</li>
<li>每次使用 Eden 区和 1 块 Survivor 区；</li>
<li>回收时，将以上 2 部分区域中的存活对象复制到另一块 Survivor 区中，然后将以上两部分区域清空；</li>
<li>JVM 参数设置：<code>-XX:SurvivorRatio=8</code> 表示 <code>Eden 区大小 / 1 块 Survivor 区大小 = 8</code>。</li>
</ul>
</li>
</ul>
<p><img src="./pic/%E5%A4%8D%E5%88%B6GC%E7%AE%97%E6%B3%95.png" alt="复制GC算法.png"></p>
<h3 id="解决空间碎片问题：标记-整理算法"><a href="#解决空间碎片问题：标记-整理算法" class="headerlink" title="解决空间碎片问题：标记 - 整理算法"></a>解决空间碎片问题：标记 - 整理算法</h3><ul>
<li><strong>算法描述：</strong><ul>
<li>标记方法与 “标记 - 清除算法” 一样；</li>
<li>标记完后，将所有存活对象向一端移动，然后直接清理掉边界以外的内存。</li>
</ul>
</li>
<li><strong>不足：</strong> 存在效率问题，适合老年代。</li>
</ul>
<p><img src="./pic/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86GC%E7%AE%97%E6%B3%95.png" alt="标记整理GC算法.png"></p>
<h3 id="进化：分代收集算法"><a href="#进化：分代收集算法" class="headerlink" title="进化：分代收集算法"></a>进化：分代收集算法</h3><ul>
<li><strong>新生代：</strong> GC 过后只有少量对象存活 —— <strong>复制算法</strong></li>
<li><strong>老年代：</strong> GC 过后对象存活率高 —— <strong>标记 - 整理算法</strong></li>
</ul>
<h2 id="HotSpot-中-GC-算法的实现"><a href="#HotSpot-中-GC-算法的实现" class="headerlink" title="HotSpot 中 GC 算法的实现"></a>HotSpot 中 GC 算法的实现</h2><p>通过前两小节对于判断对象生死和垃圾收集算法的介绍，我们已经对虚拟机是进行 GC 的流程有了一个大致的了解。但是，在 HotSpot 虚拟机中，高效的实现这些算法也是一个需要考虑的问题。所以，接下来，我们将研究一下 HotSpot 虚拟机到底是如何高效的实现这些算法的，以及在实现中有哪些需要注意的问题。</p>
<p><img src="./pic/GC%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0.png" alt="GC的算法实现.png"></p>
<p>通过之前的分析，GC 算法的实现流程简单的来说分为以下两步：</p>
<ol>
<li>找到死掉的对象；</li>
<li>把它清了。</li>
</ol>
<p>想要找到死掉的对象，我们就要进行可达性分析，也就是从 GC Root 找到引用链的这个操作。</p>
<p>也就是说，进行可达性分析的第一步，就是要枚举 GC Roots，这就需要虚拟机知道哪些地方存放着对象应用。如果每一次枚举 GC Roots 都需要把整个栈上位置都遍历一遍，那可就费时间了，毕竟并不是所有位置都存放在引用呀。所以为了提高 GC 的效率，HotSpot 使用了一种 OopMap 的数据结构，<strong>OopMap 记录了栈上本地变量到堆上对象的引用关系</strong>，也就是说，GC 的时候就不用遍历整个栈只遍历每个栈的 OopMap 就行了。</p>
<p>在 OopMap 的帮助下，HotSpot 可以快速准确的完成 GC 枚举了，不过，OopMap 也不是万年不变的，它也是需要被更新的，当内存中的对象间的引用关系发生变化时，就需要改变 OopMap 中的相应内容。可是能导致引用关系发生变化的指令非常之多，如果我们执行完一条指令就改下 OopMap，这 GC 成本实在太高了。</p>
<p>因此，HotSpot 采用了一种在 “安全点” 更新 OopMap 的方法，安全点的选取既不能让 GC 等待的时间过长，也不能过于频繁增加运行负担，也就是说，我们既要让程序运行一段时间，又不能让这个时间太长。我们知道，JVM 中每条指令执行的是很快的，所以一个超级长的指令流也可能很快就执行完了，所以 <strong>真正会出现 “长时间执行” 的一般是指令的复用，例如：方法调用、循环跳转、异常跳转等</strong>，虚拟机一般会将这些地方设置为安全点更新 OopMap 并判断是否需要进行 GC 操作。</p>
<p>此外，在进行枚举根节点的这个操作时，为了保证准确性，我们需要在一段时间内 “冻结” 整个应用，即 Stop The World（传说中的 GC 停顿），因为如果在我们分析可达性的过程中，对象的引用关系还在变来变去，那是不可能得到正确的分析结果的。即便是在号称几乎不会发生停顿的 CMS 垃圾收集器中，枚举根节点时也是必须要停顿的。这里就涉及到了一个问题：</p>
<p><strong>我们让所有线程跑到最近的安全点再停顿下来进行 GC 操作呢？</strong></p>
<p>主要有以下两种方式：</p>
<ul>
<li>抢先式中断：<ul>
<li>先中断所有线程；</li>
<li>发现有线程没中断在安全点，恢复它，让它跑到安全点。</li>
</ul>
</li>
<li><strong>主动式中断：</strong> (主要使用)<ul>
<li>设置一个中断标记；</li>
<li>每个线程到达安全点时，检查这个中断标记，选择是否中断自己。</li>
</ul>
</li>
</ul>
<p>除此安全点之外，还有一个叫做 “安全区域” 的东西，一个一直在执行的线程可以自己 “走” 到安全点去，可是一个处于 Sleep 或者 Blocked 状态的线程是没办法自己到达安全点中断自己的，我们总不能让 GC 操作一直等着这些个 ”不执行“ 的线程重新被分配资源吧。对于这种情况，我们要依靠安全区域来解决。</p>
<p><strong>安全区域是指在一段代码片段之中，引用关系不会发生变化，因此在这个区域中的任意位置开始 GC 都是安全的。</strong></p>
<p>当线程执行到安全区域时，它会把自己标识为 Safe Region，这样 JVM 发起 GC 时是不会理会这个线程的。当这个线程要离开安全区域时，它会检查系统是否在 GC 中，如果不在，它就继续执行，如果在，它就等 GC 结束再继续执行。</p>
<p>本小节我们主要讲述 HotSpot 虚拟机是如何发起内存回收的，也就是如何找到死掉的对象，至于如何清掉这些个对象，HotSpot 将其交给了一堆叫做 ”GC 收集器“ 的东西，这东西又有好多种，不同的 GC 收集器的处理方式不同，适用的场景也不同，我们将在下一小节进行详细讲述。</p>
<h2 id="7-个垃圾收集器"><a href="#7-个垃圾收集器" class="headerlink" title="7 个垃圾收集器"></a>7 个垃圾收集器</h2><p>垃圾收集器就是内存回收操作的具体实现，HotSpot 里足足有 7 种，为啥要弄这么多，因为它们各有各的适用场景。有的属于新生代收集器，有的属于老年代收集器，所以一般是搭配使用的（除了万能的 G1）。关于它们的简单介绍以及分类请见下图。</p>
<p><img src="./pic/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%BB%AC.png" alt="垃圾收集器们.png"></p>
<h3 id="Serial-ParNew-搭配-Serial-Old-收集器"><a href="#Serial-ParNew-搭配-Serial-Old-收集器" class="headerlink" title="Serial / ParNew 搭配 Serial Old 收集器"></a>Serial / ParNew 搭配 Serial Old 收集器</h3><p><img src="./pic/Serial_ParNew%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="Serial_ParNew收集器.jpg"></p>
<p>Serial 收集器是虚拟机在 Client 模式下的默认新生代收集器，它的优势是简单高效，在单 CPU 模式下很牛。</p>
<p>ParNew 收集器就是 Serial 收集器的多线程版本，虽然除此之外没什么创新之处，但它却是许多运行在 Server 模式下的虚拟机中的首选新生代收集器，因为除了 Serial 收集器外，只有它能和 CMS 收集器搭配使用。</p>
<h3 id="Parallel-搭配-Parallel-Scavenge-收集器"><a href="#Parallel-搭配-Parallel-Scavenge-收集器" class="headerlink" title="Parallel 搭配 Parallel Scavenge 收集器"></a>Parallel 搭配 Parallel Scavenge 收集器</h3><p>首先，这俩货肯定是要搭配使用的，不仅仅如此，它俩还贼特别，它们的关注点与其他收集器不同，其他收集器关注于尽可能缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 收集器的目的是达到一个可控的吞吐量。</p>
<blockquote>
<p>吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )</p>
</blockquote>
<p>因此，Parallel Scavenge 收集器不管是新生代还是老年代都是多个线程同时进行垃圾收集，十分适合于应用在注重吞吐量以及 CPU 资源敏感的场合。</p>
<p>可调节的虚拟机参数：</p>
<ul>
<li><code>-XX:MaxGCPauseMillis</code>：最大 GC 停顿的秒数；</li>
<li><code>-XX:GCTimeRatio</code>：吞吐量大小，一个 0 ~ 100 的数，<code>最大 GC 时间占总时间的比率 = 1 / (GCTimeRatio + 1)</code>；</li>
<li><code>-XX:+UseAdaptiveSizePolicy</code>：一个开关参数，打开后就无需手工指定 <code>-Xmn</code>，<code>-XX:SurvivorRatio</code> 等参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，自行调整。</li>
</ul>
<h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p><img src="./pic/CMS%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="CMS垃圾收集器.png"></p>
<p><img src="./pic/CMS%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="CMS收集器运行示意图.jpg"></p>
<p><strong>参数设置：</strong></p>
<ul>
<li><code>-XX:+UseCMSCompactAtFullCollection</code>：在 CMS 要进行 Full GC 时进行内存碎片整理（默认开启）</li>
<li><code>-XX:CMSFullGCsBeforeCompaction</code>：在多少次 Full GC 后进行一次空间整理（默认是 0，即每一次 Full GC 后都进行一次空间整理）</li>
</ul>
<blockquote>
<p><strong>关于 CMS 使用 标记 - 清除 算法的一点思考：</strong></p>
<p>之前对于 CMS 为什么要采用 标记 - 清除 算法十分的不理解，既然已经有了看起来更高级的 标记 - 整理 算法，那 CMS 为什么不用呢？最近想了想，感觉可能是这个原因，不过也不是很确定，只是个人的一种猜测。</p>
<p>标记 - 整理 会将所有存活对象向一端移动，然后直接清理掉边界以外的内存。这就意味着需要一个指针来维护这个分隔存活对象和无用空间的点，而我们知道 CMS 是并发清理的，虽然我们启动了多个线程进行垃圾回收，不过如果使用 标记 - 整理 算法，为了保证线程安全，在整理时要对那个分隔指针加锁，保证同一时刻只有一个线程能修改它，<strong>加锁的这一过程相当于将并行的清理过程变成了串行的，也就失去了并行清理的意义了。</strong></p>
<p>所以，CMS 采用了 标记 - 清除 算法。</p>
</blockquote>
<h3 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h3><p><img src="./pic/G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="G1垃圾收集器.png"></p>
<p><img src="./pic/G1%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="G1收集器运行示意图.jpg"></p>
<h2 id="GC-日志解读"><a href="#GC-日志解读" class="headerlink" title="GC 日志解读"></a>GC 日志解读</h2><p><img src="./pic/GC%E6%97%A5%E5%BF%97%E8%A7%A3%E8%AF%BB.png" alt="GC日志解读.png"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>常用虚拟机性能监控工具</title>
    <url>/2023/04/27/%E5%B8%B8%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="常用虚拟机性能监控工具"><a href="#常用虚拟机性能监控工具" class="headerlink" title="常用虚拟机性能监控工具"></a>常用虚拟机性能监控工具</h1><!-- TOC -->

<ul>
<li><a href="#%E5%B8%B8%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7">常用虚拟机性能监控工具</a><ul>
<li><a href="#jdk-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7">JDK 命令行工具</a></li>
<li><a href="#%E8%A1%A5%E5%85%85ps-%E5%91%BD%E4%BB%A4-linux">补充：<code>ps</code> 命令 (Linux)</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h2 id="JDK-命令行工具"><a href="#JDK-命令行工具" class="headerlink" title="JDK 命令行工具"></a>JDK 命令行工具</h2><p><img src="./pic/JDK%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7.png" alt="JDK命令行工具.png"></p>
<p>其中的重中之重是 jstat 命令！而它最常用的参数就是 -gcutil，使用格式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jstat -gcutil [pid] [intervel] [count]</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<ul>
<li><code>S0</code>：堆上 Survivor space 0 区已使用空间的百分比</li>
<li><code>S1</code>：堆上 Survivor space 1 区已使用空间的百分比</li>
<li><code>E</code>：堆上 Eden 区已使用空间的百分比</li>
<li><code>O</code>：堆上 Old space 区已使用空间的百分比</li>
<li><code>P</code>：堆上 Perm space 区已使用空间的百分比</li>
<li><code>YGC</code>：从程序启动到采样时发生的 Minor GC 次数</li>
<li><code>YGCT</code>：从程序启动到采样时 Minor GC 所用的时间</li>
<li><code>FGC</code>：从程序启动到采样时发生的 Full GC 次数</li>
<li><code>FGCT</code>：从程序启动到采样时 Full GC 所用的时间</li>
<li><code>GCT</code>：从程序启动到采样时 GC 的总时间</li>
</ul>
<h2 id="补充：ps-命令-Linux"><a href="#补充：ps-命令-Linux" class="headerlink" title="补充：ps 命令 (Linux)"></a>补充：<code>ps</code> 命令 (Linux)</h2><p>对于 <code>jps</code> 命令，其实没必要使用，一般使用 Linux 里的 <code>ps</code> 就够了，<code>ps</code> 为我们提供了当前进程状态的一次性的查看，它所提供的查看结果并不动态连续的，如果想对进程时间监控，应该用 <code>top</code> 工具。</p>
<p><strong>Linux 上进程的 5 种状态</strong></p>
<ul>
<li>运行 [R, Runnable]：正在运行或者在运行队列中等待；</li>
<li>中断 [S, Sleep]：休眠中, 受阻, 在等待某个条件的形成或接受到信号；</li>
<li>不可中断 [D]：收到信号不唤醒和不可运行, 进程必须等待直到有中断发生；</li>
<li>僵死 [Z, zombie]：进程已终止, 但进程描述符存在, 直到父进程调用 wait4() 系统调用后释放；</li>
<li>停止 [T, Traced or stop]：进程收到 SIGSTOP, SIGSTP, SIGTIN, SIGTOU 信号后停止运行运行。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -A # 列出所有进程信息（非详细信息）</span><br><span class="line">ps aux  # 列出所有进程的信息</span><br><span class="line">ps aux | grep zsh</span><br><span class="line"></span><br><span class="line">ps -ef # 显示所有进程信息，连同命令行</span><br><span class="line">ps -ef | grep zsh </span><br><span class="line"></span><br><span class="line">ps -u root # 显示指定用户信息</span><br><span class="line">ps -l  # 列出这次登录bash相关信息</span><br><span class="line"></span><br><span class="line">ps axjf  # 同时列出进程树状信息</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机操作系统 - 概述</title>
    <url>/2023/11/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h1 id="计算机操作系统-概述"><a href="#计算机操作系统-概述" class="headerlink" title="计算机操作系统 - 概述"></a>计算机操作系统 - 概述</h1><!-- GFM-TOC -->
<ul>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F---%E6%A6%82%E8%BF%B0">计算机操作系统 - 概述</a><ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81">基本特征</a><ul>
<li><a href="#1-%E5%B9%B6%E5%8F%91">1. 并发</a></li>
<li><a href="#2-%E5%85%B1%E4%BA%AB">2. 共享</a></li>
<li><a href="#3-%E8%99%9A%E6%8B%9F">3. 虚拟</a></li>
<li><a href="#4-%E5%BC%82%E6%AD%A5">4. 异步</a></li>
</ul>
</li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD">基本功能</a><ul>
<li><a href="#1-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86">1. 进程管理</a></li>
<li><a href="#2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">2. 内存管理</a></li>
<li><a href="#3-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86">3. 文件管理</a></li>
<li><a href="#4-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86">4. 设备管理</a></li>
</ul>
</li>
<li><a href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">系统调用</a></li>
<li><a href="#%E5%AE%8F%E5%86%85%E6%A0%B8%E5%92%8C%E5%BE%AE%E5%86%85%E6%A0%B8">宏内核和微内核</a><ul>
<li><a href="#1-%E5%AE%8F%E5%86%85%E6%A0%B8">1. 宏内核</a></li>
<li><a href="#2-%E5%BE%AE%E5%86%85%E6%A0%B8">2. 微内核</a></li>
</ul>
</li>
<li><a href="#%E4%B8%AD%E6%96%AD%E5%88%86%E7%B1%BB">中断分类</a><ul>
<li><a href="#1-%E5%A4%96%E4%B8%AD%E6%96%AD">1. 外中断</a></li>
<li><a href="#2-%E5%BC%82%E5%B8%B8">2. 异常</a></li>
<li><a href="#3-%E9%99%B7%E5%85%A5">3. 陷入</a><!-- GFM-TOC --></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h2><h3 id="1-并发"><a href="#1-并发" class="headerlink" title="1. 并发"></a>1. 并发</h3><p>并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。</p>
<p>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</p>
<p>操作系统通过引入进程和线程，使得程序能够并发运行。</p>
<h3 id="2-共享"><a href="#2-共享" class="headerlink" title="2. 共享"></a>2. 共享</h3><p>共享是指系统中的资源可以被多个并发进程共同使用。</p>
<p>有两种共享方式：互斥共享和同时共享。</p>
<p>互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。</p>
<h3 id="3-虚拟"><a href="#3-虚拟" class="headerlink" title="3. 虚拟"></a>3. 虚拟</h3><p>虚拟技术把一个物理实体转换为多个逻辑实体。</p>
<p>主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。</p>
<p>多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</p>
<p>虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</p>
<h3 id="4-异步"><a href="#4-异步" class="headerlink" title="4. 异步"></a>4. 异步</h3><p>异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。</p>
<h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><h3 id="1-进程管理"><a href="#1-进程管理" class="headerlink" title="1. 进程管理"></a>1. 进程管理</h3><p>进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p>
<h3 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2. 内存管理"></a>2. 内存管理</h3><p>内存分配、地址映射、内存保护与共享、虚拟内存等。</p>
<h3 id="3-文件管理"><a href="#3-文件管理" class="headerlink" title="3. 文件管理"></a>3. 文件管理</h3><p>文件存储空间的管理、目录管理、文件读写管理和保护等。</p>
<h3 id="4-设备管理"><a href="#4-设备管理" class="headerlink" title="4. 设备管理"></a>4. 设备管理</h3><p>完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。</p>
<p>主要包括缓冲管理、设备分配、设备处理、虛拟设备等。</p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/tGPV0.png" width="600"/> </div><br>

<p>Linux 的系统调用主要有以下这些：</p>
<table>
<thead>
<tr>
<th align="center">Task</th>
<th>Commands</th>
</tr>
</thead>
<tbody><tr>
<td align="center">进程控制</td>
<td>fork(); exit(); wait();</td>
</tr>
<tr>
<td align="center">进程通信</td>
<td>pipe(); shmget(); mmap();</td>
</tr>
<tr>
<td align="center">文件操作</td>
<td>open(); read(); write();</td>
</tr>
<tr>
<td align="center">设备操作</td>
<td>ioctl(); read(); write();</td>
</tr>
<tr>
<td align="center">信息维护</td>
<td>getpid(); alarm(); sleep();</td>
</tr>
<tr>
<td align="center">安全</td>
<td>chmod(); umask(); chown();</td>
</tr>
</tbody></table>
<h2 id="宏内核和微内核"><a href="#宏内核和微内核" class="headerlink" title="宏内核和微内核"></a>宏内核和微内核</h2><h3 id="1-宏内核"><a href="#1-宏内核" class="headerlink" title="1. 宏内核"></a>1. 宏内核</h3><p>宏内核是将操作系统功能作为一个紧密结合的整体放到内核。</p>
<p>由于各模块共享信息，因此有很高的性能。</p>
<h3 id="2-微内核"><a href="#2-微内核" class="headerlink" title="2. 微内核"></a>2. 微内核</h3><p>由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。</p>
<p>在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。</p>
<p>因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2_14_microkernelArchitecture.jpg"/> </div><br>

<h2 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h2><h3 id="1-外中断"><a href="#1-外中断" class="headerlink" title="1. 外中断"></a>1. 外中断</h3><p>由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。</p>
<p>(下面2、3属于内中断     内外中断的区别就是来源于cpu的内部还是外部)</p>
<h3 id="2-异常"><a href="#2-异常" class="headerlink" title="2. 异常"></a>2. 异常</h3><p>由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</p>
<h3 id="3-陷入"><a href="#3-陷入" class="headerlink" title="3. 陷入"></a>3. 陷入</h3><p>在用户程序中使用系统调用。</p>
<h1 id="计算机操作系统-进程管理"><a href="#计算机操作系统-进程管理" class="headerlink" title="计算机操作系统 - 进程管理"></a>计算机操作系统 - 进程管理</h1><!-- GFM-TOC -->
<ul>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F---%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86">计算机操作系统 - 进程管理</a><ul>
<li><a href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B">进程与线程</a><ul>
<li><a href="#1-%E8%BF%9B%E7%A8%8B">1. 进程</a></li>
<li><a href="#2-%E7%BA%BF%E7%A8%8B">2. 线程</a></li>
<li><a href="#3-%E5%8C%BA%E5%88%AB">3. 区别</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E5%88%87%E6%8D%A2">进程状态的切换</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">进程调度算法</a><ul>
<li><a href="#1-%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F">1. 批处理系统</a></li>
<li><a href="#2-%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%B3%BB%E7%BB%9F">2. 交互式系统</a></li>
<li><a href="#3-%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F">3. 实时系统</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5">进程同步</a><ul>
<li><a href="#1-%E4%B8%B4%E7%95%8C%E5%8C%BA">1. 临界区</a></li>
<li><a href="#2-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5">2. 同步与互斥</a></li>
<li><a href="#3-%E4%BF%A1%E5%8F%B7%E9%87%8F">3. 信号量</a></li>
<li><a href="#4-%E7%AE%A1%E7%A8%8B">4. 管程</a></li>
</ul>
</li>
<li><a href="#%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98">经典同步问题</a><ul>
<li><a href="#1-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98">1. 哲学家进餐问题</a></li>
<li><a href="#2-%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98">2. 读者-写者问题</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1">进程通信</a><ul>
<li><a href="#1-%E7%AE%A1%E9%81%93">1. 管道</a></li>
<li><a href="#2-fifo">2. FIFO</a></li>
<li><a href="#3-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">3. 消息队列</a></li>
<li><a href="#4-%E4%BF%A1%E5%8F%B7%E9%87%8F">4. 信号量</a></li>
<li><a href="#5-%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8">5. 共享存储</a></li>
<li><a href="#6-%E5%A5%97%E6%8E%A5%E5%AD%97">6. 套接字</a><!-- GFM-TOC --></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="1-进程"><a href="#1-进程" class="headerlink" title="1. 进程"></a>1. 进程</h3><p>(进程控制是用原语实现的，原语的执行 必须一气呵成，不可中断)</p>
<p>进程是资源分配的基本单位。</p>
<p>进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。(pcb是进程存在的唯一标志！)</p>
<p>下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a6ac2b08-3861-4e85-baa8-382287bfee9f.png"/> </div><br>

<h3 id="2-线程"><a href="#2-线程" class="headerlink" title="2. 线程"></a>2. 线程</h3><p>线程是独立调度的基本单位。</p>
<p>（分为用户级线程  是从用户视角下能看到的线程   内核级线程  是从操作系统内核视角看能看到的线程）</p>
<p>一个进程中可以有多个线程，它们共享进程资源。</p>
<p>QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/3cd630ea-017c-488d-ad1d-732b4efeddf5.png"/> </div><br>

<h3 id="3-区别"><a href="#3-区别" class="headerlink" title="3. 区别"></a>3. 区别</h3><p>Ⅰ 拥有资源</p>
<p>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</p>
<p>Ⅱ 调度</p>
<p>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</p>
<p>Ⅲ 系统开销</p>
<p>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</p>
<p>Ⅳ 通信方面</p>
<p>线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。</p>
<h2 id="进程状态的切换"><a href="#进程状态的切换" class="headerlink" title="进程状态的切换"></a>进程状态的切换</h2><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ProcessState.png" width="500"/> </div><br>

<ul>
<li>就绪状态（ready）：等待被调度</li>
<li>运行状态（running）</li>
<li>阻塞状态（waiting）：等待资源</li>
</ul>
<p>应该注意以下内容：</p>
<ul>
<li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li>
<li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li>
</ul>
<h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p>
<h3 id="1-批处理系统"><a href="#1-批处理系统" class="headerlink" title="1. 批处理系统"></a>1. 批处理系统</h3><p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。</p>
<h4 id="三种层次的调度"><a href="#三种层次的调度" class="headerlink" title="三种层次的调度"></a>三种层次的调度</h4><ul>
<li>作业调度（高级调度）：从外存的后备队列中选择一批作业进入内存，并为它们创建进程</li>
<li>内存调度（中级调度）：使那些暂时不能运行的进程调至外存等待，把外存上已经具备运行条件的就绪进程重新调入内存</li>
<li>进程调度（低级调度）：从就绪队列中选取一个进程，将处理机分配给它。发生的频率最高</li>
</ul>
<p><strong>1.1 先来先服务 first-come first-serverd（FCFS）</strong>  （非抢占式）</p>
<p>非抢占式的调度算法，按照请求的顺序进行调度。</p>
<p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p>
<p><strong>1.2 短作业优先 shortest job first（SJF）</strong>(非抢占式)</p>
<p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。</p>
<p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p>
<p><strong>1.3 最短剩余时间优先 shortest remaining time next（SRTN）</strong>  （抢占式）</p>
<p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p>
<p>（有个高响应比优先 是综合了fcfs sjf  两者的优点）</p>
<h3 id="2-交互式系统"><a href="#2-交互式系统" class="headerlink" title="2. 交互式系统"></a>2. 交互式系统</h3><p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p>
<p><strong>2.1 时间片轮转</strong>  </p>
<p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p>
<p>时间片轮转算法的效率和时间片的大小有很大关系：</p>
<ul>
<li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</li>
<li>而如果时间片过长，那么实时性就不能得到保证。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8c662999-c16c-481c-9f40-1fdba5bc9167.png"/> </div><br>

<p><strong>2.2 优先级调度</strong>  </p>
<p>为每个进程分配一个优先级，按优先级进行调度。</p>
<p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>
<p><strong>2.3 多级反馈队列</strong>  </p>
<p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p>
<p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p>
<p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p>
<p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/042cf928-3c8e-4815-ae9c-f2780202c68f.png"/> </div><br>

<h3 id="3-实时系统"><a href="#3-实时系统" class="headerlink" title="3. 实时系统"></a>3. 实时系统</h3><p>实时系统要求一个请求在一个确定时间内得到响应。</p>
<p>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="1-临界区"><a href="#1-临界区" class="headerlink" title="1. 临界区"></a>1. 临界区</h3><p>（临界资源是一次仅允许一个进程使用的共享资源。各进程采取互斥的方式,实现共享的资源称作临界资源。 ）</p>
<p>对临界资源进行访问的那段代码称为临界区。</p>
<p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// entry section</span><br><span class="line">// critical section;</span><br><span class="line">// exit section</span><br></pre></td></tr></table></figure>

<h3 id="2-同步与互斥"><a href="#2-同步与互斥" class="headerlink" title="2. 同步与互斥"></a>2. 同步与互斥</h3><ul>
<li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li>
<li>互斥：多个进程在同一时刻只有一个进程能进入临界区。（另一个进程必须等待） （进程互斥的软件实现方法和硬件实现方法）</li>
</ul>
<h3 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3. 信号量"></a>3. 信号量</h3><p>(用信号量实现进程互斥 实现进程同步 实现进程前驱关系)</p>
<p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p>
<ul>
<li>  <strong>down</strong>   : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li>
<li>  <strong>up</strong>  ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li>
</ul>
<p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p>
<p>如果信号量的取值只能为 0 或者 1，那么就成为了   <strong>互斥量（Mutex）</strong>  ，0 表示临界区已经加锁，1 表示临界区解锁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&lt;font size=3&gt;   <strong>使用信号量实现生产者-消费者问题</strong>   &lt;/font&gt; &lt;/br&gt;</p>
<p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p>
<p>因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。</p>
<p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p>
<p>注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。（导致死锁 ）  （P应该将导致互斥的信号量放到同步的信号量之后）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore empty = N;</span><br><span class="line">semaphore full = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        <span class="keyword">int</span> item = produce_item();</span><br><span class="line">        down(&amp;empty);</span><br><span class="line">        down(&amp;mutex);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        up(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;full);</span><br><span class="line">        down(&amp;mutex);</span><br><span class="line">        <span class="keyword">int</span> item = remove_item();</span><br><span class="line">        consume_item(item);</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        up(&amp;empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-管程"><a href="#4-管程" class="headerlink" title="4. 管程"></a>4. 管程</h3><p>使用信号量机制实现的生产 者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。           (目的无非就是要更方便地实现进程互斥和同步)</p>
<p>c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。</p>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">    integer i;</span><br><span class="line">    condition c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">()</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">remove</span><span class="params">()</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br></pre></td></tr></table></figure>

<p>管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</p>
<p>管程引入了   <strong>条件变量</strong>   以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</p>
<p><font size=3>  <strong>使用管程实现生产者-消费者问题</strong>  </font><br></p>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 管程</span></span><br><span class="line">monitor ProducerConsumer</span><br><span class="line">    condition full, empty;</span><br><span class="line">    integer count := <span class="number">0</span>;</span><br><span class="line">    condition c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">(item: integer)</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> count = N <span class="keyword">then</span> wait(full);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        count := count + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">1</span> <span class="keyword">then</span> signal(empty);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">remove</span>:</span> integer;</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">0</span> <span class="keyword">then</span> wait(empty);</span><br><span class="line">        remove = remove_item;</span><br><span class="line">        count := count - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = N -<span class="number">1</span> <span class="keyword">then</span> signal(full);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者客户端</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">producer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">    <span class="title">begin</span></span></span><br><span class="line"><span class="function">        <span class="title">item</span> = <span class="title">produce_item</span>;</span></span><br><span class="line">        ProducerConsumer.insert(item);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者客户端</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">consumer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">    <span class="title">begin</span></span></span><br><span class="line"><span class="function">        <span class="title">item</span> = <span class="title">ProducerConsumer</span>.<span class="title">remove</span>;</span></span><br><span class="line">        consume_item(item);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<h2 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h2><p>生产者和消费者问题前面已经讨论过了。</p>
<h3 id="1-哲学家进餐问题"><a href="#1-哲学家进餐问题" class="headerlink" title="1. 哲学家进餐问题"></a>1. 哲学家进餐问题</h3><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a9077f06-7584-4f2b-8c20-3a8e46928820.jpg"/> </div><br>

<p>五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。</p>
<p>下面是一种错误的解法，如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        think();</span><br><span class="line">        take(i);       <span class="comment">// 拿起左边的筷子</span></span><br><span class="line">        take((i+<span class="number">1</span>)%N); <span class="comment">// 拿起右边的筷子</span></span><br><span class="line">        eat();</span><br><span class="line">        put(i);</span><br><span class="line">        put((i+<span class="number">1</span>)%N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了防止死锁的发生，可以设置两个条件：</p>
<ul>
<li>必须同时拿起左右两根筷子；</li>
<li>只有在两个邻居都没有进餐的情况下才允许进餐。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT (i + N - 1) % N <span class="comment">// 左邻居</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT (i + 1) % N    <span class="comment">// 右邻居</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THINKING 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HUNGRY   1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EATING   2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line"><span class="keyword">int</span> state[N];                <span class="comment">// 跟踪每个哲学家的状态</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;         <span class="comment">// 临界区的互斥，临界区是 state 数组，对其修改需要互斥</span></span><br><span class="line">semaphore s[N];              <span class="comment">// 每个哲学家一个信号量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        think(i);</span><br><span class="line">        take_two(i);</span><br><span class="line">        eat(i);</span><br><span class="line">        put_two(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">take_two</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = HUNGRY;</span><br><span class="line">    check(i);</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">    down(&amp;s[i]); <span class="comment">// 只有收到通知之后才可以开始吃，否则会一直等下去</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_two</span><span class="params">(i)</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = THINKING;</span><br><span class="line">    check(LEFT); <span class="comment">// 尝试通知左右邻居，自己吃完了，你们可以开始吃了</span></span><br><span class="line">    check(RIGHT);</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = EATING;</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查两个邻居是否都没有用餐，如果是的话，就 up(&amp;s[i])，使得 down(&amp;s[i]) 能够得到通知并继续执行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(i)</span> </span>&#123;         </span><br><span class="line">    <span class="keyword">if</span>(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] !=EATING) &#123;</span><br><span class="line">        state[i] = EATING;</span><br><span class="line">        up(&amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-读者-写者问题"><a href="#2-读者-写者问题" class="headerlink" title="2. 读者-写者问题"></a>2. 读者-写者问题</h3><p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p>
<p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore count_mutex = <span class="number">1</span>;</span><br><span class="line">semaphore data_mutex = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>) down(&amp;data_mutex); <span class="comment">// 第一个读者需要对数据进行加锁，防止写进程访问</span></span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">        read();</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) up(&amp;data_mutex);</span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;data_mutex);</span><br><span class="line">        write();</span><br><span class="line">        up(&amp;data_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下内容由 <a href="https://github.com/yugandharbandi">@Bandi Yugandhar</a> 提供。</p>
<p>The first case may result Writer to starve. This case favous Writers i.e no writer, once added to the queue, shall be kept waiting longer than absolutely necessary(only when there are readers that entered the queue before the writer).</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> readcount, writecount;                   <span class="comment">//(initial value = 0)</span></span><br><span class="line">semaphore rmutex, wmutex, readLock, resource; <span class="comment">//(initial value = 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//READER</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&lt;ENTRY Section&gt;</span><br><span class="line"> down(&amp;readLock);                 <span class="comment">//  reader is trying to enter</span></span><br><span class="line"> down(&amp;rmutex);                  <span class="comment">//   lock to increase readcount</span></span><br><span class="line">  readcount++;                 </span><br><span class="line">  <span class="keyword">if</span> (readcount == <span class="number">1</span>)          </span><br><span class="line">   down(&amp;resource);              <span class="comment">//if you are the first reader then lock  the resource</span></span><br><span class="line"> up(&amp;rmutex);                  <span class="comment">//release  for other readers</span></span><br><span class="line"> up(&amp;readLock);                 <span class="comment">//Done with trying to access the resource</span></span><br><span class="line"></span><br><span class="line">&lt;CRITICAL Section&gt;</span><br><span class="line"><span class="comment">//reading is performed</span></span><br><span class="line"></span><br><span class="line">&lt;EXIT Section&gt;</span><br><span class="line"> down(&amp;rmutex);                  <span class="comment">//reserve exit section - avoids race condition with readers</span></span><br><span class="line"> readcount--;                       <span class="comment">//indicate you&#x27;re leaving</span></span><br><span class="line">  <span class="keyword">if</span> (readcount == <span class="number">0</span>)          <span class="comment">//checks if you are last reader leaving</span></span><br><span class="line">   up(&amp;resource);              <span class="comment">//if last, you must release the locked resource</span></span><br><span class="line"> up(&amp;rmutex);                  <span class="comment">//release exit section for other readers</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//WRITER</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &lt;ENTRY Section&gt;</span><br><span class="line">  down(&amp;wmutex);                  <span class="comment">//reserve entry section for writers - avoids race conditions</span></span><br><span class="line">  writecount++;                <span class="comment">//report yourself as a writer entering</span></span><br><span class="line">  <span class="keyword">if</span> (writecount == <span class="number">1</span>)         <span class="comment">//checks if you&#x27;re first writer</span></span><br><span class="line">   down(&amp;readLock);               <span class="comment">//if you&#x27;re first, then you must lock the readers out. Prevent them from trying to enter CS</span></span><br><span class="line">  up(&amp;wmutex);                  <span class="comment">//release entry section</span></span><br><span class="line"></span><br><span class="line">&lt;CRITICAL Section&gt;</span><br><span class="line"> down(&amp;resource);                <span class="comment">//reserve the resource for yourself - prevents other writers from simultaneously editing the shared resource</span></span><br><span class="line">  <span class="comment">//writing is performed</span></span><br><span class="line"> up(&amp;resource);                <span class="comment">//release file</span></span><br><span class="line"></span><br><span class="line">&lt;EXIT Section&gt;</span><br><span class="line">  down(&amp;wmutex);                  <span class="comment">//reserve exit section</span></span><br><span class="line">  writecount--;                <span class="comment">//indicate you&#x27;re leaving</span></span><br><span class="line">  <span class="keyword">if</span> (writecount == <span class="number">0</span>)         <span class="comment">//checks if you&#x27;re the last writer</span></span><br><span class="line">   up(&amp;readLock);               <span class="comment">//if you&#x27;re last writer, you must unlock the readers. Allows them to try enter CS for reading</span></span><br><span class="line">  up(&amp;wmutex);                  <span class="comment">//release exit section</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We can observe that every reader is forced to acquire ReadLock. On the otherhand, writers doesn’t need to lock individually. Once the first writer locks the ReadLock, it will be released only when there is no writer left in the queue.</p>
<p>From the both cases we observed that either reader or writer has to starve. Below solutionadds the constraint that no thread shall be allowed to starve; that is, the operation of obtaining a lock on the shared data will always terminate in a bounded amount of time.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int readCount;                  &#x2F;&#x2F; init to 0; number of readers currently accessing resource</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; all semaphores initialised to 1</span><br><span class="line">Semaphore resourceAccess;       &#x2F;&#x2F; controls access (read&#x2F;write) to the resource</span><br><span class="line">Semaphore readCountAccess;      &#x2F;&#x2F; for syncing changes to shared variable readCount</span><br><span class="line">Semaphore serviceQueue;         &#x2F;&#x2F; FAIRNESS: preserves ordering of requests (signaling must be FIFO)</span><br><span class="line"></span><br><span class="line">void writer()</span><br><span class="line">&#123; </span><br><span class="line">    down(&amp;serviceQueue);           &#x2F;&#x2F; wait in line to be servicexs</span><br><span class="line">    &#x2F;&#x2F; &lt;ENTER&gt;</span><br><span class="line">    down(&amp;resourceAccess);         &#x2F;&#x2F; request exclusive access to resource</span><br><span class="line">    &#x2F;&#x2F; &lt;&#x2F;ENTER&gt;</span><br><span class="line">    up(&amp;serviceQueue);           &#x2F;&#x2F; let next in line be serviced</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; &lt;WRITE&gt;</span><br><span class="line">    writeResource();            &#x2F;&#x2F; writing is performed</span><br><span class="line">    &#x2F;&#x2F; &lt;&#x2F;WRITE&gt;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; &lt;EXIT&gt;</span><br><span class="line">    up(&amp;resourceAccess);         &#x2F;&#x2F; release resource access for next reader&#x2F;writer</span><br><span class="line">    &#x2F;&#x2F; &lt;&#x2F;EXIT&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void reader()</span><br><span class="line">&#123; </span><br><span class="line">    down(&amp;serviceQueue);           &#x2F;&#x2F; wait in line to be serviced</span><br><span class="line">    down(&amp;readCountAccess);        &#x2F;&#x2F; request exclusive access to readCount</span><br><span class="line">    &#x2F;&#x2F; &lt;ENTER&gt;</span><br><span class="line">    if (readCount &#x3D;&#x3D; 0)         &#x2F;&#x2F; if there are no readers already reading:</span><br><span class="line">        down(&amp;resourceAccess);     &#x2F;&#x2F; request resource access for readers (writers blocked)</span><br><span class="line">    readCount++;                &#x2F;&#x2F; update count of active readers</span><br><span class="line">    &#x2F;&#x2F; &lt;&#x2F;ENTER&gt;</span><br><span class="line">    up(&amp;serviceQueue);           &#x2F;&#x2F; let next in line be serviced</span><br><span class="line">    up(&amp;readCountAccess);        &#x2F;&#x2F; release access to readCount</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; &lt;READ&gt;</span><br><span class="line">    readResource();             &#x2F;&#x2F; reading is performed</span><br><span class="line">    &#x2F;&#x2F; &lt;&#x2F;READ&gt;</span><br><span class="line"></span><br><span class="line">    down(&amp;readCountAccess);        &#x2F;&#x2F; request exclusive access to readCount</span><br><span class="line">    &#x2F;&#x2F; &lt;EXIT&gt;</span><br><span class="line">    readCount--;                &#x2F;&#x2F; update count of active readers</span><br><span class="line">    if (readCount &#x3D;&#x3D; 0)         &#x2F;&#x2F; if there are no readers left:</span><br><span class="line">        up(&amp;resourceAccess);     &#x2F;&#x2F; release resource access for all</span><br><span class="line">    &#x2F;&#x2F; &lt;&#x2F;EXIT&gt;</span><br><span class="line">    up(&amp;readCountAccess);        &#x2F;&#x2F; release access to readCount</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程同步与进程通信很容易混淆，它们的区别在于：</p>
<ul>
<li>进程同步：控制多个进程按一定顺序执行；</li>
<li>进程通信：进程间传输信息。</li>
</ul>
<p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p>
<h3 id="1-管道"><a href="#1-管道" class="headerlink" title="1. 管道"></a>1. 管道</h3><p>是指用于连续读写进程的一个共享文件。其实就是再内存中开辟一个大小固定的缓冲区。</p>
<p>(各进程要互地访问管道)</p>
<p>管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>

<p>它具有以下限制：</p>
<ul>
<li>只支持半双工通信（单向交替传输）；</li>
<li>只能在父子进程或者兄弟进程中使用。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/53cd9ade-b0a6-4399-b4de-7f1fbd06cdfb.png"/> </div><br>

<h3 id="2-FIFO"><a href="#2-FIFO" class="headerlink" title="2. FIFO"></a>2. FIFO</h3><p>也称为命名管道，去除了管道只能在父子进程中使用的限制。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifoat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>

<p>FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2ac50b81-d92a-4401-b9ec-f2113ecc3076.png"/> </div><br>

<h3 id="3-消息队列"><a href="#3-消息队列" class="headerlink" title="3. 消息队列"></a>3. 消息队列</h3><p>相比于 FIFO，消息队列具有以下优点：</p>
<ul>
<li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li>
<li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</li>
<li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。</li>
</ul>
<h3 id="4-信号量"><a href="#4-信号量" class="headerlink" title="4. 信号量"></a>4. 信号量</h3><p>它是一个计数器，用于为多个进程提供对共享数据对象的访问。</p>
<h3 id="5-共享存储"><a href="#5-共享存储" class="headerlink" title="5. 共享存储"></a>5. 共享存储</h3><p>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。（多个进程对共享空间的访问必须是互斥的）</p>
<p>需要使用信号量用来同步对共享存储的访问。</p>
<p>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。</p>
<h3 id="6-套接字"><a href="#6-套接字" class="headerlink" title="6. 套接字"></a>6. 套接字</h3><p>与其它通信机制不同的是，它可用于不同机器间的进程通信。</p>
<h1 id="计算机操作系统-死锁"><a href="#计算机操作系统-死锁" class="headerlink" title="计算机操作系统 - 死锁"></a>计算机操作系统 - 死锁</h1><!-- GFM-TOC -->
<ul>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F---%E6%AD%BB%E9%94%81">计算机操作系统 - 死锁</a><ul>
<li><a href="#%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6">必要条件</a></li>
<li><a href="#%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95">处理方法</a></li>
<li><a href="#%E9%B8%B5%E9%B8%9F%E7%AD%96%E7%95%A5">鸵鸟策略</a></li>
<li><a href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E4%B8%8E%E6%AD%BB%E9%94%81%E6%81%A2%E5%A4%8D">死锁检测与死锁恢复</a><ul>
<li><a href="#1-%E6%AF%8F%E7%A7%8D%E7%B1%BB%E5%9E%8B%E4%B8%80%E4%B8%AA%E8%B5%84%E6%BA%90%E7%9A%84%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B">1. 每种类型一个资源的死锁检测</a></li>
<li><a href="#2-%E6%AF%8F%E7%A7%8D%E7%B1%BB%E5%9E%8B%E5%A4%9A%E4%B8%AA%E8%B5%84%E6%BA%90%E7%9A%84%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B">2. 每种类型多个资源的死锁检测</a></li>
<li><a href="#3-%E6%AD%BB%E9%94%81%E6%81%A2%E5%A4%8D">3. 死锁恢复</a></li>
</ul>
</li>
<li><a href="#%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2">死锁预防</a><ul>
<li><a href="#1-%E7%A0%B4%E5%9D%8F%E4%BA%92%E6%96%A5%E6%9D%A1%E4%BB%B6">1. 破坏互斥条件</a></li>
<li><a href="#2-%E7%A0%B4%E5%9D%8F%E5%8D%A0%E6%9C%89%E5%92%8C%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6">2. 破坏占有和等待条件</a></li>
<li><a href="#3-%E7%A0%B4%E5%9D%8F%E4%B8%8D%E5%8F%AF%E6%8A%A2%E5%8D%A0%E6%9D%A1%E4%BB%B6">3. 破坏不可抢占条件</a></li>
<li><a href="#4-%E7%A0%B4%E5%9D%8F%E7%8E%AF%E8%B7%AF%E7%AD%89%E5%BE%85">4. 破坏环路等待</a></li>
</ul>
</li>
<li><a href="#%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D">死锁避免</a><ul>
<li><a href="#1-%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81">1. 安全状态</a></li>
<li><a href="#2-%E5%8D%95%E4%B8%AA%E8%B5%84%E6%BA%90%E7%9A%84%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95">2. 单个资源的银行家算法</a></li>
<li><a href="#3-%E5%A4%9A%E4%B8%AA%E8%B5%84%E6%BA%90%E7%9A%84%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95">3. 多个资源的银行家算法</a><!-- GFM-TOC --></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h2><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c037c901-7eae-4e31-a1e4-9d41329e5c3e.png"/> </div><br>

<ul>
<li>互斥：每个资源要么已经分配给了一个进程，要么就是可用的。</li>
<li>占有和等待：已经得到了某个资源的进程可以再请求新的资源。</li>
<li>不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。</li>
<li>环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</li>
</ul>
<h2 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h2><p>主要有以下四种方法：</p>
<ul>
<li>鸵鸟策略</li>
<li>死锁检测与死锁恢复</li>
<li>死锁预防</li>
<li>死锁避免</li>
</ul>
<h2 id="鸵鸟策略"><a href="#鸵鸟策略" class="headerlink" title="鸵鸟策略"></a>鸵鸟策略</h2><p>把头埋在沙子里，假装根本没发生问题。</p>
<p>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。</p>
<p>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p>
<p>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p>
<h2 id="死锁检测与死锁恢复"><a href="#死锁检测与死锁恢复" class="headerlink" title="死锁检测与死锁恢复"></a>死锁检测与死锁恢复</h2><p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p>
<h3 id="1-每种类型一个资源的死锁检测"><a href="#1-每种类型一个资源的死锁检测" class="headerlink" title="1. 每种类型一个资源的死锁检测"></a>1. 每种类型一个资源的死锁检测</h3><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b1fa0453-a4b0-4eae-a352-48acca8fff74.png"/> </div><br>

<p>上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。</p>
<p>图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。</p>
<p>每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p>
<h3 id="2-每种类型多个资源的死锁检测"><a href="#2-每种类型多个资源的死锁检测" class="headerlink" title="2. 每种类型多个资源的死锁检测"></a>2. 每种类型多个资源的死锁检测</h3><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e1eda3d5-5ec8-4708-8e25-1a04c5e11f48.png"/> </div><br>

<p>上图中，有三个进程四个资源，每个数据代表的含义如下：</p>
<ul>
<li>E 向量：资源总量</li>
<li>A 向量：资源剩余量</li>
<li>C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</li>
<li>R 矩阵：每个进程请求的资源数量</li>
</ul>
<p>进程 P<sub>1</sub> 和 P<sub>2</sub> 所请求的资源都得不到满足，只有进程 P<sub>3</sub> 可以，让 P<sub>3</sub> 执行，之后释放 P<sub>3</sub> 拥有的资源，此时 A = (2 2 2 0)。P<sub>2</sub> 可以执行，执行后释放 P<sub>2</sub> 拥有的资源，A = (4 2 2 1) 。P<sub>1</sub> 也可以执行。所有进程都可以顺利执行，没有死锁。</p>
<p>算法总结如下：</p>
<p>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。</p>
<ol>
<li>寻找一个没有标记的进程 P<sub>i</sub>，它所请求的资源小于等于 A。</li>
<li>如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。</li>
<li>如果没有这样一个进程，算法终止。</li>
</ol>
<h3 id="3-死锁恢复"><a href="#3-死锁恢复" class="headerlink" title="3. 死锁恢复"></a>3. 死锁恢复</h3><ul>
<li>利用抢占恢复</li>
<li>利用回滚恢复</li>
<li>通过杀死进程恢复</li>
</ul>
<h2 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h2><p>在程序运行之前预防发生死锁。</p>
<h3 id="1-破坏互斥条件"><a href="#1-破坏互斥条件" class="headerlink" title="1. 破坏互斥条件"></a>1. 破坏互斥条件</h3><p>例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。</p>
<h3 id="2-破坏占有和等待条件"><a href="#2-破坏占有和等待条件" class="headerlink" title="2. 破坏占有和等待条件"></a>2. 破坏占有和等待条件</h3><p>一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。</p>
<h3 id="3-破坏不可抢占条件"><a href="#3-破坏不可抢占条件" class="headerlink" title="3. 破坏不可抢占条件"></a>3. 破坏不可抢占条件</h3><h3 id="4-破坏环路等待"><a href="#4-破坏环路等待" class="headerlink" title="4. 破坏环路等待"></a>4. 破坏环路等待</h3><p>给资源统一编号，进程只能按编号顺序来请求资源。</p>
<h2 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h2><p>在程序运行时避免发生死锁。</p>
<h3 id="1-安全状态"><a href="#1-安全状态" class="headerlink" title="1. 安全状态"></a>1. 安全状态</h3><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ed523051-608f-4c3f-b343-383e2d194470.png"/> </div><br>

<p>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p>
<p>定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。</p>
<p>安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。</p>
<h3 id="2-单个资源的银行家算法"><a href="#2-单个资源的银行家算法" class="headerlink" title="2. 单个资源的银行家算法"></a>2. 单个资源的银行家算法</h3><p>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png"/> </div><br>

<p>上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。</p>
<h3 id="3-多个资源的银行家算法"><a href="#3-多个资源的银行家算法" class="headerlink" title="3. 多个资源的银行家算法"></a>3. 多个资源的银行家算法</h3><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/62e0dd4f-44c3-43ee-bb6e-fedb9e068519.png"/> </div><br>

<p>上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。</p>
<p>检查一个状态是否安全的算法如下：</p>
<ul>
<li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li>
<li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li>
<li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li>
</ul>
<p>如果一个状态不是安全的，需要拒绝进入这个状态。</p>
<h1 id="计算机操作系统-内存管理"><a href="#计算机操作系统-内存管理" class="headerlink" title="计算机操作系统 - 内存管理"></a>计算机操作系统 - 内存管理</h1><!-- GFM-TOC -->
<ul>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F---%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">计算机操作系统 - 内存管理</a><ul>
<li><a href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">虚拟内存</a></li>
<li><a href="#%E5%88%86%E9%A1%B5%E7%B3%BB%E7%BB%9F%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84">分页系统地址映射</a></li>
<li><a href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">页面置换算法</a><ul>
<li><a href="#1-%E6%9C%80%E4%BD%B3">1. 最佳</a></li>
<li><a href="#2-%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8">2. 最近最久未使用</a></li>
<li><a href="#3-%E6%9C%80%E8%BF%91%E6%9C%AA%E4%BD%BF%E7%94%A8">3. 最近未使用</a></li>
<li><a href="#4-%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA">4. 先进先出</a></li>
<li><a href="#5-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%9C%BA%E4%BC%9A%E7%AE%97%E6%B3%95">5. 第二次机会算法</a></li>
<li><a href="#6-%E6%97%B6%E9%92%9F">6. 时钟</a></li>
</ul>
</li>
<li><a href="#%E5%88%86%E6%AE%B5">分段</a></li>
<li><a href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F">段页式</a></li>
<li><a href="#%E5%88%86%E9%A1%B5%E4%B8%8E%E5%88%86%E6%AE%B5%E7%9A%84%E6%AF%94%E8%BE%83">分页与分段的比较</a><!-- GFM-TOC --></li>
</ul>
</li>
</ul>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p>
<p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p>
<p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7b281b1e-0595-402b-ae35-8c91084c33c1.png"/> </div><br>

<h2 id="分页系统地址映射"><a href="#分页系统地址映射" class="headerlink" title="分页系统地址映射"></a>分页系统地址映射</h2><p>内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。</p>
<p>一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。</p>
<p>下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的页框的地址为 （110 000000000100）。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cf4386a1-58c9-4eca-a17f-e12b1e9770eb.png" width="500"/> </div><br>

<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。(请求调页、页面置换、需要修改请求页表中新增的表项)</p>
<p>页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。</p>
<p>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p>
<h3 id="1-最佳"><a href="#1-最佳" class="headerlink" title="1. 最佳"></a>1. 最佳</h3><blockquote>
<p>OPT, Optimal replacement algorithm</p>
</blockquote>
<p>所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。</p>
<p>是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。</p>
<p>举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1</span><br></pre></td></tr></table></figure>

<p>开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。</p>
<h3 id="2-最近最久未使用"><a href="#2-最近最久未使用" class="headerlink" title="2. 最近最久未使用"></a>2. 最近最久未使用</h3><blockquote>
<p>LRU, Least Recently Used</p>
</blockquote>
<p>虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。</p>
<p>为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</p>
<p>因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">4，7，0，7，1，0，1，2，1，2，6</span><br></pre></td></tr></table></figure>

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/eb859228-c0f2-4bce-910d-d9f76929352b.png"/> </div><br>
### 3. 最近未使用

<blockquote>
<p>NRU, Not Recently Used （时钟）</p>
</blockquote>
<p>每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：</p>
<ul>
<li>R=0，M=0</li>
<li>R=0，M=1</li>
<li>R=1，M=0</li>
<li>R=1，M=1</li>
</ul>
<p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。</p>
<p>NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。</p>
<h3 id="4-先进先出"><a href="#4-先进先出" class="headerlink" title="4. 先进先出"></a>4. 先进先出</h3><blockquote>
<p>FIFO, First In First Out</p>
</blockquote>
<p>选择换出的页面是最先进入的页面。</p>
<p>该算法会将那些经常被访问的页面换出，导致缺页率升高。</p>
<p>（当为进程分配的物理块数增大时，缺页次数不减反增的现象   belady异常）</p>
<h3 id="5-第二次机会算法"><a href="#5-第二次机会算法" class="headerlink" title="5. 第二次机会算法"></a>5. 第二次机会算法</h3><p>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：</p>
<p>当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ecf8ad5d-5403-48b9-b6e7-f2e20ffe8fca.png"/> </div><br>

<h3 id="6-时钟"><a href="#6-时钟" class="headerlink" title="6. 时钟"></a>6. 时钟</h3><blockquote>
<p>Clock</p>
</blockquote>
<p>第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5f5ef0b6-98ea-497c-a007-f6c55288eab1.png"/> </div><br>







<p>（下面这部分是内存的非连续分配管理方式）</p>
<h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><p>虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。</p>
<p>下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/22de0538-7c6e-4365-bd3b-8ce3c5900216.png"/> </div><br>

<p>分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e0900bb2-220a-43b7-9aa9-1d5cd55ff56e.png"/> </div><br>

<h2 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h2><p>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</p>
<h2 id="分页与分段的比较"><a href="#分页与分段的比较" class="headerlink" title="分页与分段的比较"></a>分页与分段的比较</h2><ul>
<li><p> 对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。</p>
</li>
<li><p>地址空间的维度：分页是一维地址空间，分段是二维的。</p>
</li>
<li><p>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</p>
</li>
<li><p>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</p>
</li>
</ul>
<h1 id="计算机操作系统-设备管理"><a href="#计算机操作系统-设备管理" class="headerlink" title="计算机操作系统 - 设备管理"></a>计算机操作系统 - 设备管理</h1><!-- GFM-TOC -->
<ul>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F---%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86">计算机操作系统 - 设备管理</a><ul>
<li><a href="#%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84">磁盘结构</a></li>
<li><a href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">磁盘调度算法</a><ul>
<li><a href="#1-%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1">1. 先来先服务</a></li>
<li><a href="#2-%E6%9C%80%E7%9F%AD%E5%AF%BB%E9%81%93%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88">2. 最短寻道时间优先</a></li>
<li><a href="#3-%E7%94%B5%E6%A2%AF%E7%AE%97%E6%B3%95">3. 电梯算法</a><!-- GFM-TOC --></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h2><p>​    (可以用 柱面号，盘面号，扇区号定位磁盘中特定的扇区)</p>
<ul>
<li>盘面（Platter）：一个磁盘有多个盘面；</li>
<li>磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；</li>
<li>扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；</li>
<li>磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；</li>
<li>制动手臂（Actuator arm）：用于在磁道之间移动磁头；</li>
<li>主轴（Spindle）：使整个盘面转动。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/014fbc4d-d873-4a12-b160-867ddaed9807.jpg"/> </div><br>

<h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><p>读写一个磁盘块的时间的影响因素有：</p>
<ul>
<li><p>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）</p>
</li>
<li><p>寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）</p>
</li>
<li><p>实际的数据传输时间</p>
<p>（旋转时间和实际的数据传输时间是磁盘的固有属性，无法通过算法来优化）</p>
</li>
</ul>
<p>其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p>
<h3 id="1-先来先服务"><a href="#1-先来先服务" class="headerlink" title="1. 先来先服务"></a>1. 先来先服务</h3><blockquote>
<p>FCFS, First Come First Served</p>
</blockquote>
<p>按照磁盘请求的顺序进行调度。</p>
<p>优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</p>
<h3 id="2-最短寻道时间优先"><a href="#2-最短寻道时间优先" class="headerlink" title="2. 最短寻道时间优先"></a>2. 最短寻道时间优先</h3><blockquote>
<p>SSTF, Shortest Seek Time First</p>
</blockquote>
<p>优先调度与当前磁头所在磁道距离最近的磁道。</p>
<p>虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4e2485e4-34bd-4967-9f02-0c093b797aaa.png"/> </div><br>

<h3 id="3-电梯算法"><a href="#3-电梯算法" class="headerlink" title="3. 电梯算法"></a>3. 电梯算法</h3><blockquote>
<p>SCAN</p>
</blockquote>
<p>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</p>
<p>电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。</p>
<p>因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/271ce08f-c124-475f-b490-be44fedc6d2e.png"/> </div><br>

<h1 id="计算机操作系统-链接"><a href="#计算机操作系统-链接" class="headerlink" title="计算机操作系统 - 链接"></a>计算机操作系统 - 链接</h1><!-- GFM-TOC -->
<ul>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F---%E9%93%BE%E6%8E%A5">计算机操作系统 - 链接</a><ul>
<li><a href="#%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F">编译系统</a></li>
<li><a href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5">静态链接</a></li>
<li><a href="#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6">目标文件</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5">动态链接</a><!-- GFM-TOC --></li>
</ul>
</li>
</ul>
<h2 id="编译系统"><a href="#编译系统" class="headerlink" title="编译系统"></a>编译系统</h2><p>以下是一个 hello.c 程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Unix 系统上，由编译器把源文件转换为目标文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -o hello hello.c</span><br></pre></td></tr></table></figure>

<p>这个过程大致如下：</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b396d726-b75f-4a32-89a2-03a7b6e19f6f.jpg" width="800"/> </div><br>

<ul>
<li>预处理阶段：处理以 # 开头的预处理命令；</li>
<li>编译阶段：翻译成汇编文件；</li>
<li>汇编阶段：将汇编文件翻译成可重定位目标文件；</li>
<li>链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。</li>
</ul>
<h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：</p>
<ul>
<li>符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。</li>
<li>重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/47d98583-8bb0-45cc-812d-47eefa0a4a40.jpg"/> </div><br>

<h2 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h2><ul>
<li>可执行目标文件：可以直接在内存中执行；</li>
<li>可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件；</li>
<li>共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接；</li>
</ul>
<h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>静态库有以下两个问题：</p>
<ul>
<li>当静态库更新时那么整个程序都要重新进行链接；</li>
<li>对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。</li>
</ul>
<p>共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：</p>
<ul>
<li>在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；</li>
<li>在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/76dc7769-1aac-4888-9bea-064f1caa8e77.jpg"/> </div><br>
]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>Thread</tag>
        <tag>Process</tag>
        <tag>Semaphore</tag>
        <tag>Message Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux用户管理</title>
    <url>/2023/08/31/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><h2 id="1-基本用户管理"><a href="#1-基本用户管理" class="headerlink" title="1. 基本用户管理"></a>1. 基本用户管理</h2><blockquote>
<ul>
<li>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</li>
<li>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</li>
<li>每个用户账号都拥有一个唯一的用户名和各自的口令。</li>
<li>要完成的工作主要有如下几个方面：<ul>
<li>用户账号的添加、删除与修改。</li>
<li>用户口令的管理。</li>
<li>用户组的管理。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="1-1-添加用户"><a href="#1-1-添加用户" class="headerlink" title="1.1 添加用户"></a>1.1 添加用户</h3><blockquote>
<p>添加用户：useradd [选项] 用户名。</p>
</blockquote>
<h4 id="1-1-1-参数说明"><a href="#1-1-1-参数说明" class="headerlink" title="1.1.1 参数说明"></a>1.1.1 参数说明</h4><ul>
<li><p>选项:</p>
<ul>
<li>-c comment 指定一段注释性描述。</li>
<li>-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。</li>
<li>-g 用户组 指定用户所属的用户组。</li>
<li>-G 用户组，用户组 指定用户所属的附加组。</li>
<li>-s Shell文件 指定用户的登录Shell。</li>
<li>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</li>
<li>-f [缓冲天数] 指定在密码过期后多少天即关闭该帐号。</li>
<li>-e 有效期限 指定帐号的有效期限；</li>
<li>-M：不要自动建立用户的登入目录；</li>
</ul>
</li>
<li><p>用户名:</p>
<ul>
<li>指定新账号的登录名。</li>
</ul>
</li>
</ul>
<h4 id="1-1-2-实例"><a href="#1-1-2-实例" class="headerlink" title="1.1.2 实例"></a>1.1.2 实例</h4><ol>
<li>useradd –d  /home/sam -m sam<ul>
<li>此命令创建了一个用户sam，其中-d和-m选项用来为登录名sam产生一个主目录 /home/sam（/home为默认的用户主目录所在的父目录）。</li>
</ul>
</li>
<li>useradd -s /bin/sh -g group –G adm,root gem<ul>
<li>新建了一个用户gem，该用户的登录Shell是 /bin/sh，它属于group用户组，同时又属于adm和root用户组，其中group用户组是其主组。</li>
</ul>
</li>
</ol>
<h3 id="1-2-用户口令的管理"><a href="#1-2-用户口令的管理" class="headerlink" title="1.2 用户口令的管理"></a>1.2 用户口令的管理</h3><blockquote>
<p>指定和修改用户口令: passwd 选项 用户名</p>
</blockquote>
<h4 id="1-2-1-参数说明"><a href="#1-2-1-参数说明" class="headerlink" title="1.2.1 参数说明"></a>1.2.1 参数说明</h4><ul>
<li>选项：<ul>
<li>-l 锁定口令，即禁用账号。</li>
<li>-u 口令解锁。</li>
<li>-d 使账号无口令。</li>
<li>-f 强迫用户下次登录时修改口令。</li>
</ul>
</li>
</ul>
<h4 id="1-2-2-注意事项"><a href="#1-2-2-注意事项" class="headerlink" title="1.2.2 注意事项"></a>1.2.2 注意事项</h4><ul>
<li>如果默认用户名，则修改当前用户的口令。<ul>
<li>假设当前用户是sam，则下面的命令修改该用户自己的口令：passwd sam</li>
</ul>
</li>
<li>普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；</li>
<li>超级用户为用户指定口令时，就不需要知道原口令。</li>
</ul>
<h4 id="1-2-3-案例"><a href="#1-2-3-案例" class="headerlink" title="1.2.3 案例"></a>1.2.3 案例</h4><ol>
<li>passwd -l sam<ul>
<li>用 -l(lock) 选项锁定某一用户，使其不能登录</li>
</ul>
</li>
<li>passwd -d sam<ul>
<li>为用户指定空口令</li>
</ul>
</li>
</ol>
<h3 id="1-3-删除帐号"><a href="#1-3-删除帐号" class="headerlink" title="1.3 删除帐号"></a>1.3 删除帐号</h3><blockquote>
<p>删除帐号: userdel 选项 用户名</p>
</blockquote>
<h4 id="1-3-1-注意事项"><a href="#1-3-1-注意事项" class="headerlink" title="1.3.1 注意事项"></a>1.3.1 注意事项</h4><ul>
<li>常用的选项是 -r，它的作用是把用户的主目录一起删除。<ul>
<li>userdel -r sam</li>
</ul>
</li>
</ul>
<h3 id="1-4-修改帐号"><a href="#1-4-修改帐号" class="headerlink" title="1.4 修改帐号"></a>1.4 修改帐号</h3><blockquote>
<p>修改已有用户的信息: usermod 选项 用户名</p>
</blockquote>
<h4 id="1-4-1-注意事项"><a href="#1-4-1-注意事项" class="headerlink" title="1.4.1 注意事项"></a>1.4.1 注意事项</h4><ul>
<li>常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。</li>
</ul>
<h3 id="1-5-查询用户信息"><a href="#1-5-查询用户信息" class="headerlink" title="1.5 查询用户信息"></a>1.5 查询用户信息</h3><ul>
<li>查询用户信息: id 用户名<ul>
<li>用户不存在是返回“无此用户”</li>
</ul>
</li>
<li>查看当前用户/登录用户：who am i</li>
</ul>
<h3 id="1-6-切换用户"><a href="#1-6-切换用户" class="headerlink" title="1.6 切换用户"></a>1.6 切换用户</h3><ul>
<li>切换用户：su - 切换用户名<ul>
<li>从权限高切换到权限低的用户不需要输密码。</li>
<li>返回切换前的用户：exit</li>
</ul>
</li>
</ul>
<h2 id="2-用户组的管理"><a href="#2-用户组的管理" class="headerlink" title="2. 用户组的管理"></a>2. 用户组的管理</h2><blockquote>
<p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。<br>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。</p>
</blockquote>
<h3 id="2-1-增加一个新的用户组"><a href="#2-1-增加一个新的用户组" class="headerlink" title="2.1 增加一个新的用户组"></a>2.1 增加一个新的用户组</h3><blockquote>
<p>增加一个新的用户组: groupadd 选项 用户组</p>
</blockquote>
<h4 id="2-1-1-说明"><a href="#2-1-1-说明" class="headerlink" title="2.1.1 说明"></a>2.1.1 说明</h4><ul>
<li>选项有：<ul>
<li>-g GID 指定新用户组的组标识号（GID）。</li>
<li>-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。</li>
</ul>
</li>
</ul>
<h4 id="2-1-2-案例"><a href="#2-1-2-案例" class="headerlink" title="2.1.2 案例"></a>2.1.2 案例</h4><ol>
<li>groupadd -g 101 group2<ul>
<li>向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。</li>
</ul>
</li>
<li>groupadd -g 101 group2<ul>
<li>向系统中增加了一个新组group2，同时指定新组的组标识号是101。</li>
</ul>
</li>
</ol>
<h3 id="2-2-删除用户组"><a href="#2-2-删除用户组" class="headerlink" title="2.2 删除用户组"></a>2.2 删除用户组</h3><blockquote>
<p>删除用户组: groupmod 选项 用户组</p>
</blockquote>
<h4 id="2-1-2-说明"><a href="#2-1-2-说明" class="headerlink" title="2.1.2 说明"></a>2.1.2 说明</h4><ul>
<li>选项有：<ul>
<li>-g GID 为用户组指定新的组标识号。</li>
<li>-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。</li>
<li>-n新用户组 将用户组的名字改为新名字</li>
</ul>
</li>
</ul>
<h4 id="2-1-3-案例"><a href="#2-1-3-案例" class="headerlink" title="2.1.3 案例"></a>2.1.3 案例</h4><ol>
<li>groupmod -g 102 group2<ul>
<li>将组group2的组标识号修改为102。</li>
</ul>
</li>
<li>groupmod –g 10000 -n group3 group2<ul>
<li>将组group2的标识号改为10000，组名修改为group3。</li>
</ul>
</li>
</ol>
<h3 id="2-3-组的切换"><a href="#2-3-组的切换" class="headerlink" title="2.3 组的切换"></a>2.3 组的切换</h3><blockquote>
<p>用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如：</p>
<ul>
<li>$ newgrp root<ul>
<li>这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="3-与用户账号有关的系统文件"><a href="#3-与用户账号有关的系统文件" class="headerlink" title="3. 与用户账号有关的系统文件"></a>3. 与用户账号有关的系统文件</h2><h3 id="3-1-etc-passwd-文件"><a href="#3-1-etc-passwd-文件" class="headerlink" title="3.1 /etc/passwd 文件"></a>3.1 /etc/passwd 文件</h3><blockquote>
<p>用户（user）的配置文件，记录用户的各种信息。</p>
</blockquote>
<ul>
<li><p>每行的含义：</p>
<ol>
<li><p>“用户名”是代表用户账号的字符串。</p>
<ul>
<li>通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。</li>
<li>为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。</li>
</ul>
</li>
<li><p>“口令”一些系统中，存放着加密后的用户口令字。</p>
<ul>
<li>虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。</li>
</ul>
</li>
<li><p>“用户标识号”是一个整数，系统内部用它来标识用户。</p>
<ul>
<li>一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。</li>
<li>通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。</li>
</ul>
</li>
<li><p>“组标识号”字段记录的是用户所属的用户组。</p>
<ul>
<li>它对应着/etc/group文件中的一条记录。</li>
</ul>
</li>
<li><p>“注释性描述”字段记录着用户的一些个人情况。</p>
<ul>
<li>例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用做finger命令的输出。</li>
</ul>
</li>
<li><p>“主目录”，也就是用户的起始工作目录。</p>
<ul>
<li>它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。</li>
</ul>
</li>
<li><p>用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。</p>
<ul>
<li>Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等。</li>
<li>系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。</li>
<li>用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。</li>
<li>利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。</li>
</ul>
</li>
<li><p>系统中有一类用户称为伪用户（pseudo users）。</p>
<ul>
<li>这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。</li>
</ul>
<p>   <img src="../imgs/3/3.4etcpasswd%E6%96%87%E4%BB%B6.jpg" alt="3.4etcpasswd文件.jpg"></p>
</li>
</ol>
</li>
</ul>
<h3 id="3-2-etc-shadow-文件"><a href="#3-2-etc-shadow-文件" class="headerlink" title="3.2 /etc/shadow 文件"></a>3.2 /etc/shadow 文件</h3><blockquote>
<p>口令配置文件</p>
</blockquote>
<ul>
<li><p>每行的含义：</p>
<ol>
<li><p>“登录名”是与/etc/passwd文件中的登录名相一致的用户账号</p>
</li>
<li><p>“口令”字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。</p>
</li>
<li><p>“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。</p>
</li>
<li><p>“最小时间间隔”指的是两次修改口令之间所需的最小天数。</p>
</li>
<li><p>“最大时间间隔”指的是口令保持有效的最大天数。</p>
</li>
<li><p>“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。</p>
</li>
<li><p>“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。</p>
</li>
<li><p>“失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。</p>
<p>   <img src="../imgs/3/3.4etcshadow.jpg" alt="3.4etcshadow.jpg"></p>
</li>
</ol>
</li>
</ul>
<h3 id="3-3-etc-group-文件"><a href="#3-3-etc-group-文件" class="headerlink" title="3.3 /etc/group 文件"></a>3.3 /etc/group 文件</h3><blockquote>
<p>组（group）的配置文件，用户组的所有信息都存放在/etc/group文件中。</p>
</blockquote>
<ul>
<li><p>每行含义：</p>
<ol>
<li>“组名”是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。</li>
<li>“口令”字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。</li>
<li>“组标识号”与用户标识号类似，也是一个整数，被系统内部用来标识组。</li>
<li>“组内用户列表”是属于这个组的所有用户的列表/b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。</li>
</ol>
<p><img src="../imgs/3/3.4etcgroup.jpg" alt="3.4etcgroup.jpg"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux组管理和权限管理</title>
    <url>/2023/09/05/%E7%BB%84%E7%AE%A1%E7%90%86%E5%92%8C%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="组管理和权限管理"><a href="#组管理和权限管理" class="headerlink" title="组管理和权限管理"></a>组管理和权限管理</h1><h2 id="1-Linux组基本介绍"><a href="#1-Linux组基本介绍" class="headerlink" title="1. Linux组基本介绍"></a>1. Linux组基本介绍</h2><ul>
<li>Linux中每个用户属于一个组，不能独立于组以外。所以在Linux中每个文件存在组的概念：<ol>
<li>所有者</li>
<li>所在组</li>
<li>其他组</li>
<li>改变用户所在组</li>
</ol>
</li>
</ul>
<h2 id="2-文件-目录所有者"><a href="#2-文件-目录所有者" class="headerlink" title="2. 文件/目录所有者"></a>2. 文件/目录所有者</h2><blockquote>
<p>一般为文件的创建者，谁创建了该文件，就自然的称为该文件的所有者。</p>
</blockquote>
<ul>
<li>查看文件所有者：ls -ahl</li>
<li>修改文件所有者：chown (用户名) (文件名)</li>
</ul>
<h2 id="3-文件-目录所在组"><a href="#3-文件-目录所在组" class="headerlink" title="3. 文件/目录所在组"></a>3. 文件/目录所在组</h2><blockquote>
<p>当某个用户创建了一个文件之后，默认之歌文件所在组就是该用户所在的组</p>
</blockquote>
<ul>
<li>查看文件所有者：ls -ahl</li>
<li>修改文件所在组：chgrp (组名) (文件名)</li>
</ul>
<h2 id="4-其他组"><a href="#4-其他组" class="headerlink" title="4. 其他组"></a>4. 其他组</h2><blockquote>
<p>除文件的所有者和所在组的用户外，系统的其他用户都是文件的其他组</p>
</blockquote>
<h2 id="5-文件属性"><a href="#5-文件属性" class="headerlink" title="5. 文件属性"></a>5. 文件属性</h2><ul>
<li>ls -l中显示的内容如图所示<br><img src="../imgs/3/3.6%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7.jpg" alt="3.6文件属性.jpg"></li>
</ul>
<ol>
<li>在Linux中第一个字符代表这个文件是目录、文件或链接文件等等。<ul>
<li>当为[ d ]则是目录</li>
<li>当为[ - ]则是文件；</li>
<li>若是[ l ]则表示为链接文档(link file)；</li>
<li>若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；</li>
<li>若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</li>
</ul>
</li>
<li>接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。<br>每个文件的属性由左边第一部分的10个字符来确定（如下图）。<br> <img src="../imgs/3/3.6%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90.png" alt="文件权限"></li>
</ol>
<h3 id="5-1-rwx权限详解"><a href="#5-1-rwx权限详解" class="headerlink" title="5.1 rwx权限详解"></a>5.1 rwx权限详解</h3><ul>
<li>rwx作用到文件：<ul>
<li>r：read，可读。读取查看。</li>
<li>w：write，可以修改。但不代表可以删除该文件。删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件。</li>
<li>x：execute，可执行。可以被执行。</li>
</ul>
</li>
<li>rwx作用到目录：<ul>
<li>r：可以读取，ls查看目录内容。</li>
<li>w：可以修改，目录内创建+删除+重命名目录。</li>
<li>x：可执行，可以进入该目录。</li>
</ul>
</li>
</ul>
<h3 id="5-2-修改权限"><a href="#5-2-修改权限" class="headerlink" title="5.2 修改权限"></a>5.2 修改权限</h3><h4 id="5-2-1-chgrp：更改文件属组"><a href="#5-2-1-chgrp：更改文件属组" class="headerlink" title="5.2.1 chgrp：更改文件属组"></a>5.2.1 chgrp：更改文件属组</h4><ul>
<li>chgrp [-R] 属组名 文件名<ul>
<li>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</li>
</ul>
</li>
</ul>
<h4 id="5-2-2-chown：更改文件属主，也可以同时更改文件属组"><a href="#5-2-2-chown：更改文件属主，也可以同时更改文件属组" class="headerlink" title="5.2.2 chown：更改文件属主，也可以同时更改文件属组"></a>5.2.2 chown：更改文件属主，也可以同时更改文件属组</h4><blockquote>
<p>语法:</p>
<ul>
<li>chown [–R] 属主名 文件名</li>
<li>chown [-R] 属主名：属组名 文件名</li>
</ul>
</blockquote>
<h4 id="5-2-3-chmod：更改文件9个属性"><a href="#5-2-3-chmod：更改文件9个属性" class="headerlink" title="5.2.3 chmod：更改文件9个属性"></a>5.2.3 chmod：更改文件9个属性</h4><ul>
<li>Linux文件属性有两种设置方法，一种是数字，一种是符号。</li>
<li>Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。</li>
<li>我们可以使用数字来代表各个权限，各权限的分数对照表如下：<ul>
<li>r:4</li>
<li>w:2</li>
<li>x:1</li>
</ul>
</li>
<li>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx—] 分数则是：<ul>
<li>owner = rwx = 4+2+1 = 7</li>
<li>group = rwx = 4+2+1 = 7</li>
<li>others= — = 0+0+0 = 0</li>
</ul>
</li>
</ul>
<h5 id="5-2-3-1-使用数字修改权限"><a href="#5-2-3-1-使用数字修改权限" class="headerlink" title="5.2.3.1 使用数字修改权限"></a>5.2.3.1 使用数字修改权限</h5><ul>
<li><strong>chmod [-R] xyz 文件或目录</strong><ul>
<li>xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。</li>
<li>-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更</li>
<li>举例来说，如果要将.bashrc这个文件所有的权限都设定启用，那么命令如下：<br><img src="../imgs/3/3.6%E6%9B%B4%E6%94%B9%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7.jpg" alt="3.6更改文件属性.jpg"></li>
</ul>
</li>
</ul>
<h5 id="5-2-3-1-使用符号修改权限"><a href="#5-2-3-1-使用符号修改权限" class="headerlink" title="5.2.3.1 使用符号修改权限"></a>5.2.3.1 使用符号修改权限</h5><ul>
<li>我们就可以使用 u(user), g(group), o(others) 来代表三种身份的权限！</li>
<li>此外， a 则代表 all，即全部的身份。读写的权限可以写成 r, w, x，也就是可以使用下表的方式来看<br><img src="../imgs/3/3.6%E7%AC%A6%E5%8F%B7%E4%BF%AE%E6%94%B9%E6%9D%83%E9%99%90.jpg" alt="3.6符号修改权限.jpg"></li>
<li>举例说明<br><img src="../imgs/3/3.6%E6%9D%83%E9%99%90%E4%BF%AE%E6%94%B9%E4%B8%BE%E4%BE%8B.jpg" alt="3.6权限修改举例"></li>
</ul>
<h3 id="5-3-ACL权限设置（setfacl和getfacl）"><a href="#5-3-ACL权限设置（setfacl和getfacl）" class="headerlink" title="5.3 ACL权限设置（setfacl和getfacl）"></a>5.3 ACL权限设置（setfacl和getfacl）</h3><h4 id="5-3-1-setfacl的用途"><a href="#5-3-1-setfacl的用途" class="headerlink" title="5.3.1 setfacl的用途"></a>5.3.1 setfacl的用途</h4><p>setfacl命令可以用来细分linux下的文件权限。<br>chmod命令可以把文件权限分为u,g,o三个组，而setfacl可以对每一个文件或目录设置更精确的文件权限。<br>换句话说，setfacl可以更精确的控制权限的分配。<br>比如：让某一个用户对某一个文件具有某种权限。</p>
<p>这种独立于传统的u,g,o的rwx权限之外的具体权限设置叫ACL（Access Control List）<br>ACL可以针对单一用户、单一文件或目录来进行r,w,x的权限控制，对于需要特殊权限的使用状况有一定帮助。<br>如，某一个文件，不让单一的某个用户访问。</p>
<blockquote>
<p>用法:</p>
<p>setfacl [-bkndRLP] { -m|-M|-x|-X … } file …</p>
<p><strong>-m：设定ACL权限</strong></p>
<ul>
<li>针对用户：使用格式“u:用户名:权限”，例如 setfacl -m u:st:rx /project 表示设定 st 用户对 project 目录具有 rx 权限；</li>
<li>针对群组：使用格式“g:组名:权限”，例如 setfacl -m g:tgroup:rx /project 表示设定群组 tgroup 对 project 目录具有 rx 权限。</li>
</ul>
<p><strong>-x：删除指定用户和群组的ACL权限</strong></p>
<ul>
<li>针对用户：使用格式“u:用户名”，例如 setfacl -x u:st /project 表示删除用户st对project目录的ACL权限；</li>
<li>针对群组：使用格式“g:群组名”，例如 setfacl -x g:tgroup /project 表示删除群组tgrope对目录project的ACL权限。</li>
</ul>
<p><strong>-b：删除所有的ACL权限</strong></p>
<ul>
<li>例如 setfacl -b /project 表示删除有关 project 目录的所有 ACL 权限。</li>
</ul>
<p><strong>-d ：设定默认 ACL 权限</strong></p>
<ul>
<li>命令格式为 “setfacl -m d:u:用户名:权限 文件名”（如果是群组，则使用 d:g:群组名:权限），该选项只对目录生效，指目录中新建立的文件拥有此默认权限，例如 setfacl -m d:u:st:rx /project 表示 st 用户对 project 目录中新建立的文件拥有 rx 权限。</li>
</ul>
<p><strong>-R：递归设定ACL权限</strong></p>
<ul>
<li>指设定的 ACL 权限会对目录下的所有子文件生效，命令格式为 “setfacl -m u:用户名:权限 -R 文件名”（群组使用 g:群组名:权限），例如 setfacl -m u:st:rx -R /project 表示 st 用户对已存在于 project 目录中的子文件和子目录拥有 rx 权限。</li>
</ul>
<p><strong>-k：删除默认 ACL 权限</strong></p>
</blockquote>
<h4 id="5-3-2-getfacl"><a href="#5-3-2-getfacl" class="headerlink" title="5.3.2 getfacl"></a>5.3.2 getfacl</h4><p><strong>getfacl – 获取目录或文件访问控制列表</strong></p>
<blockquote>
<p>**使用方法: getfacl [-aceEsRLPtpndvh] 文件 **<br>-a,  <em>–access           仅显示文件访问控制列表</em><br>-d, <em>–default           仅显示默认的访问控制列表</em><br>-c, <em>–omit-header       不显示注释表头</em><br>-e, <em>–all-effective     显示所有的有效权限</em><br>-E, <em>–no-effective      显示无效权限</em><br>-s, <em>–skip-base         跳过只有基条目(base entries)的文件</em><br>-R, <em>–recursive         递归显示子目录</em><br>-L, <em>–logical           逻辑遍历(跟随符号链接)</em><br>-P, <em>–physical          物理遍历(不跟随符号链接)</em><br>-t, <em>–tabular           使用制表符分隔的输出格式</em><br>-n, <em>–numeric           显示数字的用户/组标识</em><br>-p, <em>–absolute-names    不去除路径前的 ‘/‘ 符号</em><br>-v, <em>–version           显示版本并退出</em><br>-h, <em>–help              显示本帮助信息</em></p>
</blockquote>
<h3 id="5-4-特殊权限"><a href="#5-4-特殊权限" class="headerlink" title="5.4 特殊权限"></a>5.4 特殊权限</h3><h4 id="5-4-1-setuid和setgid"><a href="#5-4-1-setuid和setgid" class="headerlink" title="5.4.1 setuid和setgid"></a>5.4.1 setuid和setgid</h4><h5 id="5-4-1-1-setuid简介"><a href="#5-4-1-1-setuid简介" class="headerlink" title="5.4.1.1 setuid简介"></a>5.4.1.1 setuid简介</h5><ol>
<li>set_uid 只能作用于二进制可执行文件的s权限，忽略脚本类可执行文件的s权限。脚本类包括shell、python等等。防止安全隐患。</li>
<li>普通用户执行拥有该权限的二进制文件时，可以使普通用户临时拥有root权限（例如：更改密码的命令 /usr/bin/passwd 对除 root 以外的用户不可读、不可写和不可执行，但是普通用户同样可以使用该命令更改自己的密码）</li>
<li>子进程不继承s权限，脚本类文件s权限不受认可，那么可不可以先用C写个程序赋予s权限，然后在C里通过system()等函数调用脚本，从而通过“传递”实现脚本s权限呢。答案是不行的。不仅system()调用脚本不行，system( )调用二进制可执行文件也不具有s权限。本质原因是，system()是通过fork()建立子进程，fork()建立子进程时把子进程归属uid而归属euid。</li>
</ol>
<h5 id="5-4-1-2-setgid简介"><a href="#5-4-1-2-setgid简介" class="headerlink" title="5.4.1.2 setgid简介"></a>5.4.1.2 setgid简介</h5><p>setgid的意思和setuid是一样的，即让执行文件的用户以该文件所属组的权限去执行。</p>
<h4 id="5-4-2-stick-bit（粘滞位）"><a href="#5-4-2-stick-bit（粘滞位）" class="headerlink" title="5.4.2 stick bit（粘滞位）"></a>5.4.2 stick bit（粘滞位）</h4><p>看一下系统中用到它的地方，以/tmp为例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">root@Salve1 /</span>]<span class="meta"># ll -d /tmp </span></span><br><span class="line">drwxrwxrwt <span class="number">13</span> root root <span class="number">4096</span> Apr <span class="number">23</span> <span class="number">02</span>:<span class="number">06</span> /tmp </span><br><span class="line">[<span class="meta">root@Salve1 /</span>]<span class="meta"># </span></span><br></pre></td></tr></table></figure>

<p>我们知道/tmp是系统的临时文件目录，所有的用户在该目录下拥有所有的权限，</p>
<p>也就是说在该目录下可以任意创建、修改、删除文件，那如果用户A在该目录下创建了一个文件，</p>
<p>用户B将该文件删除了，这种情况我们是不能允许的。为了达到该目的，就出现了stick bit（粘滞位）的概念。</p>
<p>它是针对目录来说的，如果该目录设置了stick bit（粘滞位），</p>
<p>则该目录下的文件除了该文件的创建者和root用户可以删除和修改/tmp目录下的stuff，</p>
<p>别的用户均不能动别人的，这就是粘滞位的作用。</p>
<h4 id="5-4-3-setuid-setgid-stick-bit用法示范"><a href="#5-4-3-setuid-setgid-stick-bit用法示范" class="headerlink" title="5.4.3 setuid  setgid  stick bit用法示范"></a>5.4.3 setuid  setgid  stick bit用法示范</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod u+s xxx <span class="comment"># 设置setuid权限 </span></span><br><span class="line">chmod g+s xxx <span class="comment"># 设置setgid权限 </span></span><br><span class="line">chmod o+t xxx <span class="comment"># 设置stick bit权限，针对目录 </span></span><br><span class="line">chmod 4775 xxx <span class="comment"># 设置setuid权限 </span></span><br><span class="line">chmod 2775 xxx <span class="comment"># 设置setgid权限 </span></span><br><span class="line">chmod 1775 xxx <span class="comment"># 设置stick bit权限，针对目录 </span></span><br></pre></td></tr></table></figure>

<h5 id="5-4-3-2-注意事项"><a href="#5-4-3-2-注意事项" class="headerlink" title="5.4.3.2 注意事项"></a>5.4.3.2 注意事项</h5><p>有时你设置了s或t 权限，你会发现它变成了S或T，</p>
<p>这是因为在那个位置上你没有给它x（可执行）的权限，这样的话这样的设置是不会有效的，</p>
<p>你可以先给它赋上x的权限，然后再给s或t 的权限。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux网络配置</title>
    <url>/2023/09/27/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h1><h2 id="1-Linux网络配置原理"><a href="#1-Linux网络配置原理" class="headerlink" title="1 Linux网络配置原理"></a>1 Linux网络配置原理</h2><blockquote>
<p>虚拟机NAT网络配置原理</p>
</blockquote>
<p><img src="../imgs/3/3.9%E8%99%9A%E6%8B%9F%E6%9C%BANAT%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86.jpg" alt="虚拟机NAT网络配置原理"></p>
<h2 id="2-查看网络IP和网关"><a href="#2-查看网络IP和网关" class="headerlink" title="2 查看网络IP和网关"></a>2 查看网络IP和网关</h2><h3 id="2-1-虚拟机网络编辑器"><a href="#2-1-虚拟机网络编辑器" class="headerlink" title="2.1 虚拟机网络编辑器"></a>2.1 虚拟机网络编辑器</h3><p><img src="../imgs/3/3.9%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BC%96%E8%BE%91%E5%99%A8.jpg" alt="3.9虚拟机网络编辑器.jpg"></p>
<h3 id="2-2-修改IP地址"><a href="#2-2-修改IP地址" class="headerlink" title="2.2 修改IP地址"></a>2.2 修改IP地址</h3><p><img src="../imgs/3/3.9%E4%BF%AE%E6%94%B9IP%E5%9C%B0%E5%9D%80.jpg" alt="修改IP地址"></p>
<h3 id="2-3-查看网关"><a href="#2-3-查看网关" class="headerlink" title="2.3 查看网关"></a>2.3 查看网关</h3><p><img src="../imgs/3/3.9%E6%9F%A5%E7%9C%8B%E7%BD%91%E5%85%B3.jpg" alt="查看网关"></p>
<h3 id="2-4-查看windows中的虚拟网卡的ip地址"><a href="#2-4-查看windows中的虚拟网卡的ip地址" class="headerlink" title="2.4 查看windows中的虚拟网卡的ip地址"></a>2.4 查看windows中的虚拟网卡的ip地址</h3><ul>
<li>windows中使用ipconfig查看ip配置</li>
</ul>
<h2 id="3-ping测试"><a href="#3-ping测试" class="headerlink" title="3. ping测试"></a>3. ping测试</h2><blockquote>
<p>基本语法: ping [主机地址]</p>
</blockquote>
<ul>
<li>例如： ping <a href="http://www.baidu.com/">www.baidu.com</a></li>
</ul>
<h2 id="4-Linux网络环境配置"><a href="#4-Linux网络环境配置" class="headerlink" title="4. Linux网络环境配置"></a>4. Linux网络环境配置</h2><h3 id="4-1-自动抓取"><a href="#4-1-自动抓取" class="headerlink" title="4.1 自动抓取"></a>4.1 自动抓取</h3><p><img src="../imgs/3/3.9%E8%87%AA%E5%8A%A8%E6%8A%93%E5%8F%96.jpg" alt="自动抓取自动抓取"></p>
<p><strong><code>缺点：</code></strong> 每次自动获取的ip地址可能不一样，不适用于做服务器</p>
<h3 id="4-2-指定ip地址"><a href="#4-2-指定ip地址" class="headerlink" title="4.2 指定ip地址"></a>4.2 指定ip地址</h3><ol>
<li>直接修改配置文件来指定IP，并可以连接到外网，编辑：vim /etc/sysconfig/network-scripts/ifcfg-eth0<br> <img src="../imgs/3/3.9%E6%8C%87%E5%AE%9Aip%E5%9C%B0%E5%9D%80.jpg" alt="指定ip地址"></li>
<li>重启网络服务：service network restart</li>
<li>重启系统：reboot<br><img src="../imgs/3/3.9ifcfg-eth0%E8%AF%B4%E6%98%8E.jpg" alt="3.9ifcfg-eth0说明"></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机字节码执行引擎_01-方法调用</title>
    <url>/2023/04/01/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E_01-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<h1 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h1><p>Java 的方法的执行分为两个部分：</p>
<ul>
<li>方法调用：确定被调用的方法是哪一个；</li>
<li>基于栈的解释执行：真正的执行方法的字节码。</li>
</ul>
<p>在本节中我们将对方法调用进行详细的讲解，我们知道，一切方法的调用在 Class 文件中存储的都是常量池中的符号引用，而不是方法实际运行时的入口地址（直接引用），直到类加载的时候，甚至是实际运行的时候才回去会去确定要被运行的方法的直接引用，而确定要被运行的方法的直接引用的过程就叫做方法调用。</p>
<!-- TOC -->

<ul>
<li><a href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8">方法调用</a><ul>
<li><a href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4">方法调用字节码指令</a></li>
<li><a href="#%E8%A7%A3%E6%9E%90%E8%B0%83%E7%94%A8">解析调用</a></li>
<li><a href="#%E5%88%86%E6%B4%BE%E8%B0%83%E7%94%A8">分派调用</a><ul>
<li><a href="#%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD">静态分派（方法重载）</a><ul>
<li><a href="#%E5%8F%98%E9%87%8F%E7%9A%84%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AE%9E%E9%99%85%E7%B1%BB%E5%9E%8B">变量的静态类型和实际类型</a></li>
<li><a href="#%E9%87%8D%E8%BD%BD%E6%96%B9%E6%B3%95%E5%8C%B9%E9%85%8D%E4%BC%98%E5%85%88%E7%BA%A7%E4%BE%8B%E5%A6%82%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6-a-%E4%BD%9C%E4%B8%BA%E5%85%A5%E5%8F%82">重载方法匹配优先级，例如一个字符 ‘a’ 作为入参</a></li>
</ul>
</li>
<li><a href="#%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99">动态分派（方法重写）</a><ul>
<li><a href="#%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE%E7%9A%84%E8%BF%87%E7%A8%8B">动态分派的过程</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE%E7%9A%84%E5%AE%9E%E7%8E%B0">动态分派的实现</a></li>
</ul>
</li>
<li><a href="#%E5%8D%95%E5%88%86%E6%B4%BE%E4%B8%8E%E5%A4%9A%E5%88%86%E6%B4%BE">单分派与多分派</a></li>
</ul>
</li>
<li><a href="#%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80%E6%94%AF%E6%8C%81">动态类型语言支持</a><ul>
<li><a href="#javalanginvoke-%E5%8C%85">java.lang.invoke 包</a><ul>
<li><a href="#methodhandle-%E7%9A%84%E4%BD%BF%E7%94%A8">MethodHandle 的使用</a></li>
<li><a href="#methodhandle-%E5%92%8C-reflection-%E7%9A%84%E5%8C%BA%E5%88%AB">MethodHandle 和 Reflection 的区别</a></li>
</ul>
</li>
<li><a href="#invokedynamic-%E6%8C%87%E4%BB%A4"><code>invokedynamic</code> 指令</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h2 id="方法调用字节码指令"><a href="#方法调用字节码指令" class="headerlink" title="方法调用字节码指令"></a>方法调用字节码指令</h2><p>Java 虚拟机提供了 5 个职责不同的方法调用字节码指令：</p>
<ul>
<li><code>invokestatic</code>：调用静态方法；</li>
<li><code>invokespecial</code>：调用构造器方法、私有方法、父类方法；</li>
<li><code>invokevirtual</code>：调用所有虚方法，除了静态方法、构造器方法、私有方法、父类方法、final 方法的其他方法叫虚方法；</li>
<li><code>invokeinterface</code>：调用接口方法，会在运行时确定一个该接口的实现对象；</li>
<li><code>invokedynamic</code>：在运行时动态解析出调用点限定符引用的方法，再执行该方法。</li>
</ul>
<p>除了 <code>invokedynamic</code>，其他 4 种方法的第一个参数都是被调用的方法的符号引用，是在编译时确定的，所以它们缺乏动态类型语言支持，因为动态类型语言只有在运行期才能确定接收者的类型，即变量的类型检查的主体过程在运行期，而非编译期。</p>
<blockquote>
<p>final 方法虽然是通过 <code>invokevirtual</code> 调用的，但是其无法被覆盖，没有其他版本，无需对接收者进行多态选择，或者说多态选择的结果是唯一的，所以属于非虚方法。</p>
</blockquote>
<h2 id="解析调用"><a href="#解析调用" class="headerlink" title="解析调用"></a>解析调用</h2><p>解析调用，正如其名，就是 <strong>在类加载的解析阶段，就确定了方法的调用版本</strong> 。我们知道类加载的解析阶段会将一部分符号引用转化为直接引用，这一过程就叫做解析调用。因为是在程序真正运行前就确定了要调用哪一个方法，所以 <strong>解析调用能成立的前提就是：方法在程序真正运行前就有一个明确的调用版本了，并且这个调用版本不会在运行期发生改变。</strong></p>
<p>符合这两个要求的只有以下两类方法：</p>
<ul>
<li>通过 <code>invokestatic</code> 调用的方法：静态方法；</li>
<li>通过 <code>invokespecial</code> 调用的方法：私有方法、构造器方法、父类方法；</li>
</ul>
<p>这两类方法根本不可能通过继承或者别的方式重写出来其他版本，也就是说，在运行前就可以确定调用版本了，十分适合在类加载阶段就解析好。它们会在类加载的解析阶被解析为直接引用，即确定调用版本。</p>
<h2 id="分派调用"><a href="#分派调用" class="headerlink" title="分派调用"></a>分派调用</h2><p>在介绍分派调用前，我们先来介绍一下 Java 所具备的面向对象的 3 个基本特征：封装，继承，多态。</p>
<p>其中多态最基本的体现就是重载和重写了，重载和重写的一个重要特征就是方法名相同，其他各种不同：</p>
<ul>
<li>重载：发生在同一个类中，入参必须不同，返回类型、访问修饰符、抛出的异常都可以不同；</li>
<li>重写：发生在子父类中，入参和返回类型必须相同，访问修饰符大于等于被重写的方法，不能抛出新的异常。</li>
</ul>
<p>相同的方法名实际上给虚拟机的调用带来了困惑，因为虚拟机需要判断，它到底应该调用哪个方法，而这个过程会在分派调用中体现出来。其中：</p>
<ul>
<li>方法重载 —— 静态分派</li>
<li>方法重写 —— 动态分派</li>
</ul>
<h3 id="静态分派（方法重载）"><a href="#静态分派（方法重载）" class="headerlink" title="静态分派（方法重载）"></a>静态分派（方法重载）</h3><p>在介绍静态分派前，我们先来介绍一下什么是变量的静态类型和实际类型。</p>
<h4 id="变量的静态类型和实际类型"><a href="#变量的静态类型和实际类型" class="headerlink" title="变量的静态类型和实际类型"></a>变量的静态类型和实际类型</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Human guy)</span> </span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;Hello guy!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Man man)</span> </span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;Hello man!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Woman woman)</span> </span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;Hello woman!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        StaticDispatch sr = <span class="keyword">new</span> StaticDispatch();</span><br><span class="line">        sr.sayHello(man);</span><br><span class="line">        sr.sayHello(woman);</span><br><span class="line">        <span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">        Hello guy!</span></span><br><span class="line"><span class="comment">        Hello guy!</span></span><br><span class="line"><span class="comment">        因为是根据变量的静态类型，也就是左面的类型：Human 来判断调用哪个方法，</span></span><br><span class="line"><span class="comment">        所以调用的都是 public void sayHello(Human guy)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 简单讲解 */</span></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Human man = <span class="keyword">new</span> Man();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际类型发生变化</span></span><br><span class="line">Human man = <span class="keyword">new</span> Man();</span><br><span class="line">man = <span class="keyword">new</span> Woman();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态类型发生变化</span></span><br><span class="line">sr.sayHello((Man) man);   <span class="comment">// 输出：Hello man!</span></span><br><span class="line">sr.sayHello((Woman) man); <span class="comment">// 输出：Hello woman!</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>Human</code> 称为变量的静态类型，<code>Man</code> 称为变量的实际类型。</p>
<p>在重载时，编译器是通过方法参数的静态类型，而不是实际类型，来判断应该调用哪个方法的。</p>
<p><strong>通俗的讲，静态分派就是通过方法的参数（类型 &amp; 个数 &amp; 顺序）这种静态的东西来判断到底调用哪个方法的过程。</strong></p>
<h4 id="重载方法匹配优先级，例如一个字符-‘a’-作为入参"><a href="#重载方法匹配优先级，例如一个字符-‘a’-作为入参" class="headerlink" title="重载方法匹配优先级，例如一个字符 ‘a’ 作为入参"></a>重载方法匹配优先级，例如一个字符 ‘a’ 作为入参</h4><ul>
<li>基本类型<ul>
<li>char</li>
<li>int</li>
<li>long</li>
<li>float</li>
<li>double</li>
</ul>
</li>
<li>Character</li>
<li>Serializable（Character 实现的接口）<ul>
<li>同时出现两个优先级相同的接口，如 Serializable 和 Comparable，会提示类型模糊，拒绝编译。</li>
</ul>
</li>
<li>Object</li>
<li>char…（变长参数优先级最低）</li>
</ul>
<h3 id="动态分派（方法重写）"><a href="#动态分派（方法重写）" class="headerlink" title="动态分派（方法重写）"></a>动态分派（方法重写）</h3><p>动态分派就是在运行时，根据实际类型确定方法执行版本的分派过程。</p>
<h4 id="动态分派的过程"><a href="#动态分派的过程" class="headerlink" title="动态分派的过程"></a>动态分派的过程</h4><p>我们先来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">  	  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        	System.out.println(<span class="string">&quot;Hello man&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        	System.out.println(<span class="string">&quot;Hello woman&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">        woman.sayHello();</span><br><span class="line">        man = woman;</span><br><span class="line">        man.sayHello();</span><br><span class="line">        <span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">        Hello man</span></span><br><span class="line"><span class="comment">        Hello woman</span></span><br><span class="line"><span class="comment">        Hello woman</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码分析：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">        stack&#x3D;2, locals&#x3D;3, args_size&#x3D;1</span><br><span class="line">        0: new           #2      &#x2F;&#x2F; class com&#x2F;jvm&#x2F;ch8&#x2F;DynamicDispatch$Man</span><br><span class="line">        3: dup</span><br><span class="line">        4: invokespecial #3      &#x2F;&#x2F; Method com&#x2F;jvm&#x2F;ch8&#x2F;DynamicDispatch$Man.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        7: astore_1</span><br><span class="line">        8: new           #4      &#x2F;&#x2F; class com&#x2F;jvm&#x2F;ch8&#x2F;DynamicDispatch$Woman</span><br><span class="line">        11: dup</span><br><span class="line">        12: invokespecial #5     &#x2F;&#x2F; Method com&#x2F;jvm&#x2F;ch8&#x2F;DynamicDispatch$Woman.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        15: astore_2</span><br><span class="line">        16: aload_1		        &#x2F;&#x2F; 把刚创建的对象的引用压到操作数栈顶，</span><br><span class="line">        					   &#x2F;&#x2F; 供之后执行sayHello时确定是执行哪个对象的sayHello</span><br><span class="line">        17: invokevirtual #6    &#x2F;&#x2F; 方法调用</span><br><span class="line">        20: aload_2             &#x2F;&#x2F; 把刚创建的对象的引用压到操作数栈顶，</span><br><span class="line">                                &#x2F;&#x2F; 供之后执行sayHello时确定是执行哪个对象的sayHello</span><br><span class="line">        21: invokevirtual #6    &#x2F;&#x2F; 方法调用</span><br><span class="line">        24: aload_2</span><br><span class="line">        25: astore_1</span><br><span class="line">        26: aload_1</span><br><span class="line">        27: invokevirtual #6    &#x2F;&#x2F; Method com&#x2F;jvm&#x2F;ch8&#x2F;DynamicDispatch$Human.sayHello:()V</span><br><span class="line">        30: return</span><br></pre></td></tr></table></figure>

<p>通过字节码分析可以看出，<code>invokevirtual</code> 指令的运行过程大致为：</p>
<ul>
<li>去操作数栈顶取出将要执行的方法的所有者，记作 C；</li>
<li>查找此方法：<ul>
<li>在 C 中查找此方法；</li>
<li>在 C 的各个父类中查找；</li>
<li>查找过程：<ul>
<li>查找与常量的描述符和简单名称都相同的方法；</li>
<li>进行访问权限验证，不通过抛出：IllegalAccessError 异常；</li>
<li>通过访问权限验证则返回直接引用；</li>
</ul>
</li>
</ul>
</li>
<li>没找到则抛出：AbstractMethodError 异常，即该方法没被实现。</li>
</ul>
<h4 id="动态分派的实现"><a href="#动态分派的实现" class="headerlink" title="动态分派的实现"></a>动态分派的实现</h4><p>动态分派在虚拟机种执行的非常频繁，而且方法查找的过程要在类的方法元数据中搜索合适的目标，从性能上考虑，不太可能进行如此频繁的搜索，需要进行性能上的优化。</p>
<p><strong>常用优化手段：</strong> 在类的方法区中建立一个虚方法表。</p>
<ul>
<li>虚方法表中存放着各个方法的实际入口地址，如果某个方法没有被子类方法重写，那子类方法表中该方法的入口地址 = 父类方法表中该方法的入口地址；</li>
<li>使用这个方法表索引代替在元数据中查找；</li>
<li>该方法表会在类加载的连接阶段初始化好。</li>
</ul>
<p><strong>通俗的讲，动态分派就是通过方法的接收者这种动态的东西来判断到底调用哪个方法的过程。</strong></p>
<blockquote>
<p>总结一下：静态分派看左面，动态分派看右面。</p>
</blockquote>
<h3 id="单分派与多分派"><a href="#单分派与多分派" class="headerlink" title="单分派与多分派"></a>单分派与多分派</h3><p>除了静态分派和动态分派这种分派分类方式，还有一种根据宗量分类的方式，可以将方法分派分为单分派和多分派。</p>
<blockquote>
<p>宗量：方法的接收者 &amp; 方法的参数。</p>
</blockquote>
<p>Java 语言的静态分派属于多分派，根据 <strong>方法接收者的静态类型</strong> 和 <strong>方法参数类型</strong> 两个宗量进行选择。</p>
<p>Java 语言的动态分派属于单分派，只根据 <strong>方法接收者的实际类型</strong> 一个宗量进行选择。</p>
<h2 id="动态类型语言支持"><a href="#动态类型语言支持" class="headerlink" title="动态类型语言支持"></a>动态类型语言支持</h2><p><strong>什么是动态类型语言？</strong> </p>
<p>就是类型检查的主体过程在运行期，而非编译期的编程语言。</p>
<p><strong>动/静态类型语言各自的优点？</strong></p>
<ul>
<li>动态类型语言：灵活性高，开发效率高。</li>
<li>静态类型语言：编译器提供了严谨的类型检查，类型相关的问题能在编码的时候就发现。</li>
</ul>
<p><strong>Java虚拟机层面提供的动态类型支持：</strong></p>
<ul>
<li><code>invokedynamic</code> 指令</li>
<li>java.lang.invoke 包</li>
</ul>
<h3 id="java-lang-invoke-包"><a href="#java-lang-invoke-包" class="headerlink" title="java.lang.invoke 包"></a>java.lang.invoke 包</h3><p><strong>目的：</strong> 在之前的依靠符号引用确定调用的目标方法的方式之外，提供了 MethodHandle 这种动态确定目标方法的调用机制。</p>
<h4 id="MethodHandle-的使用"><a href="#MethodHandle-的使用" class="headerlink" title="MethodHandle 的使用"></a>MethodHandle 的使用</h4><ul>
<li><p>获得方法的参数描述，第一个参数是方法返回值的类型，之后的参数是方法的入参：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MethodType mt = MethodType.methodType(<span class="keyword">void</span>.class, String.class);</span><br></pre></td></tr></table></figure></li>
<li><p>获取一个普通方法的调用：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需要的参数：</span></span><br><span class="line"><span class="comment"> * 1. 被调用方法所属类的类对象</span></span><br><span class="line"><span class="comment"> * 2. 方法名</span></span><br><span class="line"><span class="comment"> * 3. MethodType 对象 mt</span></span><br><span class="line"><span class="comment"> * 4. 调用该方法的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MethodHandle.lookup().findVirtual(receiver.getClass(), <span class="string">&quot;方法名&quot;</span>, mt).bindTo(receiver);</span><br></pre></td></tr></table></figure></li>
<li><p>获取一个父类方法的调用：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需要的参数：</span></span><br><span class="line"><span class="comment"> * 1. 被调用方法所属类的类对象</span></span><br><span class="line"><span class="comment"> * 2. 方法名</span></span><br><span class="line"><span class="comment"> * 3. MethodType 对象 mt</span></span><br><span class="line"><span class="comment"> * 4. 调用这个方法的类的类对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MethodHandle.lookup().findSpecial(GrandFather.class, <span class="string">&quot;方法名&quot;</span>, mt, getClass());</span><br></pre></td></tr></table></figure></li>
<li><p>通过 <code>MethodHandle mh</code> 执行方法：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">invoke() 和 invokeExact() 的区别：</span></span><br><span class="line"><span class="comment">- invokeExact() 要求更严格，要求严格的类型匹配，方法的返回值类型也在考虑范围之内</span></span><br><span class="line"><span class="comment">- invoke() 允许更加松散的调用方式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">mh.invoke(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">mh.invokeExact(<span class="string">&quot;Hello world&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodHandleTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        obj的静态类型是Object，是没有println方法的，所以尽管obj的实际类型都包含println方法，</span></span><br><span class="line"><span class="comment">        它还是不能调用println方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Object obj = System.currentTimeMillis() % <span class="number">2</span> == <span class="number">0</span> ? System.out : <span class="keyword">new</span> ClassA();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        invoke()和invokeExact()的区别：</span></span><br><span class="line"><span class="comment">        - invokeExact()要求更严格，要求严格的类型匹配，方法的返回值类型也在考虑范围之内</span></span><br><span class="line"><span class="comment">        - invoke()允许更加松散的调用方式</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        getPrintlnMH(obj).invoke(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">        getPrintlnMH(obj).invokeExact(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MethodHandle <span class="title">getPrintlnMH</span><span class="params">(Object receiver)</span> </span></span><br><span class="line"><span class="function">        	<span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="comment">/* MethodType代表方法类型，第一个参数是方法返回值的类型，之后的参数是方法的入参 */</span></span><br><span class="line">        MethodType mt = MethodType.methodType(<span class="keyword">void</span>.class, String.class);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        lookup()方法来自于MethodHandles.lookup，</span></span><br><span class="line"><span class="comment">        这句的作用是在指定类中查找符合给定的方法名称、方法类型，并且符合调用权限的方法句柄</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        因为这里调用的是一个虚方法，按照Java语言的规则，方法第一个参数是隐式的，代表该方法的接收者，</span></span><br><span class="line"><span class="comment">        也即是this指向的对象，这个参数以前是放在参数列表中进行传递，现在提供了bindTo()方法来完成这件事情</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> MethodHandles.lookup().findVirtual(receiver.getClass(), <span class="string">&quot;println&quot;</span>, mt).bindTo(receiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>MethodHandles.lookup 中 3 个方法对应的字节码指令：</strong></p>
<ul>
<li><code>findStatic()</code>：对应 invokestatic</li>
<li><code>findVirtual()</code>：对应 invokevirtual &amp; invokeinterface</li>
<li><code>findSpecial()</code>：对应 invokespecial</li>
</ul>
<h4 id="MethodHandle-和-Reflection-的区别"><a href="#MethodHandle-和-Reflection-的区别" class="headerlink" title="MethodHandle 和 Reflection 的区别"></a>MethodHandle 和 Reflection 的区别</h4><ul>
<li><strong>本质区别：</strong> 它们都在模拟方法调用，但是<ul>
<li>Reflection 模拟的是 Java 代码层次的调用；</li>
<li>MethodHandle 模拟的是字节码层次的调用。</li>
</ul>
</li>
<li><strong>包含信息的区别：</strong><ul>
<li>Reflection 的 Method 对象包含的信息多，包括：方法签名、方法描述符、方法的各种属性的Java端表达方式、方法执行权限等；</li>
<li>MethodHandle 对象包含的信息比较少，既包含与执行该方法相关的信息。</li>
</ul>
</li>
</ul>
<h3 id="invokedynamic-指令"><a href="#invokedynamic-指令" class="headerlink" title="invokedynamic 指令"></a><code>invokedynamic</code> 指令</h3><p>Lambda 表达式就是通过 <code>invokedynamic</code> 指令实现的。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机字节码执行引擎_00-虚拟机栈栈帧结构</title>
    <url>/2023/03/24/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E_00-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="虚拟机栈栈帧结构"><a href="#虚拟机栈栈帧结构" class="headerlink" title="虚拟机栈栈帧结构"></a>虚拟机栈栈帧结构</h1><p><img src="./pic/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84.png" alt="虚拟机栈栈帧结构.png"></p>
<!-- TOC -->

<ul>
<li><a href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84">虚拟机栈栈帧结构</a><ul>
<li><a href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8">局部变量表</a><ul>
<li><a href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%E7%9A%84%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D">局部变量表的空间分配</a></li>
<li><a href="#slot-%E7%9A%84%E5%A4%8D%E7%94%A8">Slot 的复用</a></li>
</ul>
</li>
<li><a href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88">操作数栈</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E8%BF%9E%E6%8E%A5">动态连接</a></li>
<li><a href="#%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80">方法返回地址</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h2 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h2><ul>
<li>存放方法参数和方法内部定义的局部变量；<ul>
<li>Java 程序编译为 class 文件时，就确定了每个方法需要分配的局部变量表的最大容量。</li>
</ul>
</li>
<li>最小单位：Slot；<ul>
<li>一个 Slot 中可以存放：boolean，byte，char，short，int，float，reference，returnAddress (少见)；</li>
<li>虚拟机可通过局部变量表中的 reference 做到：<ul>
<li>查找 Java 堆中的实例对象的起始地址；</li>
<li>查找方法区中的 Class 对象。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="局部变量表的空间分配"><a href="#局部变量表的空间分配" class="headerlink" title="局部变量表的空间分配"></a>局部变量表的空间分配</h3><p><img src="./pic/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%E7%9A%84%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D.png" alt="局部变量表的空间分配.png"></p>
<h3 id="Slot-的复用"><a href="#Slot-的复用" class="headerlink" title="Slot 的复用"></a>Slot 的复用</h3><p><strong>定义：</strong> 如果当前位置已经超过某个变量的作用域时，例如出了定义这个变量的代码块，这个变量对应的 Slot 就可以给其他变量使用了。但同时也说明，只要其他变量没有使用这部分 Slot 区域，这个变量就还保存在那里，这会对 GC 操作产生影响。</p>
<p><strong>对 GC 操作的影响：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>-verbose:gc</code> 输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[GC (System.gc())  68813K-&gt;66304K(123904K), 0.0034797 secs]</span><br><span class="line">[Full GC (System.gc())  66304K-&gt;66204K(123904K), 0.0086225 secs]  &#x2F;&#x2F; 没有被回收</span><br></pre></td></tr></table></figure>

<p>进行如下修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>; <span class="comment">// 新加一个赋值操作</span></span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>-verbose:gc</code> 输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[GC (System.gc())  68813K-&gt;66320K(123904K), 0.0017394 secs]</span><br><span class="line">[Full GC (System.gc())  66320K-&gt;668K(123904K), 0.0084337 secs]  &#x2F;&#x2F; 被回收了</span><br></pre></td></tr></table></figure>

<p><strong>第二次修改后，placeholder 能被回收的原因？</strong></p>
<ul>
<li>placeholder 能否被回收的关键：局部变量表中的 Slot 是否还存在关于 placeholder 的引用；</li>
<li>出了 placeholder 所在的代码块后，还没有进行其他操作，所以 placeholder 所在的 Slot 还没有被其他变量复用，也就是说，局部变量表的 Slot 中依然存在着 placeholder 的引用；</li>
<li>第二次修改后，int a 占用了原来 placeholder 所在的 Slot，所以可以被 GC 掉了。</li>
</ul>
<h2 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h2><ul>
<li>元素可以是任意 Java 类型，32 位数据占 1 个栈容量，64 位数据占 2 个栈容量；</li>
<li>Java 虚拟机的解释执行称为：基于栈的执行引擎，其中 “栈” 指的就是操作数栈；</li>
</ul>
<h2 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h2><ul>
<li>指向运行时常量池中该栈帧所属方法的引用；</li>
<li>为了支持方法调用过程中的动态连接，什么是动态连接会在下一篇文章进行讲解，先知道有这么个东西就行。</li>
</ul>
<h2 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h2><ul>
<li><strong>两种退出方法的方式：</strong><ul>
<li>遇到 return；</li>
<li>遇到异常。</li>
</ul>
</li>
<li><strong>退出方法时可能执行的操作：</strong><ul>
<li>恢复上层方法的局部变量表和操作数栈；</li>
<li>把返回值压入调用者栈帧的操作数栈；</li>
<li>调整 PC 计数器指向方法调用后面的指令。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机字节码执行引擎_02-基于栈的字节码解释执行引擎</title>
    <url>/2023/04/15/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E_02-%E5%9F%BA%E4%BA%8E%E6%A0%88%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<h1 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h1><p>这个栈，就是栈帧中的操作数栈。</p>
<h2 id="解释执行"><a href="#解释执行" class="headerlink" title="解释执行"></a>解释执行</h2><p>先通过 javac 将代码编译成字节码，虚拟机再通过加载字节码文件，解释执行字节码文件生成机器码，解释执行的流程如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">词法分析 -&gt; 语法分析 -&gt; 形成抽象语法树 -&gt; 遍历语法树生成线性字节码指令流</span><br></pre></td></tr></table></figure>



<h2 id="指令集分类"><a href="#指令集分类" class="headerlink" title="指令集分类"></a>指令集分类</h2><h3 id="基于栈的指令集"><a href="#基于栈的指令集" class="headerlink" title="基于栈的指令集"></a>基于栈的指令集</h3><ul>
<li><p><strong>优点：</strong></p>
<ul>
<li>可移植：寄存器由硬件直接提供，程序如果直接依赖这些硬件寄存器，会不可避免的受到硬件的约束；</li>
<li>代码更紧凑：字节码中每个字节对应一条指令，多地址指令集中还需要存放参数；</li>
<li>编译器实现更简单：不需要考虑空间分配问题，所需的空间都在栈上操作。</li>
</ul>
</li>
<li><p><strong>缺点：</strong> 执行速度稍慢</p>
<ul>
<li>完成相同的功能，需要更多的指令，因为出入栈本身就产生相当多的指令；</li>
<li>频繁的栈访问导致频繁的内存访问，对于处理器而言，内存是执行速度的瓶颈。</li>
</ul>
</li>
<li><p><strong>示例：</strong> 两数相加</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iconst_1  &#x2F;&#x2F; 把常量1入栈</span><br><span class="line">iconst_1</span><br><span class="line">iadd      &#x2F;&#x2F; 把栈顶两元素出栈相加，结果入栈</span><br><span class="line">istore_0  &#x2F;&#x2F; 把栈顶值存入第0个Slot中</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="基于寄存器的指令集"><a href="#基于寄存器的指令集" class="headerlink" title="基于寄存器的指令集"></a>基于寄存器的指令集</h3><p><strong>示例：</strong> 两数相加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov  eax, 1</span><br><span class="line">add  eax, 1</span><br></pre></td></tr></table></figure>



<h2 id="执行过程分析"><a href="#执行过程分析" class="headerlink" title="执行过程分析"></a>执行过程分析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Architecture</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    calc函数的字节码分析：</span></span><br><span class="line"><span class="comment">    public int calc();</span></span><br><span class="line"><span class="comment">    descriptor: ()I</span></span><br><span class="line"><span class="comment">    flags: ACC_PUBLIC</span></span><br><span class="line"><span class="comment">    Code:</span></span><br><span class="line"><span class="comment">    stack=2, locals=4, args_size=1 // stack=2，说明需要深度为2的操作数栈</span></span><br><span class="line"><span class="comment">                                   // locals=4，说明需要4个Slot的局部变量表</span></span><br><span class="line"><span class="comment">    0: bipush 100                  // 将单字节的整型常数值push到操作数栈</span></span><br><span class="line"><span class="comment">    2: istore_1                    // 将操作数栈顶的整型值出栈并存放到第一个局部变量Slot中</span></span><br><span class="line"><span class="comment">    3: sipush 200</span></span><br><span class="line"><span class="comment">    6: istore_2</span></span><br><span class="line"><span class="comment">    7: sipush 300</span></span><br><span class="line"><span class="comment">    10: istore_3</span></span><br><span class="line"><span class="comment">    11: iload_1                    // 将局部变量表第一个Slot中的整型值复制到操作数栈顶</span></span><br><span class="line"><span class="comment">    12: iload_2</span></span><br><span class="line"><span class="comment">    13: iadd                       // 将操作数栈中头两个元素出栈并相加，将结果重新入栈</span></span><br><span class="line"><span class="comment">    14: iload_3</span></span><br><span class="line"><span class="comment">    15: imul                       // 将操作数栈中头两个元素出栈并相乘，将结果重新入栈</span></span><br><span class="line"><span class="comment">    16: ireturn                    // 返回指令，结束方法执行，将操作数栈顶的整型值返回给此方法的调用者</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">300</span>;</span><br><span class="line">        <span class="keyword">return</span> (a + b) * c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Architecture architecture = <span class="keyword">new</span> Architecture();</span><br><span class="line">        architecture.calc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机的类加载机制</title>
    <url>/2023/03/15/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="虚拟机的类加载机制"><a href="#虚拟机的类加载机制" class="headerlink" title="虚拟机的类加载机制"></a>虚拟机的类加载机制</h1><!-- TOC -->

<ul>
<li><a href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6">虚拟机的类加载机制</a><ul>
<li><a href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%97%B6%E6%9C%BA">类加载的时机</a></li>
<li><a href="#%E7%B1%BB%E7%9A%84%E6%98%BE%E5%BC%8F%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%9A%90%E5%BC%8F%E5%8A%A0%E8%BD%BD">类的显式加载和隐式加载</a></li>
<li><a href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B">类加载的过程</a><ul>
<li><a href="#%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">类的生命周期</a></li>
<li><a href="#%E5%8A%A0%E8%BD%BD">加载</a><ul>
<li><a href="#%E5%8A%A0%E8%BD%BD%E7%9A%84-3-%E4%B8%AA%E9%98%B6%E6%AE%B5">加载的 3 个阶段</a></li>
<li><a href="#%E5%88%86%E7%B1%BB">分类</a></li>
</ul>
</li>
<li><a href="#%E9%AA%8C%E8%AF%81">验证</a></li>
<li><a href="#%E5%87%86%E5%A4%87">准备</a></li>
<li><a href="#%E8%A7%A3%E6%9E%90">解析</a></li>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a></li>
</ul>
</li>
<li><a href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8">类加载器</a><ul>
<li><a href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E7%B1%BB-%E7%9B%B8%E7%AD%89">如何判断两个类 “相等”</a></li>
<li><a href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB">类加载器的分类</a></li>
<li><a href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B">双亲委派模型</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>JVM 会在程序第一次主动引用类的时候，加载该类，被动引用时并不会引发类加载的操作。也就是说，JVM 并不是在一开始就把一个程序就所有的类都加载到内存中，而是到不得不用的时候才把它加载进来，而且只加载一次。那么什么是主动引用，什么是被动引用呢？</p>
<ul>
<li><strong>主动引用</strong><ul>
<li>遇到 new、getstatic、putstatic、invokestatic 字节码指令，例如：<ul>
<li>使用 new 实例化对象；</li>
<li>读取或设置一个类的 static 字段（被 final 修饰的除外）；</li>
<li>调用类的静态方法。</li>
</ul>
</li>
<li>对类进行反射调用；</li>
<li>初始化一个类时，其父类还没初始化（需先初始化父类）；<ul>
<li>这点类与接口具有不同的表现，接口初始化时，不要求其父接口完成初始化，只有真正使用父接口时才初始化，如引用父接口中定义的常量。</li>
</ul>
</li>
<li>虚拟机启动，先初始化包含 main() 函数的主类；</li>
<li>JDK 1.7 动态语言支持：一个 java.lang.invoke.MethodHandle 的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic。</li>
</ul>
</li>
<li><strong>被动引用</strong><ul>
<li>通过子类引用父类静态字段，不会导致子类初始化；</li>
<li><code>Array[] arr = new Array[10];</code> 不会触发 Array 类初始化；</li>
<li><code>static final VAR</code> 在编译阶段会存入调用类的常量池，通过 <code>ClassName.VAR</code> 引用不会触发 ClassName 初始化。</li>
</ul>
</li>
</ul>
<p>也就是说，只有发生主动引用所列出的 5 种情况，一个类才会被加载到内存中，也就是说类的加载是 lazy-load 的，不到必要时刻是不会提前加载的，毕竟如果将程序运行中永远用不到的类加载进内存，会占用方法区中的内存，浪费系统资源。</p>
<h2 id="类的显式加载和隐式加载"><a href="#类的显式加载和隐式加载" class="headerlink" title="类的显式加载和隐式加载"></a>类的显式加载和隐式加载</h2><ul>
<li><strong>显示加载：</strong><ul>
<li>调用 <code>ClassLoader#loadClass(className)</code> 或 <code>Class.forName(className)</code>。</li>
<li>两种显示加载 .class 文件的区别：<ul>
<li><code>Class.forName(className)</code> 加载 class 的同时会初始化静态域，<code>ClassLoader#loadClass(className)</code> 不会初始化静态域；</li>
<li>Class.forName 借助当前调用者的 class 的 ClassLoader 完成 class 的加载。</li>
</ul>
</li>
</ul>
</li>
<li><strong>隐式加载：</strong><ul>
<li>new 类对象；</li>
<li>使用类的静态域；</li>
<li>创建子类对象；</li>
<li>使用子类的静态域；</li>
<li>其他的隐式加载，在 JVM 启动时：<ul>
<li>BootStrapLoader 会加载一些 JVM 自身运行所需的 Class；</li>
<li>ExtClassLoader 会加载指定目录下一些特殊的 Class；</li>
<li>AppClassLoader 会加载 classpath 路径下的 Class，以及 main 函数所在的类的 Class 文件。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">加载 --&gt; 验证 --&gt; 准备 --&gt; 解析 --&gt; 初始化 --&gt; 使用 --&gt; 卸载</span><br><span class="line">       |&lt;------- 连接 -------&gt;|</span><br><span class="line">|&lt;------------- 类加载 ----------------&gt;|</span><br></pre></td></tr></table></figure>

<p>类的生命周期一共有 7 个阶段，其中前五个阶段较为重要，统称为类加载，第 2 ~ 4 阶段统称为连接，加载和连接中的三个过程开始的顺序是固定的，但是执行过程中是可以交叉执行的。接下来，我们将对类加载的 5 个阶段进行一一讲解。</p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><h4 id="加载的-3-个阶段"><a href="#加载的-3-个阶段" class="headerlink" title="加载的 3 个阶段"></a>加载的 3 个阶段</h4><ul>
<li>通过类的全限定名获取二进制字节流（将 .class 文件读进内存）；</li>
<li>将字节流的静态存储结构转化为运行时的数据结构；</li>
<li>在内存中生成该类的 Class 对象；<ul>
<li>HotSpot 虚拟机把这个对象放在方法区，非 Java 堆。</li>
</ul>
</li>
</ul>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li><strong>非数组类</strong><ul>
<li>系统提供的引导类加载器</li>
<li>用户自定义的类加载器</li>
</ul>
</li>
<li><strong>数组类</strong><ul>
<li>不通过类加载器，由 Java 虚拟机直接创建</li>
<li>创建动作由 newarray 指令触发，new 实际上触发了 <code>[L全类名</code> 对象的初始化</li>
<li>规则<ul>
<li>数组元素是引用类型<ul>
<li>加载：递归加载其组件</li>
<li>可见性：与引用类型一致</li>
</ul>
</li>
<li>数组元素是非引用类型<ul>
<li>加载：与引导类加载器关联</li>
<li>可见性：public</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><ul>
<li><strong>目的：</strong> 确保 .class 文件中的字节流信息符合虚拟机的要求。</li>
<li><strong>4 个验证过程：</strong><ul>
<li>文件格式验证：是否符合 Class 文件格式规范，验证文件开头 4 个字节是不是 “魔数” <code>0xCAFEBABE</code></li>
<li>元数据验证：保证字节码描述信息符号 Java 规范（语义分析）</li>
<li>字节码验证：程序语义、逻辑是否正确（通过数据流、控制流分析）</li>
<li>符号引用验证：对类自身以外的信息（常量池中的符号引用）进行匹配性校验</li>
</ul>
</li>
<li>这个操作虽然重要，但不是必要的，可以通过 <code>-Xverify:none</code> 关掉。</li>
</ul>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul>
<li><strong>描述：</strong> 为 static 变量在方法区分配内存。</li>
<li>static 变量准备后的初始值：<ul>
<li><code>public static int value = 123;</code><ul>
<li>准备后为 0，value 的赋值指令 putstatic 会被放在 <code>&lt;clinit&gt;()</code> 方法中，<code>&lt;clinit&gt;()</code>方法会在初始化时执行，也就是说，value 变量只有在初始化后才等于 123。</li>
</ul>
</li>
<li><code>public static final int value = 123;</code><ul>
<li>准备后为 123，因为被 <code>static final</code> 赋值之后 value 就不能再修改了，所以在这里进行了赋值之后，之后不可能再出现赋值操作，所以可以直接在准备阶段就把 value 的值初始化好。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><ul>
<li><strong>描述：</strong> 将常量池中的 “符号引用” 替换为 “直接引用”。<ul>
<li>在此之前，常量池中的引用是不一定存在的，解析过之后，可以保证常量池中的引用在内存中一定存在。</li>
<li>什么是 “符号引用” 和 “直接引用” ？<ul>
<li>符号引用：以一组符号描述所引用的对象（如对象的全类名），引用的目标不一定存在于内存中。</li>
<li>直接引用：直接指向被引用目标在内存中的位置的指针等，也就是说，引用的目标一定存在于内存中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul>
<li><strong>描述：</strong> 执行类构造器 <code>&lt;clinit&gt;()</code> 方法的过程。</li>
<li><strong><code>&lt;clinit&gt;()</code> 方法</strong><ul>
<li>包含的内容：<ul>
<li>所有 static 的赋值操作；</li>
<li>static 块中的语句；</li>
</ul>
</li>
<li><code>&lt;clinit&gt;()</code> 方法中的语句顺序：<ul>
<li>基本按照语句在源文件中出现的顺序排列；</li>
<li>静态语句块只能访问定义在它前面的变量，定义在它后面的变量，可以赋值，但不能访问。</li>
</ul>
</li>
<li>与 <code>&lt;init&gt;()</code> 的不同：<ul>
<li>不需要显示调用父类的 <code>&lt;clinit&gt;()</code> 方法；</li>
<li>虚拟机保证在子类的 <code>&lt;clinit&gt;()</code> 方法执行前，父类的 <code>&lt;clinit&gt;()</code> 方法一定执行完毕。<ul>
<li>也就是说，父类的 static 块和 static 字段的赋值操作是要先于子类的。</li>
</ul>
</li>
</ul>
</li>
<li>接口与类的不同：<ul>
<li>执行子接口的 <code>&lt;clinit&gt;()</code> 方法前不需要先执行父接口的 <code>&lt;clinit&gt;()</code> 方法（除非用到了父接口中定义的 public static final 变量）；</li>
</ul>
</li>
<li>执行过程中加锁：<ul>
<li>同一时刻只能有一个线程在执行 <code>&lt;clinit&gt;()</code> 方法，因为虚拟机要保证在同一个类加载器下，一个类只被加载一次。</li>
</ul>
</li>
<li>非必要性：<ul>
<li>一个类如果没有任何 static 的内容就不需要执行 <code>&lt;clinit&gt;()</code> 方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><em>注：初始化时，才真正开始执行类中定义的 Java 代码。</em></p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="如何判断两个类-“相等”"><a href="#如何判断两个类-“相等”" class="headerlink" title="如何判断两个类 “相等”"></a>如何判断两个类 “相等”</h3><ul>
<li><strong>“相等” 的要求</strong><ul>
<li>同一个 .class 文件</li>
<li>被同一个虚拟机加载</li>
<li>被同一个类加载器加载</li>
</ul>
</li>
<li><strong>判断 “相等” 的方法</strong><ul>
<li><code>instanceof</code> 关键字</li>
<li>Class 对象中的方法：<ul>
<li><code>equals()</code></li>
<li><code>isInstance()</code></li>
<li><code>isAssignableFrom()</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h3><ul>
<li><strong>启动类加载器（Bootstrap）</strong><ul>
<li><JAVA_HOME>/lib</li>
<li>-Xbootclasspath 参数指定的路径</li>
</ul>
</li>
<li><strong>扩展类加载器（Extension）</strong><ul>
<li><JAVA_HOME>/lib/ext</li>
<li>java.ext.dirs 系统变量指定的路径</li>
</ul>
</li>
<li><strong>应用程序类加载器（Application）</strong><ul>
<li>-classpath 参数</li>
</ul>
</li>
</ul>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><ul>
<li><strong>工作过程</strong><ul>
<li>当前类加载器收到类加载的请求后，先不自己尝试加载类，而是先将请求委派给父类加载器<ul>
<li>因此，所有的类加载请求，都会先被传送到启动类加载器</li>
</ul>
</li>
<li>只有当父类加载器加载失败时，当前类加载器才会尝试自己去自己负责的区域加载</li>
</ul>
</li>
<li><strong>实现</strong><ul>
<li>检查该类是否已经被加载</li>
<li>将类加载请求委派给父类<ul>
<li>如果父类加载器为 null，默认使用启动类加载器</li>
<li><code>parent.loadClass(name, false)</code></li>
</ul>
</li>
<li>当父类加载器加载失败时<ul>
<li>catch ClassNotFoundException 但不做任何处理</li>
<li>调用自己的 findClass() 去加载<ul>
<li>我们在实现自己的类加载器时只需要 <code>extends ClassLoader</code>，然后重写 <code>findClass()</code> 方法而不是 <code>loadClass()</code> 方法，这样就不用重写 <code>loadClass()</code> 中的双亲委派机制了</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>优点</strong><ul>
<li>自己写的类库同名类不会覆盖类库的类</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机调优案例分析</title>
    <url>/2023/05/17/%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="虚拟机调优案例分析"><a href="#虚拟机调优案例分析" class="headerlink" title="虚拟机调优案例分析"></a>虚拟机调优案例分析</h1><!-- TOC -->

<ul>
<li><a href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90">虚拟机调优案例分析</a><ul>
<li><a href="#%E9%AB%98%E6%80%A7%E8%83%BD%E7%A1%AC%E4%BB%B6%E4%B8%8A%E7%9A%84%E7%A8%8B%E5%BA%8F%E9%83%A8%E7%BD%B2%E7%AD%96%E7%95%A5">高性能硬件上的程序部署策略</a></li>
<li><a href="#%E6%9C%8D%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%BB%8F%E5%B8%B8%E5%87%BA%E7%8E%B0%E5%8D%A1%E9%A1%BFfull-gc-%E6%97%B6%E9%97%B4%E5%A4%AA%E9%95%BF">服务系统经常出现卡顿（Full GC 时间太长）</a></li>
<li><a href="#%E9%99%A4%E4%BA%86-java-%E5%A0%86%E5%92%8C%E6%B0%B8%E4%B9%85%E4%BB%A3%E4%B9%8B%E5%A4%96%E4%BC%9A%E5%8D%A0%E7%94%A8%E8%BE%83%E5%A4%9A%E5%86%85%E5%AD%98%E7%9A%84%E5%8C%BA%E5%9F%9F">除了 Java 堆和永久代之外，会占用较多内存的区域</a></li>
<li><a href="#%E4%BB%8E-gc-%E8%B0%83%E4%BC%98%E8%A7%92%E5%BA%A6%E8%A7%A3%E5%86%B3%E6%96%B0%E7%94%9F%E4%BB%A3%E5%AD%98%E6%B4%BB%E5%A4%A7%E9%87%8F%E5%AF%B9%E8%B1%A1%E9%97%AE%E9%A2%98minor-gc-%E6%97%B6%E9%97%B4%E5%A4%AA%E9%95%BF">从 GC 调优角度解决新生代存活大量对象问题（Minor GC 时间太长）</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h2 id="高性能硬件上的程序部署策略"><a href="#高性能硬件上的程序部署策略" class="headerlink" title="高性能硬件上的程序部署策略"></a>高性能硬件上的程序部署策略</h2><p><img src="./pic/%E9%AB%98%E6%80%A7%E8%83%BD%E7%A1%AC%E4%BB%B6%E4%B8%8A%E7%9A%84%E7%A8%8B%E5%BA%8F%E9%83%A8%E7%BD%B2%E7%AD%96%E7%95%A5.png" alt="高性能硬件上的程序部署策略.png"></p>
<blockquote>
<p><strong>补充：64 位虚拟机</strong></p>
<p>在 Java EE 方面，企业级应用经常需要使用超过 4GB 的内存，此时，32 位虚拟机将无法满足需求，可是 64 位虚拟机虽然可以设置更大的内存，却存在以下缺点：</p>
<ul>
<li><strong>内存问题：</strong> 由于指针膨胀和各种数据类型对齐补白的原因，运行于 64 位系统上的 Java 应用程序需要消耗更多的内存，通常要比 32 位系统额外增加 10% ~ 30% 的内存消耗。</li>
<li><strong>性能问题：</strong> 64 位虚拟机的运行速度在各个测试项中几乎全面落后于 32 位虚拟机，两者大概有 15% 左右的性能差距。</li>
</ul>
</blockquote>
<h2 id="服务系统经常出现卡顿（Full-GC-时间太长）"><a href="#服务系统经常出现卡顿（Full-GC-时间太长）" class="headerlink" title="服务系统经常出现卡顿（Full GC 时间太长）"></a>服务系统经常出现卡顿（Full GC 时间太长）</h2><p>首先 <code>jstat -gcutil</code> 观察 GC 的耗时，<code>jstat -gccapacity</code> 检查内存用量（也可以加上 <code>-verbose:gc</code> 参数获取 GC 的详细日志），发现卡顿是由于 Full GC 时间太长导致的，然后 <code>jinfo -v pid</code>，查看虚拟机参数设置，发现 <code>-XX:NewRatio=9</code>，这就是原因：</p>
<ul>
<li>新生代太小，对象提前进入老年代，触发 Full GC</li>
<li>老年代较大，一次 Full GC 时间较长</li>
</ul>
<p>可以调小 NewRatio 的值，尽肯能让比较少的对象进入老年代。</p>
<h2 id="除了-Java-堆和永久代之外，会占用较多内存的区域"><a href="#除了-Java-堆和永久代之外，会占用较多内存的区域" class="headerlink" title="除了 Java 堆和永久代之外，会占用较多内存的区域"></a>除了 Java 堆和永久代之外，会占用较多内存的区域</h2><table>
<thead>
<tr>
<th>区域</th>
<th>大小调整 / 说明</th>
<th>内存不足时抛出的异常</th>
</tr>
</thead>
<tbody><tr>
<td>直接内存</td>
<td><code>-XX:MaxDirectMemorySize</code></td>
<td>OutOfMemoryError: Direct buffer memory</td>
</tr>
<tr>
<td>线程堆栈</td>
<td><code>-Xss</code></td>
<td>StackOverflowError 或 OutOfMemoryError: unable to create new native thread</td>
</tr>
<tr>
<td>Socket 缓存区</td>
<td>每个 Socket 连接都有 Receive(37KB) 和 Send(25KB) 两个缓存区</td>
<td>IOException: Too many open files</td>
</tr>
<tr>
<td>JNI 代码</td>
<td>如果代码中使用 JNI 调用本地库，那本地库使用的内存也不在堆中</td>
<td></td>
</tr>
<tr>
<td>虚拟机和 GC</td>
<td>虚拟机、GC 代码执行要消耗一定内存</td>
<td></td>
</tr>
</tbody></table>
<h2 id="从-GC-调优角度解决新生代存活大量对象问题（Minor-GC-时间太长）"><a href="#从-GC-调优角度解决新生代存活大量对象问题（Minor-GC-时间太长）" class="headerlink" title="从 GC 调优角度解决新生代存活大量对象问题（Minor GC 时间太长）"></a>从 GC 调优角度解决新生代存活大量对象问题（Minor GC 时间太长）</h2><ul>
<li>将 Survivor 空间去除，让新生代中存活的对象在第一次 Minor GC 后立刻进入老年代，等到 Full GC 时再清理。</li>
<li>参数调整方法：<ul>
<li><code>-XX:SurvivorRatio=65536</code></li>
<li><code>-XX:MaxTenuringThreshold=0</code></li>
<li><code>-XX:AlwaysTenure</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop常见参数</title>
    <url>/2024/06/01/Hadoop%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="Hadoop常见参数"><a href="#Hadoop常见参数" class="headerlink" title="Hadoop常见参数"></a>Hadoop常见参数</h1><table>
<thead>
<tr>
<th><strong>配置所在文件</strong></th>
<th><strong>参数</strong></th>
<th><strong>参数默认值</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>hdfs-site.xml</td>
<td>dfs.namenode.support.allow.format</td>
<td>true</td>
<td>表示设置NameNode是否允许被格式化。  在生产系统，把它设置为false，阻止任何格式化操作在一个运行的DFS上。  建议初次格式化后，修改配置禁止，改成false</td>
</tr>
<tr>
<td>hdfs-site.xml</td>
<td>dfs.heartbeat.interval</td>
<td>3</td>
<td>DataNode的心跳间隔，默认单位为秒  在集群网络通信状态不好的时候，适当调大</td>
</tr>
<tr>
<td>hdfs-site.xml</td>
<td>dfs.blocksize</td>
<td>134217728</td>
<td>块大小，默认是128MB  必须得是1024(page size)的整数倍</td>
</tr>
<tr>
<td>hdfs-site.xml</td>
<td>dfs.namenode.checkpoint.period  或者：  fs.checkpoint.period</td>
<td>3600</td>
<td>edits和fsimage文件合并周期阈值，默认单位为s</td>
</tr>
<tr>
<td>hdfs-site.xml</td>
<td>dfs.stream-buffer-size</td>
<td>4096</td>
<td>文件流缓存大小。需要是硬件page大小的整数倍。在读写操作时，数据缓存大小。  注意：是1024的整数倍  注意和core-default.xml中指定文件类型的缓存是不同的，这个是dfs共用的</td>
</tr>
<tr>
<td>mapred-site.xml</td>
<td>mapreduce.task.io.sort.mb</td>
<td>100</td>
<td>任务内部排序缓冲区大小，默认单位是MB  此参数调大，能够减少Spil溢写次数，减少磁盘I/O     建议：250MB~400MB</td>
</tr>
<tr>
<td>mapred-site.xml</td>
<td>mapreduce.map.sort.spill.percent</td>
<td>0.8</td>
<td>Map阶段溢写文件的阈值。不建议修改此值</td>
</tr>
<tr>
<td>mapred-site.xml</td>
<td>mapreduce.reduce.shuffle.parallelcopies</td>
<td>5</td>
<td>ReduceTask  启动的并发拷贝数据的线程数（fetch线程数）  建议，尽可能等于或接近于Map任务数量，达到并行抓取的效果</td>
</tr>
<tr>
<td>mapred-site.xml</td>
<td>mapreduce.job.reduce.slowstart.completedmaps</td>
<td>0.05</td>
<td>当Map任务数量完成率在5%时，Reduce任务启动，这个参数建议不要轻易改动，如果Map任务总量非常大时，可以将此参数调低，让reduce更早开始工作。</td>
</tr>
<tr>
<td>mapred-site.xml</td>
<td>io.sort.factor</td>
<td>10</td>
<td>文件合并（Merge）因子，如果文件数量太多，可以适当调大，从而减少I/O次数</td>
</tr>
<tr>
<td>mapred-site.xml</td>
<td>mapred.<strong>compress</strong>.map.output</td>
<td>false</td>
<td>是否对Map的输出结果文件进行压缩，默认是不压缩。但是如果Map的结果文件很大，可以开启压缩，在Reduce的远程拷贝阶段可以节省网络带宽。</td>
</tr>
<tr>
<td>mapred-site.xml</td>
<td><strong>mapred.map.tasks.speculative.execution</strong></td>
<td>true  <br />==一般设置为false==</td>
<td>启动map任务的推测执行机制       推测执行是Hadoop对“拖后腿”的任务的一种优化机制，当一个作业的某些任务运行速度明显慢于同作业的其他任务时，Hadoop会在另一个节点上为“慢任务”启动一个备份任务，这样两个任务同时处理一份数据，而Hadoop最终会将优先完成的那个任务的结果作为最终结果，并将另一个任务杀掉。     启动推测执行机制的目的是更快的完成job，     但是在集群计算资源紧张时，比如同时在运行很多个job，启动推测机制可能会带来相反效果。如果是这样，就改成false。     对于这个参数的控制，轻易不要改动。</td>
</tr>
<tr>
<td>mapred-site.xml</td>
<td>mapred.reduce.tasks.speculative.execution</td>
<td>true<br />==一般设置为false==</td>
<td>启动reduce任务的推测执行机制</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Big Data</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop简介</title>
    <url>/2024/05/26/Hadoop%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="Hadoop简介"><a href="#Hadoop简介" class="headerlink" title="Hadoop简介"></a>Hadoop简介</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>Hadoop：开源分布式存储、计算矿框架。免费试用</p>
<p>CHD：Hadoop的一个发行版本，可以一键式部署集群，但是是收费的，非常昂贵</p>
</blockquote>
<ol>
<li><p>Hadoop是Yahoo 开发，后来贡献给了Apache的一套开源的、可靠的、可扩展的（可伸缩的）用于进行分布式计算的框架</p>
</li>
<li><p>Hadoop之父：Doug Cutting（道格·卡丁）</p>
</li>
<li><p>Hadoop的版本管理非常混乱（最新更新版本2.10，版本最新确实3.2）</p>
<p><img src="https://gitee.com/sxhDrk/images/raw/master/imgs/Hadoop%E5%AE%8C%E5%85%A8%E5%88%86%E5%B8%83%E5%BC%8F-3%E4%B8%AA%E8%8A%82%E7%82%B9.png"></p>
</li>
</ol>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><ol>
<li>Hadoop Common：基本模块，支撑其他模块运行</li>
<li>Hadoop Distributed File System (HDFS™)：分布式存储</li>
<li>Hadoop YARN：任务调度和集群资源管理</li>
<li>Hadoop MapReduce：分布式计算</li>
<li>Hadoop Ozone：对象存储</li>
</ol>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><ol>
<li>Hadoop 1.0：包含Common、HDFS、MapReduce</li>
<li>Hadoop 2.0：包含Common、HDFS、MapReduce和YARN<ul>
<li>从Hadoop 2.7开始包含了Ozone</li>
<li>从Hadoop 2.9开始包含了Submarine</li>
<li>==Hadoop 1.0和Hadoop 2.0不兼容==</li>
</ul>
</li>
<li>Hadoop 3.0：包含Common、HDFS、MapReduce和YARN<ul>
<li>从Hadoop 3.1开始包含了Ozone</li>
<li>从Hadoop 3.1最新版本中包含了Submarine</li>
</ul>
</li>
</ol>
<h2 id="相关组件"><a href="#相关组件" class="headerlink" title="相关组件"></a>相关组件</h2><ol>
<li>HBase: 类似Google BigTable的分布式NoSQL列数据库。（HBase和Avro已经于2010年5月成为顶级     Apache 项目）</li>
<li>Hive：数据仓库工具，由Facebook贡献</li>
<li>Zookeeper：分布式锁设施，提供类似Google  Chubby的功能，由Facebook贡献</li>
<li>Avro：新的数据序列化格式与传输工具，将逐步取代Hadoop原有的IPC机制。</li>
<li>Pig:     大数据分析平台，为用户提供多种接口</li>
<li>Ambari：Hadoop管理工具，可以快捷的监控、部署、管理集群</li>
<li>Sqoop：用在Hadoop与传统的数据库间进行数据的传递</li>
</ol>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><blockquote>
<p>开启Hadoop：start-all.sh</p>
<p>关闭Hadoop：stop-all.sh</p>
</blockquote>
<h2 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a>单机模式</h2><p>只能启动MapReduce，所以不使用单机模式</p>
<h2 id="伪分布式"><a href="#伪分布式" class="headerlink" title="伪分布式"></a>伪分布式</h2><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><blockquote>
<p>能启动HDFS、MapReduce、Yran的大部分功能</p>
</blockquote>
<ol>
<li><p>关闭防火墙</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">service iptables stop</span><br><span class="line">chkconfig iptables off</span><br></pre></td></tr></table></figure></li>
<li><p>修改云主机的主机名，Hadoop集群中要求主机名中不能出现<code>-</code>或者<code>_</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/sysconfig</span><br><span class="line">vim network</span><br></pre></td></tr></table></figure>

<p>修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HOSTNAME&#x3D;hadoop01</span><br></pre></td></tr></table></figure>

<p>保存退出，重新生效</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> network</span><br></pre></td></tr></table></figure></li>
<li><p>需要将IP和主机名进行映射</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc</span><br><span class="line">vim hosts</span><br></pre></td></tr></table></figure>

<p>添加host映射</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">10.9.162.133 hadoop01</span><br></pre></td></tr></table></figure></li>
<li><p>重启</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure></li>
<li><p>配置免密登录</p>
<p>产生密钥：<code>ssh-keygen</code></p>
<p>拷贝密钥：<code>ssh-copy-id root@hadoop01</code></p>
<p>测试是否能够免密登录：<code>ssh hadoop01</code></p>
<p>如果成功，则退出：<code>logout</code></p>
</li>
<li><p>下载Hadoop的安装包</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget http://bj-yzjd.ufile.cn-north-02.ucloud.cn/hadoop-alone.tar.gz</span><br></pre></td></tr></table></figure></li>
<li><p>解压安装包</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -xvf hadoop-alone.tar.gz</span><br></pre></td></tr></table></figure></li>
<li><p>配置环境变量</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure>

<p>文件末尾添加</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> HADOOP_HOME=/home/software/hadoop-2.7.1</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$HADOOP_HOME</span>/bin:<span class="variable">$HADOOP_HOME</span>/sbin</span><br></pre></td></tr></table></figure>

<p>保存退出，重新生效</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure></li>
<li><p>格式化<code>namenode</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hadoop namenode -format</span><br></pre></td></tr></table></figure>

<p>如果出现</p>
<p><code>Storage directory /home/software/hadoop-2.7.1/tmp/dfs/name has been successfully formatted.</code></p>
<p>表示格式化成功</p>
</li>
<li><p>启动hadoop</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">start-all.sh</span><br></pre></td></tr></table></figure>

<p>通过jps查看，有6个进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Jps</span><br><span class="line">NameNode</span><br><span class="line">DataNode</span><br><span class="line">SecondaryNameNode</span><br><span class="line">ResourceManager</span><br><span class="line">NodeManager</span><br></pre></td></tr></table></figure></li>
<li><p>通过网页浏览</p>
<p>可以通过浏览器访问HDFS的页面，访问地址为：IP地址:50070</p>
<p>可以通过浏览器访问Yarn的页面，访问地址为：IP地址:8088</p>
</li>
</ol>
<h3 id="配置文件的修改"><a href="#配置文件的修改" class="headerlink" title="配置文件的修改"></a>配置文件的修改</h3><blockquote>
<p>进入：<code>cd hadoop-2.7.1/etc/hadoop</code></p>
</blockquote>
<ol>
<li><p>配置<code>hadoop-env.sh</code></p>
<ul>
<li><p>编辑hadoop-env.sh:<code>vim hadoop-env.sh</code></p>
</li>
<li><p>修改JAVA_HOME的路径：</p>
<p><code>export JAVA_HOME=/home/software/jdk1.8</code></p>
</li>
<li><p>修改HADOOP_CONF_DIR的路径</p>
<p><code>export HADOOP_CONF_DIR=/home/software/hadoop-2.7.1/etc/hadoop</code></p>
</li>
<li><p>保存退出</p>
</li>
<li><p>重新生效：<code>source hadoop-env.sh</code></p>
</li>
</ul>
</li>
<li><p>配置<code>core-site.xml</code></p>
<ul>
<li><p>编辑core-site.xml：<code>vim core-site.xml</code></p>
</li>
<li><p>指定如下内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定HDFS中的主节点 - namenode --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span>               </span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop01:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 执行Hadoop运行时的数据存放目录 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/software/hadoop-2.7.1/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>保存退出</p>
</li>
</ul>
</li>
<li><p>配置<code>hdfs-site.xml</code></p>
<ul>
<li><p>编辑文件：<code>vim hdfs-site.xml</code></p>
</li>
<li><p>添加如下内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置HDFS中的副本数量 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在伪分布式下，值设置为1 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>保存退出</p>
</li>
</ul>
</li>
<li><p>配置<code>mapred-site.xml</code></p>
<ul>
<li><p>将<code>mapred-site.xml.template</code>复制为<code>mapred-site.xml</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cp mapred-site.xml.template mapred-site.xml</span><br></pre></td></tr></table></figure></li>
<li><p>编辑新文件：<code>vim mapred-site.xml</code></p>
</li>
<li><p>添加如下配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定将MapReduce在Yarn上运行  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>保存退出</p>
</li>
</ul>
</li>
<li><p>配置<code>yarn-site.xml</code></p>
<ul>
<li><p>编辑yarn-site.xml：<code>vim yarn-site.xml</code></p>
</li>
<li><p>添加如下内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 指定Yarn的主节点 - resourcemanager --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop01<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- NodeManager的数据获取方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>保存退出</p>
</li>
</ul>
</li>
<li><p>配置<code>slaves</code></p>
<ul>
<li>编辑slaves：<code>vim slaves</code></li>
<li>添加从节点信息，例如：hadoop01</li>
<li>保存退出</li>
</ul>
</li>
</ol>
<h2 id="完全分布式"><a href="#完全分布式" class="headerlink" title="完全分布式"></a>完全分布式</h2><blockquote>
<p>能启动Hadoop的所有功能</p>
</blockquote>
<p><img src="https://gitee.com/sxhDrk/images/raw/master/imgs/%E5%AE%8C%E5%85%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%93%E6%9E%84.png"></p>
<blockquote>
<p>如上图所示，完全分布式的Hadoop的结构，最少需要13个节点，才能保证高可用，也就是最少需要13台服务器</p>
</blockquote>
<p>只有三台服务器，在三台服务器上搭建Hadoop完全分布式集群</p>
<p><img src="https://gitee.com/sxhDrk/images/raw/master/imgs/Hadoop%E7%89%88%E6%9C%AC%E6%B7%B7%E4%B9%B1.png"></p>
<h3 id="环境配置-1"><a href="#环境配置-1" class="headerlink" title="环境配置"></a>环境配置</h3><blockquote>
<p>因为第一台 服务器搭建过伪分布式，所以需要将伪分布式Hadoop文件重命名</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/software/</span><br><span class="line">mv hadoop-2.7.1/ hadoop-alone</span><br></pre></td></tr></table></figure>



<ol>
<li><p>三台云主机关闭防火墙</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">service iptables stop</span><br><span class="line">chkconfig iptables off</span><br></pre></td></tr></table></figure></li>
<li><p>修改三台云主机的主机名</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim /etc/sysconfig/network</span><br></pre></td></tr></table></figure>

<p>修改HOSTNAME属性，依次改为hadoop01、hadoop02、hadoop03</p>
<p>保存退出，并且重新生效</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/sysconfig/network</span><br></pre></td></tr></table></figure></li>
<li><p>三台云主机添加IP映射</p>
<blockquote>
<p>编辑hosts文件<code>vim /etc/hosts</code>，添加如下内容</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">10.9.162.133 hadoop01</span><br><span class="line">10.9.152.65 hadoop02</span><br><span class="line">10.9.130.83 hadoop03</span><br></pre></td></tr></table></figure></li>
<li><p>三台云主机重启：<code>reboot</code></p>
</li>
<li><p>三台云主机开启Zookeeper</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/software/zookeeper-3.4.8/bin </span><br><span class="line">sh zkServer.sh start	<span class="comment">#开启Zookeeper</span></span><br><span class="line">sh zkServer.sh status	<span class="comment">#检查Zookeeper的状态，应该为2个follower1个leader</span></span><br></pre></td></tr></table></figure></li>
<li><p>返回第一个节点software目录下：<code>cd /home/software</code></p>
</li>
<li><p>下载Hadoop完全分布式的安装包</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget http://bj-yzjd.ufile.cn-north-02.ucloud.cn/hadoop-dist.tar.gz</span><br></pre></td></tr></table></figure></li>
<li><p>三台机器进行免密登录</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br><span class="line">ssh-copy-id	root@hadoop01</span><br><span class="line">ssh-copy-id	root@hadoop02</span><br><span class="line">ssh-copy-id	root@hadoop03</span><br></pre></td></tr></table></figure>

<p>三台集器测试：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh hadoop01 <span class="comment">#如果不需要密码logout</span></span><br><span class="line">ssh hadoop02 <span class="comment">#如果不需要密码logout</span></span><br><span class="line">ssh hadoop03 <span class="comment">#如果不需要密码logout</span></span><br></pre></td></tr></table></figure></li>
<li><p>解压安装包</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -xvf hadoop-dist.tar.gz</span><br></pre></td></tr></table></figure></li>
<li><p>将Hadoop的安装包拷贝到其他两个节点上</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">scp -r hadoop-2.7.1/ root@hadoop02:/home/software/</span><br><span class="line">scp -r hadoop-2.7.1/ root@hadoop03:/home/software/</span><br></pre></td></tr></table></figure></li>
<li><p>三台节点配置环境变量</p>
<blockquote>
<p>修改文件：<code>vim /etc/profile</code></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> HADOOP_HOME=/home/software/hadoop-2.7.1</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$HADOOP_HOME</span>/bin:<span class="variable">$HADOOP_HOME</span>/sbin</span><br></pre></td></tr></table></figure>

<p>保存退出，并且重新生效：<code>source /etc/profile</code></p>
</li>
<li><p>在任意一个节点格式化Zookeeper</p>
<blockquote>
<p>实际上就是在Zookeeper中注册Hadoop节点</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hdfs zkfc -formatZK</span><br></pre></td></tr></table></figure>

<p>如果成功，日志会显示：<code>Successfully created /hadoop-ha/ns in ZK</code></p>
<p>如果出现：<code>HA is not available</code>，说明系统兼容性不够，重装系统解决</p>
</li>
<li><p>三台云主机启动<code>JournalNode</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hadoop-daemon.sh start journalnode</span><br></pre></td></tr></table></figure></li>
<li><p>在第一个节点上格式化<code>NameNode</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hadoop namenode -format</span><br></pre></td></tr></table></figure>

<p>如果格式化成功，则出现：<code>Storage directory /home/software/hadoop-2.7.1/tmp/hdfs/name has been successfully formatted. </code></p>
</li>
<li><p>在第一个节点上启动NameNode</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hadoop-daemon.sh start namenode</span><br></pre></td></tr></table></figure></li>
<li><p>在第二个节点上格式化NameNode</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hdfs namenode -bootstrapStandby</span><br></pre></td></tr></table></figure>

<p>如果格式化成功，则出现：<code>Storage directory /home/software/hadoop-2.7.1/tmp/hdfs/name has been successfully formatted.</code></p>
</li>
<li><p>在第二个节点启动NameNode</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hadoop-daemon.sh start namenode</span><br></pre></td></tr></table></figure></li>
<li><p>在==三个节点上都启动==DataNode</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hadoop-daemon.sh start datanode</span><br></pre></td></tr></table></figure></li>
<li><p>在==第三个节点==上启动YARN</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">start-yarn.sh</span><br></pre></td></tr></table></figure></li>
<li><p>在第一个节点上启动ResourceManager</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yarn-daemon.sh start resourcemanager</span><br></pre></td></tr></table></figure></li>
<li><p>在第一个和第二个节点上启动zkfc</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hadoop-daemon.sh start zkfc</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>如果都启动成功，通过jps查看：</p>
<ul>
<li><p>第一个节点出现8个进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- Jps</span><br><span class="line">- NameNode</span><br><span class="line">- DataNode</span><br><span class="line">- JournalNode</span><br><span class="line">- ResourceManager</span><br><span class="line">- NodeManager</span><br><span class="line">- DFSZKFailoverController</span><br><span class="line">- QuorumPeerMain</span><br></pre></td></tr></table></figure></li>
<li><p>第二个节点出现7个进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- Jps</span><br><span class="line">- NameNode</span><br><span class="line">- DataNode</span><br><span class="line">- JournalNode</span><br><span class="line">- NodeManager</span><br><span class="line">- DFSZKFailoverController</span><br><span class="line">- QuorumPeerMain</span><br></pre></td></tr></table></figure></li>
<li><p>第三个节点出现6个进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- Jps</span><br><span class="line">- DataNode</span><br><span class="line">- JournalNode</span><br><span class="line">- ResourceManager</span><br><span class="line">- NodeManager</span><br><span class="line">- QuorumPeerMain</span><br></pre></td></tr></table></figure></li>
</ul>
<p>如果少了QuorumPeerMain，表示Zookeeper启动出错</p>
<p>如果少了NameNode/DataNode/JournalNode/DFSZKFailoverController</p>
<ul>
<li>可以通过<code>hadoop-daemon.sh start namenode/datanode/journalnode/zkfc</code></li>
</ul>
<p>如果少了ResourceManager/NodeManager</p>
<ul>
<li>可以通过<code>yarn-daemon.sh start resourcemanager/nodemanager</code></li>
</ul>
<p>==Hadoop完全分布式开启，需要先启动ZooKeeper，再开Hadoop==</p>
</blockquote>
<h3 id="配置文件的修改-1"><a href="#配置文件的修改-1" class="headerlink" title="配置文件的修改"></a>配置文件的修改</h3><blockquote>
<p>上述下载的Hadoop的jar包中已经配置好了</p>
</blockquote>
<ol>
<li><p>编辑core-site.xml，添加如下内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--指定hdfs的nameservice，为整个集群起一个别名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span>                </span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://ns<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--指定Hadoop数据临时存放目录--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/software/hadoop-2.7.1/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--指定zookeeper的存放地址--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>ha.zookeeper.quorum<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop01:2181,hadoop02:2181,hadoop03:2181<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br></pre></td></tr></table></figure></li>
<li><p>编辑hdfs-site.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--执行hdfs的nameservice为ns，注意要和core-site.xml中的名称保持一致--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.nameservices<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>ns<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--ns集群下有两个namenode，分别为nn1, nn2--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.ha.namenodes.ns<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>nn1,nn2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--nn1的RPC通信--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.rpc-address.ns.nn1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop01:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--nn1的http通信--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.http-address.ns.nn1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop01:50070<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- nn2的RPC通信地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.rpc-address.ns.nn2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop02:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- nn2的http通信地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.http-address.ns.nn2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop02:50070<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--指定namenode的元数据在JournalNode上存放的位置，这样，namenode2可以从journalnode集群里的指定位置上获取信息，达到热备效果--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.shared.edits.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>qjournal://hadoop01:8485;hadoop02:8485;hadoop03:8485/ns<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定JournalNode在本地磁盘存放数据的位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.journalnode.edits.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/software/hadoop-2.7.1/tmp/journal<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启NameNode故障时自动切换 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.ha.automatic-failover.enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置失败自动切换实现方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.client.failover.proxy.provider.ns<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置隔离机制 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.ha.fencing.methods<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>sshfence<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用隔离机制时需要ssh免登陆 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.ha.fencing.ssh.private-key-files<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/root/.ssh/id_rsa<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置namenode存放元数据的目录，可以不配置，如果不配置则默认放到hadoop.tmp.dir下--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:///home/software/hadoop-2.7.1/tmp/hdfs/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    </span><br><span class="line"><span class="comment">&lt;!--配置datanode存放元数据的目录，可以不配置，如果不配置则默认放到hadoop.tmp.dir下--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:///home/software/hadoop-2.7.1/tmp/hdfs/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置副本数量--&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>3<span class="tag">&lt;/<span class="name">value</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>   </span><br><span class="line"><span class="comment">&lt;!--设置用户的操作权限，false表示关闭权限验证，任何用户都可以操作--&gt;</span>                                                                    </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.permissions<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br></pre></td></tr></table></figure></li>
<li><p>编辑mapred-site.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br></pre></td></tr></table></figure></li>
<li><p>编辑yarn-site.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置yarn的高可用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.ha.enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--指定两个resourcemaneger的名称--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.ha.rm-ids<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>rm1,rm2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置rm1的主机--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname.rm1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop01<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置rm2的主机--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname.rm2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop03<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--开启yarn恢复机制--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.recovery.enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--执行rm恢复机制实现类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.store.class<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.hadoop.yarn.server.resourcemanager.recovery.ZKRMStateStore<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置zookeeper的地址--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.zk-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop01:2181,hadoop02:2181,hadoop03:2181<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--执行yarn集群的别名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.cluster-id<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>ns-yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定nodemanager启动时加载server的方式为shuffle server --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 指定resourcemanager地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop03<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h1>]]></content>
      <categories>
        <category>Big Data</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Java设计模式及UML类图</title>
    <url>/2024/05/05/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8F%8AUML%E7%B1%BB%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>[TOC]</p>
<h1 id="23种设计模式"><a href="#23种设计模式" class="headerlink" title="23种设计模式"></a>23种设计模式</h1><h2 id="GOF"><a href="#GOF" class="headerlink" title="GOF"></a>GOF</h2><p>在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 <strong>Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）</strong> 的书，该书首次提到了软件开发中设计模式的概念。</p>
<p>四位作者合称 <strong>GOF（四人帮，全拼 Gang of Four）</strong>。他们所提出的设计模式主要是基于以下的面向对象设计原则。</p>
<ul>
<li>对接口编程而不是对实现编程。</li>
<li>优先使用对象组合而不是继承。</li>
</ul>
<h2 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h2><p><a href="https://www.runoob.com/design-pattern/design-pattern-intro.html">参考网址</a></p>
<table>
<thead>
<tr>
<th align="left">模式类型</th>
<th align="center">模式 &amp; 描述</th>
<th align="left">包括</th>
</tr>
</thead>
<tbody><tr>
<td align="left">创建型模式</td>
<td align="center">这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，<br />而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</td>
<td align="left">单例模式（Singleton Pattern）<br />原型模式（Prototype Pattern）<br />工厂模式（Factory Pattern）<br />抽象工厂模式（Abstract Factory Pattern）<br />建造者模式（Builder Pattern）</td>
</tr>
<tr>
<td align="left">结构型模式</td>
<td align="center">这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td>
<td align="left">代理模式（Proxy Pattern）<br />适配器模式（Adapter Pattern）<br />桥接模式（Bridge Pattern）<br />组合模式（Composite Pattern）<br />装饰器模式（Decorator Pattern）<br />外观模式（Facade Pattern）<br />享元模式（Flyweight Pattern）</td>
</tr>
<tr>
<td align="left">行为型模式</td>
<td align="center">这些设计模式特别关注对象之间的通信。</td>
<td align="left">模板模式（Template Pattern）<br />策略模式（Strategy Pattern）<br />命令模式（Command Pattern）<br />责任链模式（Chain of Responsibility Pattern）<br />状态模式（State Pattern）<br />观察者模式（Observer Pattern）<br />中介者模式（Mediator Pattern）<br />迭代器模式（Iterator Pattern）<br />访问者模式（Visitor Pattern）<br />备忘录模式（Memento Pattern）<br />解释器模式（Interpreter Pattern）<br /></td>
</tr>
<tr>
<td align="left">J2EE 模式</td>
<td align="center">这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。</td>
<td align="left">MVC 模式（MVC Pattern）<br />业务代表模式（Business Delegate Pattern）<br />组合实体模式（Composite Entity Pattern）<br />数据访问对象模式（Data Access Object Pattern）<br />前端控制器模式（Front Controller Pattern）<br />拦截过滤器模式（Intercepting Filter Pattern）<br />服务定位器模式（Service Locator Pattern）<br />传输对象模式（Transfer Object Pattern）</td>
</tr>
</tbody></table>
<h2 id="设计模式七大原则"><a href="#设计模式七大原则" class="headerlink" title="设计模式七大原则"></a>设计模式七大原则</h2><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p><strong>定义</strong></p>
<p>一个类应该只负责一项职责</p>
<p><strong>目的</strong></p>
<ul>
<li>降低类的复杂度</li>
<li>提高类的可读性，可维护性</li>
</ul>
<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p><strong>定义</strong></p>
<p>一个类对另一个类的依赖应该建立在最小接口上。</p>
<p><strong>目的</strong></p>
<p>降低类之间的耦合度</p>
<p><strong>实现</strong></p>
<p>尽可能对接口进行拆分</p>
<h3 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h3><p><strong>定义</strong></p>
<p><strong>面向接口编程</strong>，针对接口编程，依赖于抽象而不依赖于具体。</p>
<p><strong>目的</strong></p>
<p>编程时，制定好规范，而不涉及具体实现操作，增加代码通用性和稳定性。</p>
<p><strong>实现</strong></p>
<p>利用了多态性</p>
<h3 id="里式替换原则"><a href="#里式替换原则" class="headerlink" title="里式替换原则"></a>里式替换原则</h3><p><strong>定义</strong></p>
<p><strong>继承必须确保超类所拥有的性质在子类中仍然成立</strong>。里式替换原则说明继承实际上让两个类的耦合程度增加，在适当情况下，应该使用聚合，组合，依赖等形式组织类之间的关系。</p>
<p><strong>目的</strong></p>
<ul>
<li>类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性</li>
<li>里氏替换原则是实现开闭原则的重要方式之一</li>
</ul>
<p><strong>实现</strong></p>
<p>子类尽量不要重写父类中的方法</p>
<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p><strong>定义</strong></p>
<p><strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果</p>
<p><strong>目的</strong></p>
<ul>
<li>提高代码复用能力</li>
<li>提高软件可维护性，方便进行软件测试。后期扩展只需要测试新添加部分，因为原有代码未受到影响</li>
</ul>
<p><strong>实现</strong></p>
<p>使用接口和抽象类</p>
<h3 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h3><p><strong>定义</strong></p>
<p>又称最小知道原则，<strong>一个类只与直接朋友通信</strong>，即一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立</p>
<p>直接朋友：成员变量，方法参数，方法返回值中的类。局部变量中的类不是直接朋友</p>
<p><strong>目的</strong></p>
<ul>
<li>减少类之间的耦合度，提高模块独立性</li>
<li>提高类的可复用率和系统的扩展性</li>
</ul>
<p><strong>实现</strong></p>
<p>使用中介类来解耦</p>
<h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p><strong>定义</strong></p>
<p>通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用</p>
<p>继承复用破坏了类的封装性，将父类的实现细节暴露给子类，也称“白箱复用”。</p>
<p><strong>目的</strong></p>
<ul>
<li>维持类的封装性，合成复用也称“黑箱复用”</li>
<li>降低耦合度</li>
<li>复用更加灵活，针对接口进行编程。</li>
</ul>
<p><strong>实现</strong></p>
<p><strong>尽量使用合成/聚合的方式，而不是使用继承</strong></p>
<p><strong>示例</strong></p>
<img src="https://gitee.com/fangjie1229/node_pictures/raw/master/img/image-20200627152347918.png" alt="image-20200627152347918" style="zoom: 67%;" />

<img src="Java设计模式及UML类图.assets/image-20200627152432899.png" alt="image-20200627152432899" style="zoom:67%;" />



<h2 id="创建型模式-5种"><a href="#创建型模式-5种" class="headerlink" title="创建型模式(5种)"></a>创建型模式(5种)</h2><p>创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。就像我们去商场购买商品时，不需要知道商品是怎么生产出来一样，因为它们由专门的厂商生产。</p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>一个类只有一个实例，且该类能自行创建这个实例的一种模式。</p>
<p><strong>作用</strong></p>
<p>节省内存资源、保证数据内容的一致性</p>
<p><strong>示例</strong></p>
<p>静态内部类式单例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SingleTon</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTonHoler</span></span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> SingleTon INSTANCE = <span class="keyword">new</span> SingleTon();</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SingleTonHoler.INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举单例</p>
<ul>
<li>反序列化后生成对象和原来对象是同一个对象</li>
<li>避免反射攻击（因为枚举类的构造方法继承自Enum类，在newInstance时，会检查当前类是不是Enum类，如果是则抛出异常）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">xx</span></span>&#123;</span><br><span class="line">	INSTANCE(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;fj&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">(String id,String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象，即<strong>克隆</strong>。</p>
<p><strong>作用</strong></p>
<p>在有些系统中，存在大量相同或相似对象的创建问题，如果用传统的构造函数来创建对象，会比较复杂且耗时耗资源，用原型模式生成对象就很<strong>高效</strong></p>
<h4 id="浅度克隆"><a href="#浅度克隆" class="headerlink" title="浅度克隆"></a>浅度克隆</h4><p><strong>定义</strong></p>
<p>只负责克隆按值传递的数据（比如基本数据类型、String类型），而不复制它所引用的对象，换言之，所有的对其他对象的引用都仍然指向原来的对象。</p>
<p><strong>示例</strong></p>
<p>Java中clone函数就是一个浅度克隆</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Monkey</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 浅克隆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Object temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            temp = <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Monkey monkey = <span class="keyword">new</span> Monkey();</span><br><span class="line">    Monkey copyMonkey = (Monkey)monkey.clone();</span><br><span class="line">    System.out.println(<span class="string">&quot;大圣本尊的生日是：&quot;</span> + monkey.getBirthDate());</span><br><span class="line">    System.out.println(<span class="string">&quot;克隆的大圣的生日是：&quot;</span> + monkey.getBirthDate());</span><br><span class="line">    System.out.println(<span class="string">&quot;大圣本尊跟克隆的大圣是否为同一个对象 &quot;</span> + (monkey == copyMonkey));</span><br><span class="line">    System.out.println(<span class="string">&quot;大圣本尊持有的金箍棒 跟 克隆的大圣持有的金箍棒是否为同一个对象？ &quot;</span> + (monkey.getStaff() == copyMonkey.getStaff()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>![img](Java设计模式及UML类图.assets/Sat, 27 Jun 2020 171122.png)</p>
<h4 id="深度克隆"><a href="#深度克隆" class="headerlink" title="深度克隆"></a>深度克隆</h4><p><strong>定义</strong></p>
<p>既克隆的值，还克隆引用类型的数据。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。</p>
<p>换言之，<strong>深度克隆把要复制的对象所引用的对象都复制了一遍</strong>，而这种对被引用到的对象的复制叫做<strong>间接复制</strong>。</p>
<p><strong>注意</strong></p>
<ul>
<li><strong>深度克隆要深入到多少层，是一个不易确定的问题</strong>。在决定以深度克隆的方式复制一个对象的时候，必须决定对间接复制的对象时采取浅度克隆还是继续采用深度克隆。因此，在采取深度克隆时，需要决定多深才算深。此外，在深度克隆的过程中，很可能会出现<strong>循环引用</strong>的问题，必须小心处理</li>
<li>==一般使用序列化和反序列机制来实现深度克隆==</li>
<li><strong>对象以及对象内部所有引用到的对象都是可序列化的</strong>，否则，就需要仔细考察那些不可序列化的对象可否设成transient，从而将之排除在复制过程之外。</li>
<li>有一些对象，比如线程(Thread)对象或Socket对象，是不能简单复制或共享的。不管是使用浅度克隆还是深度克隆，只要涉及这样的间接对象，就必须把间接对象设成transient而不予复制；或者由程序自行创建出相当的同种对象，权且当做复制件使用</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现序列化接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Monkey</span> <span class="keyword">implements</span> <span class="title">Serializable</span>  </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 深克隆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Object <span class="title">deepClone</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>&#123;</span><br><span class="line">        <span class="comment">//将对象写到流里</span></span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">        oos.writeObject(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//从流里读回来</span></span><br><span class="line">        ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">        <span class="keyword">return</span> ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoldRingedStaff</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Monkey monkey = <span class="keyword">new</span> Monkey();</span><br><span class="line">    Monkey copyMonkey = (Monkey)monkey.clone();</span><br><span class="line">    System.out.println(<span class="string">&quot;大圣本尊的生日是：&quot;</span> + monkey.getBirthDate());</span><br><span class="line">    System.out.println(<span class="string">&quot;克隆的大圣的生日是：&quot;</span> + monkey.getBirthDate());</span><br><span class="line">    System.out.println(<span class="string">&quot;大圣本尊跟克隆的大圣是否为同一个对象 &quot;</span> + (monkey == copyMonkey));</span><br><span class="line">    System.out.println(<span class="string">&quot;大圣本尊持有的金箍棒 跟 克隆的大圣持有的金箍棒是否为同一个对象？ &quot;</span> + (monkey.getStaff() == copyMonkey.getStaff()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>![img](Java设计模式及UML类图.assets/Sat, 27 Jun 2020 171432.png)</p>
<h4 id="带原型管理器的原型模式"><a href="#带原型管理器的原型模式" class="headerlink" title="带原型管理器的原型模式"></a>带原型管理器的原型模式</h4><p>在原型模式的基础上增加了一个原型管理器 PrototypeManager 类。该类用 HashMap 保存多个复制的原型（实现同一接口的），Client 类可以通过管理器的 get(String id) 方法从中获取复制的原型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> <span class="keyword">extends</span> <span class="title">Cloneable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>;    <span class="comment">//拷贝</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countArea</span><span class="params">()</span></span>;    <span class="comment">//计算面积</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countArea</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countArea</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProtoTypeManager</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Shape&gt;ht=<span class="keyword">new</span> HashMap&lt;String,Shape&gt;(); </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProtoTypeManager</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ht.put(<span class="string">&quot;Circle&quot;</span>,<span class="keyword">new</span> Circle());</span><br><span class="line">        ht.put(<span class="string">&quot;Square&quot;</span>,<span class="keyword">new</span> Square());</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addshape</span><span class="params">(String id,Shape obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ht.put(id,obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Shape temp=ht.get(id);</span><br><span class="line">        <span class="keyword">return</span> (Shape) temp.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtoTypeShape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ProtoTypeManager pm=<span class="keyword">new</span> ProtoTypeManager();    </span><br><span class="line">        Shape obj1=(Circle)pm.getShape(<span class="string">&quot;Circle&quot;</span>);</span><br><span class="line">        obj1.countArea();          </span><br><span class="line">        Shape obj2=(Shape)pm.getShape(<span class="string">&quot;Square&quot;</span>);</span><br><span class="line">        obj2.countArea();     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。我们把被创建的对象称为<strong>产品</strong>，把创建产品的对象称为<strong>工厂</strong></p>
<p>工厂中也可以使用一个Map来缓存产品，下次创建直接从Map中获取，这就成了<strong>享元模式</strong>。</p>
<p><strong>工厂模式分类</strong></p>
<ul>
<li><p>简单工厂模式：多个产品实现相同接口，工厂根据id生产具体类型的产品</p>
<img src="https://www.runoob.com/wp-content/uploads/2014/08/AB6B814A-0B09-4863-93D6-1E22D6B07FF8.jpg" alt="工厂模式的 UML 图" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">   <span class="comment">//使用 getShape 方法获取形状类型的对象</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(shapeType == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;        </span><br><span class="line">      <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;CIRCLE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;RECTANGLE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;SQUARE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>工厂方法模式：多个产品实现相同接口，工厂中不同方法生产不同的产品</p>
<p><img src="Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8F%8AUML%E7%B1%BB%E5%9B%BE.assets/aHR0cDovL2RsLml0ZXllLmNvbS91cGxvYWQvYXR0YWNobWVudC8wMDgzLzExODEvODQ2NzNjY2YtZWY4OS0zNzc0LWI1Y2YtNmQyNTIzY2QwM2U1LmpwZw" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sender <span class="title">produceMail</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MailSender();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sender <span class="title">produceSms</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类，绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。</p>
<p><strong>和工厂模式不同之处</strong></p>
<p>工厂模式：仅仅针对产品的生成</p>
<p>抽象工厂模式：针对产品族中的产品，即选择哪个工厂，就只能使用该工厂提供的产品</p>
<p>进一步说明：车的种类有汽车、摩托车、货车，飞机的种类有客机，战斗机，车和飞机的品牌有奔驰、宝马。</p>
<p>工厂模式只能选择车的种类</p>
<p>抽象工厂模式先选择车的品牌（生产商），然后再选择车的种类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ------------------------------产品1</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Automobile</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trunk</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Motorbike</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ---------------------------------产品2</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Plane</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Airliner</span> <span class="keyword">implements</span> <span class="title">Plane</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Warcraft</span> <span class="keyword">implements</span> <span class="title">Plane</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ----------------------------------工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Brand</span></span>&#123;</span><br><span class="line">    <span class="function">Car <span class="title">produceCar</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Plane <span class="title">producePlane</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMW</span> <span class="keyword">implements</span> <span class="title">Brand</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Benz</span> <span class="keyword">implements</span> <span class="title">Brand</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>建造者模式是用于构建复杂对象，且复杂对象通常由多个子部件<strong>按一定的步骤组合</strong>而成</p>
<p><strong>建造者模式的主要角色</strong></p>
<ol>
<li>产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个部件（实际产品）。</li>
<li>抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回产品的方法 getResult()。</li>
<li>具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。</li>
<li>指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息（实现构造复杂对象时的<strong>逻辑</strong>）。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//产品 ---------------------------</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String partA;<span class="comment">//必要</span></span><br><span class="line">    <span class="keyword">private</span> String partB;<span class="comment">//必要</span></span><br><span class="line">	<span class="keyword">private</span> String partC;<span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">private</span> String partD;<span class="comment">//可选</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">(String partA,String partB)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.partA = partA;</span><br><span class="line">        <span class="keyword">this</span>.partB = partB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPartC</span><span class="params">(String partC)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.partC = partC;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPartD</span><span class="params">(String partD)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.partD = partD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象建造者 ------------------------</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">class</span> <span class="title">Builder</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPartC</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPartD</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//创建产品对象</span></span><br><span class="line">    <span class="function">Product <span class="title">getProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体建造者 --------------------------</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">implements</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Product product;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteBuilder</span><span class="params">(String partA,String partB)</span></span>&#123;</span><br><span class="line">        product = <span class="keyword">new</span> Product(partA,partB);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPartC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        product.setPartC(<span class="string">&quot;PartC&quot;</span>);<span class="comment">//这里是默认配置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPartD</span><span class="params">()</span></span>&#123;</span><br><span class="line">        product.setPartD(<span class="string">&quot;PartC&quot;</span>);<span class="comment">//这里是默认配置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getProduct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指挥者 --------------------------------</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder=builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//产品构建与组装方法，返回产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 组件C和组件D有特定的构建顺序</span></span><br><span class="line">        builder.buildPartC();</span><br><span class="line">        builder.buildPartD();</span><br><span class="line">        <span class="keyword">return</span> builder.getProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主函数 -------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mian</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Builder builder = <span class="keyword">new</span> Builder(partA,partB);</span><br><span class="line">    Product product = <span class="keyword">new</span> Director(builder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>改进的建造者模式</strong></p>
<p>为了简化系统结构，可以把指挥者和抽象建造者进行结合</p>
<p>==这样做确实简化了系统结构，但同时也加重了抽象建造者类的职责，也不是太符合单一职责原则，如果construct() 过于复杂，建议还是封装到 Director==</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="keyword">class</span> <span class="title">Builder</span> &#123; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPartC</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPartD</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="comment">//创建产品对象</span></span><br><span class="line">    <span class="function">Product <span class="title">getProduct</span>(<span class="params"></span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 把指挥者中的construct()方法合并到抽象建造者类中 </span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * @return 具体产品对象 </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="function"><span class="literal">default</span> Product <span class="title">construct</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">        <span class="comment">//特定顺序</span></span><br><span class="line">        <span class="keyword">this</span>.setPartC(); </span><br><span class="line">        <span class="keyword">this</span>.setPartD(); </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getProduct(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h4 id="重构传统实例化方式"><a href="#重构传统实例化方式" class="headerlink" title="重构传统实例化方式"></a>重构传统实例化方式</h4><p>对于一些子部件不需要特定步骤组合但是传入参数很多的复杂对象构建，传统方式构建可读性很差，可以使用builder模式重构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//产品 ---------------------------</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String partA;<span class="comment">//必要</span></span><br><span class="line">    <span class="keyword">private</span> String partB;<span class="comment">//必要</span></span><br><span class="line">	<span class="keyword">private</span> String partC;<span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">private</span> String partD;<span class="comment">//可选</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">(Builder builder)</span></span>&#123;</span><br><span class="line">        partA = builder.partA;</span><br><span class="line">        partB = builder.partB;</span><br><span class="line">        partC = builder.partC;</span><br><span class="line">        partD = builder.partD;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123; </span><br><span class="line">        <span class="keyword">private</span> String partA; </span><br><span class="line">        <span class="keyword">private</span> String partB; </span><br><span class="line">        <span class="keyword">private</span> String partC; </span><br><span class="line">        <span class="keyword">private</span> String partD; </span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(String partA,String partB)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.partA = partA;</span><br><span class="line">            <span class="keyword">this</span>.partB = partB;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setPartC</span><span class="params">(String partC)</span> </span>&#123; </span><br><span class="line">            <span class="keyword">this</span>.partC = partC; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setPartD</span><span class="params">(String partD)</span> </span>&#123; </span><br><span class="line">            <span class="keyword">this</span>.partD = partD; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Product <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Product(<span class="keyword">this</span>);&#125; </span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="结构型模式-7种"><a href="#结构型模式-7种" class="headerlink" title="结构型模式(7种)"></a>结构型模式(7种)</h2><p>结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为<strong>类结构型模式</strong>和<strong>对象结构型模式</strong>，前者采用<strong>继承</strong>机制来组织接口和类，后者釆用<strong>组合或聚合</strong>来组合对象。</p>
<p>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以<strong>对象结构型模式比类结构型模式具有更大的灵活性</strong>。</p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。同时，代理方式还可以用来对代码前后添加一些逻辑处理</p>
<h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><img src="Java设计模式及UML类图.assets/image-20200629132008130.png" alt="image-20200629132008130" style="zoom:80%;" />

<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>利用JDK动态代理类通过接口创建代理类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">func2</span><span class="params">(String str)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//被代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">func2</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//动态代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">	<span class="comment">//被代理对象</span></span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxyHandler</span><span class="params">(<span class="keyword">final</span> Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 代理类对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">newProxyInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> ClassLoader 被代理对象使用的类加载器</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> Class&lt;?&gt;[] 被代理对象实现的接口的类型,使用泛型方式确认类型</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> InvocationHandler 指定动态处理器，执行目标对象的方法时,会触发事件处理器的方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Object result = Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 执行被代理对象的任何接口方法都会经过该方法 </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> proxy 代理对象的引用 </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> method 代理对象当前执行的方法 </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> args 代理对象当前执行方法所需的参数 </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 和被代理对象方法有相同的返回值 </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Throwable */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//方法调用前的逻辑处理</span></span><br><span class="line">            result = method.invoke(object, args);</span><br><span class="line">            <span class="comment">//方法调用后的逻辑处理</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printTranstack();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态代理实际上也是由字节码来生成一个代理类（保存在内存中）</p>
<p>==public final class $Proxy0 extends Proxy implements Subject 通过生成的代理类对象可以看出，该类已经继承了JDK的Proxy类，所以不能再继承其他类，所以必须通过实现接口来完成代理==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> InvocationHandler h;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Proxy</span><span class="params">(InvocationHandler h)</span></span>&#123;</span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line">        <span class="keyword">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真正生成的代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Method m5;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler handler) &#123;</span><br><span class="line">    	<span class="keyword">super</span>(paramInvocationHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object paramObject)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//this将代理对象传入到了方法中</span></span><br><span class="line">            <span class="keyword">return</span> ((Boolean)<span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[] &#123; paramObject &#125;)).booleanValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error|RuntimeException localError)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> localError;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable localThrowable)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(localThrowable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">(String var1)</span> <span class="keyword">throws</span>  </span>&#123;        </span><br><span class="line">        <span class="keyword">try</span> &#123;            </span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1, var2&#125;);                                                            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var4) &#123;            </span><br><span class="line">            <span class="keyword">throw</span> var4;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var5) &#123;           </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这个静态块本来是在最后的，我把它拿到前面来，方便描述</span></span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">&quot;com.cn.proxy.Subject&quot;</span>).getMethod(<span class="string">&quot;func1&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">            m2 = Class.forName(<span class="string">&quot;com.cn.proxy.Subject&quot;</span>).getMethod(<span class="string">&quot;func2&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]&#123;Class.forName(<span class="string">&quot;java.lang.String&quot;</span>)&#125;);</span><br><span class="line">            m3 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, <span class="keyword">new</span> Class[] &#123; Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>) &#125;);</span><br><span class="line">            m4 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">            m5 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NoSuchMethodException localNoSuchMethodException)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(localNoSuchMethodException.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException localClassNotFoundException)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(localClassNotFoundException.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="Cglib代理"><a href="#Cglib代理" class="headerlink" title="Cglib代理"></a>Cglib代理</h4><p>通过字节码技术为一个类创建子类，并在子类中采用<strong>方法拦截的技术</strong>拦截所有父类方法的调用，顺势织入横切逻辑。因为采用的是<strong>继承</strong>，所以不能对final修饰的类进行代理。</p>
<p>cglib 是基于asm 字节修改技术。导入 cglib 会间接导入 asm, ant, ant-launcher 三个jar 包。</p>
<p>Spring框架的spring-core.jar包中已经集成了cglib与asm。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- cglib 动态代理依赖 begin --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="comment">&lt;!-- cglib 动态代理依赖 stop --&gt;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//被代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Cglib代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 用于生成 Cglib 动态代理类工具方法</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> target 代表需要 被代理的 委托类的 Class 对象</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 代理类对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">CglibProxyGeneratory</span><span class="params">(Class target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建加强器，用来创建动态代理类</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();        </span><br><span class="line">        <span class="comment">// 为代理类指定需要代理的类，也即是父类</span></span><br><span class="line">        enhancer.setSuperclass(target);        </span><br><span class="line">        <span class="comment">// 设置方法拦截器回调引用，对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept() 方法进行拦截</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);        </span><br><span class="line">        <span class="comment">// 获取动态代理类对象并返回</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> obj    代理类对象</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> method 被代理类方法</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> args   方法参数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> proxy  代理类方法</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 方法返回结果</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//方法调用前的逻辑处理</span></span><br><span class="line">        <span class="comment">//注意这里的写法，使用被代理类来执行父类方法</span></span><br><span class="line">        Object result = proxy.invokeSuper(obj, args);</span><br><span class="line">        <span class="comment">//方法调用后的逻辑处理   </span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//真正生成代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span>$$<span class="title">EnhancerByCGLIB</span>$$<span class="title">be45efdd</span> <span class="keyword">extends</span> <span class="title">HelloService</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    ...  </span><br><span class="line">    <span class="keyword">private</span> MethodInterceptor CGLIB$CALLBACK_0;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CGLIB$func$<span class="number">0</span>$Method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodProxy CGLIB$func$<span class="number">0</span>$Proxy;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> CGLIB$STATICHOOK1() &#123;</span><br><span class="line">        ...</span><br><span class="line">        Class var0 = Class.forName(<span class="string">&quot;com.jpeony.spring.proxy.cglib.HelloService$$EnhancerByCGLIB$$be45efdd&quot;</span>);</span><br><span class="line">        Class var1;</span><br><span class="line">        CGLIB$sayHello$<span class="number">0</span>$Method = ReflectUtils.findMethods(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;func&quot;</span>, <span class="string">&quot;()V&quot;</span>&#125;, (var1 = Class.forName(<span class="string">&quot;com.cn.proxy.Subject&quot;</span>)).getDeclaredMethods())[<span class="number">0</span>];</span><br><span class="line">        CGLIB$func$<span class="number">0</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">&quot;()V&quot;</span>, <span class="string">&quot;func&quot;</span>, <span class="string">&quot;CGLIB$func$0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">void</span> CGLIB$sayHello$<span class="number">0</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MethodInterceptor var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> (var10000 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (var10000 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            var10000.intercept(<span class="keyword">this</span>, CGLIB$func$<span class="number">0</span>$Method, CGLIB$emptyArgs, CGLIB$sayHello$<span class="number">0</span>$Proxy);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.sayHello();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么intercept中不能使用method.invoke(obj,args)</strong></p>
<p>这种方式是无法调用到父类的方法的，子类有方法重写，隐藏了父类的方法，父类的方法已经不可见，如果硬调arg1.invoke(arg0, …)很明显会死循环。</p>
<p><strong>使用proxy.invokeSuper(obj,args)原理</strong></p>
<p>cglib采用了fastclass机制，不仅巧妙的避开了调不到父类方法的问题，还加速了方法的调用。</p>
<p>fastclass基本原理是，给每个方法编号，通过编号找到方法执行避免了通过反射调用。</p>
<h4 id="动态代理和Cglib的区别"><a href="#动态代理和Cglib的区别" class="headerlink" title="动态代理和Cglib的区别"></a>动态代理和Cglib的区别</h4><ul>
<li>jdk创建对象的速度远大于cglib，这是由于cglib创建对象时需要操作字节码。</li>
<li>cglib执行速度略大于jdk，所以比较适合单例模式。</li>
<li>由于CGLIB的大部分类是直接对Java字节码进行操作，这样生成的类会在Java的永久堆中。如果动态代理操作过多，容易造成永久堆满，触发OutOfMemory异常。spring默认使用jdk动态代理，如果类没有接口，则使用cglib。</li>
</ul>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p>
<p><strong>适配器模式分类</strong></p>
<ul>
<li><p>类结构型模式，java没有多继承，所以只能继承和实现结合使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> adapter;</span><br><span class="line"><span class="comment">//目标接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Target</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//适配者接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;       </span><br><span class="line">        System.out.println(<span class="string">&quot;适配者中的业务代码被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类适配器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassAdapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassAdapterTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;类适配器模式测试：&quot;</span>);</span><br><span class="line">        Target target = <span class="keyword">new</span> ClassAdapter();</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对象结构型模式，推荐使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> adapter;</span><br><span class="line"><span class="comment">//对象适配器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectAdapter</span> <span class="keyword">implements</span> <span class="title">Target</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObjectAdapter</span><span class="params">(Adaptee adaptee)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee=adaptee;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectAdapterTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对象适配器模式测试：&quot;</span>);</span><br><span class="line">        Adaptee adaptee = <span class="keyword">new</span> Adaptee();</span><br><span class="line">        Target target = <span class="keyword">new</span> ObjectAdapter(adaptee);</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>将抽象与实现分离，使它们可以独立变化。它是用<strong>组合关系</strong>代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p>
<p>当某个类存在多个维度变化时，如果全部使用继承，则会有n*m种子类，使用组合方式来实现，则只会有n+m个子类</p>
<p><strong>示例</strong></p>
<p>包按用途分为钱包（Wallet）和挎包（HandBag），按颜色分为黄色（Yellow）和红色（Red）</p>
<img src="Java设计模式及UML类图.assets/3-1Q11512532X54.gif" alt="女士皮包选购的结构图" style="zoom:80%;" />



<h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><p>在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。（感觉和静态代理模式很像）</p>
<img src="Java设计模式及UML类图.assets/3-1Q115142204235.gif" alt="游戏角色“莫莉卡·安斯兰”的结构图" style="zoom:80%;" />



<h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p>一种通过为多个复杂的子系统提供一个统一的接口，而使这些子系统更加容易被访问的模式。</p>
<p><img src="Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8F%8AUML%E7%B1%BB%E5%9B%BE.assets/3-1Q11515205E60.gif" alt="办理房产证过户的相关部门"></p>
<p><strong>优点</strong></p>
<ul>
<li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类</li>
<li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li>
<li>降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>不能很好地限制客户使用子系统类。</li>
<li>增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</li>
</ul>
<p><strong>示例</strong></p>
<img src="Java设计模式及UML类图.assets/image-20200629175053062.png" alt="image-20200629175053062" style="zoom:80%;" />



<h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>通过缓存对象来大幅度减少需要创建的对象数量，从而提高系统资源的利用率。</p>
<p><strong>享元模式的主要角色</strong></p>
<ol>
<li><p>抽象享元角色（Flyweight）</p>
<p>是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入。</p>
</li>
<li><p>具体享元（Concrete Flyweight）角色</p>
<p>可共享的角色，需实现抽象享元角色中所规定的接口。</p>
<p>==如果只有一个种类，但是由于参数不同而产生不同对象的享元角色，其实并不需要构建抽象享元角色，如java基本数据类型包装类的缓存，只是值不同，就不需要构建抽象类；还有连接池和线程池==</p>
<ul>
<li>Byte, Short, Long 缓存的范围都是 -128~127</li>
<li>Character 缓存的范围是 0~127</li>
<li>Integer的默认范围是 -128~127<br>最小值不能变<br>但最大值可以通过调整虚拟机参数 <code> -Djava.lang.Integer.IntegerCache.high</code> 来改变</li>
<li>Boolean 缓存了 TRUE 和 FALSE  </li>
</ul>
</li>
<li><p>非可共享享元（Unsharable Flyweight)角色</p>
<p>是<strong>不可以共享</strong>的外部状态，它以参数的形式注入具体享元的相关方法中。</p>
</li>
<li><p>享元工厂（Flyweight Factory）角色</p>
<p>负责创建和管理（缓存）享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。</p>
</li>
</ol>
<p><strong>示例</strong></p>
<p>棋子，作为<strong>抽象享元角色</strong>，分为白子和黑子，白子和黑子对象可以作为可共享对象，充当<strong>具体享元角色</strong>，棋子的坐标由于一直变化，所以是不可共享对象，作为<strong>参数传入</strong></p>
<img src="Java设计模式及UML类图.assets/3-1Q11516141M29.gif" alt="五子棋游戏的结构图" style="zoom:80%;" />



<h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>又叫作<strong>部分-整体</strong>模式，它是一种将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性。</p>
<p>对于组合模式而言，在安全性和透明性上，==会更看重透明性==，毕竟组合模式的功能就是要让用户对叶子对象和组合对象的使用具有一致性。</p>
<h4 id="透明式的组合模式"><a href="#透明式的组合模式" class="headerlink" title="透明式的组合模式"></a>透明式的组合模式</h4><p>抽象构件声明了所有子类中的全部方法，所以客户端无须区别树叶对象和树枝（容器）对象，对客户端来说是透明的。</p>
<p><strong>缺点</strong></p>
<p>树叶构件本来没有 Add()、Remove() 及 GetChild() 方法，却要实现它们（空实现或抛异常）</p>
<img src="Java设计模式及UML类图.assets/3-1Q1151G62L17.gif" alt="透明式的组合模式的结构图" style="zoom:80%;" />

<p><strong>示例</strong></p>
<p><img src="Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8F%8AUML%E7%B1%BB%E5%9B%BE.assets/3-1Q1151GUH32.gif" alt="集合c0的树状图"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositePattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Component branch1=<span class="keyword">new</span> Branch(); </span><br><span class="line">        Component branch2=<span class="keyword">new</span> Branch(); </span><br><span class="line">        Component leaf1=<span class="keyword">new</span> Leaf(<span class="string">&quot;1&quot;</span>); </span><br><span class="line">        Component leaf2=<span class="keyword">new</span> Leaf(<span class="string">&quot;2&quot;</span>); </span><br><span class="line">        Component leaf3=<span class="keyword">new</span> Leaf(<span class="string">&quot;3&quot;</span>);          </span><br><span class="line">        branch1.add(leaf1); </span><br><span class="line">        branch1.add(branch2);</span><br><span class="line">        branch2.add(leaf2); </span><br><span class="line">        branch2.add(leaf3);          </span><br><span class="line">        branch1.operation(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象构件</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span></span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span></span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树叶构件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">implements</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Leaf</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;树叶&quot;</span>+name+<span class="string">&quot;：被访问！&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树枝构件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Branch</span> <span class="keyword">implements</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Component&gt; children=<span class="keyword">new</span> ArrayList&lt;Component&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        children.add(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        children.remove(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> children.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Object obj:children)</span><br><span class="line">        &#123;</span><br><span class="line">            ((Component)obj).operation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="安全式的组合模式"><a href="#安全式的组合模式" class="headerlink" title="安全式的组合模式"></a>安全式的组合模式</h4><p>将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法，这样就避免了上一种方式的安全性问题。</p>
<p><strong>缺点</strong></p>
<p>由于叶子和分支有不同的接口，客户端在调用时要知道树叶对象和树枝对象的存在，所以失去了透明性。</p>
<img src="Java设计模式及UML类图.assets/3-1Q1151GF5221.gif" alt="安全式的组合模式的结构图" style="zoom:80%;" />

<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">李先生到韶关“天街e角”生活用品店购物</span></span><br><span class="line"><span class="comment">用 1 个红色小袋子装了 2 包婺源特产（单价 7.9 元）、1 张婺源地图（单价 9.9 元）；</span></span><br><span class="line"><span class="comment">用 1 个白色小袋子装了 2 包韶关香藉（单价 68 元）和 3 包韶关红茶（单价 180 元）；</span></span><br><span class="line"><span class="comment">用 1 个中袋子装了前面的红色小袋子和 1 个景德镇瓷器（单价 380 元）；</span></span><br><span class="line"><span class="comment">用 1 个大袋子装了前面的中袋子、白色小袋子和 1 双李宁牌运动鞋（单价 198 元）。</span></span><br><span class="line"><span class="comment">最后“大袋子”中的内容有：</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	1 双李宁牌运动鞋（单价 198 元）、</span></span><br><span class="line"><span class="comment">	白色小袋子&#123;</span></span><br><span class="line"><span class="comment">		2 包韶关香菇（单价 68 元）、</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		3 包韶关红茶（单价 180 元）</span></span><br><span class="line"><span class="comment">	&#125;、</span></span><br><span class="line"><span class="comment">	中袋子&#123;</span></span><br><span class="line"><span class="comment">		1 个景德镇瓷器（单价 380 元）、</span></span><br><span class="line"><span class="comment">		红色小袋子&#123;</span></span><br><span class="line"><span class="comment">			2 包婺源特产（单价 7.9 元）、</span></span><br><span class="line"><span class="comment">			1 张婺源地图（单价 9.9 元）</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;，现在要求编程显示李先生放在大袋子中的所有商品信息并计算要支付的总价。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShoppingTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> s=<span class="number">0</span>;</span><br><span class="line">        Bags BigBag,mediumBag,smallRedBag,smallWhiteBag;</span><br><span class="line">        Goods sp;</span><br><span class="line">        BigBag=<span class="keyword">new</span> Bags(<span class="string">&quot;大袋子&quot;</span>);</span><br><span class="line">        mediumBag=<span class="keyword">new</span> Bags(<span class="string">&quot;中袋子&quot;</span>);</span><br><span class="line">        smallRedBag=<span class="keyword">new</span> Bags(<span class="string">&quot;红色小袋子&quot;</span>);</span><br><span class="line">        smallWhiteBag=<span class="keyword">new</span> Bags(<span class="string">&quot;白色小袋子&quot;</span>);               </span><br><span class="line">        sp=<span class="keyword">new</span> Goods(<span class="string">&quot;婺源特产&quot;</span>,<span class="number">2</span>,<span class="number">7.9f</span>);</span><br><span class="line">        smallRedBag.add(sp);</span><br><span class="line">        sp=<span class="keyword">new</span> Goods(<span class="string">&quot;婺源地图&quot;</span>,<span class="number">1</span>,<span class="number">9.9f</span>);</span><br><span class="line">        smallRedBag.add(sp);       </span><br><span class="line">        sp=<span class="keyword">new</span> Goods(<span class="string">&quot;韶关香菇&quot;</span>,<span class="number">2</span>,<span class="number">68</span>);</span><br><span class="line">        smallWhiteBag.add(sp);</span><br><span class="line">        sp=<span class="keyword">new</span> Goods(<span class="string">&quot;韶关红茶&quot;</span>,<span class="number">3</span>,<span class="number">180</span>);</span><br><span class="line">        smallWhiteBag.add(sp);       </span><br><span class="line">        sp=<span class="keyword">new</span> Goods(<span class="string">&quot;景德镇瓷器&quot;</span>,<span class="number">1</span>,<span class="number">380</span>);</span><br><span class="line">        mediumBag.add(sp);</span><br><span class="line">        mediumBag.add(smallRedBag);       </span><br><span class="line">        sp=<span class="keyword">new</span> Goods(<span class="string">&quot;李宁牌运动鞋&quot;</span>,<span class="number">1</span>,<span class="number">198</span>);</span><br><span class="line">        BigBag.add(sp);</span><br><span class="line">        BigBag.add(smallWhiteBag);</span><br><span class="line">        BigBag.add(mediumBag);</span><br><span class="line">        System.out.println(<span class="string">&quot;您选购的商品有：&quot;</span>);</span><br><span class="line">        BigBag.show();</span><br><span class="line">        s=BigBag.calculation();       </span><br><span class="line">        System.out.println(<span class="string">&quot;要支付的总价是：&quot;</span>+s+<span class="string">&quot;元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象构件：物品</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Articles</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">calculation</span><span class="params">()</span></span>; <span class="comment">//计算</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树叶构件：商品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Goods</span> <span class="keyword">implements</span> <span class="title">Articles</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;     <span class="comment">//名字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> quantity;    <span class="comment">//数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> unitPrice; <span class="comment">//单价</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">(String name,<span class="keyword">int</span> quantity,<span class="keyword">float</span> unitPrice)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.quantity=quantity;</span><br><span class="line">        <span class="keyword">this</span>.unitPrice=unitPrice;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">calculation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> quantity*unitPrice; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;(数量：&quot;</span>+quantity+<span class="string">&quot;，单价：&quot;</span>+unitPrice+<span class="string">&quot;元)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树枝构件：袋子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bags</span> <span class="keyword">implements</span> <span class="title">Articles</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;     <span class="comment">//名字   </span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Articles&gt; bags=<span class="keyword">new</span> ArrayList&lt;Articles&gt;();   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bags</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Articles c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        bags.add(c);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Articles c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        bags.remove(c);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Articles <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bags.get(i);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">calculation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> s=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Object obj:bags)</span><br><span class="line">        &#123;</span><br><span class="line">            s+=((Articles)obj).calculation();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Object obj:bags)</span><br><span class="line">        &#123;</span><br><span class="line">            ((Articles)obj).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="组合模式扩展"><a href="#组合模式扩展" class="headerlink" title="组合模式扩展"></a>组合模式扩展</h4><p>对树叶和树枝进行抽象，然后继承得到不同的树叶和树枝</p>
<img src="Java设计模式及UML类图.assets/3-1Q1151H632613.gif" alt="复杂的组合模式的结构图" style="zoom:80%;" />





<h2 id="行为型模式-11种"><a href="#行为型模式-11种" class="headerlink" title="行为型模式(11种)"></a>行为型模式(11种)</h2><p>行为型模式用于描述程序在运行时复杂的<strong>流程控制</strong>，即描述多个类或对象之间怎样<strong>相互协作</strong>共同完成单个对象都无法单独完成的任务，它<strong>涉及算法与对象间职责的分配</strong>。</p>
<p>分为<strong>类行为模式</strong>和<strong>对象行为模式</strong>，前者采用<strong>继承机制</strong>来在类间分派行为，后者采用<strong>组合或聚合</strong>在对象间分配行为。</p>
<h3 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h3><p>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</p>
<p>抽象类中方法类型</p>
<ul>
<li>抽象方法：在抽象类中申明，由具体子类实现。</li>
<li>具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。</li>
<li>钩子方法：在抽象类中已经实现，表示默认方式，但是子类也可以重写，表示自定义方法</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> templateMethod;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateMethodPattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        AbstractClass tm=<span class="keyword">new</span> ConcreteClass();</span><br><span class="line">        tm.TemplateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">TemplateMethod</span><span class="params">()</span> <span class="comment">//为防止恶意操作，一般模板方法都加上 final 关键词</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SpecificMethod();</span><br><span class="line">        abstractMethod1();          </span><br><span class="line">        abstractMethod2();</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SpecificMethod</span><span class="params">()</span> <span class="comment">//具体方法</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象类中的具体方法被调用...&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractMethod1</span><span class="params">()</span></span>; <span class="comment">//抽象方法1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractMethod2</span><span class="params">()</span></span>; <span class="comment">//抽象方法2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abstractMethod1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象方法1的实现被调用...&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abstractMethod2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象方法2的实现被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。</p>
<p>策略模式属于<strong>对象行为模式</strong>，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</p>
<p><strong>策略模式的主要角色</strong></p>
<ol>
<li><p>抽象策略（Strategy）类</p>
<p>定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。</p>
</li>
<li><p>具体策略（Concrete Strategy）类</p>
<p>实现了抽象策略定义的接口，提供具体的算法实现。</p>
</li>
<li><p>环境（Context）类</p>
<p>持有一个策略类的引用，最终给客户端调用。</p>
</li>
</ol>
<p><strong>示例</strong></p>
<img src="Java设计模式及UML类图.assets/3-1Q116103K1205.gif" alt="策略模式的结构图" style="zoom:80%;" />



<h4 id="策略工厂模式"><a href="#策略工厂模式" class="headerlink" title="策略工厂模式"></a>策略工厂模式</h4><p>当需要频繁切换策略时，可以使用策略工厂模式来缓存策略对象，减少生成对象的时间</p>
<img src="Java设计模式及UML类图.assets/3-1Q116104010550.gif" alt="策略工厂模式的结构图" style="zoom:80%;" />



<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便对<strong>命令对象</strong>进行储存、传递、调用、增加与管理（日志记录）。</p>
<p><strong>示例</strong></p>
<img src="Java设计模式及UML类图.assets/3-1Q11611335E44.gif" alt="命令模式的结构图" style="zoom: 80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> command;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandPattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Command cmd=<span class="keyword">new</span> ConcreteCommand();</span><br><span class="line">        Invoker invoker=<span class="keyword">new</span> Invoker();</span><br><span class="line">        invoker.setCommand(cmd);</span><br><span class="line">        System.out.println(<span class="string">&quot;客户访问调用者的call()方法...&quot;</span>);</span><br><span class="line">        ir.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invoker</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Invoker</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(Command command)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command=command;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用者执行命令command...&quot;</span>);</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象命令</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Command</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体命令</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand</span> <span class="keyword">implements</span> <span class="title">Command</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line">    ConcreteCommand()</span><br><span class="line">    &#123;</span><br><span class="line">        receiver=<span class="keyword">new</span> Receiver();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        receiver.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接收者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收者的action()方法被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="宏命令模式"><a href="#宏命令模式" class="headerlink" title="宏命令模式"></a>宏命令模式</h4><p>也叫组合命令模式，将命令模式与组合模式联合使用。宏命令包含了一组命令，它充当了具体命令与调用者的双重角色，执行它时将递归调用它所包含的所有命令</p>
<img src="Java设计模式及UML类图.assets/3-1Q1161135322R.gif" alt="组合命令模式的结构图" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositeCommandPattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        AbstractCommand cmd1=<span class="keyword">new</span> ConcreteCommand1();</span><br><span class="line">        AbstractCommand cmd2=<span class="keyword">new</span> ConcreteCommand2();</span><br><span class="line">        CompositeInvoker ir=<span class="keyword">new</span> CompositeInvoker();</span><br><span class="line">        ir.add(cmd1);</span><br><span class="line">        ir.add(cmd2);</span><br><span class="line">        System.out.println(<span class="string">&quot;客户访问调用者的execute()方法...&quot;</span>);</span><br><span class="line">        ir.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象命令</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AbstractCommand</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树叶构件: 具体命令1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand1</span> <span class="keyword">implements</span> <span class="title">AbstractCommand</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CompositeReceiver receiver;</span><br><span class="line">    ConcreteCommand1()</span><br><span class="line">    &#123;</span><br><span class="line">        receiver=<span class="keyword">new</span> CompositeReceiver();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;       </span><br><span class="line">        receiver.action1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树叶构件: 具体命令2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand2</span> <span class="keyword">implements</span> <span class="title">AbstractCommand</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CompositeReceiver receiver;</span><br><span class="line">    ConcreteCommand2()</span><br><span class="line">    &#123;</span><br><span class="line">        receiver=<span class="keyword">new</span> CompositeReceiver();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;       </span><br><span class="line">        receiver.action2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树枝构件: 调用者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompositeInvoker</span> <span class="keyword">implements</span> <span class="title">AbstractCommand</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;AbstractCommand&gt; children = <span class="keyword">new</span> ArrayList&lt;AbstractCommand&gt;();   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(AbstractCommand c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        children.add(c);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(AbstractCommand c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        children.remove(c);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractCommand <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> children.get(i);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Object obj:children)</span><br><span class="line">        &#123;</span><br><span class="line">            ((AbstractCommand)obj).execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接收者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompositeReceiver</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收者的action1()方法被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收者的action2()方法被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p>
<p><strong>职责链模式主要包含以下角色</strong></p>
<ol>
<li><p>抽象处理者（Handler）角色</p>
<p>定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</p>
</li>
<li><p>具体处理者（Concrete Handler）角色</p>
<p>实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</p>
</li>
<li><p>客户类（Client）角色</p>
<p>创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程</p>
</li>
</ol>
<p><strong>示例</strong></p>
<p>规定学生请假小于或等于 2 天，班主任可以批准；小于或等于 7 天，系主任可以批准；小于或等于 10 天，院长可以批准；其他情况不予批准；</p>
<img src="Java设计模式及UML类图.assets/3-1Q11614000IV.gif" alt="请假条审批模块的结构图" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeaveApprovalTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//组装责任链 </span></span><br><span class="line">        Leader teacher1=<span class="keyword">new</span> ClassAdviser();</span><br><span class="line">        Leader teacher2=<span class="keyword">new</span> DepartmentHead();</span><br><span class="line">        Leader teacher3=<span class="keyword">new</span> Dean();</span><br><span class="line">        <span class="comment">//Leader teacher4=new DeanOfStudies();</span></span><br><span class="line">        teacher1.setNext(teacher2);</span><br><span class="line">        teacher2.setNext(teacher3);</span><br><span class="line">        <span class="comment">//teacher3.setNext(teacher4);</span></span><br><span class="line">        <span class="comment">//提交请求 </span></span><br><span class="line">        teacher1.handleRequest(<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象处理者：领导类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Leader next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Leader next)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next=next; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Leader <span class="title">getNext</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> next; </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">//处理请求的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">int</span> LeaveDays)</span></span>;       </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体处理者1：班主任类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassAdviser</span> <span class="keyword">extends</span> <span class="title">Teacher</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">int</span> LeaveDays)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(LeaveDays&lt;=<span class="number">2</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;班主任批准您请假&quot;</span> + LeaveDays + <span class="string">&quot;天。&quot;</span>);       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(getNext() != <span class="keyword">null</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                getNext().handleRequest(LeaveDays);             </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                  System.out.println(<span class="string">&quot;请假天数太多，没有人批准该假条！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体处理者2：系主任类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DepartmentHead</span> <span class="keyword">extends</span> <span class="title">Teacher</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">int</span> LeaveDays)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(LeaveDays&lt;=<span class="number">7</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;系主任批准您请假&quot;</span> + LeaveDays + <span class="string">&quot;天。&quot;</span>);       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(getNext() != <span class="keyword">null</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                  getNext().handleRequest(LeaveDays);             </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请假天数太多，没有人批准该假条！&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体处理者3：院长类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dean</span> <span class="keyword">extends</span> <span class="title">Teacher</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">int</span> LeaveDays)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(LeaveDays&lt;=<span class="number">10</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;院长批准您请假&quot;</span> + LeaveDays + <span class="string">&quot;天。&quot;</span>);       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">              <span class="keyword">if</span>(getNext() != <span class="keyword">null</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                getNext().handleRequest(LeaveDays);             </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                  System.out.println(<span class="string">&quot;请假天数太多，没有人批准该假条！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体处理者4：教务处长类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeanOfStudies</span> <span class="keyword">extends</span> <span class="title">Teacher</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">int</span> LeaveDays)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(LeaveDays&lt;=<span class="number">20</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;教务处长批准您请假&quot;</span>+LeaveDays+<span class="string">&quot;天。&quot;</span>);       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">              <span class="keyword">if</span>(getNext()!=<span class="keyword">null</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                getNext().handleRequest(LeaveDays);          </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                  System.out.println(<span class="string">&quot;请假天数太多，没有人批准该假条！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>有些对象可能会根据不同的情况做出不同的行为，我们把这种对象称为有状态的对象，而把影响对象行为的一个或多个动态变化的属性称为状态。</p>
<p>状态（State）模式的定义：对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。</p>
<p><strong>状态模式包含以下主要角色</strong></p>
<ol>
<li><p>环境（Context）角色</p>
<p>也称为上下文，它定义了客户感兴趣的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。</p>
</li>
<li><p>抽象状态（State）角色</p>
<p>定义一个接口，用以封装环境对象中的特定状态所对应的行为。</p>
</li>
<li><p>具体状态（Concrete  State）角色</p>
<p>实现抽象状态所对应的行为。</p>
</li>
</ol>
<p><strong>示例</strong></p>
<p><img src="Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8F%8AUML%E7%B1%BB%E5%9B%BE.assets/3-1Q11615412U55.gif" alt="状态模式的结构图"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> state;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatePatternClient</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;       </span><br><span class="line">        Context context=<span class="keyword">new</span> Context();    <span class="comment">//创建环境       </span></span><br><span class="line">        context.Handle();    <span class="comment">//处理请求</span></span><br><span class="line">        context.Handle();</span><br><span class="line">        context.Handle();</span><br><span class="line">        context.Handle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//环境类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line">    <span class="comment">//定义环境类的初始状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state=<span class="keyword">new</span> ConcreteStateA();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置新状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state=state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>(state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对请求做处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        state.Handle(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象状态类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Handle</span><span class="params">(Context context)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体状态A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStateA</span> <span class="keyword">extends</span> <span class="title">State</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span><span class="params">(Context context)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//A状态下的逻辑</span></span><br><span class="line">        <span class="comment">//A状态--&gt;B状态</span></span><br><span class="line">        context.setState(<span class="keyword">new</span> ConcreteStateB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体状态B类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStateB</span> <span class="keyword">extends</span> <span class="title">State</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span><span class="params">(Context context)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//B状态下的执行逻辑</span></span><br><span class="line">        <span class="comment">//B状态--&gt;A状态</span></span><br><span class="line">        context.setState(<span class="keyword">new</span> ConcreteStateA());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="享元状态模式"><a href="#享元状态模式" class="headerlink" title="享元状态模式"></a>享元状态模式</h4><p>当状态较多时，结合享元模式来缓存状态对象</p>
<img src="Java设计模式及UML类图.assets/3-1Q116154539147.gif" alt="共享状态模式的结构图" style="zoom:80%;" />



<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>指多个对象间存在<strong>一对多的依赖关系</strong>，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被<strong>自动更新</strong>。这种模式有时又称作<strong>发布-订阅模式</strong>、模型-视图模式，它是对象行为型模式。</p>
<p><strong>示例</strong></p>
<img src="Java设计模式及UML类图.assets/3-1Q1161A6221S.gif" alt="观察者模式的结构图" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverPattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Subject subject=<span class="keyword">new</span> ConcreteSubject();</span><br><span class="line">        Observer obs1=<span class="keyword">new</span> ConcreteObserver1();</span><br><span class="line">        Observer obs2=<span class="keyword">new</span> ConcreteObserver2();</span><br><span class="line">        subject.add(obs1);</span><br><span class="line">        subject.add(obs2);</span><br><span class="line">        subject.notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象目标</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;Observer&gt; observers=<span class="keyword">new</span> ArrayList&lt;Observer&gt;();   </span><br><span class="line">    <span class="comment">//增加观察者方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Observer observer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//删除观察者方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Observer observer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>; <span class="comment">//通知观察者方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体目标</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体目标发生改变...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------&quot;</span>);       </span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span>(Observer obs:observers)</span><br><span class="line">        &#123;</span><br><span class="line">            obs.response();</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;          </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象观察者</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Observer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">response</span><span class="params">()</span></span>; <span class="comment">//反应</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体观察者1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver1</span> <span class="keyword">implements</span> <span class="title">Observer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体观察者1作出反应！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体观察者1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver2</span> <span class="keyword">implements</span> <span class="title">Observer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体观察者2作出反应！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><p>定义一个<strong>中介对象</strong>来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。中介者模式又叫调停模式，它是迪米特法则的典型应用。</p>
<p><strong>和观察者模式区别</strong></p>
<p>观察者模式分为被观察者和观察者，由被观察者通知观察者</p>
<p>中介者模式每个对象即使观察者又是被观察者</p>
<p><strong>示例</strong></p>
<img src="Java设计模式及UML类图.assets/3-1Q1161I532V0.gif" alt="中介者模式的结构图" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象中介者</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Colleague colleague)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">relay</span><span class="params">(Colleague cl)</span></span>; <span class="comment">//转发</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体中介者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title">Mediator</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Colleague&gt; colleagues=<span class="keyword">new</span> ArrayList&lt;Colleague&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Colleague colleague)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!colleagues.contains(colleague))</span><br><span class="line">        &#123;</span><br><span class="line">            colleagues.add(colleague);</span><br><span class="line">            colleague.setMedium(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">relay</span><span class="params">(Colleague cl)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Colleague ob:colleagues)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!ob.equals(cl))</span><br><span class="line">            &#123;</span><br><span class="line">                ((Colleague)ob).receive();</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象同事类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Colleague</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Mediator mediator;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMedium</span><span class="params">(Mediator mediator)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mediator=mediator;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span></span>;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体同事类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleague1</span> <span class="keyword">extends</span> <span class="title">Colleague</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体同事类1收到请求。&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体同事类1发出请求。&quot;</span>);</span><br><span class="line">        mediator.relay(<span class="keyword">this</span>); <span class="comment">//请中介者转发</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体同事类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleague2</span> <span class="keyword">extends</span> <span class="title">Colleague</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体同事类2收到请求。&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体同事类2发出请求。&quot;</span>);</span><br><span class="line">        mediator.relay(<span class="keyword">this</span>); <span class="comment">//请中介者转发</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="简化中介者模式"><a href="#简化中介者模式" class="headerlink" title="简化中介者模式"></a>简化中介者模式</h4><ol>
<li>不定义中介者接口，把具体中介者对象实现成为单例。</li>
<li>同事对象不持有中介者，而是在发消息时直接获取中介者对象并调用。</li>
</ol>
<img src="Java设计模式及UML类图.assets/3-1Q1161IA5242.gif" alt="简化中介者模式的结构图" style="zoom:80%;" />



<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。迭代器模式是一种对象行为型模式</p>
<p><strong>优点</strong></p>
<ol>
<li>访问一个聚合对象的内容而无须暴露它的内部表示。</li>
<li>遍历任务交由迭代器完成，这简化了聚合类。</li>
<li>它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。</li>
<li>增加新的聚合类和迭代器类都很方便，无须修改原有代码。</li>
<li>封装性良好，为遍历不同的聚合结构提供一个统一的接口</li>
</ol>
<p><strong>示例</strong></p>
<img src="Java设计模式及UML类图.assets/3-1Q1161PU9528.gif" alt="迭代器模式的结构图" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorPattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Aggregate ag=<span class="keyword">new</span> ConcreteAggregate(); </span><br><span class="line">        ag.add(<span class="string">&quot;中山大学&quot;</span>); </span><br><span class="line">        ag.add(<span class="string">&quot;华南理工&quot;</span>); </span><br><span class="line">        ag.add(<span class="string">&quot;韶关学院&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;聚合的内容有：&quot;</span>);</span><br><span class="line">        Iterator it=ag.getIterator(); </span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())</span><br><span class="line">        &#123; </span><br><span class="line">            Object ob=it.next(); </span><br><span class="line">            System.out.print(ob.toString()+<span class="string">&quot;\t&quot;</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        Object ob=it.first();</span><br><span class="line">        System.out.println(<span class="string">&quot;\nFirst：&quot;</span>+ob.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象聚合</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Aggregate</span></span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object obj)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体聚合</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteAggregate</span> <span class="keyword">implements</span> <span class="title">Aggregate</span></span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; list=<span class="keyword">new</span> ArrayList&lt;Object&gt;(); </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        list.add(obj); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        list.remove(obj); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span>(<span class="keyword">new</span> ConcreteIterator(list)); </span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象迭代器</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">first</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体迭代器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; list=<span class="keyword">null</span>; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index=-<span class="number">1</span>; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteIterator</span><span class="params">(List&lt;Object&gt; list)</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.list=list; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(index&lt;list.size()-<span class="number">1</span>)</span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">first</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        index=<span class="number">0</span>;</span><br><span class="line">        Object obj=list.get(index);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        Object obj=<span class="keyword">null</span>; </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.hasNext())</span><br><span class="line">        &#123; </span><br><span class="line">            obj=list.get(++index); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> obj; </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="迭代器模式扩展"><a href="#迭代器模式扩展" class="headerlink" title="迭代器模式扩展"></a>迭代器模式扩展</h4><p>将迭代器模式和组合模式结合，实现对组合模式构成的树的遍历。迭代器存放在树枝组件中</p>
<img src="Java设计模式及UML类图.assets/3-1Q1161Q152626.gif" alt="组合迭代器模式的结构图" style="zoom:80%;" />





<h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><p>有些集合对象中存在多种不同的元素，且每种元素也存在多种不同的访问者和处理方式。</p>
<p>访问者（Visitor）模式就是将作用于某种数据结构中的<strong>各元素的操作分离出来封装成独立的类</strong>，使其在<strong>不改变数据结构的前提</strong>下可以添加作用于这些元素的新的操作，为数据结构中的<strong>每个元素提供多种访问方式</strong>。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。</p>
<p><strong>示例</strong></p>
<img src="Java设计模式及UML类图.assets/image-20200630110016809.png" alt="image-20200630110016809" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VisitorPattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ObjectStructure os=<span class="keyword">new</span> ObjectStructure();</span><br><span class="line">        os.add(<span class="keyword">new</span> ConcreteElementA());</span><br><span class="line">        os.add(<span class="keyword">new</span> ConcreteElementB());</span><br><span class="line">        Visitor visitor=<span class="keyword">new</span> ConcreteVisitorA();</span><br><span class="line">        os.accept(visitor);</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line">        visitor=<span class="keyword">new</span> ConcreteVisitorB();</span><br><span class="line">        os.accept(visitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象访问者</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB element)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体访问者A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteVisitorA</span> <span class="keyword">implements</span> <span class="title">Visitor</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体访问者A访问--&gt;&quot;</span>+element.operationA());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB element)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体访问者A访问--&gt;&quot;</span>+element.operationB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体访问者B类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteVisitorB</span> <span class="keyword">implements</span> <span class="title">Visitor</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体访问者B访问--&gt;&quot;</span>+element.operationA());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB element)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体访问者B访问--&gt;&quot;</span>+element.operationB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象元素类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Element</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体元素A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteElementA</span> <span class="keyword">implements</span> <span class="title">Element</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operationA</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;具体元素A的操作。&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体元素B类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteElementB</span> <span class="keyword">implements</span> <span class="title">Element</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operationB</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;具体元素B的操作。&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对象结构角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectStructure</span></span></span><br><span class="line"><span class="class"></span>&#123;   </span><br><span class="line">    <span class="keyword">private</span> List&lt;Element&gt; list=<span class="keyword">new</span> ArrayList&lt;Element&gt;();   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//迭代器</span></span><br><span class="line">        Iterator&lt;Element&gt; i=list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(i.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            ((Element) i.next()).accept(visitor);</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Element element)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        list.add(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Element element)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        list.remove(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="访问者模式扩展"><a href="#访问者模式扩展" class="headerlink" title="访问者模式扩展"></a>访问者模式扩展</h4><p><strong>和迭代器模式联合</strong></p>
<p>当对象结构中的聚合类没有提供迭代器时，可以用迭代器模式自定义一个。</p>
<p><strong>和组合模式联合</strong></p>
<p>访问者（Visitor）模式中的“元素对象”可能是叶子对象或者是容器对象，如果元素对象包含容器对象，就必须用到组合模式</p>
<img src="Java设计模式及UML类图.assets/3-1Q11910210Jc.gif" alt="包含组合模式的访问者模式的结构图" style="zoom:80%;" />



<h3 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h3><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫快照模式。</p>
<p><strong>主要角色</strong></p>
<ol>
<li><p>发起人（Originator）角色</p>
<p>记录当前时刻的内部状态信息，提供<strong>创建</strong>备忘录和<strong>恢复</strong>备忘录数据的功能，实现其他业务功能，它可以<strong>访问</strong>备忘录里的所有信息。</p>
</li>
<li><p>备忘录（Memento）角色</p>
<p>负责<strong>存储</strong>发起人的内部状态，在需要的时候提供这些内部状态给发起人。</p>
</li>
<li><p>管理者（Caretaker）角色</p>
<p>对备忘录进行管理，提供<strong>保存与获取</strong>备忘录的功能，但其<strong>不能对备忘录的内容进行访问与修改</strong>。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//备忘录</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memento</span></span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> String state;<span class="comment">//State也可以单独作为一个类，里面可以维护一个版本号作为key</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(String state)</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.state=state; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.state=state; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> state; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//发起者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Originator</span></span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line">    <span class="comment">//设置当前状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.state=state; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显示当前状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> state; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建备忘录</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">createMemento</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Memento(state); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//恢复，从备忘录中读取状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreMemento</span><span class="params">(Memento m)</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.setState(m.getState()); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//管理者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Caretaker</span></span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    Map&lt;String,Memento&gt; mementos = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//添加备忘录</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMemento</span><span class="params">(String key,Memento memento)</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        mementos.put(key,memento);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取指定备忘录</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">getMemento</span><span class="params">(String key)</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> mementos.get(key); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="备忘录模式扩展"><a href="#备忘录模式扩展" class="headerlink" title="备忘录模式扩展"></a>备忘录模式扩展</h4><p><strong>备忘录模式和原型模式联合</strong></p>
<p>在备忘录模式中，备忘录就是用来保存发起人内部信息的类，如果<strong>发起人内部所有信息都要被记录</strong>，则可以直接使用<strong>原型模式的clone方法</strong>(浅拷贝)，来复制一个相同的类，然后<strong>将该类作为备忘录</strong>保存在管理者类中。</p>
<img src="Java设计模式及UML类图.assets/3-1Q119130HW56.gif" alt="带原型的备忘录模式的结构图" style="zoom:80%;" />



<h3 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h3><p>给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子</p>
<p>由于效率很低，不常用</p>
<img src="Java设计模式及UML类图.assets/3-1Q119150626422.gif" alt="解释器模式的结构图" style="zoom:80%;" />

<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*文法规则</span></span><br><span class="line"><span class="comment">  &lt;expression&gt; ::= &lt;city&gt;的&lt;person&gt;</span></span><br><span class="line"><span class="comment">  &lt;city&gt; ::= 韶关|广州</span></span><br><span class="line"><span class="comment">  &lt;person&gt; ::= 老人|妇女|儿童</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterpreterPatternDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Context bus=<span class="keyword">new</span> Context();</span><br><span class="line">        bus.freeRide(<span class="string">&quot;韶关的老人&quot;</span>);</span><br><span class="line">        bus.freeRide(<span class="string">&quot;韶关的年轻人&quot;</span>);</span><br><span class="line">        bus.freeRide(<span class="string">&quot;广州的妇女&quot;</span>);</span><br><span class="line">        bus.freeRide(<span class="string">&quot;广州的儿童&quot;</span>);</span><br><span class="line">        bus.freeRide(<span class="string">&quot;山东的儿童&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象表达式类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Expression</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String info)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//终结符表达式类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TerminalExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; set= <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TerminalExpression</span><span class="params">(String[] data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;data.length;i++)set.add(data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(set.contains(info))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非终结符表达式类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AndExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Expression city=<span class="keyword">null</span>;    </span><br><span class="line">    <span class="keyword">private</span> Expression person=<span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AndExpression</span><span class="params">(Expression city,Expression person)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.city=city;</span><br><span class="line">        <span class="keyword">this</span>.person=person;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String s[]=info.split(<span class="string">&quot;的&quot;</span>);       </span><br><span class="line">        <span class="keyword">return</span> city.interpret(s[<span class="number">0</span>])&amp;&amp;person.interpret(s[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//环境类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] citys=&#123;<span class="string">&quot;韶关&quot;</span>,<span class="string">&quot;广州&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> String[] persons=&#123;<span class="string">&quot;老人&quot;</span>,<span class="string">&quot;妇女&quot;</span>,<span class="string">&quot;儿童&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> Expression cityPerson;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Expression city=<span class="keyword">new</span> TerminalExpression(citys);</span><br><span class="line">        Expression person=<span class="keyword">new</span> TerminalExpression(persons);</span><br><span class="line">        cityPerson=<span class="keyword">new</span> AndExpression(city,person);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">freeRide</span><span class="params">(String info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> ok=cityPerson.interpret(info);</span><br><span class="line">        <span class="keyword">if</span>(ok) System.out.println(<span class="string">&quot;您是&quot;</span>+info+<span class="string">&quot;，您本次乘车免费！&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> System.out.println(info+<span class="string">&quot;，您不是免费人员，本次乘车扣费2元！&quot;</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Java-常用解析器"><a href="#Java-常用解析器" class="headerlink" title="Java 常用解析器"></a>Java 常用解析器</h3><p>Java 提供了以下强大的数学公式解析器：Expression4J、MESP(Math Expression String Parser) 和 Jep (Java expression parser )等，它们可以解释一些复杂的文法，功能强大，使用简单。</p>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用Jep</span></span><br><span class="line"><span class="keyword">import</span> com.singularsys.jep.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JepDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JepException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Jep jep=<span class="keyword">new</span> Jep();</span><br><span class="line">        <span class="comment">//定义要计算的数据表达式</span></span><br><span class="line">        String 存款利息=<span class="string">&quot;本金*利率*时间&quot;</span>;</span><br><span class="line">        <span class="comment">//给相关变量赋值</span></span><br><span class="line">        jep.addVariable(<span class="string">&quot;本金&quot;</span>,<span class="number">10000</span>);</span><br><span class="line">        jep.addVariable(<span class="string">&quot;利率&quot;</span>,<span class="number">0.038</span>);</span><br><span class="line">        jep.addVariable(<span class="string">&quot;时间&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        jep.parse(存款利息);    <span class="comment">//解析表达式</span></span><br><span class="line">        Object accrual=jep.evaluate();    <span class="comment">//计算</span></span><br><span class="line">        System.out.println(<span class="string">&quot;存款利息：&quot;</span>+accrual);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h1><h2 id="UML图分类"><a href="#UML图分类" class="headerlink" title="UML图分类"></a>UML图分类</h2><ul>
<li>用例图</li>
<li>静态结构图：类图、对象图、包图、组件图、部署图</li>
<li>动态行为图：交互图（时序图与协作图）、状态图、活动图</li>
</ul>
<h2 id="UML类图简介"><a href="#UML类图简介" class="headerlink" title="UML类图简介"></a>UML类图简介</h2><p>用于描述系统中<strong>类本身组成</strong>和<strong>类之间的各种静态关系</strong></p>
<p><strong>类本身组成</strong></p>
<p>在UML类图中，类使用包含<strong>类名</strong>、<strong>属性(field)</strong> 和<strong>方法(method)</strong> 且带有分割线的<strong>矩形</strong>来表示，比如下图表示一个Employee类，它包含name,age和email这3个属性，以及modifyInfo()方法。</p>
<img src="Java设计模式及UML类图.assets/5336514-d05e8edc42eb1469.png" alt="img" style="zoom:50%;" />

<p>符号解释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-表示private  </span><br><span class="line">#表示protected </span><br><span class="line">~表示default,也就是包权限  </span><br><span class="line">_下划线表示static  </span><br><span class="line">斜体表示抽象</span><br></pre></td></tr></table></figure>



<p><strong>类之间的关系</strong></p>
<ol>
<li>依赖(下面几种其实都是特殊的依赖关系)</li>
<li>泛化</li>
<li>实现</li>
<li>关联</li>
<li>聚合</li>
<li>组合</li>
</ol>
<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p><strong>介绍</strong></p>
<p>对于两个相对独立的对象，当一个对象负责构造另一个对象的实例，或者依赖另一个对象的服务时，这两个对象之间主要体现为依赖关系</p>
<p><strong>表示方法</strong></p>
<p>依赖关系用<strong>虚线箭头</strong>表示。</p>
<p><strong>示例</strong><br>动物依赖氧气和水。调用新陈代谢方法需要氧气类与水类的实例作为参数</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5336514-823083d2d77916ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/414/format/webp" alt="img"></p>
<h2 id="泛化-继承"><a href="#泛化-继承" class="headerlink" title="泛化(继承)"></a>泛化(继承)</h2><p><strong>介绍</strong></p>
<p>继承表示是一个类（称为子类）继承另外的一个类（称为父类）的功能，并可以增加它自己的新功能的能力。</p>
<p><strong>表示方法</strong></p>
<p>继承使用<strong>空心三角形+实线</strong>表示。</p>
<p><strong>示例</strong></p>
<p>鸟类继承抽象类动物</p>
<p><img src="Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8F%8AUML%E7%B1%BB%E5%9B%BE.assets/5336514-dc3ac9dd64968b59.png" alt="img"></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><strong>介绍</strong></p>
<p>实现表示一个class类实现interface接口（可以是多个）的功能。</p>
<p><strong>表示方法</strong></p>
<p>使用<strong>空心三角形+虚线</strong>表示</p>
<p><strong>示例</strong></p>
<p>大雁和飞机需要飞行，就要实现飞()接口</p>
<p><img src="Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8F%8AUML%E7%B1%BB%E5%9B%BE.assets/%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB-c570177e290942b981025f5b4dd3e8ac.JPG" alt="实现关系"></p>
<h2 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h2><p><strong>介绍</strong></p>
<p>对于两个相对独立的对象，当一个对象的实例与另一个对象的一些特定实例存在固定的对应关系时，这两个对象之间为关联关系</p>
<h3 id="关联的性质"><a href="#关联的性质" class="headerlink" title="关联的性质"></a>关联的性质</h3><ul>
<li>导航性<ul>
<li>单向关联</li>
<li>双向关联</li>
<li>自关联</li>
</ul>
</li>
<li>多重性<ul>
<li>“1”有且仅有一个</li>
<li>“0…”0个或多个</li>
<li>“0,1”0个或者1个</li>
<li>“n…m”范围[n,m]中的一个</li>
<li>“m…*”范围[m,+∞)中的一个</li>
</ul>
</li>
</ul>
<h3 id="单向关联"><a href="#单向关联" class="headerlink" title="单向关联"></a>单向关联</h3><p><strong>表示方法</strong></p>
<p>使用<strong>带箭头的直线</strong>表示</p>
<p><strong>示例</strong></p>
<p>每个顾客都有一个地址，这通过让Customer类持有一个类型为Address的成员变量类实现</p>
<p><img src="Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8F%8AUML%E7%B1%BB%E5%9B%BE.assets/1169376-20180704220205722-1559850402.png" alt="img"></p>
<h3 id="双向关联"><a href="#双向关联" class="headerlink" title="双向关联"></a>双向关联</h3><p><strong>表示方法</strong></p>
<p>使用<strong>不带箭头的直线</strong>表示</p>
<p><strong>示例</strong></p>
<p>在Customer类中维护一个Product[]数组，表示一个顾客购买了那些产品；在Product类中维护一个Customer类型的成员变量表示这个产品被哪个顾客所购买</p>
<p><img src="Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8F%8AUML%E7%B1%BB%E5%9B%BE.assets/1169376-20180704220245189-9653603.png" alt="img"></p>
<h3 id="自关联"><a href="#自关联" class="headerlink" title="自关联"></a>自关联</h3><p>是一个特殊的单向关联</p>
<p><img src="Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8F%8AUML%E7%B1%BB%E5%9B%BE.assets/1169376-20180704220350930-485510936.png" alt="img"></p>
<h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p><strong>介绍</strong></p>
<p>表示一种弱的‘拥有’关系，即has-a的关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分。 <strong>两个对象具有各自的生命周期</strong>。</p>
<p><strong>表示方法</strong> </p>
<p>聚合关系用<strong>空心的菱形+实线箭头</strong>表示。</p>
<p><strong>示例</strong></p>
<p>每一只大雁都属于一个大雁群，一个大雁群可以有多只大雁。当大雁死去后大雁群并不会消失，两个对象生命周期不同。</p>
<p><img src="Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8F%8AUML%E7%B1%BB%E5%9B%BE.assets/5336514-e63191f4e23f2ad9.png" alt="img"></p>
<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p><strong>介绍</strong></p>
<p>组合是一种强的‘拥有’关系，是一种contains-a的关系，体现了严格的部分和整体关系，<strong>部分和整体的生命周期一样</strong>。</p>
<p><strong>表示方法</strong></p>
<p>组合关系用<strong>实心的菱形+实线箭头</strong>表示，还可以使用连线两端的数字表示某一端有几个实例。</p>
<p><strong>示例</strong></p>
<p>鸟和翅膀就是组合关系，因为它们是部分和整体的关系，并且翅膀和鸟的生命周期是相同的。</p>
<p><img src="Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8F%8AUML%E7%B1%BB%E5%9B%BE.assets/5336514-dfb604bd1c4408d5.png" alt="img"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Design Patterns</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven</title>
    <url>/2024/04/04/Maven/</url>
    <content><![CDATA[<h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><h4 id="1-Maven-是什么？"><a href="#1-Maven-是什么？" class="headerlink" title="1.Maven 是什么？"></a>1.Maven 是什么？</h4><p>Maven 主要服务于基于 Java 平台的项目构建、依赖管理和项目信息管理。</p>
<p>Maven 的主要功能主要分为 5 点：</p>
<ul>
<li>依赖管理系统</li>
<li>多模块构建</li>
<li>一致的项目结构</li>
<li>一致的构建模型和插件机制</li>
</ul>
<h4 id="2-什么选用-Maven-进行构建？"><a href="#2-什么选用-Maven-进行构建？" class="headerlink" title="2.什么选用 Maven 进行构建？"></a>2.什么选用 Maven 进行构建？</h4><ul>
<li>首先，Maven 是一个优秀的项目构建工具。使用 maven，可以很方便的对项目进行分模块构建，这样在开发和测试打包部署时，效率会提高很多。</li>
<li>其次，Maven 可以进行依赖的管理。使用 Maven ，可以将不同系统的依赖进行统一管理，并且可以进行依赖之间的传递和继承。</li>
</ul>
<h4 id="3-Maven-规约是什么？"><a href="#3-Maven-规约是什么？" class="headerlink" title="3. Maven 规约是什么？"></a>3. Maven 规约是什么？</h4><ul>
<li><code>/src/main/java/</code> ：Java 源码。</li>
<li><code>/src/main/resource</code> ：Java 配置文件，资源文件。</li>
<li><code>/src/test/java/</code> ：Java 测试代码。</li>
<li><code>/src/test/resource</code> ：Java 测试配置文件，资源文件。</li>
<li><code>/target</code> ：文件编译过程中生成的 <code>.class</code> 文件、jar、war 等等。</li>
<li><code>pom.xml</code> ：配置文件</li>
</ul>
<p>Maven 要负责项目的自动化构建，以编译为例，Maven 要想自动进行编译，那么它必须知道 Java 的源文件保存在哪里，这样约定之后，不用我们手动指定位置，Maven 能知道位置，从而帮我们完成自动编译。</p>
<p>遵循 <strong>“约定&gt;&gt;&gt; 配置 &gt;&gt;&gt; 编码”</strong>。即能进行配置的不要去编码指定，能事先约定规则的不要去进行配置。这样既减轻了劳动力，也能防止出错。</p>
<h4 id="4-Maven-常用命令"><a href="#4-Maven-常用命令" class="headerlink" title="4.Maven 常用命令"></a>4.Maven 常用命令</h4><ul>
<li><code>mvn archetype：create</code> ：创建 Maven 项目。</li>
<li><code>mvn compile</code> ：编译源代码。</li>
<li><code>mvn deploy</code> ：发布项目。</li>
<li><code>mvn test-compile</code> ：编译测试源代码。</li>
<li><code>mvn test</code> ：运行应用程序中的单元测试。</li>
<li><code>mvn site</code> ：生成项目相关信息的网站。</li>
<li><code>mvn clean</code> ：清除项目目录中的生成结果。</li>
<li><code>mvn package</code> ：根据项目生成的 jar/war 等。</li>
<li><code>mvn install</code> ：在本地 Repository 中安装 jar 。</li>
<li><code>mvn eclipse:eclipse</code> ：生成 Eclipse 项目文件。</li>
<li><code>mvn jetty:run</code> 启动 Jetty 服务。</li>
<li><code>mvn tomcat:run</code> ：启动 Tomcat 服务。</li>
<li><code>mvn clean package -Dmaven.test.skip=true</code> ：清除以前的包后重新打包，跳过测试类。</li>
</ul>
<p>用到最多的命令</p>
<ul>
<li><code>mvn eclipse:clean</code> ：清除 Project 中以前的编译的东西，重新再来。</li>
<li><code>mvn eclipse:eclipse</code> ：开始编译 Maven 的 Project 。</li>
<li><code>mvn clean package</code> ：清除以前的包后重新打包。</li>
</ul>
<h4 id="5-Maven-有哪些优点和缺点"><a href="#5-Maven-有哪些优点和缺点" class="headerlink" title="5.Maven 有哪些优点和缺点"></a>5.Maven 有哪些优点和缺点</h4><h5 id="1）优点"><a href="#1）优点" class="headerlink" title="1）优点"></a>1）优点</h5><ul>
<li><p>简化了项目依赖管理。</p>
<p>当年，多少人被 SSH 整合搞死搞活，很多时候，是因为依赖不完整，或者版本不正确。自从 Maven 出来后，终于可以无痛了~ 当然，也有一部分功劳是 Spring Boot ，这是后话。</p>
</li>
<li><p>易于上手，对于新手可能一个 <code>mvn clean package</code> 命令就可能满足我们的工作。</p>
</li>
<li><p>便于与持续集成工具 (Jenkins) 整合。</p>
</li>
<li><p>便于项目升级，无论是项目本身升级还是项目使用的依赖升级。</p>
</li>
<li><p>有助于多模块项目的开发，一个模块开发好后，发布到仓库，依赖该模块时可以直接从仓库更新，而不用自己去编译。</p>
</li>
<li><p>Maven 有很多插件，便于功能扩展，比如生产站点，自动发布版本等。</p>
</li>
</ul>
<h5 id="2）缺点"><a href="#2）缺点" class="headerlink" title="2）缺点"></a>2）缺点</h5><ul>
<li><p>Maven 是一个庞大的构建系统，学习难度大。</p>
<p>这里的学习，更多指的完整学习。如果基本使用，并不会存在该问题。</p>
</li>
<li><p>Maven 采用约定优于配置的策略 (convention over configuration)，虽然上手容易，但是一旦出了问题，难于调试。</p>
<p>这个确实，略微痛苦。</p>
</li>
<li><p>当依赖很多时，m2eclipse 老是搞得 Eclipse 很卡。</p>
<p>使用 IDEA ，而不是 Eclipse ，完美解决。</p>
</li>
<li><p>中国的网络环境差，很多 repository 无法访问，比如 Google Code、 JBoss 仓库无法访问等。</p>
<p>这个也好解决，在 <code>&lt;mirrors&gt;</code> 中增加阿里巴巴的 Maven 私服，具体可以参见 <a href="https://my.oschina.net/af8991/blog/833513">《提高 Maven 速度 —— Maven 仓库修改成国内阿里巴巴地址》</a> 文章。</p>
</li>
</ul>
<h4 id="6-什么是Maven的坐标"><a href="#6-什么是Maven的坐标" class="headerlink" title="6.什么是Maven的坐标"></a>6.什么是Maven的坐标</h4><p>Maven的坐标通过groupId，artifactId，version唯一标志一个构件。groupId通常为公司或组织名字，artifactId通常为项目名称，versionId为版本号。</p>
<h4 id="7-通过坐标如何定位地址"><a href="#7-通过坐标如何定位地址" class="headerlink" title="7.通过坐标如何定位地址"></a>7.通过坐标如何定位地址</h4><p>加上groupId为org.codehaus.mojo,artifactId为myproject，versionId为v1.0.0，则对应地址为：仓库目录（.m2）/org/codehaus/mojo/myproject/v1.0.0</p>
<h4 id="8-Maven的依赖范围有哪些（在scope中指定）"><a href="#8-Maven的依赖范围有哪些（在scope中指定）" class="headerlink" title="8.Maven的依赖范围有哪些（在scope中指定）"></a>8.Maven的依赖范围有哪些（在scope中指定）</h4><p>compile：默认范围，如果未指定任何范围，则使用该范围。编译依赖项在所有（编译，测试，运行）类路径中都可用。此外，这些依赖关系会传播到依赖的项目</p>
<p>provided：这很像compile，但表示您希望JDK或容器在运行时提供它。它只在编译和测试类路径上可用，不可传递。</p>
<p>runtime：此范围表示编译不需要依赖项，但需要执行依赖项。它在运行时和测试类路径中，但不在编译类路径中。（servlet-api）</p>
<p>test：表示应用程序的正常使用不需要依赖项，并且仅在测试编译和执行阶段可用。它不是传递的。（jdbc）</p>
<p>system：系统依赖范围。该依赖与三种classpath的关系和provided依赖范围完全一致。但是，使用system范围的依赖时必须通过systemPath元素显式地指定依赖文件的路径。由于此类依赖不是通过Maven仓库解析的，而且往往与本机系统绑定，可能造成构建的不可移植。</p>
<h4 id="9-Maven生命周期"><a href="#9-Maven生命周期" class="headerlink" title="9.Maven生命周期"></a>9.Maven生命周期</h4><p>　有三套什么周期，分别为clean，default，site</p>
<p>　　　clean：</p>
<p>　　　　此生命周期旨在给工程做清理工作，它主要包含以下阶段：</p>
<p>　　　　pre-clean - 执行项目清理前所需要的工作。</p>
<p>　　　　clean - 清理上一次build项目生成的文件。</p>
<p>　　　　post-clean - 执行完成项目清理所需的工作。</p>
<p>　　　default：</p>
<p>　　　　validate - 验证项目是否正确且所有必要的信息都可用。</p>
<p>　　　　initialize - 初始化构建工作，如：设置参数，创建目录等。</p>
<p>　　　　generate-sources - 为包含在编译范围内的代码生成源代码.</p>
<p>　　　　process-sources - 处理源代码, 如过滤值.</p>
<p>　　　　generate-resources -</p>
<p>　　　　process-resources - 复制并处理资源文件，至目标目录，准备打包。</p>
<p>　　　　compile - 编译项目中的源代码.</p>
<p>　　　　process-classes - 为编译生成的文件做后期工作, 例如做Java类的字节码增强.</p>
<p>　　　　generate-test-sources - 为编译内容生成测试源代码.</p>
<p>　　　　process-test-sources - 处理测试源代码。</p>
<p>　　　　generate-test-resources -</p>
<p>　　　　process-test-resources - 复制并处理资源文件，至目标测试目录。</p>
<p>　　　　test-compile - 将需测试源代码编译到路径。一般来说，是编译/src/test/java目录下的java文件至目标输出的测试classpath目录中。</p>
<p>　　　　process-test-classes -</p>
<p>　　　　test - 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。</p>
<p>　　　　prepare-package -</p>
<p>　　　　package - 接受编译好的代码，打包成可发布的格式，如 JAR 。</p>
<p>　　　　pre-integration-test -</p>
<p>　　　　integration-test - 按需求将发布包部署到运行环境。</p>
<p>　　　　post-integration-test -</p>
<p>　　　　verify -</p>
<p>　　　　install -将包安装到本地仓库，给其他本地引用提供依赖。</p>
<p>　　　　deploy -完成集成和发布工作，将最终包复制到远程仓库以便分享给其他开发人员。</p>
<p>　　　site：</p>
<p>　　　　pre-site - 执行一些生成项目站点前的准备工作。</p>
<p>　　　　site - 生成项目站点的文档。</p>
<p>　　　　post-site - 执行需完成站点生成的工作，如站点部署的准备工作。</p>
<p>　　　　site-deploy - 向制定的web服务器部署站点生成文件。</p>
<h4 id="10-Maven命令"><a href="#10-Maven命令" class="headerlink" title="10.Maven命令"></a>10.Maven命令</h4><p>　mvn archetype:generate 创建Maven项目</p>
<p>　　　mvn compile 编译源代码</p>
<p>　　　mvn deploy 发布项目</p>
<p>　　　mvn test-compile 编译测试源代码</p>
<p>　　　mvn test 运行应用程序中的单元测试</p>
<p>　　　mvn site 生成项目相关信息的网站</p>
<p>　　　mvn clean 清除项目目录中的生成结果</p>
<p>　　　mvn package 根据项目生成的jar</p>
<p>　　　mvn install 在本地Repository中安装jar</p>
<p>　　　mvn eclipse:eclipse 生成eclipse项目文件</p>
<p>　　　mvn<a href="https://baike.baidu.com/item/jetty">jetty</a>:run 启动jetty服务</p>
<p>　　　mvn<a href="https://baike.baidu.com/item/tomcat">tomcat</a>:run 启动tomcat服务</p>
<p>　　　mvn clean package -Dmaven.test.skip=true:清除以前的包后重新打包，跳过测试</p>
<h4 id="11-依赖的解析机制"><a href="#11-依赖的解析机制" class="headerlink" title="11.依赖的解析机制"></a>11.依赖的解析机制</h4><p>当依赖的范围是 system 的时候，Maven 直接从本地文件系统中解析构件。</p>
<p>根据依赖坐标计算仓库路径，尝试直接从本地仓库寻找构件，如果发现对应的构件，就解析成功。</p>
<p>如果在本地仓库不存在相应的构件，就遍历所有的远程仓库，发现后，下载并解析使用。</p>
<p>如果依赖的版本是 RELEASE 或 LATEST，就基于更新策略读取所有远程仓库的元数据文件（groupId/artifactId/maven-metadata.xml），将其与本地仓库的对应元合并后，计算出 RELEASE 或者 LATEST 真实的值，然后基于该值检查本地仓库，或者从远程仓库下载。</p>
<p>如果依赖的版本是 SNAPSHOT，就基于更新策略读取所有远程仓库的元数据文件，将它与本地仓库对应的元数据合并，得到最新快照版本的值，然后根据该值检查本地仓库，或从远程仓库下载。</p>
<p>如果最后解析得到的构件版本包含有时间戳，先将该文件下载下来，再将文件名中时间戳信息删除，剩下 SNAPSHOT 并使用（以非时间戳的形式使用）。</p>
<h4 id="12-创建Maven的普通Java项目"><a href="#12-创建Maven的普通Java项目" class="headerlink" title="12.创建Maven的普通Java项目"></a>12.创建Maven的普通Java项目</h4><p>  mvn archetype:create -DgroupId=packageName -DartifactId=projectName</p>
<h4 id="13-创建-Maven-的-Web-项目"><a href="#13-创建-Maven-的-Web-项目" class="headerlink" title="13.创建 Maven 的 Web 项目"></a>13.创建 Maven 的 Web 项目</h4><p> mvn archetype:create -DgroupId=packageName -DartifactId=webappName -DarchetypeArtifactId=maven-archetype-webapp</p>
<h4 id="14-反向生成-maven-项目的骨架"><a href="#14-反向生成-maven-项目的骨架" class="headerlink" title="14.反向生成 maven 项目的骨架"></a>14.反向生成 maven 项目的骨架</h4><p>  mvn artifacttype:generate</p>
<h4 id="15-编译源代码"><a href="#15-编译源代码" class="headerlink" title="15.编译源代码"></a>15.编译源代码</h4><p>  mvn compile</p>
<h4 id="16-编译测试代码"><a href="#16-编译测试代码" class="headerlink" title="16.编译测试代码"></a>16.编译测试代码</h4><p>  mvn test-compile</p>
<h4 id="17-运行测试"><a href="#17-运行测试" class="headerlink" title="17.运行测试"></a>17.运行测试</h4><p>  mvn test</p>
<h4 id="18-产生-site"><a href="#18-产生-site" class="headerlink" title="18.产生 site"></a>18.产生 site</h4><p>  mvn site</p>
<h4 id="19-打包"><a href="#19-打包" class="headerlink" title="19.打包"></a>19.打包</h4><p>  mvn package</p>
<h4 id="20-在本地-Repository-中安装-jar"><a href="#20-在本地-Repository-中安装-jar" class="headerlink" title="20.在本地 Repository 中安装 jar"></a>20.在本地 Repository 中安装 jar</h4><p>  mvn install（例：installing D:\xxx\xx.jar to D:\xx\xxxx）</p>
<h4 id="21-清除产生的项目"><a href="#21-清除产生的项目" class="headerlink" title="21.清除产生的项目"></a>21.清除产生的项目</h4><p>  mvn clean</p>
<h4 id="22-生成-Eclipse-项目-idea项目"><a href="#22-生成-Eclipse-项目-idea项目" class="headerlink" title="22.生成 Eclipse 项目/idea项目"></a>22.生成 Eclipse 项目/idea项目</h4><p>eclipse项目 </p>
<p> mvn eclipse:eclipse</p>
<p> idea 项目</p>
<p> mvn idea:idea</p>
<h4 id="23-组合使用-goal-命令，如只打包不测试"><a href="#23-组合使用-goal-命令，如只打包不测试" class="headerlink" title="23.组合使用 goal 命令，如只打包不测试"></a>23.组合使用 goal 命令，如只打包不测试</h4><p>  mvn -Dtest package</p>
<h4 id="24-编译测试的内容"><a href="#24-编译测试的内容" class="headerlink" title="24.编译测试的内容"></a>24.编译测试的内容</h4><p>  mvn test-compile</p>
<h4 id="25-只打-jar-包"><a href="#25-只打-jar-包" class="headerlink" title="25.只打 jar 包"></a>25.只打 jar 包</h4><p>  mvn jar:jar</p>
<h4 id="26-只测试而不编译，也不测试编译"><a href="#26-只测试而不编译，也不测试编译" class="headerlink" title="26.只测试而不编译，也不测试编译"></a>26.只测试而不编译，也不测试编译</h4><p>  mvn test -skipping compile -skipping test-compile</p>
<h4 id="27-清除-eclipse-的一些系统设置"><a href="#27-清除-eclipse-的一些系统设置" class="headerlink" title="27.清除 eclipse 的一些系统设置"></a>27.清除 eclipse 的一些系统设置</h4><p>  mvn eclipse:clean</p>
<h4 id="28-查找当前项目已被解析的依赖"><a href="#28-查找当前项目已被解析的依赖" class="headerlink" title="28.查找当前项目已被解析的依赖"></a>28.查找当前项目已被解析的依赖</h4><p>  mvn dependency:list</p>
<h4 id="29-上传到私服"><a href="#29-上传到私服" class="headerlink" title="29.上传到私服"></a>29.上传到私服</h4><p>  mvn deploy</p>
<h4 id="30-强制检查更新，由于快照版本的更新策略（一天更新几次、隔断时间更新一次）存在，如果想强制更新就会用到此命令"><a href="#30-强制检查更新，由于快照版本的更新策略（一天更新几次、隔断时间更新一次）存在，如果想强制更新就会用到此命令" class="headerlink" title="30.强制检查更新，由于快照版本的更新策略（一天更新几次、隔断时间更新一次）存在，如果想强制更新就会用到此命令"></a>30.强制检查更新，由于快照版本的更新策略（一天更新几次、隔断时间更新一次）存在，如果想强制更新就会用到此命令</h4><p>  mvn clean install-U</p>
<h4 id="31-源码打包"><a href="#31-源码打包" class="headerlink" title="31.源码打包"></a>31.源码打包</h4><p>  mvn source:jar</p>
<p>  或</p>
<p>  mvn source:jar-no-fork</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://blog.csdn.net/a303549861/article/details/93752178">https://blog.csdn.net/a303549861/article/details/93752178</a></p>
<p><a href="https://www.cnblogs.com/lin0/p/14153982.html">https://www.cnblogs.com/lin0/p/14153982.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper</title>
    <url>/2024/03/27/Zookeeper/</url>
    <content><![CDATA[<h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><h4 id="1-ZooKeeper-是什么？"><a href="#1-ZooKeeper-是什么？" class="headerlink" title="1.ZooKeeper 是什么？"></a>1.ZooKeeper 是什么？</h4><p>ZooKeeper 是一个开源的分布式协调服务。它是一个为分布式应用提供一致性服务的软件，分布式应用程序可以基于 Zookeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。</p>
<p>ZooKeeper 的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。</p>
<p>Zookeeper 保证了如下分布式一致性特性：</p>
<p>（1）顺序一致性</p>
<p>（2）原子性</p>
<p>（3）单一视图</p>
<p>（4）可靠性</p>
<p>（5）实时性（最终一致性）</p>
<p>客户端的读请求可以被集群中的任意一台机器处理，如果读请求在节点上注册了监听器，这个监听器也是由所连接的 zookeeper 机器来处理。对于写请求，这些请求会同时发给其他 zookeeper 机器并且达成一致后，请求才会返回成功。因此，随着 zookeeper 的集群机器增多，读请求的吞吐会提高但是写请求的吞吐会下降。</p>
<p>有序性是 zookeeper 中非常重要的一个特性，所有的更新都是全局有序的，每个更新都有一个唯一的时间戳，这个时间戳称为 zxid（Zookeeper Transaction Id）。而读请求只会相对于更新有序，也就是读请求的返回结果中会带有这个zookeeper 最新的 zxid。</p>
<h4 id="2-ZooKeeper-提供了什么？"><a href="#2-ZooKeeper-提供了什么？" class="headerlink" title="2.ZooKeeper 提供了什么？"></a>2.ZooKeeper 提供了什么？</h4><ul>
<li>文件系统</li>
<li>通知机制</li>
</ul>
<h4 id="3-Zookeeper-文件系统"><a href="#3-Zookeeper-文件系统" class="headerlink" title="3.Zookeeper 文件系统"></a>3.Zookeeper 文件系统</h4><p>Zookeeper 提供一个多层级的节点命名空间（节点称为 znode）。与文件系统不同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。</p>
<p>Zookeeper 为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这种特性使得 Zookeeper 不能用于存放大量的数据，每个节点的存放数据上限为1M。</p>
<h4 id="4-Zookeeper-怎么保证主从节点的状态同步？"><a href="#4-Zookeeper-怎么保证主从节点的状态同步？" class="headerlink" title="4.Zookeeper 怎么保证主从节点的状态同步？"></a>4.Zookeeper 怎么保证主从节点的状态同步？</h4><p> Zookeeper 的核心是原子广播机制，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 Zab 协议。Zab 协议有两种模式，它们分别是恢复模式和广播模式。</p>
<h5 id="恢复模式"><a href="#恢复模式" class="headerlink" title="恢复模式"></a>恢复模式</h5><p>当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。</p>
<h5 id="广播模式"><a href="#广播模式" class="headerlink" title="广播模式"></a>广播模式</h5><p>一旦 leader 已经和多数的 follower 进行了状态同步后，它就可以开始广播消息了，即进入广播状态。这时候当一个 server 加入 ZooKeeper 服务中，它会在恢复模式下启动，发现 leader，并和 leader 进行状态同步。待到同步结束，它也参与消息广播。ZooKeeper 服务一直维持在 Broadcast 状态，直到 leader 崩溃了或者 leader 失去了大部分的 followers 支持。</p>
<h4 id="5-四种类型的数据节点-Znode"><a href="#5-四种类型的数据节点-Znode" class="headerlink" title="5.四种类型的数据节点 Znode"></a>5.四种类型的数据节点 Znode</h4><p>（1）PERSISTENT-持久节点<br> 除非手动删除，否则节点一直存在于 Zookeeper 上</p>
<p>（2）EPHEMERAL-临时节点<br> 临时节点的生命周期与客户端会话绑定，一旦客户端会话失效（客户端与zookeeper 连接断开不一定会话失效），那么这个客户端创建的所有临时节点都会被移除。</p>
<p>（3）PERSISTENT_SEQUENTIAL-持久顺序节点<br> 基本特性同持久节点，只是增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。</p>
<p>（4）EPHEMERAL_SEQUENTIAL-临时顺序节点<br> 基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。</p>
<h4 id="6-Zookeeper-Watcher-机制-–-数据变更通知"><a href="#6-Zookeeper-Watcher-机制-–-数据变更通知" class="headerlink" title="6.Zookeeper Watcher 机制 – 数据变更通知"></a>6.Zookeeper Watcher 机制 – 数据变更通知</h4><p>Zookeeper 允许客户端向服务端的某个 Znode 注册一个 Watcher 监听，当服务端的一些指定事件触发了这个 Watcher，服务端会向指定客户端发送一个事件通知来实现分布式的通知功能，然后客户端根据 Watcher 通知状态和事件类型做出业务上的改变。</p>
<p>工作机制：</p>
<p>（1）客户端注册 watcher</p>
<p>（2）服务端处理 watcher</p>
<p>（3）客户端回调 watcher</p>
<h4 id="7-Watcher-特性总结"><a href="#7-Watcher-特性总结" class="headerlink" title="7.Watcher 特性总结"></a>7.Watcher 特性总结</h4><h5 id="一次性"><a href="#一次性" class="headerlink" title="一次性"></a>一次性</h5><p>无论是服务端还是客户端，一旦一个 Watcher 被 触 发 ，Zookeeper 都会将其从相应的存储中移除。这样的设计有效的减轻了服务端的压力，不然对于更新非常频繁的节点，服务端会不断的向客户端发送事件通知，无论对于网络还是服务端的压力都非常大。</p>
<h5 id="客户端串行执行"><a href="#客户端串行执行" class="headerlink" title="客户端串行执行"></a>客户端串行执行</h5><p>客户端 Watcher 回调的过程是一个串行同步的过程。</p>
<h5 id="轻量"><a href="#轻量" class="headerlink" title="轻量"></a>轻量</h5><p>3.1、Watcher 通知非常简单，只会告诉客户端发生了事件，而不会说明事件的具体内容。<br>3.2、客户端向服务端注册 Watcher 的时候，并不会把客户端真实的 Watcher 对象实体传递到服务端，仅仅是在客户端请求中使用 boolean 类型属性进行了标记。</p>
<p>watcher event 异步发送 watcher 的通知事件从 server 发送到 client 是异步的，这就存在一个问题，不同的客户端和服务器之间通过 socket 进行通信，由于网络延迟或其他因素导致客户端在不通的时刻监听到事件，由于 Zookeeper 本身提供了 ordering guarantee，即客户端监听事件后，才会感知它所监视 znode发生了变化。所以我们使用 Zookeeper 不能期望能够监控到节点每次的变化。Zookeeper 只能保证最终的一致性，而无法保证强一致性。</p>
<p>注册 watcher getData、exists、getChildren</p>
<p>触发 watcher create、delete、setData</p>
<p>当一个客户端连接到一个新的服务器上时，watch 将会被以任意会话事件触发。当与一个服务器失去连接的时候，是无法接收到 watch 的。而当 client 重新连接时，如果需要的话，所有先前注册过的 watch，都会被重新注册。通常这是完全透明的。只有在一个特殊情况下，watch 可能会丢失：对于一个未创建的 znode的 exist watch，如果在客户端断开连接期间被创建了，并且随后在客户端连接上之前又删除了，这种情况下，这个 watch 事件可能会被丢失。</p>
<h4 id="8-客户端注册-Watcher-实现"><a href="#8-客户端注册-Watcher-实现" class="headerlink" title="8.客户端注册 Watcher 实现"></a>8.客户端注册 Watcher 实现</h4><p>（1）调用 getData()/getChildren()/exist()三个 API，传入 Watcher 对象</p>
<p>（2）标记请求 request，封装 Watcher 到 WatchRegistration</p>
<p>（3）封装成 Packet 对象，发服务端发送 request</p>
<p>（4）收到服务端响应后，将 Watcher 注册到 ZKWatcherManager 中进行管理</p>
<p>（5）请求返回，完成注册。</p>
<h4 id="9-服务端处理-Watcher-实现"><a href="#9-服务端处理-Watcher-实现" class="headerlink" title="9.服务端处理 Watcher 实现"></a>9.服务端处理 Watcher 实现</h4><h5 id="1-服务端接收-Watcher-并存储"><a href="#1-服务端接收-Watcher-并存储" class="headerlink" title="1.服务端接收 Watcher 并存储"></a>1.服务端接收 Watcher 并存储</h5><p>接收到客户端请求，处理请求判断是否需要注册 Watcher，需要的话将数据节点的节点路径和 ServerCnxn（ServerCnxn 代表一个客户端和服务端的连接，实现了 Watcher 的 process 接口，此时可以看成一个 Watcher 对象）存储在WatcherManager 的 WatchTable 和 watch2Paths 中去。</p>
<h5 id="2-Watcher-触发"><a href="#2-Watcher-触发" class="headerlink" title="2.Watcher 触发"></a>2.Watcher 触发</h5><p>以服务端接收到 setData() 事务请求触发 NodeDataChanged 事件为例：</p>
<p>2.1 封装 WatchedEvent<br>将通知状态（SyncConnected）、事件类型（NodeDataChanged）以及节点路径封装成一个 WatchedEvent 对象</p>
<p>2.2 查询 Watcher<br>从 WatchTable 中根据节点路径查找 Watcher</p>
<p>2.3 没找到；说明没有客户端在该数据节点上注册过 Watcher</p>
<p>2.4 找到；提取并从 WatchTable 和 Watch2Paths 中删除对应 Watcher（从这里可以看出 Watcher 在服务端是一次性的，触发一次就失效了）</p>
<h5 id="3-调用-process-方法来触发-Watcher"><a href="#3-调用-process-方法来触发-Watcher" class="headerlink" title="3.调用 process 方法来触发 Watcher"></a>3.调用 process 方法来触发 Watcher</h5><p>这里 process 主要就是通过 ServerCnxn 对应的 TCP 连接发送 Watcher 事件通知。</p>
<h4 id="10-客户端回调-Watcher"><a href="#10-客户端回调-Watcher" class="headerlink" title="10.客户端回调 Watcher"></a>10.客户端回调 Watcher</h4><ul>
<li>客户端 SendThread 线程接收事件通知，交由 EventThread 线程回调 Watcher。</li>
<li>客户端的 Watcher 机制同样是一次性的，一旦被触发后，该 Watcher 就失效了。</li>
</ul>
<h4 id="11-ACL-权限控制机制"><a href="#11-ACL-权限控制机制" class="headerlink" title="11.ACL 权限控制机制"></a>11.ACL 权限控制机制</h4><p>UGO（User/Group/Others）</p>
<p>目前在 Linux/Unix 文件系统中使用，也是使用最广泛的权限控制方式。是一种粗粒度的文件系统权限控制模式。</p>
<p>ACL（Access Control List）访问控制列表</p>
<p>包括三个方面：</p>
<p>权限模式（Scheme）<br>（1）IP：从 IP 地址粒度进行权限控制<br>（2）Digest：最常用，用类似于 username:password 的权限标识来进行权限配置，便于区分不同应用来进行权限控制<br>（3）World：最开放的权限控制方式，是一种特殊的 digest 模式，只有一个权限标识“world:anyone”<br>（4）Super：超级用户</p>
<p>授权对象<br>授权对象指的是权限赋予的用户或一个指定实体，例如 IP 地址或是机器灯。</p>
<p>权限 Permission<br>（1）CREATE：数据节点创建权限，允许授权对象在该 Znode 下创建子节点<br>（2）DELETE：子节点删除权限，允许授权对象删除该数据节点的子节点<br>（3）READ：数据节点的读取权限，允许授权对象访问该数据节点并读取其数据内容或子节点列表等<br>（4）WRITE：数据节点更新权限，允许授权对象对该数据节点进行更新操作<br>（5）ADMIN：数据节点管理权限，允许授权对象对该数据节点进行 ACL 相关设置操作</p>
<h4 id="12-Chroot-特性"><a href="#12-Chroot-特性" class="headerlink" title="12.Chroot 特性"></a>12.Chroot 特性</h4><p>3.2.0 版本后，添加了 Chroot 特性，该特性允许每个客户端为自己设置一个命名空间。如果一个客户端设置了 Chroot，那么该客户端对服务器的任何操作，都将会被限制在其自己的命名空间下。</p>
<p>通过设置 Chroot，能够将一个客户端应用于 Zookeeper 服务端的一颗子树相对应，在那些多个应用公用一个 Zookeeper 进群的场景下，对实现不同应用间的相互隔离非常有帮助。</p>
<h4 id="13-会话管理"><a href="#13-会话管理" class="headerlink" title="13.会话管理"></a>13.会话管理</h4><p>分桶策略：将类似的会话放在同一区块中进行管理，以便于 Zookeeper 对会话进行不同区块的隔离处理以及同一区块的统一处理。</p>
<p>分配原则：每个会话的“下次超时时间点”（ExpirationTime）</p>
<p>计算公式：</p>
<p>ExpirationTime_ = currentTime + sessionTimeout</p>
<p>ExpirationTime = (ExpirationTime_ / ExpirationInrerval + 1) *</p>
<p>ExpirationInterval , ExpirationInterval 是指 Zookeeper 会话超时检查时间间隔，默认 tickTime</p>
<h4 id="14-服务器角色"><a href="#14-服务器角色" class="headerlink" title="14.服务器角色"></a>14.服务器角色</h4><p>Leader</p>
<p>（1）事务请求的唯一调度和处理者，保证集群事务处理的顺序性</p>
<p>（2）集群内部各服务的调度者</p>
<p>Follower</p>
<p>（1）处理客户端的非事务请求，转发事务请求给 Leader 服务器</p>
<p>（2）参与事务请求 Proposal 的投票</p>
<p>（3）参与 Leader 选举投票</p>
<p>Observer</p>
<p>（1）3.0 版本以后引入的一个服务器角色，在不影响集群事务处理能力的基础上提升集群的非事务处理能力</p>
<p>（2）处理客户端的非事务请求，转发事务请求给 Leader 服务器</p>
<p>（3）不参与任何形式的投票</p>
<h4 id="15-Zookeeper-下-Server-工作状态"><a href="#15-Zookeeper-下-Server-工作状态" class="headerlink" title="15.Zookeeper 下 Server 工作状态"></a>15.Zookeeper 下 Server 工作状态</h4><p>服务器具有四种状态，分别是 LOOKING、FOLLOWING、LEADING、OBSERVING。</p>
<p>（1）LOOKING：寻 找 Leader 状态。当服务器处于该状态时，它会认为当前集群中没有 Leader，因此需要进入 Leader 选举状态。</p>
<p>（2）FOLLOWING：跟随者状态。表明当前服务器角色是 Follower。</p>
<p>（3）LEADING：领导者状态。表明当前服务器角色是 Leader。</p>
<p>（4）OBSERVING：观察者状态。表明当前服务器角色是 Observer。</p>
<h4 id="16-Leader-选举"><a href="#16-Leader-选举" class="headerlink" title="16.Leader 选举"></a>16.Leader 选举</h4><p>Leader 选举是保证分布式数据一致性的关键所在。当 Zookeeper 集群中的一台服务器出现以下两种情况之一时，需要进入 Leader 选举。</p>
<p>　　(1) 服务器初始化启动。</p>
<p>　　(2) 服务器运行期间无法和 Leader 保持连接。</p>
<p>　　下面就两种情况进行分析讲解。</p>
<p>　　1. 服务器启动时期的 Leader 选举</p>
<p>　　若进行 Leader 选举，则至少需要两台机器，这里选取 3 台机器组成的服务器集群为例。在集群初始化阶段，当有一台服务器 Server1 启动时，其单独无法进行和完成 Leader 选举，当第二台服务器 Server2 启动时，此时两台机器可以相互通信，每台机器都试图找到 Leader，于是进入 Leader 选举过程。选举过程如下</p>
<p>　　(1) 每个 Server 发出一个投票。由于是初始情况，Server1 和 Server2 都会将自己作为 Leader 服务器来进行投票，每次投票会包含所推举的服务器的 myid 和 ZXID，使用 (myid, ZXID) 来表示，此时 Server1 的投票为(1, 0)，Server2 的投票为(2, 0)，然后各自将这个投票发给集群中其他机器。</p>
<p>　　(2) 接受来自各个服务器的投票。集群的每个服务器收到投票后，首先判断该投票的有效性，如检查是否是本轮投票、是否来自 LOOKING 状态的服务器。</p>
<p>　　(3) 处理投票。针对每一个投票，服务器都需要将别人的投票和自己的投票进行 PK，PK 规则如下</p>
<p>　　　　· 优先检查 ZXID。ZXID 比较大的服务器优先作为 Leader。</p>
<p>　　　　· 如果 ZXID 相同，那么就比较 myid。myid 较大的服务器作为 Leader 服务器。</p>
<p>　　对于 Server1 而言，它的投票是 (1, 0)，接收 Server2 的投票为 (2, 0)，首先会比较两者的 ZXID，均为 0，再比较 myid，此时 Server2 的 myid 最大，于是更新自己的投票为 (2, 0)，然后重新投票，对于 Server2 而言，其无须更新自己的投票，只是再次向集群中所有机器发出上一次投票信息即可。</p>
<p>　　(4) 统计投票。每次投票后，服务器都会统计投票信息，判断是否已经有过半机器接受到相同的投票信息，对于 Server1、Server2 而言，都统计出集群中已经有两台机器接受了 (2, 0) 的投票信息，此时便认为已经选出了 Leader。</p>
<p>　　(5) 改变服务器状态。一旦确定了 Leader，每个服务器就会更新自己的状态，如果是 Follower，那么就变更为 FOLLOWING，如果是 Leader，就变更为 LEADING。</p>
<p>　　2. 服务器运行时期的 Leader 选举</p>
<p>　　在 Zookeeper 运行期间，Leader 与非 Leader 服务器各司其职，即便当有非 Leader 服务器宕机或新加入，此时也不会影响 Leader，但是一旦 Leader 服务器挂了，那么整个集群将暂停对外服务，进入新一轮 Leader 选举，其过程和启动时期的 Leader 选举过程基本一致。假设正在运行的有 Server1、Server2、Server3 三台服务器，当前 Leader 是 Server2，若某一时刻 Leader 挂了，此时便开始 Leader 选举。选举过程如下</p>
<p>　　(1) 变更状态。Leader 挂后，余下的非 Observer 服务器都会讲自己的服务器状态变更为 LOOKING，然后开始进入 Leader 选举过程。</p>
<p>　　(2) 每个 Server 会发出一个投票。在运行期间，每个服务器上的 ZXID 可能不同，此时假定 Server1 的 ZXID 为 123，Server3 的 ZXID 为 122；在第一轮投票中，Server1 和 Server3 都会投自己，产生投票 (1, 123)，(3, 122)，然后各自将投票发送给集群中所有机器。</p>
<p>　　(3) 接收来自各个服务器的投票。与启动时过程相同。</p>
<p>　　(4) 处理投票。与启动时过程相同，此时，Server1 将会成为 Leader。</p>
<p>　　(5) 统计投票。与启动时过程相同。</p>
<p>　　(6) 改变服务器的状态。与启动时过程相同。</p>
<p>　　2.2 Leader 选举算法分析</p>
<p>　　在 3.4.0 后的 Zookeeper 的版本只保留了 TCP 版本的 FastLeaderElection 选举算法。当一台机器进入 Leader 选举时，当前集群可能会处于以下两种状态</p>
<p>　　　　· 集群中已经存在 Leader。</p>
<p>　　　　· 集群中不存在 Leader。</p>
<p>　　对于集群中已经存在 Leader 而言，此种情况一般都是某台机器启动得较晚，在其启动之前，集群已经在正常工作，对这种情况，该机器试图去选举 Leader 时，会被告知当前服务器的 Leader 信息，对于该机器而言，仅仅需要和 Leader 机器建立起连接，并进行状态同步即可。而在集群中不存在 Leader 情况下则会相对复杂，其步骤如下</p>
<p>　　(1) 第一次投票。无论哪种导致进行 Leader 选举，集群的所有机器都处于试图选举出一个 Leader 的状态，即 LOOKING 状态，LOOKING 机器会向所有其他机器发送消息，该消息称为投票。投票中包含了 SID（服务器的唯一标识）和 ZXID（事务 ID），(SID, ZXID) 形式来标识一次投票信息。假定 Zookeeper 由 5 台机器组成，SID 分别为 1、2、3、4、5，ZXID 分别为 9、9、9、8、8，并且此时 SID 为 2 的机器是 Leader 机器，某一时刻，1、2 所在机器出现故障，因此集群开始进行 Leader 选举。在第一次投票时，每台机器都会将自己作为投票对象，于是 SID 为 3、4、5 的机器投票情况分别为 (3, 9)，(4, 8)， (5, 8)。</p>
<p>　　(2) 变更投票。每台机器发出投票后，也会收到其他机器的投票，每台机器会根据一定规则来处理收到的其他机器的投票，并以此来决定是否需要变更自己的投票，这个规则也是整个 Leader 选举算法的核心所在，其中术语描述如下</p>
<p>　　　　· vote_sid：接收到的投票中所推举 Leader 服务器的 SID。</p>
<p>　　　　· vote_zxid：接收到的投票中所推举 Leader 服务器的 ZXID。</p>
<p>　　　　· self_sid：当前服务器自己的 SID。</p>
<p>　　　　· self_zxid：当前服务器自己的 ZXID。</p>
<p>　　每次对收到的投票的处理，都是对 (vote_sid, vote_zxid) 和(self_sid, self_zxid)对比的过程。</p>
<p>　　　　规则一：如果 vote_zxid 大于 self_zxid，就认可当前收到的投票，并再次将该投票发送出去。</p>
<p>　　　　规则二：如果 vote_zxid 小于 self_zxid，那么坚持自己的投票，不做任何变更。</p>
<p>　　　　规则三：如果 vote_zxid 等于 self_zxid，那么就对比两者的 SID，如果 vote_sid 大于 self_sid，那么就认可当前收到的投票，并再次将该投票发送出去。</p>
<p>　　　　规则四：如果 vote_zxid 等于 self_zxid，并且 vote_sid 小于 self_sid，那么坚持自己的投票，不做任何变更。</p>
<p>　　结合上面规则，给出下面的集群变更过程。</p>
<p>　　(3) 确定 Leader。经过第二轮投票后，集群中的每台机器都会再次接收到其他机器的投票，然后开始统计投票，如果一台机器收到了超过半数的相同投票，那么这个投票对应的 SID 机器即为 Leader。此时 Server3 将成为 Leader。</p>
<p>　　由上面规则可知，通常那台服务器上的数据越新（ZXID 会越大），其成为 Leader 的可能性越大，也就越能够保证数据的恢复。如果 ZXID 相同，则 SID 越大机会越大。</p>
<p>　　2.3 Leader 选举实现细节</p>
<p>　　1. 服务器状态</p>
<p>　　服务器具有四种状态，分别是 LOOKING、FOLLOWING、LEADING、OBSERVING。</p>
<p>　　LOOKING：寻找 Leader 状态。当服务器处于该状态时，它会认为当前集群中没有 Leader，因此需要进入 Leader 选举状态。</p>
<p>　　FOLLOWING：跟随者状态。表明当前服务器角色是 Follower。</p>
<p>　　LEADING：领导者状态。表明当前服务器角色是 Leader。</p>
<p>　　OBSERVING：观察者状态。表明当前服务器角色是 Observer。</p>
<p>　　2. 投票数据结构</p>
<p>　　每个投票中包含了两个最基本的信息，所推举服务器的 SID 和 ZXID，投票（Vote）在 Zookeeper 中包含字段如下</p>
<p>　　id：被推举的 Leader 的 SID。</p>
<p>　　zxid：被推举的 Leader 事务 ID。</p>
<p>　　electionEpoch：逻辑时钟，用来判断多个投票是否在同一轮选举周期中，该值在服务端是一个自增序列，每次进入新一轮的投票后，都会对该值进行加 1 操作。</p>
<p>　　peerEpoch：被推举的 Leader 的 epoch。</p>
<p>　　state：当前服务器的状态。</p>
<p>　　3. QuorumCnxManager：网络 I/O</p>
<p>　　每台服务器在启动的过程中，会启动一个 QuorumPeerManager，负责各台服务器之间的底层 Leader 选举过程中的网络通信。</p>
<p>　　(1) 消息队列。QuorumCnxManager 内部维护了一系列的队列，用来保存接收到的、待发送的消息以及消息的发送器，除接收队列以外，其他队列都按照 SID 分组形成队列集合，如一个集群中除了自身还有 3 台机器，那么就会为这 3 台机器分别创建一个发送队列，互不干扰。</p>
<p>　　　　· recvQueue：消息接收队列，用于存放那些从其他服务器接收到的消息。</p>
<p>　　　　· queueSendMap：消息发送队列，用于保存那些待发送的消息，按照 SID 进行分组。</p>
<p>　　　　· senderWorkerMap：发送器集合，每个 SenderWorker 消息发送器，都对应一台远程 Zookeeper 服务器，负责消息的发送，也按照 SID 进行分组。</p>
<p>　　　　· lastMessageSent：最近发送过的消息，为每个 SID 保留最近发送过的一个消息。</p>
<p>　　(2) 建立连接。为了能够相互投票，Zookeeper 集群中的所有机器都需要两两建立起网络连接。QuorumCnxManager 在启动时会创建一个 ServerSocket 来监听 Leader 选举的通信端口 (默认为 3888)。开启监听后，Zookeeper 能够不断地接收到来自其他服务器的创建连接请求，在接收到其他服务器的 TCP 连接请求时，会进行处理。为了避免两台机器之间重复地创建 TCP 连接，Zookeeper 只允许 SID 大的服务器主动和其他机器建立连接，否则断开连接。在接收到创建连接请求后，服务器通过对比自己和远程服务器的 SID 值来判断是否接收连接请求，如果当前服务器发现自己的 SID 更大，那么会断开当前连接，然后自己主动和远程服务器建立连接。一旦连接建立，就会根据远程服务器的 SID 来创建相应的消息发送器 SendWorker 和消息接收器 RecvWorker，并启动。</p>
<p>　　(3) 消息接收与发送。消息接收：由消息接收器 RecvWorker 负责，由于 Zookeeper 为每个远程服务器都分配一个单独的 RecvWorker，因此，每个 RecvWorker 只需要不断地从这个 TCP 连接中读取消息，并将其保存到 recvQueue 队列中。消息发送：由于 Zookeeper 为每个远程服务器都分配一个单独的 SendWorker，因此，每个 SendWorker 只需要不断地从对应的消息发送队列中获取出一个消息发送即可，同时将这个消息放入 lastMessageSent 中。在 SendWorker 中，一旦 Zookeeper 发现针对当前服务器的消息发送队列为空，那么此时需要从 lastMessageSent 中取出一个最近发送过的消息来进行再次发送，这是为了解决接收方在消息接收前或者接收到消息后服务器挂了，导致消息尚未被正确处理。同时，Zookeeper 能够保证接收方在处理消息时，会对重复消息进行正确的处理。</p>
<p>　　4. FastLeaderElection：选举算法核心</p>
<p>　　· 外部投票：特指其他服务器发来的投票。</p>
<p>　　· 内部投票：服务器自身当前的投票。</p>
<p>　　· 选举轮次：Zookeeper 服务器 Leader 选举的轮次，即 logicalclock。</p>
<p>　　· PK：对内部投票和外部投票进行对比来确定是否需要变更内部投票。</p>
<p>　　(1) 选票管理</p>
<p>　　· sendqueue：选票发送队列，用于保存待发送的选票。</p>
<p>　　· recvqueue：选票接收队列，用于保存接收到的外部投票。</p>
<p>　　· WorkerReceiver：选票接收器。其会不断地从 QuorumCnxManager 中获取其他服务器发来的选举消息，并将其转换成一个选票，然后保存到 recvqueue 中，在选票接收过程中，如果发现该外部选票的选举轮次小于当前服务器的，那么忽略该外部投票，同时立即发送自己的内部投票。</p>
<p>　　· WorkerSender：选票发送器，不断地从 sendqueue 中获取待发送的选票，并将其传递到底层 QuorumCnxManager 中。</p>
<p>　　(2) 算法核心</p>
<p><img src="https://images2018.cnblogs.com/blog/632316/201808/632316-20180803082744195-266416769.png" alt="img"></p>
<p>　　上图展示了 FastLeaderElection 模块是如何与底层网络 I/O 进行交互的。Leader 选举的基本流程如下</p>
<p>　　1. 自增选举轮次。Zookeeper 规定所有有效的投票都必须在同一轮次中，在开始新一轮投票时，会首先对 logicalclock 进行自增操作。</p>
<p>　　2. 初始化选票。在开始进行新一轮投票之前，每个服务器都会初始化自身的选票，并且在初始化阶段，每台服务器都会将自己推举为 Leader。</p>
<p>　　3. 发送初始化选票。完成选票的初始化后，服务器就会发起第一次投票。Zookeeper 会将刚刚初始化好的选票放入 sendqueue 中，由发送器 WorkerSender 负责发送出去。</p>
<p>　　4. 接收外部投票。每台服务器会不断地从 recvqueue 队列中获取外部选票。如果服务器发现无法获取到任何外部投票，那么就会立即确认自己是否和集群中其他服务器保持着有效的连接，如果没有连接，则马上建立连接，如果已经建立了连接，则再次发送自己当前的内部投票。</p>
<p>　　5. 判断选举轮次。在发送完初始化选票之后，接着开始处理外部投票。在处理外部投票时，会根据选举轮次来进行不同的处理。</p>
<p>　　　　· 外部投票的选举轮次大于内部投票。若服务器自身的选举轮次落后于该外部投票对应服务器的选举轮次，那么就会立即更新自己的选举轮次 (logicalclock)，并且清空所有已经收到的投票，然后使用初始化的投票来进行 PK 以确定是否变更内部投票。最终再将内部投票发送出去。</p>
<p>　　　　· 外部投票的选举轮次小于内部投票。若服务器接收的外选票的选举轮次落后于自身的选举轮次，那么 Zookeeper 就会直接忽略该外部投票，不做任何处理，并返回步骤 4。</p>
<p>　　　　· 外部投票的选举轮次等于内部投票。此时可以开始进行选票 PK。</p>
<p>　　6. 选票 PK。在进行选票 PK 时，符合任意一个条件就需要变更投票。</p>
<p>　　　　· 若外部投票中推举的 Leader 服务器的选举轮次大于内部投票，那么需要变更投票。</p>
<p>　　　　· 若选举轮次一致，那么就对比两者的 ZXID，若外部投票的 ZXID 大，那么需要变更投票。</p>
<p>　　　　· 若两者的 ZXID 一致，那么就对比两者的 SID，若外部投票的 SID 大，那么就需要变更投票。</p>
<p>　　7. 变更投票。经过 PK 后，若确定了外部投票优于内部投票，那么就变更投票，即使用外部投票的选票信息来覆盖内部投票，变更完成后，再次将这个变更后的内部投票发送出去。</p>
<p>　　8. 选票归档。无论是否变更了投票，都会将刚刚收到的那份外部投票放入选票集合 recvset 中进行归档。recvset 用于记录当前服务器在本轮次的 Leader 选举中收到的所有外部投票（按照服务队的 SID 区别，如 {(1, vote1), (2, vote2)…}）。</p>
<p>　　9. 统计投票。完成选票归档后，就可以开始统计投票，统计投票是为了统计集群中是否已经有过半的服务器认可了当前的内部投票，如果确定已经有过半服务器认可了该投票，则终止投票。否则返回步骤 4。</p>
<p>　　10. 更新服务器状态。若已经确定可以终止投票，那么就开始更新服务器状态，服务器首选判断当前被过半服务器认可的投票所对应的 Leader 服务器是否是自己，若是自己，则将自己的服务器状态更新为 LEADING，若不是，则根据具体情况来确定自己是 FOLLOWING 或是 OBSERVING。</p>
<p>　　以上 10 个步骤就是 FastLeaderElection 的核心，其中步骤 4-9 会经过几轮循环，直到有 Leader 选举产生。</p>
<h4 id="17-zookeeper-负载均衡和-nginx-负载均衡区别"><a href="#17-zookeeper-负载均衡和-nginx-负载均衡区别" class="headerlink" title="17.zookeeper 负载均衡和 nginx 负载均衡区别"></a>17.zookeeper 负载均衡和 nginx 负载均衡区别</h4><ul>
<li>zk 的负载均衡是可以调控，nginx 只是能调权重，其他需要可控的都需要自己写插件；但是 nginx 的吞吐量比 zk 大很多，应该说按业务选择用哪种方式。</li>
</ul>
<h4 id="18-集群支持动态添加机器吗？"><a href="#18-集群支持动态添加机器吗？" class="headerlink" title="18.集群支持动态添加机器吗？"></a>18.集群支持动态添加机器吗？</h4><p> 其实就是水平扩容了，Zookeeper 在这方面不太好。两种方式：</p>
<p>全部重启：关闭所有 Zookeeper 服务，修改配置之后启动。不影响之前客户端的会话。</p>
<p>逐个重启：在过半存活即可用的原则下，一台机器重启不影响整个集群对外提供服务。这是比较常用的方式。</p>
<p>3.5 版本开始支持动态扩容。</p>
<h4 id="19-集群最少要几台机器，集群规则是怎样的？集群中有-3-台服务器，其中一个节点宕机，这个时候-Zookeeper-还可以使用吗？"><a href="#19-集群最少要几台机器，集群规则是怎样的？集群中有-3-台服务器，其中一个节点宕机，这个时候-Zookeeper-还可以使用吗？" class="headerlink" title="19.集群最少要几台机器，集群规则是怎样的？集群中有 3 台服务器，其中一个节点宕机，这个时候 Zookeeper 还可以使用吗？"></a>19.集群最少要几台机器，集群规则是怎样的？集群中有 3 台服务器，其中一个节点宕机，这个时候 Zookeeper 还可以使用吗？</h4><p> 集群规则为 2N+1 台，N&gt;0，即 3 台。可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用</p>
<h4 id="20-Zookeeper-对节点的-watch-监听通知是永久的吗？为什么不是永久的"><a href="#20-Zookeeper-对节点的-watch-监听通知是永久的吗？为什么不是永久的" class="headerlink" title="20.Zookeeper 对节点的 watch 监听通知是永久的吗？为什么不是永久的?"></a>20.Zookeeper 对节点的 watch 监听通知是永久的吗？为什么不是永久的?</h4><p>不是。官方声明：一个 Watch 事件是一个一次性的触发器，当被设置了 Watch 的数据发生了改变的时候，则服务器将这个改变发送给设置了 Watch 的客户端，以便通知它们。</p>
<p>为什么不是永久的，举个例子，如果服务端变动频繁，而监听的客户端很多情况下，每次变动都要通知到所有的客户端，给网络和服务器造成很大压力。<br>一般是客户端执行 getData(“/ 节点 A”,true)，如果节点 A 发生了变更或删除，客户端会得到它的 watch 事件，但是在之后节点 A 又发生了变更，而客户端又没有设置 watch 事件，就不再给客户端发送。<br>在实际应用中，很多情况下，我们的客户端不需要知道服务端的每一次变动，我只要最新的数据即可。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://blog.csdn.net/weixin_43122090/article/details/103645642">https://blog.csdn.net/weixin_43122090/article/details/103645642</a></p>
<p><a href="https://www.cnblogs.com/lanqiu5ge/p/9405601.html">https://www.cnblogs.com/lanqiu5ge/p/9405601.html</a></p>
]]></content>
      <categories>
        <category>Middleware</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基础与高级</title>
    <url>/2024/04/16/MySQL%E5%9F%BA%E7%A1%80%E4%B8%8E%E9%AB%98%E7%BA%A7/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>[TOC]</p>
<h1 id="Mysql基础"><a href="#Mysql基础" class="headerlink" title="Mysql基础"></a>Mysql基础</h1><h2 id="数据库相关概念"><a href="#数据库相关概念" class="headerlink" title="数据库相关概念"></a>数据库相关概念</h2><h3 id="数据库的好处"><a href="#数据库的好处" class="headerlink" title="数据库的好处"></a>数据库的好处</h3><ol>
<li>持久化数据到本地</li>
<li>可以实现结构化查询，方便管理</li>
</ol>
<h3 id="数据库常见名词解释"><a href="#数据库常见名词解释" class="headerlink" title="数据库常见名词解释"></a>数据库常见名词解释</h3><ol>
<li>DB：数据库，保存一组有组织的数据的容器</li>
<li>DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据</li>
<li>SQL:结构化查询语言，用于和DBMS通信的语言，不是某个数据库软件特有的，而是几乎所有的主流数据库软件通用的语言</li>
</ol>
<h3 id="数据库存储数据的特点"><a href="#数据库存储数据的特点" class="headerlink" title="数据库存储数据的特点"></a>数据库存储数据的特点</h3><ol>
<li>将数据放到表中，表再放到库中</li>
<li>一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。</li>
<li>表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。</li>
<li>表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性”</li>
<li>表中的数据是按行存储的，每一行类似于java中的“对象”。</li>
</ol>
<h3 id="常见数据库"><a href="#常见数据库" class="headerlink" title="常见数据库"></a>常见数据库</h3><p>mysql、oracle、db2、sqlserver</p>
<h2 id="MySQL产品的介绍和安装"><a href="#MySQL产品的介绍和安装" class="headerlink" title="MySQL产品的介绍和安装"></a>MySQL产品的介绍和安装</h2><h3 id="MySQL背景"><a href="#MySQL背景" class="headerlink" title="MySQL背景"></a>MySQL背景</h3><p>前身属于瑞典的一家公司，MySQL AB<br>08年被sun公司收购<br>09年sun被oracle收购</p>
<h3 id="MySQL的优点"><a href="#MySQL的优点" class="headerlink" title="MySQL的优点"></a>MySQL的优点</h3><p>1、开源、免费、成本低<br>2、性能高、移植性也好<br>3、体积小，便于安装</p>
<h3 id="Windows上使用"><a href="#Windows上使用" class="headerlink" title="Windows上使用"></a>Windows上使用</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>如果之前没有安装的mysql，则可以直接在官网上下载，使用exe安装。建议下载版本mysql5.5</p>
<p><a href="https://downloads.mysql.com/archives/community/">下载网址</a></p>
<h4 id="MySQL数据库管理系统的卸载"><a href="#MySQL数据库管理系统的卸载" class="headerlink" title="MySQL数据库管理系统的卸载"></a>MySQL数据库管理系统的卸载</h4><p>如果以前安装过mysql，虽然卸载了，但是安装时出现问题，尝试按下面步骤</p>
<ol>
<li>卸载程序</li>
<li>删除安装目录</li>
<li>删除C:/ProgramData目录下mysql文件夹</li>
<li>卸载服务<ol>
<li>删除注册表中以下文件夹，如果没有相关的注册表信息可以直接忽略<br>HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Eventlog\Application\MySQL文件夹；HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services\Eventlog\Application\MySQL文件夹。HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Eventlog\Application\MySQL的文件夹。</li>
<li>卸载服务<ol>
<li>win7系统，以管理员方式，执行命令 sc delete 服务名</li>
<li>win10系统，删除注册表中 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services 目录下对应服务名文件夹</li>
</ol>
</li>
<li>重启电脑</li>
</ol>
</li>
</ol>
<h4 id="MySQL服务的启动和停止"><a href="#MySQL服务的启动和停止" class="headerlink" title="MySQL服务的启动和停止"></a>MySQL服务的启动和停止</h4><ul>
<li>计算机——右击管理——服务</li>
<li>通过<strong>管理员身份</strong>运行<br>​    net start 服务名（启动服务）<br>​    net stop 服务名（停止服务）</li>
</ul>
<h4 id="登录和退出"><a href="#登录和退出" class="headerlink" title="登录和退出"></a>登录和退出</h4><ul>
<li>通过mysql自带的客户端<pre><code>只限于root用户
</code></pre>
</li>
<li>通过windows自带的客户端</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">登录：参数后面没有空格</span><br><span class="line">mysql 【-h主机名 -P端口号 】-u用户名 -p密码</span><br><span class="line"></span><br><span class="line">退出：</span><br><span class="line">exit或ctrl+C</span><br></pre></td></tr></table></figure>



<h4 id="自定义MySQL的配置"><a href="#自定义MySQL的配置" class="headerlink" title="自定义MySQL的配置"></a>自定义MySQL的配置</h4><p>修改MySQL安装目录下的my.ini文件，并重启服务</p>
<p>常见的配置有字符集</p>
<h3 id="Linux上使用"><a href="#Linux上使用" class="headerlink" title="Linux上使用"></a>Linux上使用</h3><p>以Centos7举例</p>
<h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><p><strong>检查是否安装过mysql</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -qa|grep mysql</span><br><span class="line">rpm -qa|grep mariadb</span><br></pre></td></tr></table></figure>

<p>默认 Linux（CentOS7） 在安装的时候， 自带了 mariadb(mysql 完全开源版本)相关的组件。</p>
<p><img src="MySQL%E5%9F%BA%E7%A1%80.assets/image-20200710152909978.png" alt="image-20200710152909978"></p>
<p><strong>如果系统中存在软件，强制卸载</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -e --nodeps mysql-libs  </span><br><span class="line">rpm -e --nodeps mariadb-libs</span><br></pre></td></tr></table></figure>

<p><strong>更改/tmp文件夹权限</strong></p>
<p>mysql安装时，会通过mysql用户在/tmp目录下新建一个tmp_db文件，所以需要给/tmp文件夹赋予更大的权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod -R 777 /tmp</span><br></pre></td></tr></table></figure>

<p><strong>下载rpm安装包到/opt目录下</strong></p>
<p>建议下载版本mysql5.5，注意linux是32位还是64位</p>
<p><a href="https://downloads.mysql.com/archives/community/">下载网址</a></p>
<p><strong>在/opt目录下执行安装</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 客户端和服务端</span></span><br><span class="line">rpm -ivh MySQL-client-5.5.54-1.linux2.6.x86_64.rpm</span><br><span class="line">rpm -ivh MySQL-server-5.5.54-1.linux2.6.x86_64.rpm</span><br></pre></td></tr></table></figure>

<p><strong>检查是否安装成功</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqladmin --version</span><br></pre></td></tr></table></figure>

<p><strong>设置mysql密码</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/user/bin/mysqladmin –u root password 123456</span><br></pre></td></tr></table></figure>

<p><strong>查看安装目录</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ef|grep mysql</span><br></pre></td></tr></table></figure>

<img src="MySQL基础.assets/image-20200710165318361.png" alt="image-20200710165318361" style="zoom:67%;" />

<h4 id="启动和关闭服务"><a href="#启动和关闭服务" class="headerlink" title="启动和关闭服务"></a>启动和关闭服务</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看服务状态</span></span><br><span class="line">service mysql status</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动服务</span></span><br><span class="line">service mysql start</span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止服务</span></span><br><span class="line">service mysql stop</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启服务</span></span><br><span class="line">service mysql restart</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开机自启动</span></span><br><span class="line">chkconfig mysql on</span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭开启自启动</span></span><br><span class="line">ntsysv</span><br><span class="line">使用空格键取消，使用Enter键确认</span><br></pre></td></tr></table></figure>



<h4 id="登录和退出-1"><a href="#登录和退出-1" class="headerlink" title="登录和退出"></a>登录和退出</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 登录</span></span><br><span class="line">mysql -uroot -p123456</span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出</span></span><br><span class="line">exit或ctrl+C</span><br></pre></td></tr></table></figure>



<h4 id="自定义Mysql配置"><a href="#自定义Mysql配置" class="headerlink" title="自定义Mysql配置"></a>自定义Mysql配置</h4><p>在/usr/share/mysql/ 中找到 my-huge.cnf 的配置文件， 拷贝到 /etc/ 并命名为 my.cnf ，mysql优先选择/etc/下的配置文件。 添加以下内容后再重启服务。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set&#x3D;utf8</span><br><span class="line">[mysqld]</span><br><span class="line">character_set_server&#x3D;utf8</span><br><span class="line">character_set_client&#x3D;utf8</span><br><span class="line">collation-server&#x3D;utf8_general_ci</span><br><span class="line">[mysql]</span><br><span class="line">default-character-set&#x3D;utf8</span><br></pre></td></tr></table></figure>

<p>注意： <strong>已经创建的数据库</strong>的设定不会发生变化， 参数修改只对新建的数据库有效！  </p>
<p><strong>修改已创建库、 表字符集</strong><br>修改数据库的字符集</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter database mydb character set &#39;utf8&#39;;</span><br></pre></td></tr></table></figure>

<p>修改数据表的字符集</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table mytbl convert to character set &#39;utf8&#39;;  </span><br></pre></td></tr></table></figure>

<p><strong>修改已经乱码数据</strong></p>
<p>无论是修改 mysql 配置文件或是修改库、 表字符集， 都<strong>无法改变</strong>已经变成乱码的数据。<br>只能删除数据重新插入或更新数据才可以完全解决  </p>
<h3 id="MySQL的常见命令"><a href="#MySQL的常见命令" class="headerlink" title="MySQL的常见命令"></a>MySQL的常见命令</h3><pre><code>1.查看当前所有的数据库
show databases;
mysql:保存用户信息(身份信息,自定义函数、存储过程)
information_schema:保存元数据信息
test:测试信息
performance_schema:监控mysql内部运行情况

2.打开指定的库
use 库名

3.查看当前库的所有表
show tables;

4.查看其它库的所有表
show tables from 库名;

5.创建表
create table 表名(

    列名 列类型,
    列名 列类型，
    。。。
);

6.查看表结构
desc 表名;

7.查看服务器的版本
方式一：登录到mysql服务端
select version();
方式二：没有登录到mysql服务端
mysql --version
或
mysql --V
</code></pre>
<h3 id="MySQL的语法规范"><a href="#MySQL的语法规范" class="headerlink" title="MySQL的语法规范"></a>MySQL的语法规范</h3><ol>
<li>不区分大小写,但建议关键字大写，表名、列名小写</li>
<li>每条命令最好用分号结尾</li>
<li>每条命令根据需要，可以进行缩进 或换行</li>
<li>注释<ol>
<li>单行注释：#注释文字</li>
<li>单行注释：– 注释文字</li>
<li>多行注释：/* 注释文字  */</li>
</ol>
</li>
</ol>
<p>​    </p>
<h3 id="SQL的语言分类"><a href="#SQL的语言分类" class="headerlink" title="SQL的语言分类"></a>SQL的语言分类</h3><p>​    DQL（Data Query Language）：数据查询语言<br>​        select<br>​    DML(Data Manipulate Language):数据操作语言<br>​        insert 、update、delete<br>​    DDL（Data Define Languge）：数据定义语言<br>​        create、drop、alter<br>​    TCL（Transaction Control Language）：事务控制语言<br>​        commit、rollback<br>​    </p>
<h3 id="SQL的常见命令"><a href="#SQL的常见命令" class="headerlink" title="SQL的常见命令"></a>SQL的常见命令</h3><pre><code>show databases； 查看所有的数据库
use 库名； 打开指定 的库
show tables ; 显示库中的所有表
show tables from 库名;显示指定库中的所有表
create table 表名(
    字段名 字段类型,    
    字段名 字段类型
); 创建表

desc 表名; 查看指定表的结构
select * from 表名;显示表中的所有数据
</code></pre>
<h2 id="DQL语言的学习"><a href="#DQL语言的学习" class="headerlink" title="DQL语言的学习"></a>DQL语言的学习</h2><p>Database Query Language</p>
<h3 id="进阶1：基础查询"><a href="#进阶1：基础查询" class="headerlink" title="进阶1：基础查询"></a>进阶1：基础查询</h3><p><strong>语法</strong></p>
<ul>
<li>SELECT 要查询的东西 FROM 表名;</li>
<li>类似于Java中 :System.out.println(要打印的东西);</li>
</ul>
<p><strong>特点</strong></p>
<ol>
<li>通过select查询完的结果，是一个虚拟的表格，不是真实存在</li>
<li>要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数</li>
</ol>
<p>==建议再编写sql脚本时，在最前面先写上切换库命令 USE myDataBase==</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、查询单个字段</span><br><span class="line">	select 字段名 from 表名;</span><br><span class="line">2、查询多个字段</span><br><span class="line">	select 字段名，字段名 from 表名;</span><br><span class="line">3、查询所有字段</span><br><span class="line">	select * from 表名</span><br><span class="line">4、查询常量</span><br><span class="line">	select 常量值;</span><br><span class="line">	注意：字符型和日期型的常量值必须用单引号引起来，数值型不需要</span><br><span class="line">5、查询函数</span><br><span class="line">	select 函数名(实参列表);</span><br><span class="line">6、查询表达式</span><br><span class="line">	select 100&#x2F;1234;</span><br><span class="line">7、起别名</span><br><span class="line">	as</span><br><span class="line">	空格</span><br><span class="line">8、去重distinct</span><br><span class="line">	select distinct 字段名 from 表名;</span><br><span class="line">9、+</span><br><span class="line">	作用：做加法运算</span><br><span class="line">	select 数值+数值 直接运算</span><br><span class="line">	select 字符+数值 先试图将字符转换成数值，如果转换成功，则继续运算；否则转换成0，再做运算</span><br><span class="line">	select null+值  结果都为null</span><br><span class="line">10、concat函数</span><br><span class="line">	功能：拼接字符</span><br><span class="line">	select concat(字符1，字符2，字符3,...);</span><br><span class="line">11、ifnull函数</span><br><span class="line">	功能：判断某字段或表达式是否为null，如果为null 返回指定的值，否则返回原本的值</span><br><span class="line">	select ifnull(commission_pct,0) from employees;</span><br><span class="line">12、isnull函数</span><br><span class="line">	功能：判断某字段或表达式是否为null，如果是，则返回1，否则返回0</span><br></pre></td></tr></table></figure>



<h3 id="进阶2：条件查询"><a href="#进阶2：条件查询" class="headerlink" title="进阶2：条件查询"></a>进阶2：条件查询</h3><p>条件查询：根据条件过滤原始表的数据，查询到想要的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">	select </span><br><span class="line">		要查询的字段|表达式|常量值|函数</span><br><span class="line">	from </span><br><span class="line">		表</span><br><span class="line">	where </span><br><span class="line">		条件 ;</span><br><span class="line"></span><br><span class="line">一、条件表达式</span><br><span class="line">	条件运算符：</span><br><span class="line">		&gt; &lt; &gt;&#x3D; &lt;&#x3D; &#x3D; !&#x3D; &lt;&gt;</span><br><span class="line">			a &gt;&#x3D; 100</span><br><span class="line">		between...and...  表示[left,right] 等价于 &gt;&#x3D;left&amp;&lt;&#x3D;right</span><br><span class="line">			id between left and right </span><br><span class="line">		in</span><br><span class="line">			id in(&#39;item1&#39;,&#39;item2&#39;,...)</span><br><span class="line">			列表中元素类型一致(相同或者兼容)</span><br><span class="line">			元素不能使用通配符</span><br><span class="line">		exists</span><br><span class="line">		is null&#x2F;is not null</span><br><span class="line">		&lt;&#x3D;&gt;</span><br><span class="line">			兼容了&#x3D;和is null</span><br><span class="line">二、逻辑表达式</span><br><span class="line">	示例：salary&gt;10000 &amp;&amp; salary&lt;20000</span><br><span class="line">	逻辑运算符：</span><br><span class="line">		and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false</span><br><span class="line">		or(||)：两个条件只要有一个成立，结果为true，否则为false</span><br><span class="line">		not(!)：如果条件成立，则not后为false，否则为true</span><br><span class="line">三、模糊查询</span><br><span class="line">	支持正则表达式</span><br><span class="line">		last_name like &#39;%a%&#39;</span><br><span class="line">	自定义转义字符</span><br><span class="line">		last_name like &#39;$%a%&#39; ESCAPE &#39;$&#39;</span><br></pre></td></tr></table></figure>



<h3 id="进阶3：排序查询"><a href="#进阶3：排序查询" class="headerlink" title="进阶3：排序查询"></a>进阶3：排序查询</h3><pre><code>语法：
select
    要查询的东西
from
    表
where 
    条件
order by 
    排序的字段|表达式|函数|别名 【asc升序|desc降序】
    
SELECT * FORM Employee order by LENGTH(last_name) DESC;
</code></pre>
<p>案例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查询员工的姓名、部门号和年薪，按年薪降序，按姓名升序</span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_id,salary<span class="operator">*</span><span class="number">12</span><span class="operator">*</span>(IFNULL(commission_pct,<span class="number">0</span>)) 年薪 <span class="keyword">FROM</span> employees <span class="keyword">ORDER</span> <span class="keyword">BY</span> 年薪 <span class="keyword">DESC</span>,last_name <span class="keyword">ASC</span>;</span><br><span class="line"># 选择工资不在<span class="number">8000</span>到<span class="number">170000</span>的员工姓名和工资，按工资降序</span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> salary <span class="keyword">NOT</span> <span class="keyword">BETWEEN</span> <span class="number">8000</span> <span class="keyword">AND</span> <span class="number">17000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>;</span><br><span class="line"># 查询邮箱中包含e的员工信息，并先按邮箱的字节数降序，再按部门号升序</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> email <span class="keyword">like</span> <span class="string">&#x27;%e%&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> LENGTH(email) <span class="keyword">DESC</span>,department_id <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>



<h3 id="进阶4：常见函数"><a href="#进阶4：常见函数" class="headerlink" title="进阶4：常见函数"></a>进阶4：常见函数</h3><p>使用函数时，首先要保证有数据，如果没有数据，函数不会执行了</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 这里查询了一条不能存在的数据,由于数据不存在,所以即使salary为<span class="keyword">null</span>,最终结果还是<span class="keyword">null</span>,因为函数就没执行</span><br><span class="line">    <span class="keyword">select</span> ifnull(salary,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">from</span> employees</span><br><span class="line">    <span class="keyword">where</span> employee_id<span class="operator">=</span><span class="number">-1</span></span><br></pre></td></tr></table></figure>



<h4 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、字符函数</span><br><span class="line">	length 获取字节个数</span><br><span class="line">	concat(a,b)拼接</span><br><span class="line">	substr</span><br><span class="line">		substr(str,index)截取从index开始的子串,mysql字符串索引从<span class="number">1</span>开始</span><br><span class="line">		substr(str,startIndex,endIndex)</span><br><span class="line">	upper转换成大写</span><br><span class="line">	lower转换成小写</span><br><span class="line">	trim去前后指定的空格和字符</span><br><span class="line">		<span class="built_in">trim</span>(特定字符串 <span class="keyword">FROM</span> 原始串)去除原始串前后的特定字符串</span><br><span class="line">	ltrim去左边空格</span><br><span class="line">	rtrim去右边空格</span><br><span class="line">	replace替换</span><br><span class="line">	lpad左填充</span><br><span class="line">		lpad(原始串,目标长度,填充串)</span><br><span class="line">	rpad右填充</span><br><span class="line">	instr返回子串第一次出现的索引</span><br><span class="line">	ascii(ch)获取ch的ascii码值</span><br><span class="line">	<span class="type">char</span>(num)根据ascii码值获取字符</span><br><span class="line">	<span class="built_in">cast</span> (expression <span class="keyword">AS</span> data_type) 数据类型转换函数</span><br><span class="line"><span class="number">2</span>、数学函数</span><br><span class="line">	round 四舍五入</span><br><span class="line">	rand 随机数[<span class="number">0</span>,<span class="number">1</span>) 生成[a,b]<span class="operator">=</span><span class="built_in">floor</span>(a<span class="operator">+</span>(b<span class="operator">-</span>a<span class="operator">+</span><span class="number">1</span>)<span class="operator">*</span>rand())</span><br><span class="line">	floor向下取整</span><br><span class="line">	ceil向上取整</span><br><span class="line">	mod取余</span><br><span class="line">	<span class="keyword">truncate</span>截断</span><br><span class="line">		<span class="keyword">truncate</span>(num,len) num取小数点后len位</span><br><span class="line"><span class="number">3</span>、日期函数</span><br><span class="line">	now当前系统日期<span class="operator">+</span>时间</span><br><span class="line">	curdate当前系统日期</span><br><span class="line">	curtime当前系统时间</span><br><span class="line">	<span class="keyword">year</span> 从时间中解析出年</span><br><span class="line">	<span class="keyword">month</span></span><br><span class="line">	...</span><br><span class="line">	str_to_date 将字符转换成日期</span><br><span class="line">		str_to_date(str,format)</span><br><span class="line">	date_format将日期转换成字符</span><br><span class="line">	datediff(time1,time2)计算日期之差</span><br><span class="line"><span class="number">4</span>、流程控制函数</span><br><span class="line">	if 处理双分支</span><br><span class="line">		if(条件表达式，表达式<span class="number">1</span>，表达式<span class="number">2</span>)：如果条件表达式成立，返回表达式<span class="number">1</span>，否则返回表达式<span class="number">2</span></span><br><span class="line">	<span class="keyword">case</span>语句 处理多分支</span><br><span class="line">    	情况<span class="number">1</span>：处理等值判断</span><br><span class="line">            <span class="keyword">case</span> 变量或表达式</span><br><span class="line">            <span class="keyword">when</span> 常量<span class="number">1</span> <span class="keyword">then</span> 值<span class="number">1</span><span class="operator">|</span>语句<span class="number">1</span></span><br><span class="line">            <span class="keyword">when</span> 常量<span class="number">2</span> <span class="keyword">then</span> 值<span class="number">2</span><span class="operator">|</span>语句<span class="number">2</span></span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">else</span> 值n<span class="operator">|</span>语句n</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            	举例</span><br><span class="line">                <span class="keyword">select</span> salary 原始工资,department_id, </span><br><span class="line">                <span class="keyword">case</span> department_id</span><br><span class="line">                <span class="keyword">when</span> <span class="number">30</span> <span class="keyword">then</span> salary<span class="operator">*</span><span class="number">1.1</span></span><br><span class="line">                <span class="keyword">when</span> <span class="number">40</span> <span class="keyword">then</span> salary<span class="operator">*</span><span class="number">1.2</span></span><br><span class="line">                <span class="keyword">else</span> salary</span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">as</span> 新工资</span><br><span class="line">                <span class="keyword">from</span> employees;</span><br><span class="line">            </span><br><span class="line">		情况<span class="number">2</span>：处理多分支</span><br><span class="line">            <span class="keyword">case</span> </span><br><span class="line">            <span class="keyword">when</span> 条件<span class="number">1</span> <span class="keyword">then</span> 值<span class="number">1</span><span class="operator">|</span>语句<span class="number">1</span></span><br><span class="line">            <span class="keyword">when</span> 条件<span class="number">2</span> <span class="keyword">then</span> 值<span class="number">2</span><span class="operator">|</span>语句<span class="number">2</span></span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">else</span> 值n<span class="operator">|</span>语句n</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            	<span class="keyword">select</span> salary,</span><br><span class="line">            	<span class="keyword">case</span></span><br><span class="line">            	<span class="keyword">when</span> salary<span class="operator">&gt;</span><span class="number">20000</span> <span class="keyword">then</span> <span class="string">&#x27;A&#x27;</span></span><br><span class="line">            	<span class="keyword">when</span> salary<span class="operator">&gt;</span><span class="number">15000</span> <span class="keyword">then</span> <span class="string">&#x27;B&#x27;</span></span><br><span class="line">            	<span class="keyword">else</span> <span class="string">&#x27;C&#x27;</span></span><br><span class="line">            	<span class="keyword">end</span> <span class="keyword">as</span> 级别</span><br><span class="line">            	<span class="keyword">from</span> employee;</span><br><span class="line">            </span><br><span class="line"><span class="number">5</span>、其他函数</span><br><span class="line">    version 当前数据库服务器的版本</span><br><span class="line">    database 当前打开的数据库</span><br><span class="line">    <span class="keyword">user</span>当前连接用户</span><br><span class="line">    password(<span class="string">&#x27;字符&#x27;</span>)：返回该字符的密码形式</span><br><span class="line">    md5(<span class="string">&#x27;字符&#x27;</span>):返回该字符的md5加密形式</span><br></pre></td></tr></table></figure>

<p><strong>日期格式化取值范围</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>秒</td>
<td>%S、%s</td>
<td>两位数字形式的秒（ 00,01, …, 59）</td>
</tr>
<tr>
<td>分</td>
<td>%I、%i</td>
<td>两位数字形式的分（ 00,01, …, 59）</td>
</tr>
<tr>
<td>小时</td>
<td>%H</td>
<td>24小时制，两位数形式小时（00,01, …,23）</td>
</tr>
<tr>
<td></td>
<td>%h</td>
<td>两位数形式小时（00,01, …,12）</td>
</tr>
<tr>
<td></td>
<td>%k</td>
<td>24小时制，数形式小时（0,1, …,23）</td>
</tr>
<tr>
<td></td>
<td>%l(L小写)</td>
<td>12小时制，数形式小时（0,1, …,12）</td>
</tr>
<tr>
<td></td>
<td>%T</td>
<td>24小时制，时间形式（HH:mm:ss）</td>
</tr>
<tr>
<td></td>
<td>%r</td>
<td>12小时制，时间形式（hh:mm:ss AM 或 PM）</td>
</tr>
<tr>
<td></td>
<td>%p</td>
<td>AM上午或PM下午</td>
</tr>
<tr>
<td>周</td>
<td>%W</td>
<td>一周中每一天的名称（Sunday,Monday, …,Saturday）</td>
</tr>
<tr>
<td></td>
<td>%a</td>
<td>一周中每一天名称的缩写（Sun,Mon, …,Sat</td>
</tr>
<tr>
<td></td>
<td>%w</td>
<td>以数字形式标识周（0=Sunday,1=Monday, …,6=Saturday）</td>
</tr>
<tr>
<td></td>
<td>%U</td>
<td>数字表示周数，星期天为周中第一天</td>
</tr>
<tr>
<td></td>
<td>%u</td>
<td>数字表示周数，星期一为周中第一天</td>
</tr>
<tr>
<td>天</td>
<td>%d</td>
<td>两位数字表示月中天数（01,02, …,31）</td>
</tr>
<tr>
<td></td>
<td>%e</td>
<td>数字表示月中天数（1,2, …,31）</td>
</tr>
<tr>
<td></td>
<td>%D</td>
<td>英文后缀表示月中天数（1st,2nd,3rd …）</td>
</tr>
<tr>
<td></td>
<td>%j</td>
<td>以三位数字表示年中天数（001,002, …,366）</td>
</tr>
<tr>
<td>月</td>
<td>%M</td>
<td>英文月名（January,February, …,December）</td>
</tr>
<tr>
<td></td>
<td>%b</td>
<td>英文缩写月名（Jan,Feb, …,Dec）</td>
</tr>
<tr>
<td></td>
<td>%m</td>
<td>两位数字表示月份（01,02, …,12）</td>
</tr>
<tr>
<td></td>
<td>%c</td>
<td>数字表示月份（1,2, …,12）</td>
</tr>
<tr>
<td>年</td>
<td>%Y</td>
<td>四位数字表示的年份（2015,2016…）</td>
</tr>
<tr>
<td></td>
<td>%y</td>
<td>两位数字表示的年份（15,16…）</td>
</tr>
<tr>
<td>文字输出</td>
<td>文字</td>
<td>直接输出文字内容</td>
</tr>
</tbody></table>
<h4 id="多行函数"><a href="#多行函数" class="headerlink" title="多行函数"></a>多行函数</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sum 求和</span><br><span class="line">	<span class="built_in">sum</span>(item)</span><br><span class="line">max 最大值</span><br><span class="line">min 最小值</span><br><span class="line">avg 平均值</span><br><span class="line">count 计数</span><br><span class="line">	<span class="built_in">count</span>(字段):统计表中该字段非空的行数</span><br><span class="line">	<span class="built_in">count</span>(<span class="operator">*</span>):统计表的行数</span><br><span class="line">	<span class="built_in">count</span>(常量):就相当于在表中加了一列常量，返回的就是表的行数，常用<span class="built_in">count</span>(<span class="number">1</span>)</span><br><span class="line">	MYISAM存储引擎下，<span class="built_in">count</span>(<span class="operator">*</span>)的效率高</span><br><span class="line">	INNODB存储引擎下，<span class="built_in">count</span>(<span class="operator">*</span>)和<span class="built_in">count</span>(<span class="number">1</span>)的效率差不多，都比<span class="built_in">count</span>(字段)效率高</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line"><span class="number">1</span>、以上五个分组函数都忽略<span class="keyword">null</span>值，除了<span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="number">2</span>、sum和avg一般用于处理数值型</span><br><span class="line">    max、min、count可以处理任何数据类型</span><br><span class="line"><span class="number">3</span>、都可以搭配<span class="keyword">distinct</span>使用，用于统计去重后的结果</span><br><span class="line">    <span class="built_in">sum</span>(<span class="keyword">distinct</span> salary)</span><br></pre></td></tr></table></figure>

<p>案例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、查询公司员工工资的最大值、最小值、平均值、总和</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(salary) max_salary,<span class="built_in">min</span>(salary) min_salary,round(<span class="built_in">avg</span>(salary)) avg_salary,<span class="built_in">sum</span>(salary) sum_salary <span class="keyword">from</span> employees;</span><br><span class="line"><span class="number">2</span>、查询员工表中的最大入职时间和最小入职时间的相差天数</span><br><span class="line"><span class="keyword">select</span> datediff(<span class="built_in">max</span>(hiredate),<span class="built_in">min</span>(hiredate)) diffrence <span class="keyword">from</span> employees;</span><br></pre></td></tr></table></figure>



<h3 id="进阶5：分组查询"><a href="#进阶5：分组查询" class="headerlink" title="进阶5：分组查询"></a>进阶5：分组查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">	<span class="keyword">select</span> 分组后依然存在的字段，分组函数</span><br><span class="line">	<span class="keyword">from</span> 表</span><br><span class="line">	[<span class="keyword">where</span> 筛选条件]</span><br><span class="line">	<span class="keyword">group</span> <span class="keyword">by</span> 分组依据字段</span><br><span class="line">	[<span class="keyword">order</span> <span class="keyword">by</span> 分组后依然存在的字段]</span><br><span class="line">执行顺序：</span><br><span class="line">	<span class="keyword">from</span><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">where</span><span class="operator">-</span><span class="operator">&gt;</span><span class="keyword">group</span> <span class="keyword">by</span><span class="operator">-</span><span class="operator">&gt;</span><span class="keyword">having</span><span class="operator">-</span><span class="operator">&gt;</span><span class="keyword">select</span><span class="operator">-</span><span class="operator">&gt;</span><span class="keyword">order</span> <span class="keyword">by</span>(针对分组后的数据进行排序)</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line"><span class="number">1</span>、可以按单个字段分组</span><br><span class="line"><span class="number">2</span>、和分组函数一同查询的字段最好是分组依据字段</span><br><span class="line"><span class="number">3</span>、分组筛选</span><br><span class="line">			针对的表			位置				关键字</span><br><span class="line">分组前筛选：	原始表				<span class="keyword">group</span> <span class="keyword">by</span>的前面		<span class="keyword">where</span></span><br><span class="line">分组后筛选：	分组后的结果集		<span class="keyword">group</span> <span class="keyword">by</span>的后面		<span class="keyword">having</span></span><br><span class="line">分组函数做筛选条件，肯定是分组后筛选</span><br><span class="line">优先使用分组前筛选，避免两次数据处理</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、可以按多个字段分组，字段之间用逗号隔开</span><br><span class="line"><span class="number">5</span>、可以支持排序</span><br><span class="line"><span class="number">6</span>、<span class="keyword">having</span>后可以支持别名</span><br></pre></td></tr></table></figure>

<p>案例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、查询每个部门中邮箱包含<span class="string">&#x27;a&#x27;</span>的员工数</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>),department_id</span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">where</span> email <span class="keyword">like</span> <span class="string">&#x27;%a%&#x27;</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> department_id</span><br><span class="line"><span class="number">2</span>、查询部门中员工数量大于<span class="number">2</span>的部门</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>),department_id</span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> department_id</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">2</span></span><br><span class="line"><span class="number">3</span>、查询领导编号<span class="operator">&gt;</span><span class="number">102</span>的每个领导手下的最低工资<span class="operator">&gt;</span><span class="number">5000</span>的领导编号，以及其最低工资</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">min</span>(salary),manager_id</span><br><span class="line"><span class="keyword">from</span> empolyees</span><br><span class="line"><span class="keyword">where</span> manager_id<span class="operator">&gt;</span><span class="number">102</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> manager_id</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">min</span>(salary)<span class="operator">&gt;</span><span class="number">5000</span></span><br></pre></td></tr></table></figure>



<h3 id="进阶6：多表连接查询"><a href="#进阶6：多表连接查询" class="headerlink" title="进阶6：多表连接查询"></a>进阶6：多表连接查询</h3><p>连接类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">内连接</span><br><span class="line">    等值</span><br><span class="line">    非等值</span><br><span class="line">    自连接</span><br><span class="line">外连接</span><br><span class="line">    左外</span><br><span class="line">    右外</span><br><span class="line">    全外</span><br><span class="line">交叉连接</span><br></pre></td></tr></table></figure>

<p>一、传统模式下的连接 ：等值连接——非等值连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>等值连接的结果 <span class="operator">=</span> 多个表的交集</span><br><span class="line"><span class="number">2.</span>n表连接，至少需要n<span class="number">-1</span>个连接条件</span><br><span class="line"><span class="number">3.</span>多个表不分主次，没有顺序要求</span><br><span class="line"><span class="number">4.</span>一般为表起别名，提高阅读性和性能</span><br></pre></td></tr></table></figure>

<p>案例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查询有奖金的每个部门的部门名和部门的领导编号和该部门的最低工资</span><br><span class="line"><span class="keyword">select</span> department_name,dept.manager_id,<span class="built_in">min</span>(salary)</span><br><span class="line"><span class="keyword">from</span> departments dept,employees emp</span><br><span class="line"><span class="keyword">where</span> dept.department_id<span class="operator">=</span>emp.department_id</span><br><span class="line"><span class="keyword">and</span> commission <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> department_name,dept.manager_id;</span><br><span class="line"></span><br><span class="line"># 查询每个工种的工种名和员工数量，并且按员工数量降序</span><br><span class="line"><span class="keyword">select</span> job_title,<span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">from</span> employees e,jobs j</span><br><span class="line"><span class="keyword">where</span> e.job_id<span class="operator">=</span>j.job_id</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line"># 已知 表student(id,name,gradeId),表grade(id,name),表<span class="keyword">result</span>(id,score,studentId)</span><br><span class="line"># 查询所有学生姓名、年级名、成绩</span><br><span class="line"><span class="keyword">select</span> s.name 姓名,g.name 年级名,r.score 成绩</span><br><span class="line"><span class="keyword">from</span> student s,grade g,<span class="keyword">result</span> r</span><br><span class="line"><span class="keyword">where</span> s.gradeId<span class="operator">=</span>g.id</span><br><span class="line"><span class="keyword">and</span> s.id<span class="operator">=</span>r.studentId</span><br></pre></td></tr></table></figure>

<p>二、sql92语法和sql99语法(使用join关键字实现连接)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sql92：</span><br><span class="line">    等值</span><br><span class="line">    非等值</span><br><span class="line">    自连接</span><br><span class="line">也支持一部分外连接（用于oracle、sqlserver，mysql不支持）</span><br><span class="line"></span><br><span class="line">sql99【推荐使用】</span><br><span class="line">    内连接</span><br><span class="line">        等值</span><br><span class="line">        非等值</span><br><span class="line">        自连接</span><br><span class="line">    外连接</span><br><span class="line">        左外</span><br><span class="line">        右外</span><br><span class="line">        全外（mysql不支持）</span><br><span class="line">    交叉连接</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line">    <span class="keyword">select</span> 字段，...</span><br><span class="line">    <span class="keyword">from</span> 表名 别名</span><br><span class="line">    【<span class="keyword">inner</span><span class="operator">|</span><span class="keyword">left</span> <span class="keyword">outer</span><span class="operator">|</span><span class="keyword">right</span> <span class="keyword">outer</span><span class="operator">|</span><span class="keyword">cross</span>】 <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span>  连接条件</span><br><span class="line">    【<span class="keyword">inner</span><span class="operator">|</span><span class="keyword">left</span> <span class="keyword">outer</span><span class="operator">|</span><span class="keyword">right</span> <span class="keyword">outer</span><span class="operator">|</span><span class="keyword">cross</span>】 <span class="keyword">join</span> 表<span class="number">3</span> <span class="keyword">on</span>  连接条件</span><br><span class="line">    【<span class="keyword">where</span> 筛选条件】</span><br><span class="line">    【<span class="keyword">group</span> <span class="keyword">by</span> 分组字段】</span><br><span class="line">    【<span class="keyword">having</span> 分组后的筛选条件】</span><br><span class="line">    【<span class="keyword">order</span> <span class="keyword">by</span> 排序的字段或表达式】</span><br><span class="line">    【limit 返回条件】</span><br><span class="line"></span><br><span class="line">好处：语句上，连接条件和筛选条件实现了分离，简洁明了！</span><br></pre></td></tr></table></figure>

<p>三、自连接</p>
<p>案例：查询员工名和直接上级的名称</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># sql92</span><br><span class="line"><span class="keyword">SELECT</span> e.last_name,m.last_name</span><br><span class="line"><span class="keyword">FROM</span> employees e,employees m </span><br><span class="line"><span class="keyword">WHERE</span> e.manager_id<span class="operator">=</span>m.employee_id;</span><br><span class="line"></span><br><span class="line"># sql99</span><br><span class="line"><span class="keyword">SELECT</span> e.last_name,m.last_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">JOIN</span> employees m <span class="keyword">ON</span> e.manager_id<span class="operator">=</span>m.employee_id;</span><br></pre></td></tr></table></figure>

<p>四、外连接</p>
<img src="https://img.jbzj.com/file_images/article/201412/Visual_SQL_JOINS_small.jpg" alt="Visual_SQL_JOINS_small.jpg"  />

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 外连接<span class="operator">=</span>内连接<span class="operator">+</span>主表中有而从表中没有的记录，一般用于查询除了交集部分的剩余的不匹配的行（A<span class="operator">-</span>A∩B）</span><br><span class="line"># <span class="keyword">left</span> <span class="keyword">join</span> 左边的就是主表</span><br><span class="line"># <span class="keyword">right</span> <span class="keyword">join</span> 右边的就是主表</span><br><span class="line"># <span class="keyword">full</span> <span class="keyword">join</span> 两边都是主表(mysql不支持)</span><br></pre></td></tr></table></figure>

<p>案例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查询没有员工的部门</span><br><span class="line"><span class="keyword">select</span> department.<span class="operator">*</span>,employee_id</span><br><span class="line"><span class="keyword">from</span> departments</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> employees</span><br><span class="line"><span class="keyword">on</span> department.department_id<span class="operator">=</span>employees.department_id</span><br><span class="line"><span class="keyword">where</span> employees.employee_id <span class="keyword">is</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>



<h3 id="进阶7：子查询"><a href="#进阶7：子查询" class="headerlink" title="进阶7：子查询"></a>进阶7：子查询</h3><p>含义：</p>
<pre><code>一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询
在外面的查询语句，称为主查询或外查询
</code></pre>
<p>特点：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、子查询都放在小括号内</span><br><span class="line"><span class="number">2</span>、子查询可以放在<span class="keyword">from</span>后面、<span class="keyword">select</span>后面、<span class="keyword">where</span>后面、<span class="keyword">having</span>后面，但一般放在条件的右侧</span><br><span class="line"><span class="number">3</span>、子查询优先于主查询执行，主查询使用了子查询的执行结果</span><br><span class="line"><span class="number">4</span>、子查询分类</span><br><span class="line">根据查询结果的行数不同分为以下两类：</span><br><span class="line">    单行子查询</span><br><span class="line">        结果集只有一行</span><br><span class="line">        细分为：</span><br><span class="line">            标量子查询(结果集只有一行一列)</span><br><span class="line">            行子查询(结果集一行多列)</span><br><span class="line">        一般搭配单行操作符使用：<span class="operator">&gt;</span> <span class="operator">&lt;</span> <span class="operator">=</span> <span class="operator">&lt;&gt;</span> <span class="operator">&gt;=</span> <span class="operator">&lt;=</span> </span><br><span class="line">        非法使用子查询的情况：</span><br><span class="line">        a、子查询的结果为一组值</span><br><span class="line">        b、子查询的结果为空</span><br><span class="line"></span><br><span class="line">    多行子查询</span><br><span class="line">        结果集有多行</span><br><span class="line">        细分为：</span><br><span class="line">            列子查询(结果集一列多行)</span><br><span class="line">            表子查询(结果集多行多列)</span><br><span class="line">        一般搭配多行操作符使用：<span class="keyword">any</span>、<span class="keyword">all</span>、<span class="keyword">in</span>、<span class="keyword">not</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">in</span><span class="operator">|</span><span class="keyword">not</span> <span class="keyword">in</span> : 等于列表中任意一个<span class="operator">|</span>不在列表中</span><br><span class="line">        	先执行子查询，再执行主查询</span><br><span class="line">        <span class="keyword">any</span><span class="operator">|</span><span class="keyword">some</span> : 条件满足列表中任意一项即可</span><br><span class="line">        	salary<span class="operator">&gt;</span><span class="keyword">any</span>(<span class="string">&#x27;10&#x27;</span>,<span class="string">&#x27;15&#x27;</span>,<span class="string">&#x27;20&#x27;</span>)</span><br><span class="line">        <span class="keyword">all</span> : 条件必须对于列表中所有元素成立</span><br><span class="line">        <span class="keyword">any</span><span class="operator">|</span><span class="keyword">some</span>和<span class="keyword">all</span>都不常用，因为可以使用标量子查询来替换这些多行查询</span><br><span class="line">        	salary<span class="operator">&gt;</span><span class="keyword">any</span>(<span class="string">&#x27;10&#x27;</span>,<span class="string">&#x27;15&#x27;</span>,<span class="string">&#x27;20&#x27;</span>)  <span class="operator">&lt;=</span><span class="operator">=</span><span class="operator">&gt;</span> salary<span class="operator">&gt;</span>(<span class="built_in">min</span>(salary))</span><br><span class="line">        	salary<span class="operator">&gt;</span><span class="keyword">all</span>(<span class="string">&#x27;10&#x27;</span>,<span class="string">&#x27;15&#x27;</span>,<span class="string">&#x27;20&#x27;</span>)  <span class="operator">&lt;=</span><span class="operator">=</span><span class="operator">&gt;</span> salary<span class="operator">&gt;</span>(<span class="built_in">max</span>(salary))</span><br><span class="line">根据子查询出现的位置</span><br><span class="line">	<span class="keyword">select</span>后面：</span><br><span class="line">		标量子查询</span><br><span class="line">    <span class="keyword">from</span>后面：</span><br><span class="line">    	表子查询 将结果集作为新表,新表必须起别名★</span><br><span class="line">    <span class="keyword">where</span>或<span class="keyword">having</span>后面(重要)：</span><br><span class="line">    	标量子查询(单行子查询)</span><br><span class="line">    	列子查询(多行子查询)</span><br><span class="line">    	行子查询</span><br><span class="line">    <span class="keyword">exists</span>后面</span><br><span class="line">   		表子查询，先执行主查询，再执行子查询</span><br><span class="line">根据查询的数据耦合情况分为</span><br><span class="line">	嵌套子查询：查询语句的执行不依赖外部的查询,执行顺序：子查询<span class="operator">-</span><span class="operator">&gt;</span>主查询</span><br><span class="line">	相关子查询：查询语句的执行依赖外部的查询,执行顺序：主查询<span class="operator">-</span><span class="operator">&gt;</span>子查询<span class="operator">-</span><span class="operator">&gt;</span>主查询</span><br></pre></td></tr></table></figure>

<h4 id="in和exists的区别"><a href="#in和exists的区别" class="headerlink" title="in和exists的区别"></a>in和exists的区别</h4><p><a href="https://blog.csdn.net/wqc19920906/article/details/79800374?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.nonecase">参考网址</a></p>
<ol>
<li>从表小，主表大且又有索引时应该用in</li>
<li>主表小，从表大且又有索引时使用exists</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> employees emp1</span><br><span class="line"><span class="keyword">where</span> emp1 <span class="keyword">in</span>(</span><br><span class="line">    <span class="keyword">select</span> emp1.id</span><br><span class="line">    <span class="keyword">from</span> employees emp2</span><br><span class="line">    <span class="keyword">where</span> emp1.id<span class="operator">&gt;</span>emp2.id</span><br><span class="line">)</span><br><span class="line">执行顺序:</span><br><span class="line">	<span class="number">1</span>、执行子查询</span><br><span class="line">		将结果与主表进行笛卡尔积</span><br><span class="line">	<span class="number">2</span>、执行主查询</span><br><span class="line"><span class="comment">------------------------</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> employees emp1</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span>(</span><br><span class="line">    <span class="keyword">select</span> emp1.id</span><br><span class="line">    <span class="keyword">from</span> employees emp2</span><br><span class="line">    <span class="keyword">where</span> emp1.id<span class="operator">&gt;</span>emp2.id</span><br><span class="line">)</span><br><span class="line">执行顺序:</span><br><span class="line">	<span class="number">1</span>、执行主查询</span><br><span class="line">		<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees</span><br><span class="line">		将结果与子表进行笛卡尔积</span><br><span class="line">	<span class="number">2</span>、执行子查询</span><br><span class="line">		<span class="keyword">exists</span>(</span><br><span class="line">            <span class="keyword">select</span> emp1.id</span><br><span class="line">            <span class="keyword">from</span> employees emp2</span><br><span class="line">            <span class="keyword">where</span> emp1.id<span class="operator">&gt;</span>emp2.id</span><br><span class="line">        )</span><br><span class="line"><span class="comment">--------------------------</span></span><br><span class="line"><span class="keyword">not</span> <span class="keyword">in</span> 和<span class="keyword">not</span> <span class="keyword">exists</span></span><br><span class="line">	如果查询语句使用了<span class="keyword">not</span> <span class="keyword">in</span> 那么内外表都进行全表扫描，且没有用到索引；而<span class="keyword">not</span> extsts 的子查询依然能用到表上的索引。</span><br><span class="line">	所以无论那个表大，用<span class="keyword">not</span> <span class="keyword">exists</span>都比<span class="keyword">not</span> <span class="keyword">in</span>要快。</span><br></pre></td></tr></table></figure>

<p>案例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="comment">--------------------标量子查询--------------------</span></span><br><span class="line"># 查询<span class="number">141</span>号员工的job_id </span><br><span class="line"># 查询<span class="number">143</span>号员工的salary</span><br><span class="line"># 查询员工的姓名，job_id和工资，要求job_id<span class="operator">=</span><span class="number">141</span>号员工的job_id，salary<span class="operator">&gt;</span><span class="number">143</span>号员工的salary</span><br><span class="line"><span class="keyword">select</span> last_name,job_id,salary</span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">where</span> job_id<span class="operator">=</span>(</span><br><span class="line">	<span class="keyword">select</span> job_id</span><br><span class="line">    <span class="keyword">from</span> employees</span><br><span class="line">    <span class="keyword">where</span> employee_id<span class="operator">=</span><span class="number">141</span></span><br><span class="line">) <span class="keyword">and</span> salary<span class="operator">&gt;</span>(</span><br><span class="line">	<span class="keyword">select</span> salary</span><br><span class="line">    <span class="keyword">from</span> employees</span><br><span class="line">    <span class="keyword">where</span> employee_id<span class="operator">=</span><span class="number">143</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 返回公司工资最少的员工last_name,job_id,salary</span><br><span class="line"><span class="keyword">select</span> last_name,job_id,salary</span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">where</span> salary<span class="operator">=</span>(</span><br><span class="line">	<span class="keyword">select</span> <span class="built_in">min</span>(salary)</span><br><span class="line">    <span class="keyword">from</span> employees</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 查询最低工资大于<span class="number">50</span>号部门最低工资的部门id,最低工资</span><br><span class="line"><span class="keyword">select</span> department_id,<span class="built_in">min</span>(salary)</span><br><span class="line"><span class="keyword">from</span> departments</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> department_id</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">min</span>(salary)<span class="operator">&gt;</span>(</span><br><span class="line">	<span class="keyword">select</span> <span class="built_in">min</span>(salary)</span><br><span class="line">    <span class="keyword">from</span> departments</span><br><span class="line">    <span class="keyword">where</span> department_id<span class="operator">=</span><span class="number">50</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># <span class="comment">--------------------------列子查询--------------</span></span><br><span class="line"># 查询location_id是<span class="number">1400</span>或<span class="number">1700</span>的部门编号</span><br><span class="line"><span class="keyword">select</span> last_name</span><br><span class="line"><span class="keyword">from</span> departments</span><br><span class="line"><span class="keyword">where</span> location_id <span class="keyword">in</span> (</span><br><span class="line">	<span class="keyword">select</span> <span class="keyword">distinct</span> department_id</span><br><span class="line">    <span class="keyword">from</span> departments</span><br><span class="line">    <span class="keyword">where</span> location_id <span class="keyword">in</span>(<span class="number">1400</span>,<span class="number">1700</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 返回其他部门中比job_id为<span class="string">&#x27;IT_PROG&#x27;</span>部门任意工资低的员工的员工号、姓名、job_id、salary</span><br><span class="line"><span class="keyword">select</span> last_name,employees,job_id,salary</span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">where</span> salary<span class="operator">&lt;</span>(</span><br><span class="line">	<span class="keyword">select</span> <span class="built_in">max</span>(salary)</span><br><span class="line">    <span class="keyword">from</span> employees</span><br><span class="line">    <span class="keyword">where</span> job_id<span class="operator">=</span><span class="string">&#x27;IT_PROG&#x27;</span></span><br><span class="line">) <span class="keyword">and</span> job_id<span class="operator">&lt;&gt;</span><span class="string">&#x27;IT_PROG&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># <span class="comment">--------------------------表子查询----------------</span></span><br><span class="line"># <span class="keyword">from</span>后面</span><br><span class="line"># 查询学生id为<span class="number">001</span>的选课名单及各科成绩</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line"><span class="keyword">from</span>(</span><br><span class="line">	<span class="keyword">select</span> student.id,sc</span><br><span class="line">)</span><br><span class="line"># exsits</span><br><span class="line"># 查询有员工的部门名</span><br><span class="line"><span class="keyword">select</span> department_name</span><br><span class="line"><span class="keyword">from</span> departments dept</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span>(</span><br><span class="line">	<span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">from</span> employees emp</span><br><span class="line">    <span class="keyword">where</span> dept.department_id<span class="operator">=</span>emp.department_id</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 查询工资最低的员工信息last_name、salary</span><br><span class="line"><span class="keyword">select</span> last_name,salary</span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">where</span> salary<span class="operator">=</span>(</span><br><span class="line">	<span class="keyword">select</span> <span class="built_in">min</span>(salary)</span><br><span class="line">    <span class="keyword">from</span> employees</span><br><span class="line">)</span><br><span class="line">等价于<span class="comment">------</span></span><br><span class="line"><span class="keyword">select</span> last_name,salary</span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">where</span> salary<span class="operator">=</span><span class="built_in">min</span>(salary)</span><br><span class="line"></span><br><span class="line"># 查询平均工资最低的部门信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> departments</span><br><span class="line"><span class="keyword">having</span> department_id <span class="operator">=</span> (</span><br><span class="line">    # 最小平均工资的部门</span><br><span class="line">	<span class="keyword">select</span> department_id</span><br><span class="line">    <span class="keyword">from</span> departments</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> department_id</span><br><span class="line">    <span class="keyword">having</span> <span class="built_in">avg</span>(salary) <span class="operator">=</span> (</span><br><span class="line">        # 最小平均工资</span><br><span class="line">        <span class="keyword">select</span> <span class="built_in">min</span>(avg_salary) min_avg_salary</span><br><span class="line">        <span class="keyword">from</span> (</span><br><span class="line">            # 平均工资</span><br><span class="line">            <span class="keyword">select</span> <span class="built_in">avg</span>(salary) avg_salary,department_id</span><br><span class="line">            <span class="keyword">from</span> employees</span><br><span class="line">            <span class="keyword">group</span> <span class="keyword">by</span> department_id</span><br><span class="line">        ) avg_department</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line">等价于<span class="comment">------</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> departments</span><br><span class="line"><span class="keyword">where</span> department_id <span class="operator">=</span> (</span><br><span class="line">	<span class="keyword">select</span> department_id</span><br><span class="line">    <span class="keyword">from</span> employees</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> department_id</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">avg</span>(salary) <span class="keyword">asc</span></span><br><span class="line">    limit <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 查询平均工资最低的部门信息和该部门的平均工资</span><br><span class="line"><span class="keyword">select</span> departments.<span class="operator">*</span>,avg_dept</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> department_id,<span class="built_in">avg</span>(salary)</span><br><span class="line">    <span class="keyword">from</span> employees</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> department_id</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">avg</span>(salary) <span class="keyword">asc</span></span><br><span class="line">    limit <span class="number">1</span></span><br><span class="line">) <span class="keyword">as</span> avg_dept</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> departments </span><br><span class="line"><span class="keyword">on</span> avg_dept.department_id <span class="operator">=</span> departments.department_id</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="进阶8：分页查询"><a href="#进阶8：分页查询" class="headerlink" title="进阶8：分页查询"></a>进阶8：分页查询</h3><p>应用场景：</p>
<pre><code>实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句
</code></pre>
<p>语法：</p>
<pre><code>select 字段|表达式,...
from 表
【where 条件】
【group by 分组字段】
【having 条件】
【order by 排序的字段】
limit 【起始的条目索引，】条目数;
条目数=-1表示遍历到结束
</code></pre>
<p>特点：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>起始条目索引从<span class="number">0</span>开始</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>limit子句放在查询语句的最后</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>公式：<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>  表 limit （page<span class="number">-1</span>）<span class="operator">*</span>sizePerPage,sizePerPage</span><br><span class="line">假如:</span><br><span class="line">每页显示条目数sizePerPage</span><br><span class="line">要显示的页数 page</span><br></pre></td></tr></table></figure>

<p>==mysql 中，limit 后面不能带运算符，只能是常量==</p>
<p>案例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 一、查询每个专业的学生人数</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> major</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> majorid</span><br><span class="line"># 二、查询参加考试的学生中，每个学生的平均分、最高分</span><br><span class="line"><span class="keyword">SELECT</span> studentno,<span class="built_in">AVG</span>(score),<span class="built_in">MAX</span>(score)</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">result</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> studentno</span><br><span class="line"># 三、查询姓张的学生中，最低分大于<span class="number">60</span>的学生的学号、姓名</span><br><span class="line"><span class="keyword">SELECT</span> newStudent.studentno 学号,newStudent.studentname 姓名,<span class="built_in">MIN</span>(score) 平均成绩</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> studentno,studentname</span><br><span class="line">	<span class="keyword">FROM</span> student</span><br><span class="line">	<span class="keyword">WHERE</span> studentname <span class="keyword">LIKE</span> <span class="string">&#x27;张%&#x27;</span></span><br><span class="line">) newStudent</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> <span class="keyword">result</span> <span class="keyword">on</span> newStudent.studentno<span class="operator">=</span>result.studentno</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> newStudent.studentno</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">MIN</span>(score)<span class="operator">&gt;</span><span class="number">60</span></span><br><span class="line"># 四、查询生日在“<span class="number">1988</span><span class="number">-1</span><span class="number">-1</span>”后的学生姓名、专业名称</span><br><span class="line"><span class="keyword">SELECT</span> ns.studentname,borndate,ns.majorid,mj.majorname</span><br><span class="line"><span class="keyword">FROM</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> studentname,majorid,borndate</span><br><span class="line">	<span class="keyword">FROM</span> student</span><br><span class="line">	<span class="keyword">WHERE</span> borndate<span class="operator">&gt;</span><span class="string">&#x27;1988-1-1&#x27;</span></span><br><span class="line">) ns</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> major mj <span class="keyword">on</span> ns.majorid<span class="operator">=</span>mj.majorid</span><br><span class="line"></span><br><span class="line"># 五、查询每个专业的男生人数和女生人数分别是多少</span><br><span class="line"><span class="comment">-- SELECT majorid,sex,COUNT(*) 人数</span></span><br><span class="line"><span class="comment">-- FROM student</span></span><br><span class="line"><span class="comment">-- GROUP BY majorid,sex</span></span><br><span class="line"><span class="keyword">SELECT</span> majorid,</span><br><span class="line">(<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> majorid<span class="operator">=</span>stu.majorid <span class="keyword">and</span> sex<span class="operator">=</span><span class="string">&#x27;男&#x27;</span>) 男,</span><br><span class="line">(<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> majorid<span class="operator">=</span>stu.majorid <span class="keyword">and</span> sex<span class="operator">=</span><span class="string">&#x27;女&#x27;</span>) 女</span><br><span class="line"><span class="keyword">FROM</span> student <span class="keyword">as</span> stu</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> majorid</span><br><span class="line"># 六、查询专业和张翠山一样的学生的最低分</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(score)</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">result</span></span><br><span class="line"><span class="keyword">WHERE</span> studentno <span class="keyword">in</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> studentno</span><br><span class="line">	<span class="keyword">FROM</span> student</span><br><span class="line">	<span class="keyword">WHERE</span> majorid <span class="operator">=</span> (</span><br><span class="line">		<span class="keyword">SELECT</span> majorid</span><br><span class="line">		<span class="keyword">from</span> student</span><br><span class="line">		<span class="keyword">WHERE</span> studentname<span class="operator">=</span><span class="string">&#x27;张翠山&#x27;</span></span><br><span class="line">	)</span><br><span class="line">)</span><br><span class="line"># 七、查询大于<span class="number">60</span>分的学生的姓名、密码、专业名</span><br><span class="line"><span class="keyword">SELECT</span> studentname 姓名,loginpwd 密码,</span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> majorname <span class="keyword">FROM</span> major <span class="keyword">WHERE</span> major.majorid<span class="operator">=</span>stu.majorid) 专业名</span><br><span class="line"><span class="keyword">from</span> student stu</span><br><span class="line"><span class="keyword">WHERE</span> studentno <span class="keyword">in</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> studentno</span><br><span class="line">	<span class="keyword">FROM</span> <span class="keyword">result</span></span><br><span class="line">	<span class="keyword">WHERE</span> score<span class="operator">&gt;</span><span class="number">60</span></span><br><span class="line">)</span><br><span class="line"># 八、按邮箱位数分组，查询每组的学生个数</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) 人数,LENGTH(email) 邮箱位数</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> LENGTH(email)</span><br><span class="line"># 九、查询学生名、专业名、分数</span><br><span class="line"><span class="keyword">SELECT</span> studentname,majorname,score</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">JOIN</span> major <span class="keyword">on</span> student.majorid<span class="operator">=</span>major.majorid</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="keyword">result</span> <span class="keyword">on</span> student.studentno<span class="operator">=</span>result.studentno</span><br><span class="line"># 十、查询哪个专业没有学生，分别用左连接和右连接实现</span><br><span class="line"><span class="keyword">SELECT</span> majorname,studentno</span><br><span class="line"><span class="keyword">FROM</span> major</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> student <span class="keyword">on</span> major.majorid<span class="operator">=</span>student.majorid</span><br><span class="line"><span class="keyword">WHERE</span> studentno <span class="keyword">is</span> <span class="keyword">NULL</span></span><br><span class="line"># 十一、查询没有成绩的学生人数</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="keyword">result</span> <span class="keyword">on</span> student.studentno<span class="operator">=</span>result.studentno</span><br><span class="line"><span class="keyword">WHERE</span> score <span class="keyword">is</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure>



<h3 id="进阶9：联合查询"><a href="#进阶9：联合查询" class="headerlink" title="进阶9：联合查询"></a>进阶9：联合查询</h3><p>引入：<br>    union 联合、合并</p>
<p>语法：</p>
<pre><code>select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】
select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】
select 字段|常量|表达式|函数 【from 表】 【where 条件】 union  【all】
.....
select 字段|常量|表达式|函数 【from 表】 【where 条件】
</code></pre>
<p>特点：</p>
<pre><code>1、多条查询语句的查询的列数必须是一致的
2、多条查询语句的查询的列的类型几乎相同
3、union代表去重，union all代表不去重
4、最终结果表的字段名是第一条查询的字段名
</code></pre>
<p>案例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查询部门编号<span class="operator">&gt;</span><span class="number">90</span>或邮箱包含a的员工信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees <span class="keyword">where</span> email <span class="keyword">like</span> <span class="string">&#x27;%a%&#x27;</span> <span class="keyword">or</span> departmentId<span class="operator">&gt;</span><span class="number">90</span></span><br><span class="line"><span class="operator">&lt;=</span><span class="operator">=</span><span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees <span class="keyword">where</span> email <span class="keyword">like</span> <span class="string">&#x27;%a%&#x27;</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees <span class="keyword">where</span> departmentId<span class="operator">&gt;</span><span class="number">90</span></span><br><span class="line"></span><br><span class="line"># 查询中国用户中男性信息和外国用户中男性信息</span><br><span class="line"><span class="keyword">select</span> id,cname <span class="keyword">from</span> t_ca <span class="keyword">where</span> csex<span class="operator">=</span><span class="string">&#x27;男&#x27;</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> t_id,tname <span class="keyword">from</span> t_ua <span class="keyword">where</span> usex<span class="operator">=</span><span class="string">&#x27;male&#x27;</span></span><br></pre></td></tr></table></figure>



<h3 id="单引号和双引号的区别"><a href="#单引号和双引号的区别" class="headerlink" title="单引号和双引号的区别"></a>单引号和双引号的区别</h3><p><a href="https://www.cnblogs.com/yulinlewis/p/9404508.html">参考网址</a></p>
<h2 id="DML语言"><a href="#DML语言" class="headerlink" title="DML语言"></a>DML语言</h2><p>Database Manipulation Language</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方式一：</span><br><span class="line">	insert into 表名(字段名,...) values(值1,...),(值1,...),...;</span><br><span class="line">	支持子查询</span><br><span class="line">		insert into 表名(字段名,...)</span><br><span class="line">		select 字段名,...</span><br><span class="line">		from 任意表名</span><br><span class="line">		where ...</span><br><span class="line">	支持多条数据插入</span><br><span class="line">		insert into 表名(字段名,...) values(值1,...),(值1,...),...;</span><br><span class="line">方式二：</span><br><span class="line">	insert into 表明 set 列名&#x3D;值,列名&#x3D;值</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<pre><code>1、字段类型和值类型一致或兼容，而且一一对应
2、可以为空的字段，可以不用插入值，或用null填充
3、不可以为空的字段，必须插入值
4、字段个数和值的个数必须一致
5、字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致
</code></pre>
<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>修改单表语法：</p>
<pre><code>update 表名 set 列名=新值,列名=新值
【where 条件】
# 修改满足条件的数据的字段
</code></pre>
<p>修改多表语法：</p>
<pre><code>update 表1 别名1 
join|left join|right join|cross 表2 别名2
on 连接条件
set 字段=新值，字段=新值
where 筛选条件;

# 修改张无忌的女朋友的手机号为114
update boys bo
inner join  beauty be on bo.id=be.boyfriend_id
set be.phone=&#39;114&#39;
where bo.boyName=&#39;张无忌&#39;
</code></pre>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>方式1：delete语句：清空表或数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">单表的删除： ★</span><br><span class="line">	delete from 表名 【where 筛选条件】</span><br><span class="line"></span><br><span class="line">多表的删除：</span><br><span class="line">	delete 别名1(删除表1中的数据)，别名2(删除表2中的数据)</span><br><span class="line">	from 表1 别名1 </span><br><span class="line">	join|left join|right join|cross 表2 别名2</span><br><span class="line">	on 连接条件</span><br><span class="line">	where 筛选条件;</span><br></pre></td></tr></table></figure>


<p>方式2：truncate语句：清空表</p>
<pre><code>truncate table 表名
</code></pre>
<p>两种方式的区别【面试题】<br>    #1.truncate不能加where条件，而delete可以加where条件</p>
<pre><code>#2.truncate的效率高一丢丢

#3.truncate 删除带自增长的列的表后，如果再插入数据，数据从1开始
# delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始

#4.truncate删除没有返回值
# delete删除会返回数据的行数

#4.truncate删除不能回滚，delete删除可以回滚
</code></pre>
<p><strong>注意</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete from Person </span><br><span class="line">where id not in (</span><br><span class="line">    select min(Id) id from Person group by Email having count(Email) &gt; 1</span><br><span class="line">) or Email not in (</span><br><span class="line">    select Email from Person group by Email having count(Email) &#x3D; 1</span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<p>执行这条语句时会报错：You can’t specify target table ‘Person’ for update in FROM clause</p>
<p>这是因为==MySQL不允许同时查询和删除一张表==(MSSQL和Oracle不会出现此问题)，我们可以通过子查询的方式包装一下即可避免这个报错</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> Person </span><br><span class="line"><span class="keyword">where</span> id <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> id <span class="keyword">from</span> (</span><br><span class="line">    	<span class="keyword">select</span> <span class="built_in">min</span>(Id) id <span class="keyword">from</span> Person <span class="keyword">group</span> <span class="keyword">by</span> Email <span class="keyword">having</span> <span class="built_in">count</span>(Email) <span class="operator">&gt;</span> <span class="number">1</span></span><br><span class="line">    ) a</span><br><span class="line">) <span class="keyword">and</span> Email <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> Email <span class="keyword">from</span> (</span><br><span class="line">    	<span class="keyword">select</span> Email <span class="keyword">from</span> Person <span class="keyword">group</span> <span class="keyword">by</span> Email <span class="keyword">having</span> <span class="built_in">count</span>(Email) <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    ) b</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h2 id="DDL语言"><a href="#DDL语言" class="headerlink" title="DDL语言"></a>DDL语言</h2><p>Database Definition Language</p>
<h3 id="定义数据库和表"><a href="#定义数据库和表" class="headerlink" title="定义数据库和表"></a>定义数据库和表</h3><p>库的定义</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">一、创建库</span><br><span class="line"><span class="keyword">create</span> database 库名</span><br><span class="line">二、删除库</span><br><span class="line"><span class="keyword">drop</span> database [if <span class="keyword">exists</span>] 库名</span><br><span class="line">三、修改库的字符集</span><br><span class="line"><span class="keyword">alter</span> database 库名 <span class="type">character</span> <span class="keyword">set</span> 字符集类型;</span><br></pre></td></tr></table></figure>
<p>表的定义    </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="number">1.</span>创建表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> stuinfo(</span><br><span class="line">	stuId <span class="type">INT</span>,</span><br><span class="line">	stuName <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">	gender <span class="type">CHAR</span>,</span><br><span class="line">	bornDate DATTIME</span><br><span class="line">	);</span><br><span class="line"># 显示表结构</span><br><span class="line"><span class="keyword">desc</span> stuinfo;</span><br><span class="line">#<span class="number">2.</span>修改表 <span class="keyword">alter</span></span><br><span class="line">	<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span><span class="operator">|</span><span class="keyword">DROP</span><span class="operator">|</span>RENAME<span class="operator">|</span>CHANGE<span class="operator">|</span>MODIFY <span class="keyword">COLUMN</span> 字段名 【字段类型，字段约束】;</span><br><span class="line">        #添加字段</span><br><span class="line">        <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> 字段名 字段类型 【字段约束】;</span><br><span class="line">        	<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> studentinfo <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> email <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">first</span>;</span><br><span class="line">        #删除字段</span><br><span class="line">        <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> 字段名;</span><br><span class="line">        	<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> studentinfo <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> email;</span><br><span class="line">        #修改表名</span><br><span class="line">        <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 RENAME [<span class="keyword">TO</span>]  新表名;</span><br><span class="line">        	<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo RENAME [<span class="keyword">TO</span>]  studentinfo;</span><br><span class="line">        #修改字段名</span><br><span class="line">        <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 CHANGE <span class="keyword">COLUMN</span> 旧字段名 新字段名 字段类型;</span><br><span class="line">        	<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> studentinfo CHANGE <span class="keyword">COLUMN</span> sex gender <span class="type">CHAR</span>;</span><br><span class="line">        #修改字段类型和列级约束</span><br><span class="line">        <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 MODIFY <span class="keyword">COLUMN</span> 字段名 新字段类型 【字段约束】;</span><br><span class="line">        	<span class="keyword">ALTER</span> <span class="keyword">TABLE</span> studentinfo MODIFY <span class="keyword">COLUMN</span> borndate <span class="type">DATE</span>;</span><br><span class="line">#<span class="number">3.</span>删除表</span><br><span class="line">	<span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> studentinfo;</span><br><span class="line">#<span class="number">4.</span>复制表结构</span><br><span class="line">	<span class="keyword">create</span> <span class="keyword">table</span> 新表名 <span class="keyword">like</span> 旧表名</span><br><span class="line">#<span class="number">5.</span>复制表结构和数据</span><br><span class="line">	复制全部数据</span><br><span class="line">        <span class="keyword">create</span> <span class="keyword">table</span> 库名.新表名</span><br><span class="line">        <span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">        <span class="keyword">from</span> 库名.旧表名</span><br><span class="line">    复制部分数据</span><br><span class="line">    	<span class="keyword">create</span> <span class="keyword">table</span> 库名.新表名</span><br><span class="line">    	<span class="keyword">select</span> 字段<span class="number">1</span>,字段<span class="number">2</span>,...</span><br><span class="line">    	<span class="keyword">from</span> 库名.旧表名</span><br><span class="line">    	<span class="keyword">where</span> ...</span><br><span class="line">    复制部分表结构，且不要数据</span><br><span class="line">    	<span class="keyword">create</span> <span class="keyword">table</span> 库名.新表名</span><br><span class="line">    	<span class="keyword">select</span> 字段<span class="number">1</span>,字段<span class="number">2</span>,...</span><br><span class="line">    	<span class="keyword">from</span> 库名.旧表名</span><br><span class="line">    	<span class="keyword">where</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>


<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">整型：</span><br><span class="line">	tinyint、<span class="type">smallint</span>、mediumint、<span class="type">int</span><span class="operator">/</span><span class="type">integer</span>、<span class="type">bigint</span></span><br><span class="line">    <span class="number">1</span>B         <span class="number">2</span>        <span class="number">3</span>          <span class="number">4</span>            <span class="number">8</span></span><br><span class="line"></span><br><span class="line">    特点：</span><br><span class="line">    ①都可以设置无符号和有符号，默认有符号，通过unsigned设置无符号</span><br><span class="line">    ②如果超出了范围，会报<span class="keyword">out</span> <span class="keyword">or</span> <span class="keyword">range</span>异常，插入临界值</span><br><span class="line">    ③长度可以不指定，默认会有一个长度</span><br><span class="line">     长度代表显示的最小宽度，如果不够则左边用<span class="number">0</span>填充，但需要搭配zerofill，使用zerofill类型默认为无符号整型</span><br><span class="line">    	id <span class="type">int</span>(<span class="number">7</span>) zerofill <span class="operator">&lt;=</span><span class="operator">=</span><span class="operator">&gt;</span> id <span class="type">int</span>(<span class="number">7</span>) zerofill unsigned</span><br><span class="line">小数：</span><br><span class="line">    定点数：<span class="type">decimal</span>(M,D)</span><br><span class="line">    浮点数:</span><br><span class="line">        <span class="type">float</span>(M,D)   <span class="number">4</span></span><br><span class="line">        <span class="keyword">double</span>(M,D)  <span class="number">8</span></span><br><span class="line">    特点：</span><br><span class="line">    ①M代表整数部位<span class="operator">+</span>小数部位的个数，D代表小数部位</span><br><span class="line">    ②如果超出范围，则报<span class="keyword">out</span> <span class="keyword">or</span> <span class="keyword">range</span>异常，并且插入临界值</span><br><span class="line">    ③M和D都可以省略，但对于定点数，M默认为<span class="number">10</span>，D默认为<span class="number">0</span></span><br><span class="line">    ④如果精度要求较高，则优先考虑使用定点数</span><br><span class="line">字符型：</span><br><span class="line">    较短的文本:<span class="type">char</span>、<span class="type">varchar</span>、<span class="type">binary</span>(较短的二进制)、<span class="type">varbinary</span>、enum、<span class="keyword">set</span></span><br><span class="line">    	<span class="type">char</span>：固定长度的字符，写法为<span class="type">char</span>(M)，最大长度不能超过M，其中M可以省略，默认为<span class="number">1</span>。</span><br><span class="line">    		最终存储的长度<span class="operator">=</span>M。效率相对高。对于一些长度固定的数据，使用<span class="type">char</span></span><br><span class="line">    	<span class="type">varchar</span>：可变长度的字符，写法为<span class="type">varchar</span>(M)，最大长度不能超过M，其中M不可以省略。</span><br><span class="line">    		最终存储的长度<span class="operator">=</span>字符数。效率相对低。对于一些长度不固定的数据，使用<span class="type">varchar</span></span><br><span class="line">        Enum:</span><br><span class="line">            <span class="keyword">create</span> <span class="keyword">table</span> person(</span><br><span class="line">                sex ENUM(<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;m&#x27;</span>)</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">insert</span> <span class="keyword">into</span> person(sex) <span class="keyword">values</span>(<span class="string">&#x27;男&#x27;</span>)</span><br><span class="line">        <span class="keyword">Set</span>:</span><br><span class="line">        	<span class="keyword">create</span> <span class="keyword">table</span> book(</span><br><span class="line">        		type <span class="keyword">SET</span>(<span class="string">&#x27;动作&#x27;</span>,<span class="string">&#x27;喜剧&#x27;</span>,<span class="string">&#x27;悬疑&#x27;</span>,<span class="string">&#x27;爱情&#x27;</span>)</span><br><span class="line">        	)</span><br><span class="line">        	<span class="keyword">insert</span> <span class="keyword">into</span> book(type) <span class="keyword">values</span>(<span class="string">&#x27;动作,喜剧&#x27;</span>)</span><br><span class="line">    较长的文本:text()、<span class="type">blob</span>(较大的二进制,图片) 	</span><br><span class="line">日期型：</span><br><span class="line">	<span class="keyword">year</span>年</span><br><span class="line">    <span class="type">date</span>日期</span><br><span class="line">    <span class="type">time</span>时间</span><br><span class="line">    datetime 日期<span class="operator">+</span>时间          <span class="number">8</span>      </span><br><span class="line">    <span class="type">timestamp</span> 日期<span class="operator">+</span>时间         <span class="number">4</span>   比较容易受时区、语法模式、版本的影响，更能反映当前时区的真实时间,范围较小(<span class="number">1970</span><span class="number">-2038</span>)</span><br><span class="line">    	<span class="keyword">create</span> <span class="keyword">table</span> tab_date(</span><br><span class="line">        	t1 datetime,</span><br><span class="line">            t2 <span class="type">timestamp</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">insert</span> <span class="keyword">into</span> tab_date <span class="keyword">values</span>(now(),now());</span><br><span class="line">        <span class="keyword">set</span> time_zone<span class="operator">=</span><span class="string">&#x27;+9:00&#x27;</span> #设置为东<span class="number">9</span>区,<span class="type">timestamp</span>类型的数据就会受到影响，自动加一个小时</span><br><span class="line"><span class="type">Blob</span>类型：</span><br></pre></td></tr></table></figure>



<h3 id="常见约束"><a href="#常见约束" class="headerlink" title="常见约束"></a>常见约束</h3><p><strong>六种约束类型</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NOT NULL：非空，该字段的值必填</span><br><span class="line">UNIQUE：唯一，该字段的值不可重复，可以为空，自动添加索引</span><br><span class="line">DEFAULT：默认，该字段的值不用手动插入有默认值</span><br><span class="line">CHECK：检查，mysql不支持</span><br><span class="line">PRIMARY KEY：主键，该字段的值不可重复并且非空  unique+not null</span><br><span class="line">FOREIGN KEY：外键，该字段的值引用了另外的表的字段</span><br></pre></td></tr></table></figure>

<p>可以分为：</p>
<ul>
<li>列级约束：除了外键的所有约束</li>
<li>表级约束：除了非空和默认的所有约束，可以给约束命名(主键除外，主键命名固定为PRIMARY)</li>
</ul>
<p>==唯一，主键，外键都是键，创建后会自动添加索引==</p>
<p><strong>注意</strong></p>
<p>主键与唯一键的异同</p>
<table>
<thead>
<tr>
<th></th>
<th>是否唯一</th>
<th>是否允许为空</th>
<th>表中键的数量</th>
<th>是否允许组合键</th>
</tr>
</thead>
<tbody><tr>
<td>主键</td>
<td>是</td>
<td>否</td>
<td>至多1个</td>
<td>是</td>
</tr>
<tr>
<td>唯一键</td>
<td>是</td>
<td>是</td>
<td>没有限制</td>
<td>是</td>
</tr>
</tbody></table>
<p>外键</p>
<ol>
<li><p>用于限制两个表的关系，从表的字段值引用了主表的某字段值</p>
</li>
<li><p>外键列和主表的被引用列要求类型一致，意义一样，名称无要求</p>
</li>
<li><p>主表的被引用列要求是一个key（一般就是主键）</p>
</li>
<li><p>插入删除时存在规则</p>
<ol>
<li><p>插入数据，先插入主表</p>
</li>
<li><p>删除数据，先删除从表</p>
<p>可以通过以下两种方式来删除主表的记录<br>级联删除</p>
<pre><code> ALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE CASCADE;
</code></pre>
<p>级联置空</p>
<pre><code> ALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE SET NULL;
</code></pre>
</li>
</ol>
</li>
</ol>
<h3 id="定义约束"><a href="#定义约束" class="headerlink" title="定义约束"></a>定义约束</h3><p><strong>创建表时添加约束</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">推荐写法</span><br><span class="line">    <span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">        字段名 字段类型 <span class="keyword">not</span> <span class="keyword">null</span>,#非空</span><br><span class="line">        字段名 字段类型 <span class="keyword">primary</span> key,#主键</span><br><span class="line">        字段名 字段类型 <span class="keyword">unique</span>,#唯一</span><br><span class="line">        字段名 字段类型 <span class="keyword">default</span> 值,#默认</span><br><span class="line">        [<span class="keyword">constraint</span> 约束名] <span class="keyword">foreign</span> key(字段名,推荐fk_表<span class="number">1</span>_表<span class="number">2</span>) <span class="keyword">references</span> 主表（被引用列）</span><br><span class="line">    )</span><br><span class="line">	</span><br><span class="line">添加列级约束</span><br><span class="line">    <span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line">        id <span class="type">int</span> <span class="keyword">primary</span> key,#主键</span><br><span class="line">        name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,#非空</span><br><span class="line">        gender <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">check</span>(gender<span class="operator">=</span><span class="string">&#x27;男&#x27;</span> <span class="keyword">or</span> gender<span class="operator">=</span><span class="string">&#x27;女&#x27;</span>),#检查</span><br><span class="line">        seat <span class="type">int</span> <span class="keyword">unique</span>,#唯一</span><br><span class="line">        age <span class="type">int</span> <span class="keyword">default</span> <span class="number">18</span>,#默认</span><br><span class="line">        majorid <span class="type">int</span> <span class="keyword">references</span> major(id)#外键,并没有添加外键，外键必须由表级约束添加，并且对于外键添加的约束都无效</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">create</span> <span class="keyword">table</span> major(</span><br><span class="line">        id <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">        majorname <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">    )</span><br><span class="line">添加表级约束</span><br><span class="line">    <span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line">        id <span class="type">int</span>,</span><br><span class="line">        name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">        gender <span class="type">char</span>(<span class="number">1</span>),</span><br><span class="line">        seat <span class="type">int</span>,</span><br><span class="line">        age <span class="type">int</span>,</span><br><span class="line">        majorid <span class="type">int</span>,</span><br><span class="line">        # <span class="keyword">constraint</span> <span class="keyword">PRIMARY</span> <span class="keyword">primary</span> key(id),</span><br><span class="line">        <span class="keyword">constraint</span> <span class="keyword">PRIMARY</span> <span class="keyword">primary</span> key(id,name),#组合主键</span><br><span class="line">        <span class="keyword">constraint</span> uq <span class="keyword">unique</span>(seat),</span><br><span class="line">        <span class="keyword">constraint</span> ck <span class="keyword">check</span>(gender<span class="operator">=</span><span class="string">&#x27;男&#x27;</span> <span class="keyword">or</span> gender<span class="operator">=</span><span class="string">&#x27;女&#x27;</span>),</span><br><span class="line">        <span class="keyword">constraint</span> fk_student_major <span class="keyword">foreign</span> key(majorid) <span class="keyword">references</span> major(id)</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p><strong>修改表时添加或删除约束</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、非空</span><br><span class="line">添加非空(列级约束)</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 modify <span class="keyword">column</span> 字段名 字段类型 <span class="keyword">not</span> <span class="keyword">null</span>;</span><br><span class="line">删除非空</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 modify <span class="keyword">column</span> 字段名 字段类型 ;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、默认</span><br><span class="line">添加默认(列级约束)</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 modify <span class="keyword">column</span> 字段名 字段类型 <span class="keyword">default</span> 值;</span><br><span class="line">删除默认</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 modify <span class="keyword">column</span> 字段名 字段类型 ;</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、主键</span><br><span class="line">添加主键</span><br><span class="line">	列级约束</span><br><span class="line">		<span class="keyword">alter</span> <span class="keyword">table</span> 表名 modify <span class="keyword">column</span> 字段名 类型 <span class="keyword">primary</span> key;</span><br><span class="line">	表级约束</span><br><span class="line">		<span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span>【 <span class="keyword">constraint</span> 约束名】 <span class="keyword">primary</span> key(字段名);</span><br><span class="line">删除主键</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">primary</span> key;</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、唯一</span><br><span class="line">添加唯一</span><br><span class="line">	列级约束</span><br><span class="line">		<span class="keyword">alter</span> <span class="keyword">table</span> 表名 modify <span class="keyword">column</span> 字段名 类型 <span class="keyword">unique</span>;</span><br><span class="line">	表级约束</span><br><span class="line">		<span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span>【 <span class="keyword">constraint</span> 约束名】 <span class="keyword">unique</span>(字段名);</span><br><span class="line">删除唯一</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> index 索引名;</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、外键</span><br><span class="line">添加外键(表级约束)</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span>【 <span class="keyword">constraint</span> 约束名】 <span class="keyword">foreign</span> key(字段名) <span class="keyword">references</span> 主表（被引用列）;</span><br><span class="line">删除外键</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">foreign</span> key 约束名;</span><br></pre></td></tr></table></figure>

<h3 id="自增长列"><a href="#自增长列" class="headerlink" title="自增长列"></a>自增长列</h3><ol>
<li>不用手动插入值，可以自动提供序列值，默认从1开始，步长为1<pre><code>auto_increment_increment步长
auto_increment_offset起始值(mysql中不能修改)
如果要更改起始值：第一次插入时，手动插入值
如果要更改步长：更改系统变量
    set auto_increment_increment=值;
</code></pre>
</li>
<li>一个表<strong>至多有一个自增长列</strong></li>
<li>自增长列只能支持<strong>数值型</strong></li>
<li>==自增长列必须为一个key==</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">一、创建表时设置自增长列</span><br><span class="line">    <span class="keyword">create</span> <span class="keyword">table</span> 表(</span><br><span class="line">        字段名 字段类型 约束 auto_increment</span><br><span class="line">    )</span><br><span class="line">二、修改表时设置自增长列</span><br><span class="line">	<span class="keyword">alter</span> <span class="keyword">table</span> 表 modify <span class="keyword">column</span> 字段名 字段类型 约束 auto_increment</span><br><span class="line">三、删除自增长列</span><br><span class="line">	<span class="keyword">alter</span> <span class="keyword">table</span> 表 modify <span class="keyword">column</span> 字段名 字段类型 约束 </span><br></pre></td></tr></table></figure>



<h2 id="DTL语言"><a href="#DTL语言" class="headerlink" title="DTL语言"></a>DTL语言</h2><p>Database Transaction Language</p>
<h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>​    通过一组逻辑操作单元（一组DML-sql语句），将数据从一种状态切换到另外一种状态</p>
<h3 id="特点-ACID"><a href="#特点-ACID" class="headerlink" title="特点(ACID)"></a>特点(ACID)</h3><ul>
<li>原子性(Atomicity)：要么都执行，要么都回滚</li>
<li>一致性(Consistency)：保证数据的状态操作前和操作后保持一致(保证数据准确)</li>
<li>隔离性(Isolation)：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰</li>
<li>持久性(Durability)：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改</li>
</ul>
<p>相关步骤：</p>
<pre><code>1、开启事务
2、编写事务的一组逻辑操作单元（多条sql语句）
3、提交事务或回滚事务
</code></pre>
<h3 id="事务的分类"><a href="#事务的分类" class="headerlink" title="事务的分类"></a>事务的分类</h3><p>隐式事务，没有明显的开启和结束事务的标志</p>
<pre><code>insert、update、delete语句本身就是一个事务
</code></pre>
<p>显式事务，具有明显的开启和结束事务的标志</p>
<pre><code>1、禁用自动提交事务的功能,开启事务
    set autocommit=0;# 只针对当前事务
    start transaction;# 也可以不写
2、编写事务的一组逻辑操作单元（select,insert,update,delete）
    DDL并不是事务
3、提交事务或回滚事务(回滚操作不能单纯在mysql上使用,必须结合实际应用,如jdbc)
    commit;
    rollback;
</code></pre>
<h3 id="使用到的关键字"><a href="#使用到的关键字" class="headerlink" title="使用到的关键字"></a>使用到的关键字</h3><pre><code>set autocommit=0;
start transaction;
commit;
rollback;

savepoint  断点
commit to 断点
rollback to 断点
</code></pre>
<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p>事务并发问题如何发生？</p>
<pre><code>当多个事务同时操作同一个数据库的相同数据时
</code></pre>
<p>事务的并发问题有哪些？</p>
<pre><code>丢失更新：多个事务对相同数据操作时，最后的更新覆盖了由其他事务所做的更新
（事务1开启事务，事务2在开启并提交事务，事务1回滚，导致事务2的提交被覆盖；
  事务1开启事务，事务2在开启并提交事务，事务1提交，导致事务2的提交被覆盖；）
脏读：事务1读取到了事务2已修改但未提交的数据。(如果事务2回滚,则事务1读取的数据就是脏数据)
不可重复读：相同事务，读取结果(数据本身)不一样。(事务1读取数据并未结束，事务2更新数据并提交，事务1再次读取数据，两次读取的数据就不一样了。)
幻读：相同事务，读取结果(数据条数)不一样。(事务1读取数据并未结束，事务2插入或删除数据并提交，事务1再次读取数据，两次读取的数据就不一样了。)
</code></pre>
<p>如何避免事务的并发问题？</p>
<p>==对于mysql来说，通常采用前三种隔离级别加上相应的并发锁的机制来控制对数据的访问==</p>
<p><strong>事务隔离级别</strong></p>
<p>丢失更新只能通过并发锁来实现</p>
<table>
<thead>
<tr>
<th></th>
<th>说明</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>READ UNCOMMITTED</td>
<td></td>
<td>允许</td>
<td>允许</td>
<td>允许</td>
</tr>
<tr>
<td>READ COMMITTED</td>
<td>事务的更新操作结果只有在该事务提交之后，才能对另一个事务可见</td>
<td>不允许</td>
<td>允许</td>
<td>允许</td>
</tr>
<tr>
<td>REPEATABLE READ</td>
<td>保证在整个事务的过程中，对同一笔数据的读取结果是相同的</td>
<td>不允许</td>
<td>不允许</td>
<td>允许</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>所有事务必须依次执行，性能差</td>
<td>不允许</td>
<td>不允许</td>
<td>不允许</td>
</tr>
</tbody></table>
<ul>
<li>oracle只支持READ COMMITED(默认)、SERIALIZABLE</li>
<li>mysql支持四种，默认REPEATABLE READ</li>
</ul>
<p>设置隔离级别：</p>
<pre><code>set session(当前会话)|global(全局)  transaction isolation level 隔离级别名;
</code></pre>
<p>查看隔离级别：</p>
<pre><code>select @@tx_isolation;
</code></pre>
<h3 id="设置保存点"><a href="#设置保存点" class="headerlink" title="设置保存点"></a>设置保存点</h3><p>savepoint+rollback搭配使用实现回滚到固定位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set autocommit&#x3D;0;</span><br><span class="line">start transacation;</span><br><span class="line">delete from account where id&#x3D;25;</span><br><span class="line">savepoint a;# 设置保存点</span><br><span class="line">delete from account where id&#x3D;16;</span><br><span class="line">rollback to a;# 回滚到保存点</span><br></pre></td></tr></table></figure>

<h3 id="delete和truncate在事务中区别"><a href="#delete和truncate在事务中区别" class="headerlink" title="delete和truncate在事务中区别"></a>delete和truncate在事务中区别</h3><ul>
<li>delete支持回滚</li>
<li>truncate不支持回滚</li>
</ul>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>含义：理解成一张虚拟的表</p>
<h3 id="视图和表的区别"><a href="#视图和表的区别" class="headerlink" title="视图和表的区别"></a>视图和表的区别</h3><table>
<thead>
<tr>
<th></th>
<th>关键字</th>
<th>作用</th>
<th>占用物理空间</th>
</tr>
</thead>
<tbody><tr>
<td>视图</td>
<td>view</td>
<td>用于查询</td>
<td>占用较小，仅仅保存的是sql逻辑</td>
</tr>
<tr>
<td>表</td>
<td>table</td>
<td>增删改查</td>
<td>保存实际数据</td>
</tr>
</tbody></table>
<p>视图的好处：</p>
<ul>
<li>sql语句提高重用性，效率高</li>
<li>和表实现了分离，提高了==安全性==</li>
</ul>
<h3 id="定义视图"><a href="#定义视图" class="headerlink" title="定义视图"></a>定义视图</h3><p><strong>视图结构的查看</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DESC test_v7;</span><br><span class="line">SHOW CREATE VIEW test_v7;</span><br></pre></td></tr></table></figure>

<p><strong>视图的创建</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">	CREATE VIEW 视图名</span><br><span class="line">	AS</span><br><span class="line">	查询语句;</span><br></pre></td></tr></table></figure>

<p><strong>视图的修改</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#方式一：</span><br><span class="line">	CREATE OR REPLACE VIEW test_v7</span><br><span class="line">	AS</span><br><span class="line">	SELECT last_name FROM employees</span><br><span class="line">	WHERE employee_id&gt;100;</span><br><span class="line">#方式二:</span><br><span class="line">	ALTER VIEW test_v7</span><br><span class="line">	AS</span><br><span class="line">	SELECT employee_id FROM employees;</span><br><span class="line">	SELECT * FROM test_v7;</span><br></pre></td></tr></table></figure>

<p><strong>视图的删除</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP VIEW test_v1,test_v2,test_v3;</span><br></pre></td></tr></table></figure>



<h3 id="视图的操作"><a href="#视图的操作" class="headerlink" title="视图的操作"></a>视图的操作</h3><p>对于视图数据的操作，<strong>如果数据变化，会自动同步到原始表中</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、查看视图的数据 ★</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> my_v4;</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> my_v1 <span class="keyword">WHERE</span> last_name<span class="operator">=</span><span class="string">&#x27;Partners&#x27;</span>;</span><br><span class="line"><span class="number">2</span>、插入视图的数据</span><br><span class="line">	<span class="keyword">INSERT</span> <span class="keyword">INTO</span> my_v4(last_name,department_id) <span class="keyword">VALUES</span>(<span class="string">&#x27;虚竹&#x27;</span>,<span class="number">90</span>);</span><br><span class="line"><span class="number">3</span>、修改视图的数据</span><br><span class="line">	UPDATE my_v4 <span class="keyword">SET</span> last_name <span class="operator">=</span><span class="string">&#x27;梦姑&#x27;</span> <span class="keyword">WHERE</span> last_name<span class="operator">=</span><span class="string">&#x27;虚竹&#x27;</span>;</span><br><span class="line"><span class="number">4</span>、删除视图的数据</span><br><span class="line">	<span class="keyword">DELETE</span> <span class="keyword">FROM</span> my_v4;</span><br></pre></td></tr></table></figure>

<p><strong>某些视图数据不能操作</strong>(几乎所有视图都不允许操作)</p>
<ol>
<li>包含以下关键字的sql语句：分组函数、distinct、group  by、having、union或者union all</li>
<li>常量视图</li>
<li>Select中包含子查询</li>
<li>join</li>
<li>from一个不能更新的视图</li>
<li>where子句的子查询引用了from子句中的表</li>
</ol>
<p>==按照规范来讲，视图就是用于查询，所以应该是只读的，对于一些可以更新的视图，应该给视图加上权限，防止对原始表修改==</p>
<p><strong>案例</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 创建视图emp_v2,查询最高工资高于<span class="number">12000</span>的部门信息</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> emp_v2</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> department.<span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> department</span><br><span class="line"><span class="keyword">where</span> Id <span class="keyword">in</span> (</span><br><span class="line">	<span class="keyword">select</span> DepartmentId</span><br><span class="line">    <span class="keyword">from</span> employees</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> DepartmentId</span><br><span class="line">    <span class="keyword">having</span> <span class="built_in">max</span>(Salary)<span class="operator">&gt;</span><span class="number">12000</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><p><strong>全局变量</strong></p>
<p>作用域：针对于所有会话（连接）有效，但<strong>重启后，配置失效</strong></p>
<pre><code>查看所有全局变量
    SHOW GLOBAL VARIABLES;
查看满足条件的部分系统变量
    SHOW GLOBAL VARIABLES LIKE &#39;%char%&#39;;
查看指定的系统变量的值
    SELECT @@global.autocommit;
为某个系统变量赋值
    SET @@global.autocommit=0;
    SET GLOBAL autocommit=0;
</code></pre>
<p><strong>会话变量</strong></p>
<p>作用域：针对于当前会话（连接）有效</p>
<pre><code>如果不写SESSION，默认为当前会话
查看所有会话变量
    SHOW [SESSION] VARIABLES;
查看满足条件的部分会话变量
    SHOW [SESSION] VARIABLES LIKE &#39;%char%&#39;;
查看指定的会话变量的值
    SELECT @@[session].tx_isolation;
为某个会话变量赋值
    SET @@[session].tx_isolation=&#39;read-uncommitted&#39;;
    SET SESSION tx_isolation=&#39;read-committed&#39;;
</code></pre>
<h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><p><strong>用户变量–@变量名</strong></p>
<p>声明并初始化</p>
<pre><code>SET @变量名=值;
SET @变量名:=值;
SELECT @变量名:=值;
</code></pre>
<p>赋值</p>
<pre><code>方式一：一般用于赋简单的值
    SET @变量名=值;
    SET @变量名:=值;
    SELECT @变量名:=值;
方式二：一般用于赋表中的字段值(只能是标量子查询)
    SELECT 字段名或表达式 INTO @变量名
    FROM 表;
</code></pre>
<p>用户变量赋值没有固定类型，即该变量类型定义为弱定义</p>
<p><strong>局部变量–变量名</strong></p>
<p>声明并初始化</p>
<pre><code>declare 变量名 类型 【default 值】;
</code></pre>
<p>赋值</p>
<pre><code>方式一：一般用于赋简单的值
    SET 变量名=值;
    SET 变量名:=值;
    SELECT 变量名:=值;
方式二：一般用于赋表 中的字段值
    SELECT 字段名或表达式 INTO 变量名
    FROM 表;
</code></pre>
<p><strong>用户变量与局部变量的区别</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>作用域</th>
<th>定义位置</th>
<th>语法</th>
</tr>
</thead>
<tbody><tr>
<td>用户变量</td>
<td>当前会话</td>
<td>会话的任何地方</td>
<td>@变量名，不用指定类型</td>
</tr>
<tr>
<td>局部变量</td>
<td>定义它的BEGIN END中</td>
<td>BEGIN END的第一句话</td>
<td>一般不用加@，需要指定类型</td>
</tr>
</tbody></table>
<p><strong>案例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 声明两个变量并赋初值，求和并打印</span><br><span class="line"># 用户变量</span><br><span class="line">set @m&#x3D;1;</span><br><span class="line">set @n&#x3D;2;</span><br><span class="line">set @sum&#x3D;@m+@n;</span><br><span class="line">select @sum;</span><br></pre></td></tr></table></figure>



<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一组经过预先编译的sql语句的集合，类似java中的方法</p>
<p><strong>作用</strong></p>
<ul>
<li>提高了sql语句的重用性，减少了开发程序员的压力</li>
<li>提高效率<ul>
<li>减少编译次数（初次编译，之后使用无需重复编译）</li>
<li>减少数据库服务器连接次数（将sql语句进行打包，在一次连接中执行）</li>
</ul>
</li>
</ul>
<h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><p><strong>语法</strong></p>
<pre><code>create procedure 存储过程名(参数模式 参数名  参数类型,...)
begin
    存储过程体
end
</code></pre>
<p><strong>参数模式</strong></p>
<ul>
<li>in：该参数作为传入参数，调用时需要传参</li>
<li>out：该参数作为返回参数</li>
<li>inout：该参数即作为传入参数，又作为返回参数</li>
<li>==这些参数就是局部变量，赋值方式参考局部变量赋值方式==</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>存储过程体中只有一条sql语句，则可以省略begin end</li>
<li>存储过程体中每条sql语句结果必须加分号</li>
</ul>
<h3 id="结束标记delimiter"><a href="#结束标记delimiter" class="headerlink" title="结束标记delimiter"></a>结束标记delimiter</h3><p>使用delimiter关键字来设置结束标记</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line">	delimiter 新的结束标记</span><br><span class="line">示例:</span><br><span class="line">	delimiter $</span><br><span class="line">    CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名  参数类型,...)</span><br><span class="line">    BEGIN</span><br><span class="line">        sql语句1;</span><br><span class="line">        sql语句2;</span><br><span class="line">        ...</span><br><span class="line">    END $</span><br></pre></td></tr></table></figure>



<h3 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line">	<span class="keyword">call</span> 存储过程名(实参列表) 结束标记</span><br><span class="line">示例:</span><br><span class="line"><span class="comment">---------------------------------------------------------</span></span><br><span class="line"># 空参类型存储过程</span><br><span class="line">	# 创建</span><br><span class="line">	delimiter $</span><br><span class="line">	# 功能:数据插入</span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> store1()</span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">    	<span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    	# 关闭自动提交</span><br><span class="line">    	<span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    	REPEAT</span><br><span class="line">    		<span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span></span><br><span class="line">    		<span class="keyword">insert</span> <span class="keyword">into</span> admin(username,<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">   			<span class="keyword">values</span>(<span class="string">&#x27;John&#x27;</span>,<span class="string">&#x27;0001&#x27;</span>),(<span class="string">&#x27;Mary&#x27;</span>,<span class="string">&#x27;0002&#x27;</span>),(<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;0003&#x27;</span>),(<span class="string">&#x27;Alice&#x27;</span>,<span class="string">&#x27;004&#x27;</span>);</span><br><span class="line">        UNTIL i <span class="operator">=</span> max_num</span><br><span class="line">        <span class="keyword">END</span> REPEAT;</span><br><span class="line">        <span class="keyword">COMMIT</span>;</span><br><span class="line">    <span class="keyword">END</span> $</span><br><span class="line">    </span><br><span class="line">    # 调用</span><br><span class="line">    <span class="keyword">call</span> myp1()$</span><br><span class="line"> <span class="comment">----------------------------------------------------------   </span></span><br><span class="line">#  带<span class="keyword">in</span>模式参数的存储过程</span><br><span class="line">	# 创建</span><br><span class="line">	delimiter $</span><br><span class="line">	# 功能:查询选课的学生信息</span><br><span class="line">	<span class="keyword">create</span> <span class="keyword">procedure</span> store2(<span class="keyword">in</span> majorName <span class="type">varchar</span>(<span class="number">20</span>))</span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">		<span class="keyword">from</span> student</span><br><span class="line">		<span class="keyword">where</span> majorId <span class="operator">=</span> (</span><br><span class="line">        	<span class="keyword">select</span> id</span><br><span class="line">            <span class="keyword">from</span> major</span><br><span class="line">            <span class="keyword">where</span> name<span class="operator">=</span>majorName</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">end</span> $</span><br><span class="line">    </span><br><span class="line">    # 调用</span><br><span class="line">    <span class="keyword">call</span> store2(<span class="string">&#x27;计算机体系结构&#x27;</span>)$</span><br><span class="line">    </span><br><span class="line"># 创建存储过程实现，用户是否登录成功</span><br><span class="line">	<span class="keyword">create</span> <span class="keyword">procedure</span> store3(<span class="keyword">in</span> username <span class="type">varchar</span>(<span class="number">20</span>),<span class="keyword">in</span> password <span class="type">varchar</span>(<span class="number">20</span>))</span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">declare</span> <span class="keyword">result</span> <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">		<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">into</span> <span class="keyword">result</span></span><br><span class="line">		<span class="keyword">from</span> admin</span><br><span class="line">		<span class="keyword">where</span> admin.username<span class="operator">=</span>username</span><br><span class="line">		<span class="keyword">and</span> admin.password<span class="operator">=</span>password;</span><br><span class="line">		<span class="keyword">select</span> if(<span class="keyword">result</span><span class="operator">&gt;</span><span class="number">0</span>,<span class="string">&#x27;成功&#x27;</span>,<span class="string">&#x27;失败&#x27;</span>);</span><br><span class="line">    <span class="keyword">end</span> $</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">call</span> store3$</span><br><span class="line"><span class="comment">-------------------------------------------------------------</span></span><br><span class="line"># 创建带<span class="keyword">out</span>模式的存储过程</span><br><span class="line">	<span class="keyword">create</span> <span class="keyword">procedure</span> store4(<span class="keyword">in</span> studentName <span class="type">varchar</span>(<span class="number">20</span>),<span class="keyword">out</span> majorName <span class="type">varchar</span>(<span class="number">20</span>),<span class="keyword">out</span> majorCredit <span class="type">int</span>)</span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">select</span> major.Name,major.credit <span class="keyword">into</span> majorName,majorCredit</span><br><span class="line">		<span class="keyword">from</span> student</span><br><span class="line">		<span class="keyword">join</span> major <span class="keyword">on</span> student.majorId<span class="operator">=</span>major.id</span><br><span class="line">		<span class="keyword">where</span> student.name<span class="operator">=</span>studentName;</span><br><span class="line">	<span class="keyword">end</span> $</span><br><span class="line">	# 使用用户变量来接受局部变量</span><br><span class="line">	<span class="keyword">call</span> store4(<span class="string">&#x27;张三&#x27;</span>,<span class="variable">@majorName</span>,<span class="variable">@majorCredit</span>)$</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p><strong>删除存储过程</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop procedure 存储过程名;</span><br></pre></td></tr></table></figure>

<p><strong>查看存储过程</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show create procedure 存储过程名;</span><br></pre></td></tr></table></figure>

<p><strong>修改存储过程</strong></p>
<p>不能修改</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数和存储过程的区别"><a href="#函数和存储过程的区别" class="headerlink" title="函数和存储过程的区别"></a>函数和存储过程的区别</h3><table>
<thead>
<tr>
<th></th>
<th>关键字</th>
<th>调用语法</th>
<th>返回值</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>函数</td>
<td>function</td>
<td>select</td>
<td>有且仅有一个</td>
<td>查询结果为一个值</td>
</tr>
<tr>
<td>存储过程</td>
<td>procedure</td>
<td>call</td>
<td>0个或多个</td>
<td>更新</td>
</tr>
</tbody></table>
<p>存储过程中可以直接使用函数</p>
<h3 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h3><p>学过的函数：LENGTH、SUBSTR、CONCAT等<br>语法：</p>
<pre><code>delimiter $
CREATE FUNCTION 函数名(参数名 参数类型,...) RETURNS 返回类型
BEGIN
    函数体,必须包含return语句
END
select 函数名(参数)$
</code></pre>
<p>当函数体只有一条语句时，BEGIN END可以省略</p>
<h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 函数名（实参列表）</span><br><span class="line"></span><br><span class="line"><span class="comment">---------------------</span></span><br><span class="line"># 无参函数</span><br><span class="line">delimiter $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> countEmp() <span class="keyword">returns</span> <span class="type">int</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">return</span>(</span><br><span class="line">    	<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line">        <span class="keyword">from</span> employees</span><br><span class="line">    );</span><br><span class="line"><span class="keyword">end</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> countEmp()$</span><br></pre></td></tr></table></figure>

<p>查看函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show create function 函数名;</span><br></pre></td></tr></table></figure>

<p>删除函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop function 函数名;</span><br></pre></td></tr></table></figure>

<p>==函数和存储过程的定义，实际存储在数据库名为mysql数据库中proc表下==</p>
<h2 id="流程控制结构"><a href="#流程控制结构" class="headerlink" title="流程控制结构"></a>流程控制结构</h2><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p><strong>分类</strong></p>
<ul>
<li>if函数，简单双分支</li>
<li>case结构，等值判断的多分支</li>
<li>if elseif结构，区间判断的多分支</li>
</ul>
<p><strong>if</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法</span><br><span class="line">	if(条件，值1，值2)</span><br><span class="line">特点</span><br><span class="line">	可以用在任何位置</span><br></pre></td></tr></table></figure>

<p><strong>case</strong></p>
<pre><code>语法
    情况一：类似于switch
        case 表达式
        when 值1 then 结果1或语句1(如果是语句，需要加分号) 
        when 值2 then 结果2或语句2(如果是语句，需要加分号)
        ...
        else 结果n或语句n(如果是语句，需要加分号)
        end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）

        select (case
        when id%2=0 then id-1
        when id=(select max(id) from seat) then id
        else id+1 end) as id ,student
        from seat 
        order by id;

    情况二：类似于多重if
        case 
        when 条件1 then 结果1或语句1(如果是语句，需要加分号) 
        when 条件2 then 结果2或语句2(如果是语句，需要加分号)
        ...
        else 结果n或语句n(如果是语句，需要加分号)
        end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）
特点
    then 后面结果是值时，可以在任何地方使用
    then 后面结果是语句时，只能在begin-end作用范围内使用
</code></pre>
<p><strong>if elseif</strong></p>
<pre><code>语法
    if 情况1 then 语句1;
    elseif 情况2 then 语句2;
    ...
    else 语句n;
    end if;
特点：
    只能在begin-end作用范围内使用
</code></pre>
<p><strong>案例</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimater $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> judge_grade(score <span class="type">int</span>) <span class="keyword">returns</span> <span class="type">char</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	if(score<span class="operator">&gt;=</span><span class="number">90</span>) <span class="keyword">then</span> <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">	elseif(score<span class="operator">&gt;=</span><span class="number">80</span>) <span class="keyword">then</span> <span class="keyword">return</span> <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">	elseif(score<span class="operator">&gt;=</span><span class="number">70</span>) <span class="keyword">then</span> <span class="keyword">return</span> <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">	<span class="keyword">end</span> if;</span><br><span class="line"><span class="keyword">end</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> judge_grade(<span class="number">80</span>)$</span><br></pre></td></tr></table></figure>



<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>循环结构只能在begin-end作用范围内使用</p>
<p><strong>分类</strong></p>
<ul>
<li>loop 死循环</li>
<li>while 类似java中while</li>
<li>repeat 类似java中do-while</li>
</ul>
<p><strong>循环控制语句关键字</strong></p>
<ul>
<li>iterate 类似java中continue</li>
<li>leave 类似java中break</li>
</ul>
<p><strong>loop</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法</span><br><span class="line">	【标签:】 loop</span><br><span class="line">            循环体</span><br><span class="line">    end loop 【标签】;</span><br></pre></td></tr></table></figure>

<p><strong>while</strong></p>
<pre><code>语法
    【标签:】 WHILE 循环条件 DO
        循环体
        【iterate 标签】
    END WHILE 【标签】;
</code></pre>
<p>repeat</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line">    【名称:】repeat</span><br><span class="line">            循环体</span><br><span class="line">    until 结束条件 </span><br><span class="line">    end repeat 【名称】</span><br></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 根据传入的参数n，批量插入n次</span><br><span class="line">delimiter $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> <span class="keyword">insert</span>(<span class="keyword">in</span> <span class="type">time</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">declare</span> i <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">	while i<span class="operator">&lt;</span><span class="type">time</span> do</span><br><span class="line">		<span class="keyword">insert</span> <span class="keyword">into</span> admin(<span class="string">&#x27;username&#x27;</span>,<span class="string">&#x27;password&#x27;</span>) <span class="keyword">values</span>(concat(<span class="string">&#x27;admin&#x27;</span>,i),<span class="string">&#x27;1234&#x27;</span>);</span><br><span class="line">		<span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">	<span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span> $</span><br><span class="line"><span class="keyword">call</span> <span class="keyword">insert</span>(<span class="number">5</span>)$</span><br><span class="line"></span><br><span class="line"># 根据传入的参数n，批量插入n次，批量插入最多允许<span class="number">20</span>次</span><br><span class="line">delimiter $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> <span class="keyword">insert</span>(<span class="keyword">in</span> <span class="type">time</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">declare</span> i <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">	a:while i<span class="operator">&lt;</span><span class="type">time</span> do</span><br><span class="line">		<span class="keyword">insert</span> <span class="keyword">into</span> admin(<span class="string">&#x27;username&#x27;</span>,<span class="string">&#x27;password&#x27;</span>) <span class="keyword">values</span>(concat(<span class="string">&#x27;admin&#x27;</span>,i),<span class="string">&#x27;1234&#x27;</span>);</span><br><span class="line">		<span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">		if i<span class="operator">=</span><span class="operator">=</span><span class="number">20</span> <span class="keyword">then</span> leave a;</span><br><span class="line">	<span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span> $</span><br><span class="line"><span class="keyword">call</span> <span class="keyword">insert</span>(<span class="number">21</span>)$</span><br><span class="line"></span><br><span class="line"># 已知表stringcontent</span><br><span class="line"># 其中字段:</span><br><span class="line"># id 自增长</span><br><span class="line"># content <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line"># 向该表插入指定长度的随机字符串</span><br><span class="line">delimiter $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> insert_random_str(<span class="keyword">in</span> length <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">declare</span> i <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;# 循环变量</span><br><span class="line">	<span class="keyword">declare</span> idx <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;# 随机值</span><br><span class="line">	<span class="keyword">declare</span> str <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">default</span> &quot;&quot;;# 插入字符串</span><br><span class="line">	while i<span class="operator">&lt;</span>length do</span><br><span class="line">		<span class="keyword">set</span> idx<span class="operator">=</span><span class="built_in">floor</span>(rand()<span class="operator">*</span><span class="number">26</span><span class="operator">+</span><span class="number">1</span>)<span class="operator">+</span><span class="number">97</span>;# ascii码</span><br><span class="line">		<span class="keyword">set</span> str<span class="operator">=</span>concat(str,<span class="type">char</span>(idx));</span><br><span class="line">	<span class="keyword">end</span> while;</span><br><span class="line">	<span class="keyword">insert</span> <span class="keyword">into</span> stringcontent(content) <span class="keyword">values</span>(str);</span><br><span class="line"><span class="keyword">end</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> insert_random_str(<span class="number">20</span>)$</span><br></pre></td></tr></table></figure>



<h1 id="Mysql高级"><a href="#Mysql高级" class="headerlink" title="Mysql高级"></a>Mysql高级</h1><h2 id="Mysql逻辑架构图"><a href="#Mysql逻辑架构图" class="headerlink" title="Mysql逻辑架构图"></a>Mysql逻辑架构图</h2><p>和其它数据库相比， MySQL 有点与众不同， 它的架构可以在<strong>多种不同场景</strong>中应用并发挥良好作用。 主要体现在存储引擎的架构上， <strong>插件式的存储引擎架构</strong>将查询处理和其它的系统任务以及数据的存储提取相分离。 这种架构可以根据业务的需求和实际需要选择合适的存储引擎  </p>
<p><img src="MySQL%E5%9F%BA%E7%A1%80.assets/image-20200710225810242.png" alt="image-20200710225810242"></p>
<h3 id="连接层"><a href="#连接层" class="headerlink" title="连接层"></a>连接层</h3><p>最上层是一些客户端和连接服务， 包含本地 sock 通信和大多数基于客户端/服务端工具实现的类似于 tcp/ip 的通信。 主要完成一些类似于连接处理、 授权认证、 及相关的安全方案。 在该层上引入了线程池的概念， 为通过认证安全接入的客户端提供线程。 同样在该层上可以实现基于 SSL 的安全链接。 服务器也会为安全接入的每个客户端验证它所具有的操作权限。  </p>
<h3 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h3><table>
<thead>
<tr>
<th>组件</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Management Serveices &amp; Utilities</td>
<td>系统管理和控制工具</td>
</tr>
<tr>
<td>SQL Interface:</td>
<td>SQL 接口。 接受用户的 SQL 命令， 并且返回用户需要查询的结果。 比如 select from 就是调用 SQL Interface</td>
</tr>
<tr>
<td>Parser</td>
<td>解析器。 SQL 命令传递到解析器的时候会被解析器进行语法规则验证和解析</td>
</tr>
<tr>
<td>Optimizer</td>
<td>查询优化器。 SQL 语句在查询之前会使用查询优化器对查询进行优化， 比如有 where 条件时， 优化器来决定先投影还是先过滤。</td>
</tr>
<tr>
<td>Cache 和 Buffer</td>
<td>查询缓存。 如果查询缓存有命中的查询结果， 查询语句就可以直接去查询缓存中取 数据。 这个缓存机制是由一系列小缓存组成的。 比如表缓存， 记录缓存， key 缓存， 权限缓存等</td>
</tr>
</tbody></table>
<h3 id="引擎层"><a href="#引擎层" class="headerlink" title="引擎层"></a>引擎层</h3><p>存储引擎层， 存储引擎真正的负责了 MySQL 中数据的存储和提取， 服务器通过 API 与存储引擎进行通信。 不同的存储引擎具有的功能不同， 这样我们可以根据自己的实际需要进行选取。 </p>
<h3 id="MyISAM引擎和InnoDB引擎区别"><a href="#MyISAM引擎和InnoDB引擎区别" class="headerlink" title="MyISAM引擎和InnoDB引擎区别"></a>MyISAM引擎和InnoDB引擎区别</h3><p><strong>InnoDB 的数据是按数据页为单位来进行读写的</strong></p>
<p>InnDB索引不只是B+树，InnoDB引擎有一个特殊的功能叫做“自适应哈希索引(adaptive hash index)”。 当InnoDB注意到某些索引值被使用得非常频繁时，它会在内存中基于B-Tree索引之上再创建-一个哈希索引，这样就让B-Tree索引也具有哈希索引的一些优点，比如快速的哈希查找。这是一个完全自动的、内部的行为，用户无法控制或者配置，不过如果有必要,完全可以关闭该功能。<a href="https://blog.csdn.net/dkingyaoyao/article/details/90373581?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param">参考网址</a></p>
<table>
<thead>
<tr>
<th>对比项</th>
<th>MyISAM</th>
<th>InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td>外键</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>事务</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>行表锁</td>
<td>表锁， 即使操作一条记录也会锁住整个表， 不适合高并发的操作</td>
<td>行锁,操作时只锁某一行， 不对其它行有影响， 适合<strong>高并发</strong>的操作</td>
</tr>
<tr>
<td>缓存</td>
<td>只缓存索引， 不缓存真实数据</td>
<td>不仅缓存索引还要缓存真实数据， 对内存要求较高， 而且内 存大小对性能有决定性的影响</td>
</tr>
<tr>
<td>关注点</td>
<td>读<strong>性能</strong></td>
<td>并发写、 事务、 资源</td>
</tr>
<tr>
<td>默认安装</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>默认使用</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>自 带 系 统 表 使用</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>是否支持MVCC</td>
<td>N</td>
<td>支持应对高并发事务, MVCC比单纯的加锁更高效;MVCC只在 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 两个隔离级别下工作;MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查看所有数据库引擎</span><br><span class="line"><span class="keyword">show</span> engines</span><br><span class="line"># 查看默认数据库引擎</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%storage_engine%&#x27;</span></span><br></pre></td></tr></table></figure>



<h3 id="存储层"><a href="#存储层" class="headerlink" title="存储层"></a>存储层</h3><p>数据存储层， 主要是将数据存储在运行于裸设备的文件系统之上， 并完成与存储引擎的交互。</p>
<h2 id="Mysql查询与执行流程"><a href="#Mysql查询与执行流程" class="headerlink" title="Mysql查询与执行流程"></a>Mysql查询与执行流程</h2><h3 id="查询流程"><a href="#查询流程" class="headerlink" title="查询流程"></a>查询流程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[&quot;mysql客户端&quot;]--&quot;1、通过协议，建立连接&quot;--&gt;B[&quot;mysql服务器&quot;]</span><br><span class="line">A--&quot;2、查询语言&quot;--&gt;B</span><br><span class="line">B--&quot;3、检查缓存，&quot;--&gt;C[&quot;缓存&quot;]</span><br><span class="line">C--&quot;命中，返回结果&quot;--&gt;A</span><br><span class="line">B--&quot;未命中&quot;--&gt;D[&quot;解析器&quot;]</span><br><span class="line">D--&quot;解析树&quot;--&gt;E[&quot;优化器&quot;]</span><br><span class="line">E--&quot;最优执行计划&quot;--&gt;F[&quot;引擎层&quot;]</span><br></pre></td></tr></table></figure>



<h3 id="mysql执行顺序"><a href="#mysql执行顺序" class="headerlink" title="mysql执行顺序"></a>mysql执行顺序</h3><p>sql编码顺序</p>
<img src="MySQL基础.assets/image-20200711073654105.png" alt="image-20200711073654105" style="zoom:67%;" />

<p>sql执行顺序</p>
<img src="MySQL基础.assets/image-20200711073725523.png" alt="image-20200711073725523" style="zoom:67%;" />

<img src="MySQL基础.assets/image-20200711073826886.png" alt="image-20200711073826886" style="zoom: 80%;" />



<h2 id="常见低性能原因及处理"><a href="#常见低性能原因及处理" class="headerlink" title="常见低性能原因及处理"></a>常见低性能原因及处理</h2><p><strong>常见原因</strong></p>
<ul>
<li>查询数据过多</li>
<li>关联过多的表，即使用太多Join</li>
<li>没有利用索引，或没有利用好索引</li>
<li>服务器调优及各个参数设置没有设置适当<ul>
<li>top，free，iostat，vmstat查看系统性能状态</li>
</ul>
</li>
<li>内存不足，导致产生大量IO操作</li>
<li>锁设置不适当<ul>
<li>线程阻塞</li>
<li>死锁</li>
</ul>
</li>
</ul>
<p><strong>发现解决问题步骤</strong></p>
<ol>
<li>观察，至少跑1天，看看生产的慢SQL情况</li>
<li>开启慢查询日志，设置阈值，比如超过5s的就是慢SQL，记录在日志中</li>
<li>使用Explain分析</li>
<li>show profile 查询SQL在Mysql服务器中的执行细节和生命周期情况</li>
<li>运维或DBA，进行数据库服务器的参数调优</li>
</ol>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>帮助Mysql高效获取数据的<strong>数据结构</strong></p>
<p>一般而言，对于数据库索引都是B树索引。聚集索引、次要索引、复合索引、前缀索引、唯一索引都默认使用B+树索引。</p>
<p>除B树索引外，也有Hash索引</p>
<p>==虽然可以在表上建立很多个索引，但是查询时，只会使用表中的一个索引==</p>
<h3 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h3><p><strong>优点</strong></p>
<ul>
<li>降低数据库的IO成本，提高数据<strong>检索</strong>的效率</li>
<li>索引列对数据进行排序， 降低数据<strong>排序</strong>的成本， 降低了CPU的消耗</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>数据<strong>更新</strong>时，索引需要重新建立，增加时间开销</li>
<li>索引以文件方式存储在磁盘，带来额外空间开销</li>
</ul>
<h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><ul>
<li>单值索引：一个索引只包含一个列</li>
<li>复合索引：一个索引包含多个列，符合索引优先与单值索引</li>
<li>唯一索引：值必须唯一，允许有空值。自动在添加唯一约束的列上建立</li>
<li>主键索引：设置主键后，默认在主键上建立主键索引。innodb中主键索引为<strong>聚集索引</strong></li>
</ul>
<h3 id="普通索引和唯一索引的区别"><a href="#普通索引和唯一索引的区别" class="headerlink" title="普通索引和唯一索引的区别"></a>普通索引和唯一索引的区别</h3><ul>
<li>对于<strong>普通索引</strong>来说，查找到满足条件的第一个记录后，<strong>需要查找下一个记录</strong>，直到碰到第一个不满足条件的记录；（可能存在跨页的情况，但是影响几乎可以忽而略）</li>
<li>对于<strong>唯一索引</strong>来说，由于索引定义了唯一性，<strong>查找到第一个满足条件的记录后，就会停止继续检索</strong>。</li>
<li><strong>唯一索引的更新就不能使用 change buffer，实际上也只有普通索引才可以使用</strong></li>
</ul>
<p><strong>唯一索引的劣势</strong></p>
<p>对于唯一索引来说，<strong>所有的操作都要先判断这个操作是否违反了唯一性约束</strong>。比如：要插入（4，400）这个记录，就要先判断现在表中是否已经存在 k = 4 的记录，而这必须将数据页读入内存才能判断。如果已经读入到内存了，那就直接更新内存会更快，就没有必要使用 change buffer 了。</p>
<h3 id="数据更新过程"><a href="#数据更新过程" class="headerlink" title="数据更新过程"></a>数据更新过程</h3><p><a href="https://blog.csdn.net/pcwl1206/article/details/86594705?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-7.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-7.channel_param">参考网址</a></p>
<p>当需要一个数据页的时候</p>
<ul>
<li>如果数据页在内存中就直接更新</li>
<li>如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，<strong>InnoDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作</strong>。<ul>
<li>需要说明的是，虽然名字叫作 change buffer，实际上它是可以持久化的数据。也就是说，change buffer 在内存中有拷贝，也会被写入到磁盘上。</li>
<li>将 change buffer 中的操作应用到原数据页，得到最新的结果的过程称为：<strong>merge</strong>。除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge。在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作。</li>
</ul>
</li>
</ul>
<p><strong>好处</strong></p>
<ul>
<li><strong>将更新操作先记录在 change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用 buffer pool 的，所以这种方式还能够避免占用内存，提高内存利用率。</strong></li>
</ul>
<p><strong>使用条件</strong></p>
<ul>
<li><strong>唯一索引的更新就不能使用 change buffer，实际上也只有普通索引才可以使用</strong></li>
</ul>
<p><strong>适用场景</strong></p>
<p>因为 merge 的时候是真正进行数据更新的时刻，而 change buffer 的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做 merge 之前，change buffer 记录的变更越多（也就是这个页面上更新的次数越多），收益就越大。</p>
<ul>
<li><strong>因此，对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。</strong></li>
</ul>
<h3 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h3><table>
<thead>
<tr>
<th>操作</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>创建</td>
<td>CREATE [UNIQUE ] INDEX [indexName] ON table_name(column))</td>
</tr>
<tr>
<td>删除</td>
<td>DROP INDEX [indexName] ON mytable;</td>
</tr>
<tr>
<td>查看</td>
<td>SHOW INDEX FROM table_name</td>
</tr>
<tr>
<td>使 用 Alter 命令</td>
<td>ALTER TABLE tbl_name ADD PRIMARY KEY (column_list) : 该语句添加一个主键， 这意味着索引值必须是唯一 的， 且不能为 NULL。</td>
</tr>
<tr>
<td></td>
<td>ALTER TABLE tbl_name ADD UNIQUE index_name (column_list)</td>
</tr>
<tr>
<td></td>
<td>ALTER TABLE tbl_name ADD INDEX index_name (column_list): 添加普通索引， 索引值可出现多次。</td>
</tr>
<tr>
<td></td>
<td>ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):该语句指定了索引为 FULLTEXT ， 用于全文索 引。</td>
</tr>
</tbody></table>
<p><strong>创建索引</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建表时添加索引</span><br><span class="line"># 以列级方式</span><br><span class="line">CREATE TABLE customer (</span><br><span class="line">    id INT(10) UNSIGNED AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">    customer_no VARCHAR(200) UNIQUE,</span><br><span class="line">    customer_name VARCHAR(200),</span><br><span class="line">    customer_age int,</span><br><span class="line">);</span><br><span class="line"># 以表级方式</span><br><span class="line">CREATE TABLE customer (</span><br><span class="line">    id INT(10) UNSIGNED AUTO_INCREMENT ,</span><br><span class="line">    customer_no VARCHAR(200),</span><br><span class="line">    customer_name VARCHAR(200),</span><br><span class="line">    customer_age int,</span><br><span class="line">    # 对于普通索引还是以表级方式建立</span><br><span class="line">    # 普通索引--单值索引</span><br><span class="line">    KEY(customer_name),</span><br><span class="line">    # 普通索引--复合索引</span><br><span class="line">    KEY(customer_name,customer_age),</span><br><span class="line">    # 唯一索引</span><br><span class="line">    UNIQUE (customer_no)</span><br><span class="line">    # 主键索引</span><br><span class="line">    PRIMARY KEY(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><h4 id="BTree索引"><a href="#BTree索引" class="headerlink" title="BTree索引"></a>BTree索引</h4><p>数据存储在所有节点</p>
<p>MyISAM引擎使用</p>
<img src="https://images2015.cnblogs.com/blog/249993/201705/249993-20170517160113541-995629282.png" alt="img" style="zoom: 50%;" />

<h4 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+Tree索引"></a>B+Tree索引</h4><p>真实数据值存储在叶子节点</p>
<p><strong>InnoDB引擎使用</strong></p>
<img src="https://images2015.cnblogs.com/blog/249993/201705/249993-20170518153741385-231278940.png" alt="img" style="zoom: 67%;" />

<p>B+树相比B树的优势</p>
<ol>
<li>磁盘读写代价更低<ul>
<li>非叶子节点不存储数据，只有索引，所以一个盘块中能存储的索引更多，B+树的高度减小，IO次数更少</li>
</ul>
</li>
<li>查询效率更加稳定<ul>
<li>每次查询都要经历等于B+树高度的IO次数，时间一致</li>
</ul>
</li>
</ol>
<h4 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h4><p>键值对方式，Memory和NDB引擎支持，Nosql采用此种索引结构</p>
<h4 id="RTree索引"><a href="#RTree索引" class="headerlink" title="RTree索引"></a>RTree索引</h4><p>相比BTree，RTree优势在于范围查找。</p>
<p>RTree在mysql中很少使用，仅支持geometry数据类型。支持该数据类型的存储引擎有：MyISAM、InnbDB、BDB、NDB、Archive</p>
<h4 id="full-text索引"><a href="#full-text索引" class="headerlink" title="full-text索引"></a>full-text索引</h4><p>全文检索，支持分词技术</p>
<p>这种方式不再使用，目前都是用专门的搜索引擎代替，如ElasticSearch，Solr</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE article (</span><br><span class="line">    id INT(10) UNSIGNED AUTO_INCREMENT ,</span><br><span class="line">    title VARCHAR(200),</span><br><span class="line">    content VARCHAR(200),</span><br><span class="line">   	PRIMARY KEY(id),</span><br><span class="line">   	FULLTEXT KEY()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 传统方式</span><br><span class="line">select * from article where content like &quot;%要查询的字符串%&quot;</span><br><span class="line"># 全文索引查询方式</span><br><span class="line">select * from article where match(title,content) against (&quot;要查询的字符串&quot;)</span><br></pre></td></tr></table></figure>



<h4 id="聚集索引和非聚集索引"><a href="#聚集索引和非聚集索引" class="headerlink" title="聚集索引和非聚集索引"></a>聚集索引和非聚集索引</h4><p><strong>聚簇索引</strong></p>
<p>聚簇索引中<strong>主键索引与行记录是存储在一起</strong>。因此聚集索引不仅是索引，它也是一种数据存储方式。</p>
<p><strong>特点</strong></p>
<ul>
<li><p>对于聚集索引而言，数据行在<strong>磁盘上的排列方式和在索引上排序一致</strong>。</p>
</li>
<li><p>聚集索引字段可以不唯一</p>
</li>
<li><p>聚集索引，有且只能有一个</p>
</li>
</ul>
<p>InnoDB 的表必须要有聚集索引：</p>
<ul>
<li>如果表定义了 PK，则 PK 就是聚集索引；</li>
<li>如果表没有定义 PK，则第一个非空 unique 列是聚集索引；</li>
<li>否则，InnoDB 会创建一个隐藏的 row-id 作为聚集索引；</li>
</ul>
<p><strong>非聚簇索引</strong></p>
<ul>
<li><p>非聚集索引，也就是普通索引，辅助索引。</p>
<p>如果给表中多个字段加上非聚集索引 ， 那么就会出现多个独立的索引结构，每个索引（非聚集索引）互相之间不存在关联</p>
</li>
</ul>
<p><strong>聚集索引与非聚集索引的区别</strong></p>
<p>==通过聚集索引可以查到需要查找的数据 而通过非聚集索引可以查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据==</p>
<p>通过主键值找真正数据的过程叫做<strong>回表</strong></p>
<img src="MySQL基础.assets/image-20200711122028372.png" alt="image-20200711122028372" style="zoom: 80%;" />

<p><strong>总结</strong></p>
<p>==不管以任何方式查询表， 最终都会利用主键通过聚集索引来定位到数据， 聚集索引（主键）是通往真实数据所在的唯一路径。==</p>
<h5 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h5><p><strong>特殊情况</strong></p>
<p>有一种例外可以不使用聚集索引就能查询出所需要的数据， 这种非主流的方法 称之为「<strong>覆盖索引</strong>」查询， 也就是平时所说的<strong>复合索引</strong>或者<strong>多字段索引</strong>查询。</p>
<p>由于复合索引会将多个字段添加到索引中，那检索一个字段，不仅会得到主键id，还会得到其他字段的值，如果结果就是这些字段，则不需要再使用主键进行检索</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 建立索引</span><br><span class="line">create index index_birthday on user_info(birthday);</span><br><span class="line"># 查询生日在1991年11月1日出生用户的用户名</span><br><span class="line">select user_name from user_info where birthday &#x3D; &#39;1991-11-1&#39;</span><br><span class="line"></span><br><span class="line">首先，通过非聚集索引 index_birthday 查找 birthday 等于1991-11-1的所有记录的主键ID值</span><br><span class="line">然后，通过得到的主键ID值执行聚集索引查找，找到主键ID值对就的真实数据（数据行）存储的位置</span><br><span class="line">最后，从得到的真实数据中取得user_name字段的值返回，也就是取得最终的结果</span><br><span class="line"></span><br><span class="line"># 复合索引</span><br><span class="line">create index index_birthday_and_user_name on user_info(birthday, user_name);</span><br><span class="line">select user_name from user_info where birthday &#x3D; &#39;1991-11-1&#39;</span><br><span class="line">直接通过非聚集索引 index_birthday 查找 birthday 等于1991-11-1的所有记录的user_name字段的值并返回</span><br></pre></td></tr></table></figure>



<h3 id="索引创建条件"><a href="#索引创建条件" class="headerlink" title="索引创建条件"></a>索引创建条件</h3><p><strong>索引适合的情况</strong></p>
<ol>
<li>主键自动建立唯一索引</li>
<li>频繁作为查询条件的字段应该创建索引</li>
<li>查询中与其它表关联的字段，外键自动建立索引</li>
<li>单键/组合索引的选择问题，组合索引性价比更高</li>
<li>查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度<ul>
<li>group by 和order by后面的字段，并且组合索引字段顺序应该和排序字段顺序一致</li>
</ul>
</li>
<li>查询中统计或者分组字段  </li>
</ol>
<p><strong>不需要创建索引的情况</strong></p>
<ol>
<li>表记录很少</li>
<li>经常修改的表</li>
<li>数据重复且分布平均的表字段<ul>
<li>例如：性别、国籍，这些字段重复率很高</li>
<li><strong>索引的选择性</strong>：索引列中不同值的数目/总列数。索引值越接近1，这个索引的效率就越高</li>
</ul>
</li>
</ol>
<h3 id="Explain性能分析"><a href="#Explain性能分析" class="headerlink" title="Explain性能分析"></a>Explain性能分析</h3><p>使用 EXPLAIN 关键字可以模拟优化器执行 SQL 查询语句， 从而知道 MySQL 是如何处理你的 SQL 语句的。 分析你的查询语句或是表结构的性能瓶颈。  </p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li>表的读取顺序–explain结果字段id</li>
<li>数据读取操作的操作类型–explain结果字段select_type</li>
<li>哪些索引可以使用–explain结果字段possible_keys</li>
<li>哪些索引被实际使用–explain结果字段key</li>
<li>表之间的引用–explain结果字段ref</li>
<li>每张表有多少行被优化器查询</li>
</ul>
<h4 id="Explain使用"><a href="#Explain使用" class="headerlink" title="Explain使用"></a>Explain使用</h4><p><strong>语法</strong></p>
<p>Explain + SQL语句</p>
<p><strong>返回结果</strong></p>
<p><img src="MySQL%E5%9F%BA%E7%A1%80.assets/image-20200711155821807.png" alt="image-20200711155821807"></p>
<h5 id="字段说明"><a href="#字段说明" class="headerlink" title="字段说明"></a>字段说明</h5><ul>
<li><p><strong>id</strong>：select 查询的序列号，包含一组数字，表示查询中执行 select 子句或操作表的顺序。  </p>
<ul>
<li>id 相同， 执行顺序由上至下 ，t1-&gt;t2-&gt;t3</li>
</ul>
<img src="MySQL基础.assets/image-20200711160310180.png" alt="image-20200711160310180" style="zoom:125%;" />

<ul>
<li><p>id 不同， 如果是子查询， id 的序号会递增， id 值越大优先级越高， 越先被执行，t3-&gt;t2-&gt;t1</p>
<p><img src="MySQL%E5%9F%BA%E7%A1%80.assets/image-20200711160340474.png" alt="image-20200711160340474"></p>
</li>
<li><p>id 如果相同，从上往下顺序执行；id 值越大， 优先级越高， 越先执行,t3-&gt;==derived2（由id为2的查询衍生得到的一张虚表）==-&gt;t2</p>
<img src="MySQL基础.assets/image-20200711160906372.png" alt="image-20200711160906372" style="zoom:120%;" /></li>
</ul>
</li>
<li><p><strong>select_type</strong>：用于区别普通查询、 联合查询、 子查询等的复杂查询  </p>
</li>
</ul>
<table>
<thead>
<tr>
<th>select_type 属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>SIMPLE</td>
<td>简单的 select 查询,查询中不包含子查询或者 UNION，即单表查询</td>
</tr>
<tr>
<td>PRIMARY</td>
<td>查询中若包含任何复杂的子部分， 最外层查询则被标记为 Primary</td>
</tr>
<tr>
<td>DERIVED</td>
<td>在 FROM 列表中包含的子查询被标记为 DERIVED(衍生) MySQL 会递归执行这些子查询, 把结果放在临时表里。</td>
</tr>
<tr>
<td>SUBQUERY</td>
<td>在SELECT或WHERE列表中包含了子查询</td>
</tr>
<tr>
<td>DEPEDENT SUBQUERY</td>
<td>在SELECT或WHERE列表中包含了子查询,子查询基于外层</td>
</tr>
<tr>
<td>UNCACHEABLE SUBQUERY</td>
<td>无法使用缓存的子查询</td>
</tr>
<tr>
<td>UNION</td>
<td>若第二个SELECT出现在UNION之后， 则被标记为UNION； 若UNION包含在FROM子句的子查询中,外层SELECT将被标记为： DERIVED</td>
</tr>
<tr>
<td>UNION RESULT</td>
<td>从UNION表获取结果的SELECT</td>
</tr>
</tbody></table>
<ul>
<li><strong>table</strong>：这个数据是基于哪个表</li>
<li><strong>type</strong>：查询的访问类型<ul>
<li>结果值从最好到最坏依次是：  </li>
<li><strong>system</strong> &gt; <strong>const</strong> &gt; <strong>eq_ref</strong> &gt; <strong>ref</strong> &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; <strong>range</strong> &gt; index &gt; <strong>ALL</strong>  </li>
<li>==一般来说， 得保证查询至少达到 range 级别， 最好能达到 ref。==</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>type</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>system</td>
<td>表只有<strong>一行记录</strong>（等于系统表）， 这是 const 类型的特列， 平时不会出现， 这个也可以忽略不计</td>
</tr>
<tr>
<td>const</td>
<td>通常情况下，如果将一个主键（唯一键）放置到where后面作为条件查询，mysql优化器就能把这次查询优化转化为一个常量<br />select * from department where id = 1;</td>
</tr>
<tr>
<td>eq_ref</td>
<td>主键唯一性索引扫描， 对于每个索引键， 表中<strong>只有一条记录</strong>与之匹配，常出现在<strong>多表连接</strong>中，外表只有一条数据的情况。对于单表，优化器直接转化成const<br />select stu.name,sc.grade from student stu,score sc where stu.sid= sc.id;每个学生只有一条成绩信息</td>
</tr>
<tr>
<td>ref</td>
<td>查找条件列使用了索引而且不为主键和unique，即<strong>索引查询结果不唯一</strong><br />select * from person department where name=’张三’;叫张三的人可能有很多</td>
</tr>
<tr>
<td>range</td>
<td>指的是有范围的<strong>索引扫描</strong>(对于表上的扫描不是range)，相对于index的全索引扫描，它有范围限制，因此要优于index。<br />一般就是where后面条件在key上使用了between，and以及’&gt;’,’&lt;’外，in和or等方式扫描</td>
</tr>
<tr>
<td>index</td>
<td>在<strong>索引上进行全表扫描</strong>，没有在索引进行过滤</td>
</tr>
<tr>
<td>all</td>
<td>直接<strong>进行全表扫描</strong></td>
</tr>
</tbody></table>
<ul>
<li><p><strong>possible_keys</strong>：查询涉及到的字段上若存在索引，则该索引将被列出，<strong>但不一定被查询实际使用</strong>。</p>
</li>
<li><p><strong>key</strong>：实际使用的索引，如果为NULL，则表示没有索引或索引没使用(索引失效)。只会选择一个</p>
<ul>
<li>possible_keys中mysql推测使用的索引和key中实际使用的索引并没有任何关系</li>
<li>这里mysql认为是全表扫描，并没有使用key，但是实际上使用了主键索引</li>
</ul>
</li>
</ul>
<p><img src="MySQL%E5%9F%BA%E7%A1%80.assets/image-20200711180610660.png" alt="image-20200711180610660"></p>
<ul>
<li><p><strong>key_len</strong>：where后面的筛选字段命中复合索引的长度。<strong>长度越长，索引利用率越大，效率越高</strong>。可以用来检查是否充分利用索引</p>
<ul>
<li><p>对于复合索引(deptno,ename)，下面分别为全命中和部分命中的情况</p>
</li>
<li><p><img src="MySQL%E5%9F%BA%E7%A1%80.assets/image-20200711234355239.png" alt="image-20200711234355239"></p>
</li>
<li><p>计算长度</p>
</li>
<li><p>类型长度int=4B，varchar(20)=20，varchar和char字符串类型，长度需要考虑具体字符集，utf8 要乘3，GBK要乘2，varchar作为动态字符串类型还需要额外添加2B，允许为空的类型需要额外加上1B</p>
</li>
<li><p>所以5=4+1，67=(20*3+2)+5</p>
</li>
</ul>
</li>
<li><p><strong>ref</strong>：查询时索引匹配的字段或者常量。当在索引列上进行<strong>等值匹配</strong>时，也就是type字段是const、eq_ref、ref、ref_or_null、unique_subquery、index-subquery其中之一时，ref列展示的是与索引列作等值匹配的<strong>条件</strong>，如常数或者某个字段</p>
<ul>
<li>根据sql语句，在emp表上与ename索引列做等值匹配的是”AvDEjl”，即一个常量，所以ref为const</li>
<li>在dept表上与deptno索引列做等值匹配的是emp.’deptno’，即emp中的一个字段，所以ref为mytest.emp.deptno，即数据库名.表名.字段名</li>
<li><img src="MySQL%E5%9F%BA%E7%A1%80.assets/image-20200712000621185.png" alt="image-20200712000621185"></li>
</ul>
</li>
<li><p><strong>rows</strong>：rows 列显示 MySQL 认为它执行查询时必须检查的行数。 越少越好！  </p>
</li>
<li><p><strong>Extra</strong></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Extra</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Using filesort</td>
<td><strong>排序时，MySQL 中无法利用索引或字段上没有索引</strong>，会对数据使用一个外部的索引排序。 这种不是基于已建立索引的外部索引排序操作称为“文件排序”。<strong>需要优化</strong></td>
</tr>
<tr>
<td>Using temporary</td>
<td>MySQL 在对查询结果<strong>排序</strong>时使用<strong>临时表</strong>。<strong>需要优化</strong></td>
</tr>
<tr>
<td>Using index</td>
<td>表示相应的 select 操作中使用了<strong>覆盖索引</strong>(Covering Index)， 避免访问了表的数据行，即<strong>查询的数据都在辅助索引中，没有再根据主键id查找实际数据</strong><br/>如果同时出现 using where， 表明索引被用来执行索引键值的查找;<br />如果没有同时出现 using where， 表明索引只是用来读取数据而非利用索引执行查找。</td>
</tr>
<tr>
<td>Using where</td>
<td>表明使用了 where 过滤</td>
</tr>
<tr>
<td>Using join buffer</td>
<td>多表连接时使用了连接缓存</td>
</tr>
<tr>
<td>impossible where</td>
<td>where 子句的值总是 false， 不能用来获取任何元组。</td>
</tr>
<tr>
<td>select tables optimized away</td>
<td>在没有 GROUPBY 子句的情况下，对一些多行函数进行优化</td>
</tr>
<tr>
<td>distinct</td>
<td>优化distinct操作，找到第一个匹配的元组就停止</td>
</tr>
</tbody></table>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select d1.name,(select id from t3) d2</span><br><span class="line">from (select id,name from t1 where other_column&#x3D;&#39;&#39;) d1</span><br><span class="line">union</span><br><span class="line">(select name,id from t2)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>PRIMARY</td>
<td>derived 3</td>
<td>system<br />临时表只有一行数据</td>
<td>NULL</td>
<td>NULL<br />临时表上没有索引</td>
<td>NULL</td>
<td>NULL</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>DERIVED</td>
<td>t1</td>
<td>ALL</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL<br />没有索引匹配</td>
<td>1</td>
<td>Using where</td>
</tr>
<tr>
<td>2</td>
<td>SUBQUERY</td>
<td>t3</td>
<td>index</td>
<td>NULL</td>
<td>PRIMARY</td>
<td>4（id为主键）</td>
<td>NULL</td>
<td>1</td>
<td>Using index</td>
</tr>
<tr>
<td>4</td>
<td>UNION</td>
<td>t2</td>
<td>ALL</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>NULL</td>
<td>UNION RESULT</td>
<td>&lt;union1,4&gt;<br />操作1和4的结果</td>
<td>ALL</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td>NULL</td>
<td></td>
</tr>
</tbody></table>
<h3 id="索引失效原因及解决"><a href="#索引失效原因及解决" class="headerlink" title="索引失效原因及解决"></a>索引失效原因及解决</h3><p>建表sql</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE staffs (</span><br><span class="line">  id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  NAME VARCHAR (24)  NULL DEFAULT &#39;&#39; COMMENT &#39;姓名&#39;,</span><br><span class="line">  age INT NOT NULL DEFAULT 0 COMMENT &#39;年龄&#39;,</span><br><span class="line">  pos VARCHAR (20) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;职位&#39;,</span><br><span class="line">  add_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;入职时间&#39;</span><br><span class="line">) CHARSET utf8 COMMENT &#39;员工记录表&#39; ;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">INSERT INTO staffs(NAME,age,pos,add_time) VALUES(&#39;z3&#39;,22,&#39;manager&#39;,NOW());</span><br><span class="line">INSERT INTO staffs(NAME,age,pos,add_time) VALUES(&#39;July&#39;,23,&#39;dev&#39;,NOW());</span><br><span class="line">INSERT INTO staffs(NAME,age,pos,add_time) VALUES(&#39;2000&#39;,23,&#39;dev&#39;,NOW());</span><br><span class="line">INSERT INTO staffs(NAME,age,pos,add_time) VALUES(null,23,&#39;dev&#39;,NOW());</span><br><span class="line">SELECT * FROM staffs;</span><br><span class="line"> </span><br><span class="line">ALTER TABLE staffs ADD INDEX idx_staffs_nameAgePos(name, age, pos);</span><br></pre></td></tr></table></figure>



<h4 id="全值匹配"><a href="#全值匹配" class="headerlink" title="全值匹配"></a>全值匹配</h4><p>按照复合索引顺序进行匹配</p>
<p><img src="MySQL%E5%9F%BA%E7%A1%80.assets/image-20200713112111054.png" alt="image-20200713112111054"></p>
<p>删除第一个条件</p>
<p><img src="MySQL%E5%9F%BA%E7%A1%80.assets/image-20200713112217844.png" alt="image-20200713112217844"></p>
<p>原因：使用复合索引，查询字段与索引字段顺序的不同会导致， 索引无法充分使用， 甚至索引失效。</p>
<p>==解决：应遵从最左前缀原则==</p>
<p>==注意:mysql5.5.62实测，where后面条件是不需要满足最左前缀==</p>
<h5 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h5><p>查询时，过滤条件应该<strong>从索引的最左前列开始</strong>并且<strong>不跳过索引中的列</strong>。  </p>
<h4 id="在索引列上操作"><a href="#在索引列上操作" class="headerlink" title="在索引列上操作"></a>在索引列上操作</h4><p>在索引列上进行操作后，索引列会失效</p>
<p><img src="MySQL%E5%9F%BA%E7%A1%80.assets/image-20200713113310184.png" alt="image-20200713113310184"></p>
<p>==解决：解决不了，尽量少使用吧==</p>
<h4 id="在复合索引上进行范围查找"><a href="#在复合索引上进行范围查找" class="headerlink" title="在复合索引上进行范围查找"></a>在复合索引上进行范围查找</h4><p>若有索引则能使用到索引，范围条件右边的索引(复合索引)会失效</p>
<p><img src="MySQL%E5%9F%BA%E7%A1%80.assets/image-20200713115753385.png" alt="image-20200713115753385"></p>
<p>==解决：避免将要进行范围查找的索引列添加到复合索引中，或者将其放在复合索引的最后一项中==</p>
<p><strong>范围查找导致索引失效的原因</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">举例</span><br><span class="line">下面是按照三个字段（id,comments,type）建立的索引排序</span><br><span class="line">1 1 1</span><br><span class="line">1 2 2</span><br><span class="line">2 1 3</span><br><span class="line">2 1 4</span><br><span class="line">2 2 1</span><br><span class="line">2 2 4</span><br><span class="line">2 3 0</span><br><span class="line">2 4 1</span><br><span class="line">先查找id&#x3D;2的，得到</span><br><span class="line">2 1 3</span><br><span class="line">2 1 4</span><br><span class="line">2 2 1</span><br><span class="line">2 2 4</span><br><span class="line">2 3 0</span><br><span class="line">2 4 1</span><br><span class="line">在查找comments&gt;1的，得到</span><br><span class="line">2 2 1</span><br><span class="line">2 2 4</span><br><span class="line">2 3 0</span><br><span class="line">2 4 1</span><br><span class="line">此时第三个索引项中数据是无序的</span><br></pre></td></tr></table></figure>

<p><strong>结论</strong></p>
<p>对于复合索引而言，后一项索引有效的基础是前一项索引值唯一</p>
<h4 id="使用不等于进行过滤"><a href="#使用不等于进行过滤" class="headerlink" title="使用不等于进行过滤"></a>使用不等于进行过滤</h4><p>使用 != 和 &lt;&gt; 的字段索引失效（!= 针对数值类型。 &lt;&gt; 针对字符类型）</p>
<p>原因：对于索引而言，就是一些有序的数据结构，而<strong>不等于就是排除了指定条件的范围查找</strong>，上面说明了范围查找导致索引失效的原因。</p>
<p><img src="MySQL%E5%9F%BA%E7%A1%80.assets/image-20200713121235428.png" alt="image-20200713121235428"></p>
<p>==解决：解决不了，尽量少使用吧==</p>
<h4 id="不为空判断"><a href="#不为空判断" class="headerlink" title="不为空判断"></a>不为空判断</h4><p>is not null无法使用索引，is null可以使用索引</p>
<p>is not null也相当于使用了不等于</p>
<p><img src="MySQL%E5%9F%BA%E7%A1%80.assets/image-20200713121959283.png" alt="image-20200713121959283"></p>
<p>==解决：解决不了，尽量少使用吧==</p>
<h4 id="通配符匹配以-开头"><a href="#通配符匹配以-开头" class="headerlink" title="通配符匹配以%开头"></a>通配符匹配以%开头</h4><p><img src="MySQL%E5%9F%BA%E7%A1%80.assets/image-20200713123647170.png" alt="image-20200713123647170"></p>
<p>可以看出，如果%在正则表达式最前面，会导致索引失效。</p>
<p>==解决：==</p>
<ol>
<li>==使用reverse反转函数，将索引中字段反转，然后查询时也使用reverse将条件反转，这样就可以将’%s’变成’s%’==</li>
<li>==使用覆盖索引。将条件中的字段和要查询的字段联合，建立复合索引==</li>
</ol>
<h4 id="数据隐形转换"><a href="#数据隐形转换" class="headerlink" title="数据隐形转换"></a>数据隐形转换</h4><p>存在索引列的数据类型隐形转换，则用不上索引。比如列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引</p>
<p><img src="MySQL%E5%9F%BA%E7%A1%80.assets/image-20200713132540818.png" alt="image-20200713132540818"></p>
<h4 id="条件中有or"><a href="#条件中有or" class="headerlink" title="条件中有or"></a>条件中有or</h4><p>使用or连接时，如果其中一个字段没有索引，则不会使用索引</p>
<p>==解决：要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引==</p>
<h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><p><strong>案例1</strong></p>
<p>假设 index(a,b,c)；  </p>
<table>
<thead>
<tr>
<th>Where 语句</th>
<th>索引是否被使用</th>
</tr>
</thead>
<tbody><tr>
<td>where a = 3</td>
<td>Y,使用到 a</td>
</tr>
<tr>
<td>where a = 3 and b = 5</td>
<td>Y,使用到 a， b</td>
</tr>
<tr>
<td>where a = 3 and b = 5 and c = 4</td>
<td>Y,使用到 a,b,c</td>
</tr>
<tr>
<td>where b = 3 或者 where b = 3 and c = 4 或者 where c = 4</td>
<td>N，不符合最左原则。</td>
</tr>
<tr>
<td>where a = 3 and c = 5</td>
<td>使用到 a， 但是 c 不可以， b 中间断了(mysql5.5.62是可以的)</td>
</tr>
<tr>
<td>where a = 3 and b &gt; 4 and c = 5</td>
<td>使用到 a 和 b， c 不能用在范围之后， b 断了</td>
</tr>
<tr>
<td>where a is null and b is not null</td>
<td>is null 支持索引 但是 is not null 不支持,所 以 a 可以使用索引,但是 b 不可以使用</td>
</tr>
<tr>
<td>where a &lt;&gt; 3</td>
<td>不能使用索引</td>
</tr>
<tr>
<td>where abs(a) =3</td>
<td>在索引列上操作，不能使用 索引</td>
</tr>
<tr>
<td>where a = 3 and b like ‘kk%’ and c = 4</td>
<td>Y,使用到 a,b,c</td>
</tr>
<tr>
<td>where a = 3 and b like ‘%kk’ and c = 4</td>
<td>Y,只用到 a</td>
</tr>
<tr>
<td>where a = 3 and b like ‘%kk%’ and c = 4</td>
<td>Y,只用到 a</td>
</tr>
<tr>
<td>where a = 3 and b like ‘k%kk%’ and c = 4</td>
<td>Y,使用到 a,b,c</td>
</tr>
</tbody></table>
<p><strong>案例2</strong></p>
<p>建表sql</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table test03(</span><br><span class="line"> id int primary key not null auto_increment,</span><br><span class="line"> c1 char(10),</span><br><span class="line"> c2 char(10),</span><br><span class="line"> c3 char(10),</span><br><span class="line"> c4 char(10),</span><br><span class="line"> c5 char(10)</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">insert into test03(c1,c2,c3,c4,c5) values(&#39;a1&#39;,&#39;a2&#39;,&#39;a3&#39;,&#39;a4&#39;,&#39;a5&#39;);</span><br><span class="line">insert into test03(c1,c2,c3,c4,c5) values(&#39;b1&#39;,&#39;b2&#39;,&#39;b3&#39;,&#39;b4&#39;,&#39;b5&#39;);</span><br><span class="line">insert into test03(c1,c2,c3,c4,c5) values(&#39;c1&#39;,&#39;c2&#39;,&#39;c3&#39;,&#39;c4&#39;,&#39;c5&#39;);</span><br><span class="line">insert into test03(c1,c2,c3,c4,c5) values(&#39;d1&#39;,&#39;d2&#39;,&#39;d3&#39;,&#39;d4&#39;,&#39;d5&#39;);</span><br><span class="line">insert into test03(c1,c2,c3,c4,c5) values(&#39;e1&#39;,&#39;e2&#39;,&#39;e3&#39;,&#39;e4&#39;,&#39;e5&#39;);</span><br></pre></td></tr></table></figure>

<p>建索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create index idx_test03_c1234 on test03(c1,c2,c3,c4);</span><br><span class="line">show index from test03;</span><br></pre></td></tr></table></figure>



<p>查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）explain select * from test03 where c1&#x3D;&#39;a1&#39; and c2&#x3D;&#39;a2&#39; and c3&#x3D;&#39;a3&#39; and c4&#x3D;&#39;a4&#39;; </span><br><span class="line">使用复合索引全部字段</span><br><span class="line">2）explain select * from test03 where c1&#x3D;&#39;a1&#39; and c2&#x3D;&#39;a2&#39; and c4&#x3D;&#39;a4&#39; and c3&#x3D;&#39;a3&#39;; </span><br><span class="line">使用符合索引全部字段，mysql会根据复合索引顺序进行优化</span><br><span class="line">3）explain select * from test03 where c1&#x3D;&#39;a1&#39; and c2&#x3D;&#39;a2&#39; and c3&gt;&#39;a3&#39; and c4&#x3D;&#39;a4&#39;;</span><br><span class="line">使用复合索引前三个字段</span><br><span class="line">4）explain select * from test03 where c1&#x3D;&#39;a1&#39; and c2&#x3D;&#39;a2&#39; and c4&gt;&#39;a4&#39; and c3&#x3D;&#39;a3&#39;;</span><br><span class="line">使用复合索引全部字段，Mysql优化顺序select * from test03 where c1&#x3D;&#39;a1&#39; and c2&#x3D;&#39;a2&#39; and c3&#x3D;&#39;a3&#39; and c4&gt;&#39;a4&#39;;</span><br><span class="line">5）explain select * from test03 where c1&#x3D;&#39;a1&#39; and c2&#x3D;&#39;a2&#39; and c4&#x3D;&#39;a4&#39; order by c3;</span><br><span class="line">使用c1,c2,c3字段索引</span><br><span class="line">6） explain select * from test03 where c1&#x3D;&#39;a1&#39; and c2&#x3D;&#39;a2&#39; order by c3;</span><br><span class="line">使用c1,c2字段索引，但是c3用于排序,无filesort</span><br><span class="line">7） explain select * from test03 where c1&#x3D;&#39;a1&#39; and c2&#x3D;&#39;a2&#39; order by c4;</span><br><span class="line">出现了filesort</span><br><span class="line">8） </span><br><span class="line">8.1 explain select * from test03 where c1&#x3D;&#39;a1&#39; and c5&#x3D;&#39;a5&#39; order by c2,c3; </span><br><span class="line"> 只用c1一个字段索引，但是c2、c3用于排序,无filesort</span><br><span class="line">8.2 explain select * from test03 where c1&#x3D;&#39;a1&#39; and c5&#x3D;&#39;a5&#39; order by c3,c2;</span><br><span class="line"> 只用c1一个字段索引，出现了filesort，我们建的索引是1234，它没有按照顺序来，3 2 颠倒了</span><br><span class="line">9） explain select * from test03 where c1&#x3D;&#39;a1&#39; and c2&#x3D;&#39;a2&#39; order by c2,c3;</span><br><span class="line"> 使用c1,c2字段索引，但是c2、c3用于排序,无filesort</span><br><span class="line">10）</span><br><span class="line"> explain select * from test03 where c1&#x3D;&#39;a1&#39; and c2&#x3D;&#39;a2&#39; and c5&#x3D;&#39;a5&#39; order by c2,c3;       </span><br><span class="line"> 用c1、c2两个字段索引，但是c2、c3用于排序,无filesort。c2已经在where部分匹配固定值，order by后再根据c2排序，其实是没用的，忽略</span><br><span class="line"> explain select * from test03 where c1&#x3D;&#39;a1&#39; and c2&#x3D;&#39;a2&#39; and c5&#x3D;&#39;a5&#39; order by c3,c2;             </span><br><span class="line"> 用c1、c2两个字段索引，但是c2、c3用于排序,无filesort。c2已经在where部分匹配固定值，order by后再根据c2排序，其实是没用的，忽略</span><br><span class="line"> explain select * from test03 where c1&#x3D;&#39;a1&#39; and c5&#x3D;&#39;a5&#39; order by c3,c2;</span><br><span class="line"> filesort。这里只有c1字段索引，order by 部分和索引顺序不匹配</span><br><span class="line">11）explain select * from test03 where c1&#x3D;&#39;a1&#39; and c4&#x3D;&#39;a4&#39; group by c2,c3;</span><br><span class="line"> 用c1索引，但是c2、c3用于排序,</span><br><span class="line">12）explain select * from test03 where c1&#x3D;&#39;a1&#39; and c4&#x3D;&#39;a4&#39; group by c3,c2;</span><br><span class="line"> 用c1索引，有Use temporary,filesort</span><br><span class="line"> Using where; Using temporary; Using filesort </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h2><h3 id="使用覆盖索引"><a href="#使用覆盖索引" class="headerlink" title="使用覆盖索引"></a>使用覆盖索引</h3><p>查询时应该避免使用select *</p>
<p><img src="MySQL%E5%9F%BA%E7%A1%80.assets/image-20200713120608468.png" alt="image-20200713120608468"></p>
<p>可以看出，第二条查询Extra字段多了Using index，即覆盖索引</p>
<h3 id="单表查询优化"><a href="#单表查询优化" class="headerlink" title="单表查询优化"></a>单表查询优化</h3><p><strong>建表sql</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS &#96;article&#96; (</span><br><span class="line">&#96;id&#96; INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">&#96;author_id&#96; INT(10) UNSIGNED NOT NULL,</span><br><span class="line">&#96;category_id&#96; INT(10) UNSIGNED NOT NULL,</span><br><span class="line">&#96;views&#96; INT(10) UNSIGNED NOT NULL,</span><br><span class="line">&#96;comments&#96; INT(10) UNSIGNED NOT NULL,</span><br><span class="line">&#96;title&#96; VARBINARY(255) NOT NULL,</span><br><span class="line">&#96;content&#96; TEXT NOT NULL</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">INSERT INTO &#96;article&#96;(&#96;author_id&#96;, &#96;category_id&#96;, &#96;views&#96;, &#96;comments&#96;, &#96;title&#96;, &#96;content&#96;) VALUES</span><br><span class="line">(1, 1, 1, 1, &#39;1&#39;, &#39;1&#39;),</span><br><span class="line">(2, 2, 2, 2, &#39;2&#39;, &#39;2&#39;),</span><br><span class="line">(1, 1, 3, 3, &#39;3&#39;, &#39;3&#39;);</span><br><span class="line"> </span><br><span class="line">SELECT * FROM article;</span><br></pre></td></tr></table></figure>

<p><strong>查询</strong></p>
<p><code>EXPLAIN SELECT id,author_id FROM article WHERE category_id = 1 AND comments &gt; 1 ORDER BY views DESC LIMIT 1;</code></p>
<p><img src="MySQL%E5%9F%BA%E7%A1%80.assets/image-20200712222235244.png" alt="image-20200712222235244"></p>
<p>type=ALL，Extra中Using filesort都需要优化</p>
<p><strong>第一步：建立索引</strong></p>
<p>建立三个字段复合索引<code>create index idx_article_ccv on article(category_id,comments,views);</code></p>
<p>此时查询分析</p>
<p><img src="MySQL%E5%9F%BA%E7%A1%80.assets/image-20200712222156186.png" alt="image-20200712222156186"></p>
<p>可以发现虽然使用了复合索引，但是type是range，且Extra中还有Using filesort</p>
<p>==原因：范围查找会导致索引失效。后面的索引只能建立在前面索引列的<strong>单条数据</strong>基础上==</p>
<p><strong>第二步：修改索引</strong></p>
<p>只建立两个字段的复合索引<code>create index idx_article_cv on article(category_id,views);</code>，舍弃了范围查找对应的索引</p>
<p>此时查询分析</p>
<p><img src="MySQL%E5%9F%BA%E7%A1%80.assets/image-20200712230254020.png" alt="image-20200712230254020"></p>
<p>可以看出type已经是ref，且Extra中filesort消失</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>不要在要进行范围查询的字段上建立复合索引，不然会导致后面的索引字段失效</p>
<h3 id="多表查询优化"><a href="#多表查询优化" class="headerlink" title="多表查询优化"></a>多表查询优化</h3><p>建表sql</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS &#96;class&#96; (</span><br><span class="line">&#96;id&#96; INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">&#96;card&#96; INT(10) UNSIGNED NOT NULL,</span><br><span class="line">PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE IF NOT EXISTS &#96;book&#96; (</span><br><span class="line">&#96;bookid&#96; INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">&#96;card&#96; INT(10) UNSIGNED NOT NULL,</span><br><span class="line">PRIMARY KEY (&#96;bookid&#96;)</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line"> </span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1 + (RAND() * 20)));</span><br></pre></td></tr></table></figure>

<p><strong>查询</strong></p>
<p><code>EXPLAIN SELECT * FROM class LEFT JOIN book ON class.card = book.card;</code><br><img src="MySQL%E5%9F%BA%E7%A1%80.assets/image-20200713101850899.png" alt="image-20200713101850899"></p>
<p>两个查询type都是ALL</p>
<p><strong>第一步：尝试给右表建索引</strong></p>
<p><code>alter table book add index idx_card(card)</code></p>
<p>此时查询分析</p>
<p><img src="MySQL%E5%9F%BA%E7%A1%80.assets/image-20200713104521260.png" alt="image-20200713104521260"></p>
<p>可以看到在book上使用到了索引，总共查询行数21行</p>
<p><strong>第二步：尝试给左表建索引</strong></p>
<p>删除右表索引，然后在左表上建立索引 <code>drop index idx_card on book </code> <code>create index on class(card)</code></p>
<p>此时查询分析</p>
<p><img src="MySQL%E5%9F%BA%E7%A1%80.assets/image-20200713104937740.png" alt="image-20200713104937740"></p>
<p>可以看到class表上查询type是index，也就是对索引进行全局扫描，总共查询行数和未加索引之前一样，40行</p>
<p>==原因：左连接会对左表进行全局扫描，所以不管有没有索引，都会遍历。==</p>
<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><ul>
<li><p>多表查询时，在从表建立索引</p>
</li>
<li><p>主表为小表，从表尾大表。小表驱动大表</p>
<ul>
<li>```kotlin<br>for(i in 0…1000){<pre><code>主表
for(i in 0...5)&#123;
    从表
&#125;
</code></pre>
}<br>//————<br>for(i in 0…5){<pre><code>主表
for(i in 0...1000)&#123;
    从表
&#125;
</code></pre>
}<br>//上面两种方式虽然执行次数都是5000次，但是对于mysql而言，二者效率是不一样的<br>外层循环其实就相当于连接join操作，内存循环就是遍历操作<br>而连接操作往往都是十分耗时的，所以这就是小表驱动大表的原因<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- 优先优化内层循环，即子查询这些</span><br><span class="line"></span><br><span class="line">- 多表查询时，可以设置较大的JoinBuffer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Order By优化</span><br><span class="line"></span><br><span class="line">建表</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;mysql</span><br><span class="line">CREATE TABLE tblA(</span><br><span class="line">  id int primary key not null auto_increment,</span><br><span class="line">  age INT,</span><br><span class="line">  birth TIMESTAMP NOT NULL,</span><br><span class="line">  name varchar(200)</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">INSERT INTO tblA(age,birth,name) VALUES(22,NOW(),&#39;abc&#39;);</span><br><span class="line">INSERT INTO tblA(age,birth,name) VALUES(23,NOW(),&#39;bcd&#39;);</span><br><span class="line">INSERT INTO tblA(age,birth,name) VALUES(24,NOW(),&#39;def&#39;);</span><br><span class="line"> </span><br><span class="line">CREATE INDEX idx_A_ageBirth ON tblA(age,birth,name);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>查询</p>
<img src="MySQL基础.assets/image-20200714003335546.png" alt="image-20200714003335546" style="zoom: 80%;" />

<img src="MySQL基础.assets/image-20200714011629886.png" alt="image-20200714011629886" style="zoom: 80%;" />

<p>说明：</p>
<ol>
<li><p><strong>MySQL在查询时最多只能使用一个索引。因此，如果WHERE条件已经占用了索引，那么在排序中就不使用索引了。</strong></p>
<p>上面查询中 <code>where age &gt; 20</code> 已经使用了索引 <code>idx_A_ageBirth</code></p>
</li>
<li><p><strong>Where和Order by子句组合满足最佳左前缀原则</strong></p>
<p>如果左边在某一列上使用范围查询，则order by就要从该列开始；</p>
<p>如果左边在某一列上使用精确查询，则order by就要从下一列开始；</p>
</li>
<li><p>Order by子句<strong>所有列的排序方向（升序或者降序）应该一样</strong></p>
</li>
</ol>
<p><strong>如果order by后面列不在索引列中，使用filesort时有两种排序方式</strong></p>
<ul>
<li>双路排序<ul>
<li>Mysql4.1之前仅支持双路排序，两次IO操作</li>
<li>过程：从表中读取行指针和ORDER BY列，对他们进行排序，一次IO；然后根据排好序的ORDER BY列，从表中读取所需要的字段，返回，一次IO。</li>
</ul>
</li>
<li>单路排序<ul>
<li>MySQL4.1之后，主要通过比较我们所设定的系统参数 max_length_for_sort_data的大小和Query 语句所取出的字段类型大小总和来判定需要使用哪一种排序算法。如果 max_length_for_sort_data更大，则使用第二种优化后的算法，反之使用第一种算法。</li>
<li>过程：一次性取出满足条件行的所有字段，然后在sort buffer中进行排序，直接返回，一次IO。</li>
</ul>
</li>
</ul>
<h3 id="Group-BY优化"><a href="#Group-BY优化" class="headerlink" title="Group BY优化"></a>Group BY优化</h3><ul>
<li>Group By实质是先排序后分组，分组部分没有太大影响，重要的还是排序。所以其实Group By优化和Order By优化类似</li>
<li>对于能放在where后面的条件，就不要放在having后面。</li>
</ul>
<h3 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h3><h2 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h2><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过(大于)<strong>long_query_time</strong>值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10s</p>
<h4 id="开启慢查询日志"><a href="#开启慢查询日志" class="headerlink" title="开启慢查询日志"></a>开启慢查询日志</h4><p>默认情况下，MySQL数据库没有开启慢查询日志，需要我们手动来设置这个参数。</p>
<p>注意：如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看慢查询日志配置信息</span><br><span class="line">SHOW VARIABLES LIKE &#39;%slow_query_log%&#39;;</span><br><span class="line"># 修改全局变量，重启后失效</span><br><span class="line">set global slow_query_log&#x3D;1</span><br><span class="line"># 永久生效：linux下修改my.cnf，windows下修改my.ini</span><br><span class="line"># 在[mysqld]下增加或修改参数</span><br><span class="line">slow_query_log &#x3D;1</span><br><span class="line"># 如果没有指定参数slow_query_log_file的话，系统默认会给一个缺省的文件host_name-slow.log</span><br><span class="line">slow_query_log_file&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;atguigu-slow.log</span><br><span class="line"></span><br><span class="line"># 查看阈值时间</span><br><span class="line">SHOW VARIABLES LIKE &#39;long_query_time%&#39;;</span><br><span class="line"># 修改阈值</span><br><span class="line">set global long_query_time&#x3D;5</span><br><span class="line"># 或在配置文件中添加</span><br><span class="line">long_query_time&#x3D;5</span><br></pre></td></tr></table></figure>

<p>模拟查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select sleep(4);</span><br></pre></td></tr></table></figure>

<p>然后打开日志文件，就可以看到记录</p>
<p>直接查询慢日志条数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show global status like &#39;%Slow_queries%&#39;;</span><br></pre></td></tr></table></figure>



<h4 id="慢日志分析工具"><a href="#慢日志分析工具" class="headerlink" title="慢日志分析工具"></a>慢日志分析工具</h4><p>mysql提供慢日志分析工具mysqldumpslow</p>
<img src="MySQL基础.assets/image-20200714093801832.png" alt="image-20200714093801832" style="zoom:80%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">常用命令</span><br><span class="line">得到返回记录集最多的10个SQL</span><br><span class="line">mysqldumpslow -s r -t 10 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;atguigu-slow.log</span><br><span class="line"> </span><br><span class="line">得到访问次数最多的10个SQL</span><br><span class="line">mysqldumpslow -s c -t 10 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;atguigu-slow.log</span><br><span class="line"> </span><br><span class="line">得到按照时间排序的前10条里面含有左连接的查询语句</span><br><span class="line">mysqldumpslow -s t -t 10 -g &quot;left join&quot; &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;atguigu-slow.log</span><br><span class="line"> </span><br><span class="line">另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况</span><br><span class="line">mysqldumpslow -s r -t 10 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;atguigu-slow.log | more</span><br></pre></td></tr></table></figure>



<h3 id="批量数据脚本"><a href="#批量数据脚本" class="headerlink" title="批量数据脚本"></a>批量数据脚本</h3><p>使用存储过程实现</p>
<p><strong>建表</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 新建库</span><br><span class="line">create database bigData;</span><br><span class="line">use bigData;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#1 建表dept</span><br><span class="line">CREATE TABLE dept(  </span><br><span class="line">id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT,  </span><br><span class="line">deptno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0,   </span><br><span class="line">dname VARCHAR(20) NOT NULL DEFAULT &quot;&quot;,  </span><br><span class="line">loc VARCHAR(13) NOT NULL DEFAULT &quot;&quot;  </span><br><span class="line">) ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;UTF8 ;  </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#2 建表emp</span><br><span class="line">CREATE TABLE emp  </span><br><span class="line">(  </span><br><span class="line">id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT,  </span><br><span class="line">empno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0, &#x2F;*编号*&#x2F;  </span><br><span class="line">ename VARCHAR(20) NOT NULL DEFAULT &quot;&quot;, &#x2F;*名字*&#x2F;  </span><br><span class="line">job VARCHAR(9) NOT NULL DEFAULT &quot;&quot;,&#x2F;*工作*&#x2F;  </span><br><span class="line">mgr MEDIUMINT UNSIGNED NOT NULL DEFAULT 0,&#x2F;*上级编号*&#x2F;  </span><br><span class="line">hiredate DATE NOT NULL,&#x2F;*入职时间*&#x2F;  </span><br><span class="line">sal DECIMAL(7,2) NOT NULL,&#x2F;*薪水*&#x2F;  </span><br><span class="line">comm DECIMAL(7,2) NOT NULL,&#x2F;*红利*&#x2F;  </span><br><span class="line">deptno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0 &#x2F;*部门编号*&#x2F;  </span><br><span class="line">)ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;UTF8 ; </span><br></pre></td></tr></table></figure>



<p><strong>创建函数</strong></p>
<p>可能会报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">“ERROR 1418 (HY000): This function has none of DETERMINISTIC, NO SQL, or READS SQL DATA in its declaration and binary logging is enabled (you *might* want to use the less safe log_bin_trust_function_creators variable)”</span><br></pre></td></tr></table></figure>

<p>这是由于启动了二进制日志，mysql会根据log_bin_trust_function_creators变量来表示是否可以信任存储函数创建者，不会创建写入二进制日志引起不安全事件的存储函数。默认值为0，用户不得创建或修改存储函数。因此，需要修改该变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global log_bin_trust_function_creators&#x3D;1;</span><br></pre></td></tr></table></figure>

<p>创建函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"># 生成指定长度的随机字符串，用于ename</span><br><span class="line">CREATE FUNCTION rand_string(n INT) RETURNS VARCHAR(255)</span><br><span class="line">BEGIN    ##方法开始</span><br><span class="line"> DECLARE chars_str VARCHAR(100) DEFAULT &#39;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#39;; </span><br><span class="line"> ##声明一个 字符串长度为 100 的变量 chars_str ,默认值 </span><br><span class="line"> DECLARE return_str VARCHAR(255) DEFAULT &#39;&#39;;</span><br><span class="line"> DECLARE i INT DEFAULT 0;</span><br><span class="line"> ##循环开始</span><br><span class="line"> WHILE i &lt; n DO</span><br><span class="line">  ##concat 连接函数  ，substring(a,index,length) 从index处开始截取</span><br><span class="line">  # mysql字符串索引从1开始</span><br><span class="line">  SET return_str &#x3D;CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));</span><br><span class="line">  SET i &#x3D; i + 1;</span><br><span class="line"> END WHILE;</span><br><span class="line"> RETURN return_str;</span><br><span class="line">END $$</span><br><span class="line"></span><br><span class="line"># 生成随机101-110的数字，用于部门标号</span><br><span class="line">DELIMITER $$</span><br><span class="line">CREATE FUNCTION rand_num() RETURNS INT(5)  </span><br><span class="line">BEGIN   </span><br><span class="line"> DECLARE i INT DEFAULT 0;  </span><br><span class="line"> SET i &#x3D; FLOOR(101+RAND()*10);</span><br><span class="line"> RETURN i;  </span><br><span class="line">END $$</span><br></pre></td></tr></table></figure>

<p>创建存储过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 从empno&#x3D;START开始，向emp表插入max_num条数据</span><br><span class="line">DELIMITER $$</span><br><span class="line">CREATE PROCEDURE insert_emp(IN START INT(10),IN max_num INT(10))  </span><br><span class="line">BEGIN  </span><br><span class="line"> DECLARE i INT DEFAULT 0;   </span><br><span class="line"> #把当前会话的autocommit设置成0  ；提高执行效率</span><br><span class="line"> SET autocommit &#x3D; 0;    </span><br><span class="line"> REPEAT  ##重复</span><br><span class="line">  # 存储过程中可以直接使用函数</span><br><span class="line">  INSERT INTO emp10000 (empno, ename ,job ,mgr ,hiredate ,sal ,comm ,deptno ) VALUES ((START+i)     ,rand_string(6),&#39;SALESMAN&#39;,0001,CURDATE(),FLOOR(1+RAND()*20000),FLOOR(1+RAND()*1000),rand_num());</span><br><span class="line">  SET i &#x3D; i + 1;</span><br><span class="line"> UNTIL i &#x3D; max_num   ##循环max_num次</span><br><span class="line"> END REPEAT;  ##满足条件后结束循环</span><br><span class="line"> COMMIT;   ##执行完成后一起提交</span><br><span class="line">END $$</span><br><span class="line"></span><br><span class="line"># 从deptno&#x3D;START开始，向dept表插入max_num条数据</span><br><span class="line">DELIMITER $$</span><br><span class="line">CREATE PROCEDURE insert_dept(IN START INT(10),IN max_num INT(10))  </span><br><span class="line">BEGIN  </span><br><span class="line">DECLARE i INT DEFAULT 0;   </span><br><span class="line"> SET autocommit &#x3D; 0;    </span><br><span class="line"> REPEAT    </span><br><span class="line">  INSERT INTO dept (deptno ,dname,loc) VALUES (START +i ,rand_string(10),rand_string(8));</span><br><span class="line">  SET i &#x3D; i + 1;</span><br><span class="line"> UNTIL i &#x3D; max_num  </span><br><span class="line"> END REPEAT;  </span><br><span class="line"> COMMIT;  </span><br><span class="line">END $$</span><br></pre></td></tr></table></figure>

<p>使用存储过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 员工编号100001-600001</span><br><span class="line">CALL insert_emp(100001,500000);</span><br><span class="line"># 部门编号101-110</span><br><span class="line">CALL insert_dept(101,10); </span><br></pre></td></tr></table></figure>



<h3 id="Show-Profile"><a href="#Show-Profile" class="headerlink" title="Show Profile"></a>Show Profile</h3><p>mysql提供用来分析当前会话中语句执行的资源消耗情况，用于SQL调优的测量。相比于慢查询日志设置阈值，profile可以查看一段时间sql查询情况。</p>
<p>默认处于关闭状态。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看状态</span><br><span class="line">Show  variables like &#39;profiling&#39;;</span><br><span class="line"># 开启当前会话的profiles，默认保存最近15条记录</span><br><span class="line">set profiling&#x3D;1;</span><br><span class="line"></span><br><span class="line"># 运行sql</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># 查看结果</span><br><span class="line">show profiles;</span><br><span class="line"># 根据query_id查看单条记录具体信息(cpu,io)</span><br><span class="line">show profile cpu,block io for query n</span><br></pre></td></tr></table></figure>

<p>查询时参数</p>
<table>
<thead>
<tr>
<th>parameters</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>ALL</td>
<td>显示所有的开销信息</td>
</tr>
<tr>
<td>BLOCK IO</td>
<td>显示块IO相关开销</td>
</tr>
<tr>
<td>CONTEXT SWITCHES</td>
<td>上下文切换相关开销</td>
</tr>
<tr>
<td>CPU</td>
<td>显示CPU相关开销信息</td>
</tr>
<tr>
<td>IPC</td>
<td>显示发送和接收相关开销信息</td>
</tr>
<tr>
<td>MEMORY</td>
<td>显示内存相关开销信息</td>
</tr>
<tr>
<td>PAGE FAULTS</td>
<td>显示页面错误相关开销信息</td>
</tr>
<tr>
<td>SOURCE</td>
<td>显示和Source_function，Source_file，Source_line相关的开销信息</td>
</tr>
<tr>
<td>SWAPS</td>
<td>显示交换次数相关开销的信息</td>
</tr>
</tbody></table>
<p>所有结果</p>
<p><img src="MySQL%E5%9F%BA%E7%A1%80.assets/image-20200714105046057.png" alt="image-20200714105046057"></p>
<p>单条查询</p>
<p><img src="MySQL%E5%9F%BA%E7%A1%80.assets/image-20200714105419116.png" alt="image-20200714105419116"></p>
<h4 id="需要注意的状态"><a href="#需要注意的状态" class="headerlink" title="需要注意的状态"></a>需要注意的状态</h4><ul>
<li><code>converting HEAP to MyISAM</code> 查询结果过大，内存不足，将堆转移到磁盘</li>
<li><code>Creating temp table</code> 创建临时表</li>
<li><code>Copying to tmp table on disk</code> 把内存中临时表复制到磁盘。<strong>十分耗时</strong></li>
<li><code>locked</code> 锁</li>
</ul>
<h3 id="全局查询日志"><a href="#全局查询日志" class="headerlink" title="全局查询日志"></a>全局查询日志</h3><p>不要用于生产环境。<strong>了解即可，使用上面的profiles可以更好地分析</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global general_log&#x3D;1;</span><br><span class="line"># 直接存放到Mysql系统数据库的general_log表中</span><br><span class="line">set global log_output&#x3D;&#39;TABLE&#39;</span><br><span class="line"># 或者修改配置文件my.inf，在[mysqld]下添加</span><br><span class="line">general_log&#x3D;1</span><br><span class="line"># 存放在文件中，性能更好</span><br><span class="line">general_log_file&#x3D;&#x2F;path&#x2F;logfile</span><br><span class="line">log_output&#x3D;TABLE</span><br><span class="line"></span><br><span class="line"># 从表中查看日志</span><br><span class="line">select * from mysql.general_log;</span><br></pre></td></tr></table></figure>

<p>查询结果</p>
<p><img src="MySQL%E5%9F%BA%E7%A1%80.assets/image-20200714111915664.png" alt="image-20200714111915664"></p>
<h2 id="Mysql锁"><a href="#Mysql锁" class="headerlink" title="Mysql锁"></a>Mysql锁</h2><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。</p>
<p>在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p>
<h3 id="数据库锁的分类"><a href="#数据库锁的分类" class="headerlink" title="数据库锁的分类"></a>数据库锁的分类</h3><h4 id="按数据操作类型分类"><a href="#按数据操作类型分类" class="headerlink" title="按数据操作类型分类"></a>按数据操作类型分类</h4><ul>
<li>读锁（共享锁）：针对同一份数据，多个会话的读操作可以同时进行，但不允许写操作</li>
<li>写锁（排它锁）：当前会话写操作未完成前，不允许其他会话同时进行其他操作</li>
</ul>
<h4 id="按操作粒度分类"><a href="#按操作粒度分类" class="headerlink" title="按操作粒度分类"></a>按操作粒度分类</h4><p>粒度使用越细，锁住的数据越少，并发度越高</p>
<ul>
<li>行锁</li>
<li>表锁</li>
</ul>
<h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>偏向<strong>MyISAM存储引擎</strong>，开销小，加锁快，无死锁，锁定粒度大，<strong>发生锁冲突的概率最高</strong>，并发度低。</p>
<h4 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 建表</span><br><span class="line">drop table if exists mylock;</span><br><span class="line">CREATE TABLE mylock (</span><br><span class="line">    id INT PRIMARY KEY auto_increment,</span><br><span class="line">    name VARCHAR (20) NOT NULL</span><br><span class="line">) ENGINE MyISAM DEFAULT charset &#x3D; utf8;</span><br><span class="line">insert into mylock (name) values (&#39;a&#39;);</span><br><span class="line">insert into mylock (name) values (&#39;b&#39;);</span><br><span class="line">insert into mylock (name) values (&#39;c&#39;);</span><br><span class="line">insert into mylock (name) values (&#39;d&#39;);</span><br><span class="line">insert into mylock (name) values (&#39;e&#39;);</span><br><span class="line"># 增加表锁(读锁或写锁)</span><br><span class="line">lock table tablename1 read(write),tablename2 read(write);</span><br><span class="line"># 查看所有表上的锁</span><br><span class="line">show open tables;</span><br><span class="line"># 释放所有表上的锁</span><br><span class="line">unlock tables;</span><br></pre></td></tr></table></figure>

<p><strong>情况1：</strong>会话A上给表A上加读锁</p>
<p>会话A只能在表A上进行<strong>读</strong>操作，<strong>写</strong>操作会<strong>报错</strong>。如果要对其他表操作，必须先释放锁。</p>
<p>会话B可以在表A上进行<strong>读</strong>操作，<strong>写</strong>操作会<strong>阻塞</strong>，当会话A释放表锁，写操作才能执行。</p>
<p><strong>情况2：</strong>会话A上给表A上加写锁</p>
<p>会话A可以在表A上进行<strong>读写</strong>操作。如果要对其他表操作，必须先释放锁。</p>
<p>会话B对于表A的<strong>读写</strong>操作都<strong>阻塞</strong>。如果操作成功，可能是mysql缓存原因，修改下sql语句即可。</p>
<p><strong>分析表锁</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show status like &#39;table%&#39;;</span><br></pre></td></tr></table></figure>

<img src="MySQL基础.assets/image-20200714125910179.png" alt="image-20200714125910179" style="zoom:67%;" />

<ol>
<li>Table_locks_immediate：立即获取锁的查询次数</li>
<li>Table_locks_waited：不能获取表锁而发生等待的次数，此值高则说明存在较严重的表级锁争用情况。</li>
</ol>
<p>MyISAM的读写锁调度是写优先，这也是MyISAM不适合做<strong>写为主</strong>的表的引擎，因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成长时间阻塞。</p>
<h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>偏向<strong>InnoDB存储引擎</strong>，开销大，加锁慢，会出现死锁，锁定粒度小，发生锁冲突的概率低，但并发度高。</p>
<p>InnoDB与MyISAM的最大不同：</p>
<ol>
<li>支持事务</li>
<li>==采用行锁(写操作时默认加锁)==。 InnoDB行锁是<strong>通过索引上的索引项来实现的</strong>，这一点ＭySQL与Oracle不同，后者是通过在数据中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味者：只有通过索引条件检索数据，InnoDB才会使用行级锁。<strong>没有索引或者索引失效</strong>，InnoDB将使用表锁！</li>
</ol>
<p>建表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop table if exists test_innodb_lock;</span><br><span class="line"># 使用innodb引擎创建数据库</span><br><span class="line">CREATE TABLE test_innodb_lock (</span><br><span class="line">    a INT (11),</span><br><span class="line">    b VARCHAR (20) </span><br><span class="line">) ENGINE INNODB DEFAULT charset &#x3D; utf8;</span><br><span class="line">insert into test_innodb_lock values (1,&#39;a&#39;);</span><br><span class="line">insert into test_innodb_lock values (2,&#39;b&#39;);</span><br><span class="line">insert into test_innodb_lock values (3,&#39;c&#39;);</span><br><span class="line">insert into test_innodb_lock values (4,&#39;d&#39;);</span><br><span class="line">insert into test_innodb_lock values (5,&#39;e&#39;);</span><br><span class="line"></span><br><span class="line">create index idx_lock_a on test_innodb_lock(a);</span><br><span class="line">create index idx_lock_b on test_innodb_lock(b);</span><br></pre></td></tr></table></figure>

<h4 id="案例1-innodb默认事务级别"><a href="#案例1-innodb默认事务级别" class="headerlink" title="案例1-innodb默认事务级别"></a>案例1-innodb默认事务级别</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 关闭自动commit</span><br><span class="line">set autocommit&#x3D;0</span><br></pre></td></tr></table></figure>

<p>可以看到</p>
<ul>
<li>左边事务修改但未提交，右边事务并不能获取到左边事务未提交的数据。</li>
<li>左边事务commit之后，右边事务还是不能获取左边事务提交的数据</li>
<li>因为innodb默认支持的事务级别REPEATABLE READ，避免了脏读和不可重复读</li>
</ul>
<p><img src="MySQL基础.assets/image-20200714152756130.png" alt="image-20200714152756130" style="zoom: 50%;" /><img src="MySQL%E5%9F%BA%E7%A1%80.assets/image-20200714154245129.png" alt="image-20200714154245129"></p>
<img src="MySQL基础.assets/image-20200714154322988.png" alt="image-20200714154322988" style="zoom: 50%;" />

<p>必须要在右边事务commit之后，才能获取左边事务提交的新数据</p>
<img src="MySQL基础.assets/image-20200714154508848.png" alt="image-20200714154508848" style="zoom: 80%;" />

<h4 id="案例2-行锁"><a href="#案例2-行锁" class="headerlink" title="案例2-行锁"></a>案例2-行锁</h4><p>可以看到使用行锁后(写操作时Innodb引擎默认加锁)</p>
<ul>
<li>不同事务对于同一张表同一数据行的操作进行加锁。右边事务必须等待左边事务提交后，才能提交</li>
</ul>
<img src="MySQL基础.assets/image-20200714160456238.png" alt="image-20200714160456238" style="zoom:67%;" />



<h4 id="案例3-行锁失效"><a href="#案例3-行锁失效" class="headerlink" title="案例3-行锁失效"></a>案例3-行锁失效</h4><p>可以看到虽然AB两个事务操作的是不同的数据行</p>
<ul>
<li>由于A事务发生了隐式数据转换（字符串没有加引号），<strong>导致索引失效，锁的级别从行锁升级为表锁</strong></li>
</ul>
<img src="MySQL基础.assets/image-20200714161847506.png" alt="image-20200714161847506" style="zoom:67%;" />



<h4 id="案例4-间隙锁"><a href="#案例4-间隙锁" class="headerlink" title="案例4-间隙锁"></a>案例4-间隙锁</h4><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁，对于键值在条件范围内但不存在的记录，叫作“间隙（GAP）”。</p>
<p>间隙锁是为了解决幻读而产生的。当进行范围查询时，为了不产生幻读，即两次读取数据条数不一致，对范围内所有数据加锁。</p>
<p>对于事务A，where条件匹配数据库中的项应该是a=3,a=4,a=5</p>
<p>但是事务B在插入a=2时，依然会被锁住。</p>
<p>因为间隙锁实际锁住了a∈[2,5]，即使a=2并不存在，此时a=2就叫“间隙”</p>
<img src="MySQL基础.assets/image-20200714163036965.png" alt="image-20200714163036965" style="zoom: 67%;" />

<img src="MySQL基础.assets/image-20200714162953374.png" alt="image-20200714162953374" style="zoom:67%;" />



<h4 id="案例5-主动添加行锁"><a href="#案例5-主动添加行锁" class="headerlink" title="案例5-主动添加行锁"></a>案例5-主动添加行锁</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 添加共享锁</span><br><span class="line">SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE</span><br><span class="line"># 锁住sno&#x3D;1的行</span><br><span class="line">select * from student where sno&#x3D;1 lock in share mode;</span><br><span class="line"># 添加排它锁</span><br><span class="line">SELECT * FROM table_name WHERE ... FOR UPDATE</span><br></pre></td></tr></table></figure>



<h4 id="案例6-行锁分析"><a href="#案例6-行锁分析" class="headerlink" title="案例6-行锁分析"></a>案例6-行锁分析</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show status like &#39;innodb_row_lock%&#39;;</span><br></pre></td></tr></table></figure>

<p>各个状态量说明：</p>
<ol>
<li>Innodb_row_lock_current_waits：当前正在等待锁定的数量。</li>
<li><strong>Innodb_row_lock_time</strong>：从系统启动到现在锁定的时长。</li>
<li><strong>Innodb_row_lock_time_avg</strong>：每次等待锁所花平均时间。</li>
<li>Innodb_row_lock_time_max：从系统启动到现在锁等待最长的一次所花的时间。</li>
<li><strong>Innodb_row_lock_waits</strong>：系统启动后到现在总共等待锁的次数。</li>
</ol>
<p>这个五个状态量中，比较重要的是：</p>
<p>Innodb_row_lock_time、Innodb_row_lock_time_avg和Innodb_row_lock_waits。尤其是等待次数很高，而且每次等待时长不小时，就可以使用profiles进行分析。</p>
<img src="MySQL基础.assets/image-20200714165832912.png" alt="image-20200714165832912" style="zoom:67%;" />

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>innodb使用更细粒度的行锁，更加适合高并发的场景，但是如果使用不当，当时行锁失效，转换表锁，效率可能比MyISAM更低。</p>
<h4 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h4><ol>
<li>尽可能让所有数据都通过索引来完成，避免无索引行升级为表锁。</li>
<li>合理设计索引，尽量缩小锁的范围。</li>
<li>尽可能使用较少的检索条件，避免间隙锁。</li>
<li>尽量控制事务大小，减少锁定资源量和时间长度。</li>
<li>尽可能降低事务隔离级别</li>
</ol>
<h3 id="页锁"><a href="#页锁" class="headerlink" title="页锁"></a>页锁</h3><ul>
<li><p>锁的粒度介于表锁和行锁之间，开销和加锁时间介于表锁和行锁之间，并发度一般</p>
</li>
<li><p>会出现死锁</p>
</li>
</ul>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><p>slave会从master读取binlog来进行数据同步。主要有以下三个步骤：</p>
<ol>
<li>master将改变记录到二进制日志（binary log），这些记录过程叫做二进制日志事件（binary log events）。</li>
<li>slave开启一个I/O Thread，将master的binary log events拷贝到中继日志（relay log）。</li>
<li>slave重做中继日志中的事件，将改变应用到自己的数据库中。MySQL的复制是<strong>异步且串行化</strong>的。</li>
</ol>
<p><img src="MySQL%E5%9F%BA%E7%A1%80.assets/706569-20180630100101056-666555235.png" alt="img"></p>
<h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ol>
<li>每个slave只能有一个master。（一对一）</li>
<li>每个slave只能有一个唯一的服务器ID。</li>
<li>每个master可以有多个slave。（一对多）</li>
</ol>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>在主从复制过程中，最大的问题就是延时。</p>
<h3 id="一主一从的常见配置"><a href="#一主一从的常见配置" class="headerlink" title="一主一从的常见配置"></a>一主一从的常见配置</h3><h4 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h4><ul>
<li>MySQL版本最好一致且后台以服务运行。</li>
<li>保证主机与从机互相ping通。</li>
<li>主从配置都在配置文件的[mysqld]结点下，都是小写</li>
<li>修改配置文件之后，要重启服务</li>
<li>主机和从机都要关闭防火墙，其实也可以配置ip规则。<ul>
<li>windows，手动关闭</li>
<li>linux，使用命令 <code>service iptables stop</code> </li>
</ul>
</li>
</ul>
<h4 id="主机配置"><a href="#主机配置" class="headerlink" title="主机配置"></a>主机配置</h4><p>修改my.ini配置文件(windows)</p>
<ol>
<li><p>设置主机服务器id，<code>server-id=1</code> （必须）</p>
</li>
<li><p>启用二进制文件。（必须）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log-bin&#x3D;&quot;D:&#x2F;MySQL&#x2F;MySQL Server 5.5&#x2F;data&#x2F;mysqlbin&quot;</span><br></pre></td></tr></table></figure>

<p><img src="MySQL%E5%9F%BA%E7%A1%80.assets/706569-20180630103727168-1004774476.png" alt="img"></p>
</li>
<li><p>启动错误日志（optional)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log_error &#x3D;&quot;D:&#x2F;MySQL&#x2F;MySQL Server 5.5&#x2F;data&#x2F;mysqlerr&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>设置根目录、数据目录(optional)</p>
<p>修改数据文件位置会导致启动报错，解决方式就是将原先的data文件夹中文件全部拷贝到当前data目录中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#mysql安装根目录</span><br><span class="line">basedir&#x3D;&quot;D:&#x2F;MySQL&#x2F;MySQL Server 5.5&#x2F;&quot;</span><br><span class="line"> </span><br><span class="line">#mysql数据文件所在位置</span><br><span class="line">datadir&#x3D;&quot;D:&#x2F;MySQL&#x2F;MySQL Server 5.5&#x2F;data&#x2F;&quot;</span><br><span class="line"></span><br><span class="line">#mysql临时目录</span><br><span class="line">tmpdir  &#x3D;&quot;D:&#x2F;MySQL&#x2F;MySQL Server 5.5&#x2F;&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>关闭只读(optional)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">read-only&#x3D;0</span><br></pre></td></tr></table></figure></li>
<li><p>设置不需要复制的数据库（optional)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">binlog-ignore-db&#x3D;mysql</span><br></pre></td></tr></table></figure></li>
<li><p>设置需要复制的数据库（optional)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">binlog-do-db&#x3D;databasename</span><br></pre></td></tr></table></figure></li>
<li><p>重启服务，使用管理员方式执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net stop mysql</span><br><span class="line">net restart mysql</span><br></pre></td></tr></table></figure></li>
<li><p>关闭防火墙</p>
</li>
</ol>
<h4 id="从机配置"><a href="#从机配置" class="headerlink" title="从机配置"></a>从机配置</h4><p>修改my.cnf配置文件(linux)</p>
<ol>
<li><p>设置从服务器ID（necessary）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#linux中 存在该项配置，只需要取消注释，同时注释掉server-id&#x3D;1</span><br><span class="line">server-id&#x3D;2</span><br></pre></td></tr></table></figure></li>
<li><p>启用二进制日志（necessary)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 配置中已经存在，不需要修改</span><br><span class="line">log-bin&#x3D;mysql-bin</span><br></pre></td></tr></table></figure></li>
<li><p>关闭防火墙</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 检查防火墙状态</span><br><span class="line">service iptables status</span><br><span class="line"># 关闭防火墙</span><br><span class="line">service iptables stop</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="主机建立账户并授权给slave"><a href="#主机建立账户并授权给slave" class="headerlink" title="主机建立账户并授权给slave"></a>主机建立账户并授权给slave</h4><ol>
<li><p>创建一个有复制权限的用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GRANT REPLICATION SLAVE ON *.* TO &#x27;slaveaccount（用户名）&#x27;@&#x27;从机数据库ip&#x27; IDENTIFIED BY &#x27;密码&#x27;</span><br></pre></td></tr></table></figure></li>
<li><p>再次刷新权限表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在windows中mysql命令行中执行</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure></li>
<li><p>查询主机状态(要保证是最新的)</p>
<p>File告诉从机需要从哪个文件进行复制，Position告诉从机从文件的哪个位置开始复制，在从机上配置时需用到。</p>
<p>执行完此操作后，尽量不要在操作主服务器MySQL，防止主服务器状态变化（File和Position状态变化）。</p>
<p><img src="https://images2018.cnblogs.com/blog/706569/201806/706569-20180630111240913-127840494.png" alt="img"></p>
</li>
</ol>
<h4 id="从机连接主机"><a href="#从机连接主机" class="headerlink" title="从机连接主机"></a>从机连接主机</h4><ol>
<li><p>从机中配置主机信息(上一步中账户信息和主机状态）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在mysql命令中执行</span><br><span class="line">CHANGE MASTER TO MASTER_HOST&#x3D;&#39;主机IP&#39;,</span><br><span class="line">MASTER_USER&#x3D;&#39;salveaccount&#39;,</span><br><span class="line">MASTER_PASSWORD&#x3D;&#39;密码&#39;,</span><br><span class="line">MASTER_LOG_FILE&#x3D;&#39;File名字&#39;,</span><br><span class="line">MASTER_LOG_POS&#x3D;Position数字;</span><br></pre></td></tr></table></figure></li>
<li><p>启动从机复制功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#启动复制</span><br><span class="line">start slave;</span><br><span class="line"># 关闭复制</span><br><span class="line">stop slave;</span><br></pre></td></tr></table></figure></li>
<li><p>查看复制状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show slave status\G;</span><br></pre></td></tr></table></figure>

<p>只有当Slave_IO_Running:Yes和Slave_SQL_Running:Yes，这两个都为Yes的时候，主从复制配置才成功。</p>
<img src="MySQL基础.assets/image-20200714190044468.png" alt="image-20200714190044468" style="zoom:67%;" /></li>
</ol>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>在主机建立数据库并插入数据</p>
<img src="MySQL基础.assets/image-20200714190451967.png" alt="image-20200714190451967" style="zoom:67%;" />

<p>检查从机是否包含刚刚创建的数据库</p>
<img src="MySQL基础.assets/image-20200714190547373.png" alt="image-20200714190547373" style="zoom:67%;" />







<h1 id="MySQL之MVVC简介"><a href="#MySQL之MVVC简介" class="headerlink" title="MySQL之MVVC简介"></a>MySQL之MVVC简介</h1><h2 id="一丶什么是MVCC？"><a href="#一丶什么是MVCC？" class="headerlink" title="一丶什么是MVCC？"></a>一丶什么是MVCC？</h2><p>　　MVCC (Multi-Version Concurrency Control) (注：与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control)是一种基于多版本的并发控制协议，只有在InnoDB引擎下存在。MVCC是为了实现事务的隔离性，通过版本号，避免同一数据在不同事务间的竞争，你可以把它当成基于多版本号的一种乐观锁。当然，这种乐观锁只在事务级别未提交锁和已提交锁时才会生效。MVCC最大的好处，相信也是耳熟能详：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能。具体见下面介绍。</p>
<h2 id="二丶MVCC的实现机制"><a href="#二丶MVCC的实现机制" class="headerlink" title="二丶MVCC的实现机制"></a>二丶MVCC的实现机制</h2><p>　　InnoDB在每行数据都增加两个隐藏字段，一个记录创建的版本号，一个记录删除的版本号。</p>
<p>　　在多版本并发控制中，为了保证数据操作在多线程过程中，保证事务隔离的机制，降低锁竞争的压力，保证较高的并发量。在每开启一个事务时，会生成一个事务的版本号，被操作的数据会生成一条新的数据行（临时），但是在提交前对其他事务是不可见的，对于数据的更新（包括增删改）操作成功，会将这个版本号更新到数据的行中，事务提交成功，将新的版本号更新到此数据行中，这样保证了每个事务操作的数据，都是互不影响的，也不存在锁的问题。</p>
<h2 id="三丶MVCC下的CRUD"><a href="#三丶MVCC下的CRUD" class="headerlink" title="三丶MVCC下的CRUD"></a>三丶MVCC下的CRUD</h2><p><strong>SELECT：</strong><br>　　当隔离级别是REPEATABLE READ时select操作，InnoDB必须每行数据来保证它符合两个条件：<br>　　1、InnoDB必须找到一个行的创建记录版本，它至少要和事务的版本一样老(也即它的版本号不大于事务的版本号)。这保证了不管是事务开始之前，或者事务创建时，或者修改了这行数据的时候，这行数据是存在的。<br>　　2、这行数据的删除版本必须是未定义的或者比事务版本要大。这可以保证在事务开始之前这行数据没有被删除。<br>符合这两个条件的行可能会被当作查询结果而返回。</p>
<p><strong>INSERT：</strong></p>
<p>　　InnoDB为这个新行记录当前的系统版本号。<br><strong>DELETE：</strong></p>
<p>　　InnoDB将当前的系统版本号设置为这一行的删除ID。<br><strong>UPDATE：</strong></p>
<p>　　InnoDB会写一个这行数据的新拷贝，这个拷贝的版本为当前的系统版本号。它同时也会将这个版本号写到旧行的删除版本里。</p>
<p>　　这种额外的记录所带来的结果就是对于大多数查询来说根本就不需要获得一个锁。他们只是简单地以最快的速度来读取数据，确保只选择符合条件的行。这个方案的缺点在于存储引擎必须为每一行存储更多的数据，做更多的检查工作，处理更多的善后操作。<br>　　MVCC只工作在REPEATABLE READ和READ COMMITED隔离级别下。READ UNCOMMITED不是MVCC兼容的，因为查询不能找到适合他们事务版本的行版本；它们每次都只能读到最新的版本。SERIABLABLE也不与MVCC兼容，因为读操作会锁定他们返回的每一行数据。</p>
<h1 id="数据库的redo-undo"><a href="#数据库的redo-undo" class="headerlink" title="数据库的redo,undo"></a>数据库的redo,undo</h1><p><a href="https://blog.csdn.net/shenjian58/article/details/102547903?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-1&spm=1001.2101.3001.4242">参考网址</a></p>
<h4 id="redo"><a href="#redo" class="headerlink" title="redo"></a>redo</h4><p> <strong>Redo是物理日志，记录的是数据页的物理变化</strong>。而逻辑Redo日志，不是记录页面的实际修改，而是记录修改页面的一类操作</p>
<h4 id="使用redo-log原因"><a href="#使用redo-log原因" class="headerlink" title="使用redo log原因"></a>使用redo log原因</h4><ul>
<li>事务提交后，必须将事务对数据页的修改刷(fsync)到磁盘上，才能保证事务的ACID特性。</li>
<li>这个刷盘，是一个随机写，随机写性能较低，如果每次事务提交都刷盘，会极大影响数据库的性能。</li>
</ul>
<p>架构设计中有两个常见的优化方法：</p>
<p>（1）先写日志(write log first)，将随机写<strong>优化为</strong>顺序写；</p>
<p>（2）将每次写<strong>优化为</strong>批量写；</p>
<p>第一条就是redo，某一时刻，数据库崩溃，还没来得及将数据页刷盘，数据库重启时，会重做redo log里的内容，以保证已提交事务对数据的影响被刷到磁盘上。</p>
<p>log是为了保证已提交事务的ACID特性，同时能够提高数据库性能的技术。</p>
<h4 id="使用redo-log，数据库崩溃，导致数据丢失原因"><a href="#使用redo-log，数据库崩溃，导致数据丢失原因" class="headerlink" title="使用redo log，数据库崩溃，导致数据丢失原因"></a>使用redo log，数据库崩溃，导致数据丢失原因</h4><p>redo的三层架构</p>
<p><img src="MySQL%E5%9F%BA%E7%A1%80%E4%B8%8E%E9%AB%98%E7%BA%A7.assets/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9ZcmV6eGNraFlPeHcya3MxQ2xOSzNqM21JUElqOVB5SEJYUHZiSFd3R0toWkV5dzd6YWpQejdpYkw0M2wyQ3BaVm9laWNRTVdMaWFLeENpY2I1b09EazZLU1EvNjQw" alt="img"></p>
<p><em><strong>*redo log*</strong>***</em>*最终落盘的步骤如何？****</p>
<ul>
<li><p><strong>首先</strong>，事务提交的时候，会写入Log Buffer，这里调用的是MySQL自己的函数WriteRedoLog；</p>
</li>
<li><p><strong>接着</strong>，只有当MySQL发起系统调用写文件write时，Log Buffer里的数据，才会写到OS cache。注意，==MySQL系统调用完write之后，就认为文件已经写完，如果不flush，什么时候落盘，是操作系统决定的==；</p>
<ul>
<li>画外音：<strong>有时候打日志，明明</strong>printf<strong>了，</strong>tail -f**却看不到，就是这个原因，这个细节在《<a href="https://blog.csdn.net/shenjian58/article/details/89850428">明明打印到文件了，为啥tail -f看不到</a>》一文里说过，此处不再展开。</li>
</ul>
</li>
<li><p><strong>最后</strong>，由操作系统（当然，MySQL也可以主动flush）将OS cache里的数据，最终fsync到磁盘上；</p>
</li>
</ul>
<p><em><strong>*操作系统为什么要缓冲数据到*</strong>***</em>*OS cache****<em><strong>*里，而不直接刷盘呢？*</strong></em></p>
<p>这里就是将“每次写”优化为“批量写”，以提高操作系统性能。</p>
<p><em><strong>*数据库为什么要缓冲数据到*</strong>***</em>*Log Buffer*<strong><strong><strong>*里，而不是直接*</strong></strong></strong>*write****<em><strong>*呢？*</strong></em></p>
<p>这也是“每次写”优化为“批量写”思路的体现，以提高数据库性能。</p>
<p><em>画外音：**这个优化思路，非常常见，高并发的MQ落盘，高并发的业务数据落盘，都可以使用。</em></p>
<p>redo log的三层架构，MySQL做了一次批量写优化，OS做了一次批量写优化，确实能极大提升性能，<strong>但有什么副作用吗？</strong></p>
<p><em>画外音：**有优点，必有缺点。</em></p>
<p>这个<strong>副作用</strong>，就是可能丢失数据：</p>
<p>（1）事务提交时，将redo log写入Log Buffer，就会认为事务提交成功；</p>
<p>（2）如果写入Log Buffer的数据，write入OS cache之前，数据库崩溃，就会出现数据丢失；</p>
<p>（3）如果写入OS cache的数据，fsync入磁盘之前，操作系统奔溃，也可能出现数据丢失；</p>
<p><em>画外音：<strong>如上文所说，应用程序系统调用完</strong>write<strong>之后（不可能每次</strong>write<strong>后都立刻</strong>flush<strong>，这样写日志很蠢），就认为写成功了，操作系统何时</strong>fsync**，应用程序并不知道，如果操作系统崩溃，数据可能丢失。</em></p>
<h4 id="undo"><a href="#undo" class="headerlink" title="undo"></a>undo</h4><p>undo log主要记录的是数据的逻辑变化，为了在发生错误时回滚之前的操作，需要将之前的操作都记录下来，然后在发生错误时才可以回滚。</p>
<h3 id="undo-log的作用"><a href="#undo-log的作用" class="headerlink" title="undo log的作用"></a>undo log的作用</h3><p>undo是一种逻辑日志，有两个作用：</p>
<ul>
<li>用于事务的回滚</li>
<li>MVCC</li>
</ul>
<p>关于MVCC(多版本并发控制)的内容这里就不多说了，本文重点关注undo log用于事务的回滚。</p>
<p>undo日志，只将数据库逻辑地恢复到原来的样子，在回滚的时候，它实际上是做的相反的工作，比如一条INSERT ，对应一条 DELETE，对于每个UPDATE,对应一条相反的 UPDATE,将修改前的行放回去。undo日志用于事务的回滚操作进而保障了事务的原子性。</p>
<h3 id="undo-log的写入时机"><a href="#undo-log的写入时机" class="headerlink" title="undo log的写入时机"></a>undo log的写入时机</h3><ul>
<li>DML操作修改聚簇索引前，记录undo日志</li>
<li>二级索引记录的修改，不记录undo日志</li>
</ul>
<p>需要注意的是，undo页面的修改，同样需要记录redo日志。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">假设有A、B两个数据，值分别为1,2.</span><br><span class="line">1. 事务开始</span><br><span class="line">2. 记录A=1到undo <span class="built_in">log</span></span><br><span class="line">3. 修改A=3</span><br><span class="line">4. 记录A=3到 redo <span class="built_in">log</span></span><br><span class="line">5. 记录B=2到 undo <span class="built_in">log</span></span><br><span class="line">6. 修改B=4</span><br><span class="line">7. 记录B=4到redo <span class="built_in">log</span></span><br><span class="line">8. 将redo <span class="built_in">log</span>写入磁盘</span><br><span class="line">9. 事务提交</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
